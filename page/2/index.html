<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="cR4Tgq6nOHr_Wo0dm8HUK3feA45_XLr5RkA2UC-tXxc">














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Yiran's Blog" type="application/atom+xml">






<meta name="description" content="Normal is boring">
<meta name="keywords" content="Linux,KVM,Ops">
<meta property="og:type" content="website">
<meta property="og:title" content="Yiran&#39;s Blog">
<meta property="og:url" content="https://zdyxry.github.io/page/2/index.html">
<meta property="og:site_name" content="Yiran&#39;s Blog">
<meta property="og:description" content="Normal is boring">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yiran&#39;s Blog">
<meta name="twitter:description" content="Normal is boring">
<meta name="twitter:creator" content="@zhouyiran1994">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zdyxry.github.io/page/2/">





  <title>Yiran's Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-136220198-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yiran's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
            读书
          </a>
        </li>
      
        
        <li class="menu-item menu-item-movies">
          <a href="/movies" rel="section">
            
            观影
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/08/23/Kubernetes-实战-Cluster-API-v1alpha2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/Kubernetes-实战-Cluster-API-v1alpha2/" itemprop="url">Kubernetes 实战-Cluster API v1alpha2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T20:13:50+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/23/Kubernetes-实战-Cluster-API-v1alpha2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/23/Kubernetes-实战-Cluster-API-v1alpha2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天继续来聊一聊 cluster-api，在上周看 cluster-api-provider-vsphere 代码的时候吐槽过，cluster-api 最近因为 v1alpha2 版本的开发，变化太快，几乎每天都在变，那么我们就来看看 v1alpha2 具体做了什么。</p>
<h2 id="Cluster-API-v1alpha2"><a href="#Cluster-API-v1alpha2" class="headerlink" title="Cluster-API v1alpha2"></a>Cluster-API v1alpha2</h2><p>虽然目前 v1alpha2 还没有正式的 release，但是已经趋于稳定，且两个主要的 provider：aws 和 vsphere 都在进行 v1alpha2 版本的适配（最近每天都有 pr 更新）。我们先来了解下为啥要进行 v1alpha2 改动，改动的目的是啥。</p>
<p>在 v1alpha1 版本中，cluster-api 要求 provider 实现从节点置备到 k8s 部署的全套流程，cluster-api 自身只负责具体的 API 定义及相关控制，在 provider 实现上也不是一个标准的 Operator，（至少）我从概念的理解上比较吃力，每个 provider 需要实现对应 cluster  与 machine 的 actuator ，开发起来要求对 cluster-api 项目本身很熟悉。</p>
<p>其次，每个 provider 都包含了 k8s 集群部署的流程，虽然大部分实现最终都是使用 kubeadm 工具，但是使用方式千差万别，有 cloud-init、有 ssh 配合密钥、有 ssh 配合密码等等。这部分 provider 中的代码完全都是重复的，可以复用的。</p>
<p>上面提到的一些缺点，在 v1alpha2 版本中进行了改进，对各个组件进行了拆分，现在使用 cluster-api 需要 3 个控制器：</p>
<ol>
<li>Core(cluster-api)</li>
<li>Bootstrap(kubeadm)</li>
<li>Infrastructure(aws, gcp, azure, vsphere, etc)</li>
</ol>
<img src="/2019/08/23/Kubernetes-实战-Cluster-API-v1alpha2/v1alpha2.png" title="v1alpha2">
<p>下面来说说各个控制器负责什么。</p>
<h2 id="Core-cluster-api"><a href="#Core-cluster-api" class="headerlink" title="Core(cluster-api)"></a>Core(cluster-api)</h2><p>核心控制器，也就是 cluster-api 项目自身，相比于 v1alpha1 版本 v1alpha2 各个方面简直可爱，来看看具体的改动：</p>
<h3 id="clusterctl"><a href="#clusterctl" class="headerlink" title="clusterctl"></a>clusterctl</h3><p>在 v1alpha1 中，clusterctl 因为耦合了最终的 provider 项目，命令行是由对应的 provider 提供，在 v1alpha2 中完全由 cluster-api 维护。具体代码在 <a href="https://github.com/kubernetes-sigs/cluster-api/blob/master/cmd/clusterctl/README.md" target="_blank" rel="noopener">cmd/clusterctl</a> 下，整体结构感觉跟 kubeadm 很像。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>仍然包含两个主要的 CRD：cluster 和 machine，针对两个资源进行了阶段定义，根据注释就很好 cluster 和 machine 会处于哪些状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// MachinePhasePending is the first state a Machine is assigned by</span></span><br><span class="line">	<span class="comment">// Cluster API Machine controller after being created.</span></span><br><span class="line">	MachinePhasePending = MachinePhase(<span class="string">"pending"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MachinePhaseProvisioning is the state when the</span></span><br><span class="line">	<span class="comment">// Machine infrastructure is being created.</span></span><br><span class="line">	MachinePhaseProvisioning = MachinePhase(<span class="string">"provisioning"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MachinePhaseProvisioned is the state when its</span></span><br><span class="line">	<span class="comment">// infrastructure has been created and configured.</span></span><br><span class="line">	MachinePhaseProvisioned = MachinePhase(<span class="string">"provisioned"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MachinePhaseRunning is the Machine state when it has</span></span><br><span class="line">	<span class="comment">// become a Kubernetes Node in a Ready state.</span></span><br><span class="line">	MachinePhaseRunning = MachinePhase(<span class="string">"running"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MachinePhaseDeleting is the Machine state when a delete</span></span><br><span class="line">	<span class="comment">// request has been sent to the API Server,</span></span><br><span class="line">	<span class="comment">// but its infrastructure has not yet been fully deleted.</span></span><br><span class="line">	MachinePhaseDeleting = MachinePhase(<span class="string">"deleting"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MachinePhaseDeleted is the Machine state when the object</span></span><br><span class="line">	<span class="comment">// and the related infrastructure is deleted and</span></span><br><span class="line">	<span class="comment">// ready to be garbage collected by the API Server.</span></span><br><span class="line">	MachinePhaseDeleted = MachinePhase(<span class="string">"deleted"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MachinePhaseFailed is the Machine state when the system</span></span><br><span class="line">	<span class="comment">// might require user intervention.</span></span><br><span class="line">	MachinePhaseFailed = MachinePhase(<span class="string">"failed"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MachinePhaseUnknown is returned if the Machine state cannot be determined.</span></span><br><span class="line">	MachinePhaseUnknown = MachinePhase(<span class="string">""</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>cluster-api 不再负责具体的 API 所有资源的定义，而是通过设置资源的 owner 来达到最终 cluster 包含 machine 的效果。</p>
<p>用 AWS 官方示例展示：</p>
<p>cluster.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">cluster.x-k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  clusterNetwork:</span></span><br><span class="line"><span class="attr">    pods:</span></span><br><span class="line"><span class="attr">      cidrBlocks:</span> <span class="string">["192.168.0.0/16"]</span></span><br><span class="line"><span class="attr">  infrastructureRef:</span></span><br><span class="line"><span class="attr">    apiVersion:</span> <span class="string">infrastructure.cluster.x-k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">AWSCluster</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">infrastructure.cluster.x-k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AWSCluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">$&#123;AWS_REGION&#125;</span></span><br><span class="line"><span class="attr">  sshKeyName:</span> <span class="string">$&#123;SSH_KEY_NAME&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在执行完 <code>kubectl apply -f cluster.yaml</code> 后， aws cluster 控制器会等待 cluster-api 控制器将 <code>AWSCluster</code> 与 <code>Cluster</code> 资源进行关联后进行下一步操作，这样最终能够达到 <code>Cluster</code> 资源是所有资源的 owner，也可以获得到所有资源的具体的 Spec 和 Status 信息。</p>
<p>（等版本 release 之后好好了解下其中的关系。</p>
<h2 id="Boostrap-kubeadm"><a href="#Boostrap-kubeadm" class="headerlink" title="Boostrap(kubeadm)"></a>Boostrap(kubeadm)</h2><p>相比 cluster-api 的复杂，目前 Bootstrap 的唯一实现 <a href="https://github.com/kubernetes-sigs/cluster-api-bootstrap-provider-kubeadm" target="_blank" rel="noopener">CABPK</a> 是一个分拆出来的独立项目，这个项目的主要目的是通过 <code>Cluster</code> 和 <code>Machine</code> 及对应的 Infrastructure <code>Cluster</code> 和 <code>Machine</code> 信息，来生成 cloud-init 配置（Userdata）。</p>
<p>目前 v1alpha2 统一部署 k8s 集群的方式为 cloud-init ，通过 CABPK 项目生成对应 Machine 的 cloud-init 配置，在部署虚拟机的时候传递 Userdata，达到自动配置的效果。也就是说如果你的 Hypervisor 不支持 cloud-init，就没办法使用 cluster-api v1alpha2 进行部署，只能通过 v1alpha1 的方式，在 Infrastructure 控制器做所有事情。</p>
<p>需要注意的是，在 Infrastructure 控制器工作前，需要保证 Bootstrap 控制器正常工作，生成用于最终创建虚拟机的 cloud-init 配置。</p>
<h2 id="Infrastructure"><a href="#Infrastructure" class="headerlink" title="Infrastructure"></a>Infrastructure</h2><p>前面说的两个控制器都是社区官方维护的，下面来说下各个厂家（provider）维护的 Infrastructure 控制器（最近几天都在搞这个）。</p>
<p>v1alpha2 版本要求各个 provider 实现一个标准且完整的 Operator。包含对应的 <code>Cluster</code>,<code>Machine</code>。以下还是使用 cluster-api-provider-vsphere 具体，截止到 20190823 ，<a href="https://github.com/kubernetes-sigs/cluster-api-provider-vsphere/pulls" target="_blank" rel="noopener">对应 PR</a> 还处于未完成状态。</p>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// VSphereClusterSpec defines the desired state of VSphereCluster</span></span><br><span class="line"><span class="keyword">type</span> VSphereClusterSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	Server <span class="keyword">string</span> <span class="string">`json:"server,omitempty"`</span></span><br><span class="line">	Username <span class="keyword">string</span> <span class="string">`json:"username,omitempty"`</span></span><br><span class="line">	Password <span class="keyword">string</span> <span class="string">`json:"password,omitempty"`</span></span><br><span class="line">	Insecure *<span class="keyword">bool</span> <span class="string">`json:"insecure,omitempty"`</span></span><br><span class="line">	SSHAuthorizedKeys []<span class="keyword">string</span> <span class="string">`json:"sshAuthorizedKeys,omitempty"`</span></span><br><span class="line">	CloudProviderConfiguration cloud.Config <span class="string">`json:"cloudProviderConfiguration,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VSphereClusterStatus defines the observed state of VSphereClusterSpec</span></span><br><span class="line"><span class="keyword">type</span> VSphereClusterStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	Ready <span class="keyword">bool</span> <span class="string">`json:"ready"`</span></span><br><span class="line">	APIEndpoints []APIEndpoint <span class="string">`json:"apiEndpoints,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSphereMachineSpec defines the desired state of VSphereMachine</span></span><br><span class="line"><span class="keyword">type</span> VSphereMachineSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	MachineRef <span class="keyword">string</span> <span class="string">`json:"machineRef,omitempty"`</span></span><br><span class="line">	Template <span class="keyword">string</span> <span class="string">`json:"template"`</span></span><br><span class="line">	Datacenter <span class="keyword">string</span> <span class="string">`json:"datacenter"`</span></span><br><span class="line">	Network NetworkSpec <span class="string">`json:"network"`</span></span><br><span class="line">	NumCPUs <span class="keyword">int32</span> <span class="string">`json:"numCPUs,omitempty"`</span></span><br><span class="line">	NumCoresPerSocket <span class="keyword">int32</span> <span class="string">`json:"numCoresPerSocket,omitempty"`</span></span><br><span class="line">	MemoryMiB <span class="keyword">int64</span> <span class="string">`json:"memoryMiB,omitempty"`</span></span><br><span class="line">	DiskGiB <span class="keyword">int32</span> <span class="string">`json:"diskGiB,omitempty"`</span></span><br><span class="line">	TrustedCerts [][]<span class="keyword">byte</span> <span class="string">`json:"trustedCerts,omitempty"`</span></span><br><span class="line">	NTPServers []<span class="keyword">string</span> <span class="string">`json:"ntpServers,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VSphereMachineStatus defines the observed state of VSphereMachine</span></span><br><span class="line"><span class="keyword">type</span> VSphereMachineStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	Ready <span class="keyword">bool</span> <span class="string">`json:"ready"`</span></span><br><span class="line">	Addresses []v1.NodeAddress <span class="string">`json:"addresses,omitempty"`</span></span><br><span class="line">	TaskRef <span class="keyword">string</span> <span class="string">`json:"taskRef,omitempty"`</span></span><br><span class="line">	Network []NetworkStatus <span class="string">`json:"networkStatus,omitempty"`</span></span><br><span class="line">	ErrorReason *errors.MachineStatusError <span class="string">`json:"errorReason,omitempty"`</span></span><br><span class="line">	ErrorMessage *<span class="keyword">string</span> <span class="string">`json:"errorMessage,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 VSphereCluster 与 VSphereMachine CRD，这里根据自己需要定义相关参数就好，比如如果不想支持自定义目标虚拟机配置，那么就不用提供 CPU、Memory 等配置。</p>
<h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><p>来分别看看 cluster controller 与 machine controller 做了啥。</p>
<h4 id="Cluster-Controller"><a href="#Cluster-Controller" class="headerlink" title="Cluster Controller"></a>Cluster Controller</h4><p>在 <code>Reconcile</code> 的实现中，先获取 VSphereCluster 信息：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vsphereCluster := &amp;infrav1.VSphereCluster&#123;&#125;</span><br><span class="line">err := r.Get(parentContext, req.NamespacedName, vsphereCluster)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后获取 VSphereCluster 关联的 Cluster 信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util 由 cluster-api 提供</span></span><br><span class="line">cluster, err := util.GetOwnerCluster(parentContext, r.Client, vsphereCluster.ObjectMeta)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cluster == <span class="literal">nil</span> &#123;</span><br><span class="line">	logger.Info(<span class="string">"Waiting for Cluster Controller to set OwnerRef on VSphereCluster"</span>)</span><br><span class="line">	<span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: <span class="number">10</span> * time.Second&#125;, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在获取了足够的信息之后，针对这些信息，创建了 context（这里 aws 是叫 scope，是一个东西），判断是否包含 <code>DeletionTimestamp</code> 来决定进行什么调度，是 <code>reconcileDelete</code> 还是 <code>reconcileNormal</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconcileDelete</span><span class="params">(ctx *context.ClusterContext)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">	ctx.Logger.Info(<span class="string">"Reconciling VSphereCluster delete"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cluster is deleted so remove the finalizer.</span></span><br><span class="line">	ctx.VSphereCluster.Finalizers = util.Filter(ctx.VSphereCluster.Finalizers, infrav1.ClusterFinalizer)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有的 provider 中，都对相应资源进行了 Finalizer 配置，方便后续在资源删除前进行一些额外的操作，这里 vsphere 还没有具体的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconcileNormal</span><span class="params">(ctx *context.ClusterContext)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">	ctx.Logger.Info(<span class="string">"Reconciling VSphereCluster"</span>)</span><br><span class="line"></span><br><span class="line">	vsphereCluster := ctx.VSphereCluster</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the VSphereCluster doesn't have our finalizer, add it.</span></span><br><span class="line">	<span class="keyword">if</span> !util.Contains(vsphereCluster.Finalizers, infrav1.ClusterFinalizer) &#123;</span><br><span class="line">		vsphereCluster.Finalizers = <span class="built_in">append</span>(vsphereCluster.Finalizers, infrav1.ClusterFinalizer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set APIEndpoints so the Cluster API Cluster Controller can pull them</span></span><br><span class="line">	vsphereCluster.Status.APIEndpoints = []infrav1.APIEndpoint&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			Host: <span class="string">""</span>, <span class="comment">// vsphereCluster.Status.Network.APIServerELB.DNSName,</span></span><br><span class="line">			Port: <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No errors, so mark us ready so the Cluster API Cluster Controller can pull it</span></span><br><span class="line">	vsphereCluster.Status.Ready = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>reconcileNormal</code> 中对集群进行 Finalizer 判断，然后这里直接更新了 <code>vsphereCluster.Status</code> 具体字段，应该是还没实现完成。</p>
<h4 id="Machine-Controller"><a href="#Machine-Controller" class="headerlink" title="Machine Controller"></a>Machine Controller</h4><p>与 Cluster 相比，Machine 包含了具体的虚拟机创建动作，相应需要的信息也会多一些，除了通过 <code>VSphereMachine</code>获取关联 <code>Machine</code> 以外，还通过 <code>Machine</code> 获取了 <code>Cluster</code> 信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the Machine.</span></span><br><span class="line">	machine, err := util.GetOwnerMachine(parentContext, r.Client, vsphereMachine.ObjectMeta)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> machine == <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Info(<span class="string">"Waiting for Machine Controller to set OwnerRef on VSphereMachine"</span>)</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: <span class="number">10</span> * time.Second&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger = logger.WithName(fmt.Sprintf(<span class="string">"machine=%s"</span>, machine.Name))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fetch the Cluster.</span></span><br><span class="line">	cluster, err := util.GetClusterFromMetadata(parentContext, r.Client, machine.ObjectMeta)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Info(<span class="string">"Machine is missing cluster label or cluster does not exist"</span>)</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>与 Cluster 一样，也会进行 <code>DeletionTimestamp</code> 判断，来看下 <code>reconcileNormal</code> 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *VSphereMachineReconciler)</span> <span class="title">reconcileNormal</span><span class="params">(ctx *context.MachineContext)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果 VSphereMachine 的状态一场，则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> ctx.VSphereMachine.Status.ErrorReason != <span class="literal">nil</span> || ctx.VSphereMachine.Status.ErrorMessage != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.Logger.Info(<span class="string">"Error state detected, skipping reconciliation"</span>)</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 VSphereMachine 没有 Finalizer，则添加</span></span><br><span class="line">	<span class="keyword">if</span> !util.Contains(ctx.VSphereMachine.Finalizers, infrav1.MachineFinalizer) &#123;</span><br><span class="line">		ctx.VSphereMachine.Finalizers = <span class="built_in">append</span>(ctx.VSphereMachine.Finalizers, infrav1.MachineFinalizer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !ctx.Cluster.Status.InfrastructureReady &#123;</span><br><span class="line">		ctx.Logger.Info(<span class="string">"Cluster infrastructure is not ready yet, requeuing machine"</span>)</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: waitForClusterInfrastructureReadyDuration&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在真正创建虚拟机之前，需要确保 cloud-init 配置已经生成</span></span><br><span class="line">	<span class="keyword">if</span> ctx.Machine.Spec.Bootstrap.Data == <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.Logger.Info(<span class="string">"Waiting for bootstrap data to be available"</span>)</span><br><span class="line">		<span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: <span class="number">10</span> * time.Second&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里缺少真正创建虚拟机的实现</span></span><br><span class="line">	<span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vsphere 所有关于虚拟机的操作都在<a href="https://github.com/kubernetes-sigs/cluster-api-provider-vsphere/tree/master/pkg/cloud/vsphere/services/govmomi" target="_blank" rel="noopener">这里</a>，感兴趣的可以看看。</p>
<h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>看完了具体实现逻辑，那么去看下控制器入口： main.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_ = clientgoscheme.AddToScheme(scheme)</span><br><span class="line">	_ = infrav1.AddToScheme(scheme)</span><br><span class="line">	<span class="comment">// +kubebuilder:scaffold:scheme</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v, err := time.ParseDuration(os.Getenv(syncPeriodEnvVar)); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		defaultSyncPeriod = v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v, err := time.ParseDuration(os.Getenv(requeuePeriodEnvVar)); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		defaultRequeuePeriod = v</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 init 函数，这里应该加上 <code>_ = clusterv1.AddToScheme(scheme)</code> ，否则在真正创建对应资源的时候，会报 <code>no kind is registered for the type</code> 的错误。（对 Operator 还不太熟，这里具体原因未了解）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相对来说 v1alpha2 版本改动范围较大，但是真香。各个逻辑部分比之前容易理解的多，且provider 实现也比之前简单许多（虽然还是比较麻烦）。</p>
<p>但是恰恰因为是 alpha 版本，再次吐槽，改动真的是太频繁了，按照项目中 Milestone 规划，在 20190831 就要 release v1alpha2 了，但是目前完成度还只有 <a href="https://github.com/kubernetes-sigs/cluster-api/milestone/6" target="_blank" rel="noopener">58%</a> 。而且目前看到除了 aws 和 vmware 对这个项目参与的比较积极，其他项目都处于假死状态，不知道后续是否会有其他厂家参与进来共同完善。</p>
<h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><ul>
<li>cluster-api 相关项目使用 kubebuilder 辅助构建的，随着 kubebuilder v2 正式发布，相关代码结构改动较大，最好花费些时间了解下 kubebuilder v2。</li>
<li>目前 provider 中 aws 完善度是最高的，但是 aws 中的概念是真的复杂，<strong>概念劝退</strong>。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/08/17/provider-vs-provisioner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/provider-vs-provisioner/" itemprop="url">provider vs provisioner</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T21:08:46+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/17/provider-vs-provisioner/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/17/provider-vs-provisioner/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前 liqiang 同学写了一篇博客：<a href="https://liqiang.io/post/status-or-state-fa70399e" target="_blank" rel="noopener">Status 还是 State</a> 用于总结日常工作中遇到的相似词的区别。这两天看代码，经常能够看到两个词：provider 和 provisioner，作为一个英语渣渣，很难准确的理解两个词的区别。</p>
<h2 id="字典解释"><a href="#字典解释" class="headerlink" title="字典解释"></a>字典解释</h2><p>provider 字典中的解释为：</p>
<ol>
<li>供应者（商）</li>
<li>提供者（商）</li>
<li>供养人</li>
<li>…</li>
</ol>
<p>provisioner 字典中的解释为：</p>
<ol>
<li>粮食供应者</li>
</ol>
<p>看上去从字面上也是一个意思，那么我们来找个实际场景看看。</p>
<h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><h3 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h3><p>在 Terraform 概念中，同时存在 provider 和 provisioner 两个概念：</p>
<figure class="highlight plain"><figcaption><span>is used to create, manage, and update infrastructure resources such as physical machines, VMs, network switches, containers, and more. Almost any infrastructure type can be represented as a resource in Terraform.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A provider is responsible for understanding API interactions and exposing resources. Providers generally are an IaaS (e.g. AWS, GCP, Microsoft Azure, OpenStack), PaaS (e.g. Heroku), or SaaS services (e.g. Terraform Cloud, DNSimple, CloudFlare).</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Provisioners are used to execute scripts on a local or remote machine as part of resource creation or destruction. Provisioners can be used to bootstrap a resource, cleanup before destroy, run configuration management, etc.</span><br></pre></td></tr></table></figure>
<p>这里的 provider 对应 <code>供应商</code> 的含义是可以正确理解的，不同的供应商提供不同的插件。</p>
<p>provisioner 在这里指的是定义的资源可使用的插件，如 <code>remote-exec</code>,<code>file</code>,<code>chef</code> 等等，跟供应商关系不大。</p>
<h3 id="Vagrant-Docker"><a href="#Vagrant-Docker" class="headerlink" title="Vagrant Docker"></a>Vagrant Docker</h3><p>在搜索过程中，看到有人在 SO 上问了这么个问题 <a href="https://stackoverflow.com/questions/30394707/vagrant-docker-provider-vs-docker-provisioner" target="_blank" rel="noopener">Vagrant - Docker provider vs. docker provisioner</a></p>
<p>下面的高票回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker provisioner help to prepare environment: build and pull images, run containers if you need multiple containers running for your vagrant machine. Docker provider is running vagrant machine in docker container (instead of VM/cloud as other providers do).</span><br></pre></td></tr></table></figure>
<p>虽然感觉说的不是很清楚，但是也可以看出 provider 是有明确分类的，而 provisioner 更像是具体的动作种类，比如创建、删除、更新等。</p>
<h3 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h3><p>在 k8s CSI 中，也有 provisioner 的概念，这里主要是指具体的“置备动作执行者”。</p>
<p>当然 provisioner 也有多个，根据具体的存储供应商的不同，提供不同的 provisioner。</p>
<h3 id="Cluster-API"><a href="#Cluster-API" class="headerlink" title="Cluster-API"></a>Cluster-API</h3><p>在 Cluster-API 中，不同厂家为了支持 Cluster-API，会实现不同的 provider，比如 cluster-api-provider-aws, cluster-api-provider-vspher 等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据实际的情况，provider 主要是用来区分供应者，是谁来提供某个事物，通常以公司区分。</p>
<p>provisioner 使用场景不多，主要是涉及到具体的功能执行，我这里理解为“置备动作执行者”，虽然也可以进行分类，但是主要意思应该是前者比较多一些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/08/16/cluster-api-provider-vsphere-源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/cluster-api-provider-vsphere-源码阅读/" itemprop="url">cluster-api-provider-vsphere 源码阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T20:57:25+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/16/cluster-api-provider-vsphere-源码阅读/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/16/cluster-api-provider-vsphere-源码阅读/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上一篇博客讲了 Cluster-API 的相关概念，现在我们来找一个 provider 实现看看具体里面做了啥，因为对 vmware 产品中的概念比较熟悉，就找了 cluster-api-provider-vsphere 。</p>
<p>以下内容均对应 clusterapi v1alpha1 版本。</p>
<h2 id="clusterctl-命令"><a href="#clusterctl-命令" class="headerlink" title="clusterctl 命令"></a>clusterctl 命令</h2><p>cluster-api provider 提供了命令行 <code>clusterctl</code> 用于给我们快速创建 bootstrap 集群用于创建目标 k8s 集群，我们来执行一下看看具体做了哪些工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $ clusterctl create cluster \                                                       </span><br><span class="line">  --provider vsphere \</span><br><span class="line">  --bootstrap-type kind \</span><br><span class="line">  --cluster ./out/management-cluster/cluster.yaml \</span><br><span class="line">  --machines ./out/management-cluster/machines.yaml \</span><br><span class="line">  --provider-components ./out/management-cluster/provider-components.yaml \</span><br><span class="line">  --addon-components ./out/management-cluster/addons.yaml \</span><br><span class="line">  --kubeconfig-out ./out/management-cluster/kubeconfig</span><br><span class="line">I0816 17:28:05.815156   14562 createbootstrapcluster.go:27] Preparing bootstrap cluster</span><br><span class="line">I0816 17:29:15.292547   14562 clusterdeployer.go:78] Applying Cluster API stack to bootstrap cluster</span><br><span class="line">I0816 17:29:15.292619   14562 applyclusterapicomponents.go:26] Applying Cluster API Provider Components</span><br><span class="line">I0816 17:29:16.492405   14562 clusterdeployer.go:83] Provisioning target cluster via bootstrap cluster</span><br><span class="line">I0816 17:29:16.505317   14562 applycluster.go:36] Creating cluster object management-cluster in namespace &quot;default&quot;</span><br><span class="line">I0816 17:29:16.518456   14562 clusterdeployer.go:92] Creating control plane machine in namespace &quot;default&quot;</span><br><span class="line">I0816 17:29:16.548814   14562 applymachines.go:36] Creating machines in namespace &quot;default&quot; # 因为众所周知的“网络”问题，导致我的 Pod image 无法拉取，所以就卡在这里了。。。</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到这个命令一共做了如下的事情：</p>
<ol>
<li>创建 bootstrap 集群</li>
<li>安装 Provider 组件</li>
<li>创建目标 k8s 集群，创建 Cluster CR，Machine CR</li>
<li>…</li>
</ol>
<p>这里因为“网络”问题我无法继续下去了，那么我们来看下命令行的具体实现。</p>
<p>这个命令最终是由 provider 提供的，在 provider 中需要实现 2个接口来辅助信息的获取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Deployer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> This requirement can be removed once after: https://github.com/kubernetes-sigs/cluster-api/issues/158</span></span><br><span class="line">	GetIP(cluster *clusterv1.Cluster, machine *clusterv1.Machine) (<span class="keyword">string</span>, error)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> This requirement can be removed after: https://github.com/kubernetes-sigs/cluster-api/issues/160</span></span><br><span class="line">	GetKubeConfig(cluster *clusterv1.Cluster, master *clusterv1.Machine) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Bootstrap 集群中，会运行 2个 StatefulSet ，分别对应的是 Cluster-api-control-manager 和 provider-control-manager。其中跟 Hypervisor 打交道的逻辑全部在 provider-control-manager 中实现。</p>
<h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>创建流程：<br><img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/cluster_create.png" title="cluster_create"></p>
<p>删除流程：<br><img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/cluster_delete.png" title="cluster_delete"></p>
<p>在 Cluster Controller 中，最终所有的调度任务都会通过 actuator 完成，actuator 需要实现以下接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Actuator <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Reconcile creates or applies updates to the cluster.</span></span><br><span class="line">	Reconcile(*clusterv1.Cluster) error</span><br><span class="line">	<span class="comment">// Delete the cluster.</span></span><br><span class="line">	Delete(*clusterv1.Cluster) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下 vsphere 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Actuator)</span> <span class="title">Reconcile</span><span class="params">(cluster *clusterv1.Cluster)</span> <span class="params">(opErr error)</span></span> &#123;</span><br><span class="line">	ctx, err := context.NewClusterContext(&amp;context.ClusterContextParams&#123;</span><br><span class="line">		Cluster:          cluster,</span><br><span class="line">		Client:           a.client,</span><br><span class="line">		CoreClient:       a.coreClient,</span><br><span class="line">		ControllerClient: a.controllerClient,</span><br><span class="line">		Logger:           klogr.New().WithName(<span class="string">"[cluster-actuator]"</span>),</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		opErr = actuators.PatchAndHandleError(ctx, <span class="string">"Reconcile"</span>, opErr)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ctx.Logger.V(<span class="number">6</span>).Info(<span class="string">"reconciling cluster"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := a.reconcilePKI(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := a.reconcileCloudConfigSecret(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := a.reconcileReadyState(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 actuator 中遇到需要等待或重新调度的情况，比如目标虚拟机未创建完成，目标集群未 ready 的情况，需要返回 <code>clusterErr.RequeueAfterError</code> ，从而重新调度。比如在配置 secret 时，如果无法获取目标集群的 k8s client，那么表示集群还未配置完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Actuator)</span> <span class="title">reconcileCloudConfigSecret</span><span class="params">(ctx *context.ClusterContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	client, err := kubeclient.New(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.Logger.Error(err, <span class="string">"target cluster is not ready"</span>)</span><br><span class="line">		<span class="keyword">return</span> &amp;clusterErr.RequeueAfterError&#123;RequeueAfter: config.DefaultRequeue&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="machine"><a href="#machine" class="headerlink" title="machine"></a>machine</h2><p>创建流程：</p>
<img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/machine_create.png" title="machine_create">
<p>删除流程：</p>
<img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/machine_delete.png" title="machine_delete">
<p>在 v1alpha1 版本中，machine actuator 负责 2件事情：</p>
<ol>
<li>虚拟机构建；</li>
<li>k8s 集群构建（cloud-init 或 ssh）</li>
</ol>
<p>在 vsphere 中，创建虚拟机和 k8s 集群构建两件事情时一起完成的，大概流程如下：</p>
<ol>
<li>生成配置信息，如证书</li>
<li>判断目标 k8s 集群是否需要初始化（kubeadm init）</li>
<li>根据是否需要初始化及是否为 controlplane，生成对应 cloud-init 配置文件</li>
<li>克隆虚拟机，并将 cloud-init 配置文件作为 <code>guestinfo.userdata</code> 放入虚拟机配置参数中</li>
<li>虚拟机开机，通过 <code>vmtoolsd</code> 获取 <code>guestinfo.userdata</code> 信息，并作为 cloud-init 参数进行配置</li>
<li>k8s 集群构建完成（我在实际测试中，发现并没有自动创建 CNI 插件，不知道是不是 bug）</li>
<li>vsphere 克隆虚拟机为异步任务，提交克隆虚拟机任务后，得到 task id，后续判断虚拟机是否存在会用到；</li>
</ol>
<h2 id="Cloud-init-or-SSH"><a href="#Cloud-init-or-SSH" class="headerlink" title="Cloud-init or SSH"></a>Cloud-init or SSH</h2><h3 id="Cloud-init"><a href="#Cloud-init" class="headerlink" title="Cloud-init"></a>Cloud-init</h3><p>在 vsphere provider 中，k8s 部署是通过 cloud-init 实现的，因为之前对 cloud-init 并不了解，这里大概看了下实现方式。</p>
<p>首先在克隆虚拟机时，给目标虚拟机添加了 <code>guestinfo.userdata</code> 字段作为虚拟机配置参数，这个参数是配置在 Hypervisor 层面的，理论上存在虚拟机隔离性，那么虚拟机内部应该无法感知这个参数，这时候就需要一个工具：vmtools。各个虚拟化平台都会提供一个 vmtools 或类似的工具，用于给虚拟机提供一些高级功能，如：获取 IP、设置主机名、配置 NTP/DNS Server、执行特定命令等等。这些都是根据 vmtools 的实现方式不同支持的功能也不同。</p>
<p>vmware vmtools 在安装后，vsphere 可以获取到虚拟机的 IP 等信息，同时，在虚拟机内部会安装一些命令，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> $ <span class="built_in">which</span> vmtoolsd     </span><br><span class="line">/usr/bin/vmtoolsd</span><br><span class="line">root@yiran-workstation:~/project/cluster-api-provider-vsphere </span><br><span class="line">7d21730f ✔ $ vmware-*</span><br><span class="line">vmware-checkvm             vmware-hgfsclient          vmware-toolbox-cmd         vmware-vgauth-cmd        </span><br><span class="line">vmware-config-tools.pl     vmware-namespace-cmd       vmware-uninstall-tools.pl  vmware-vmblock-fuse      </span><br><span class="line">vmware-guestproxycerttool  vmware-rpctool             vmware-user-suid-wrapper   vmware-xferlogs</span><br></pre></td></tr></table></figure>
<p>vsphere provider 代码中并没有很明确的给出参数是如何传递的，通过不断的寻找，我找到了这个项目： <a href="https://github.com/vmware/cloud-init-vmware-guestinfo" target="_blank" rel="noopener">https://github.com/vmware/cloud-init-vmware-guestinfo</a> ，在这里我们可以看到获取 Hypervisor 层面虚拟机的额外配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_guestinfo_value</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Returns a guestinfo value for the specified key.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    LOG.debug(<span class="string">"Getting guestinfo value for key %s"</span>, key)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (stdout, stderr) = util.subp(</span><br><span class="line">            [VMTOOLSD, <span class="string">"--cmd"</span>, <span class="string">"info-get guestinfo."</span> + key])</span><br></pre></td></tr></table></figure>
<p>那么后续的步骤就可以想象的到了，全靠 cloud-init ，这里因为对 cloud-init 了解不多，之后有机会去学习下。</p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH 是我们日常远程连接服务器最常用的方式了，通过用户名，密码（或密钥）来进行 SSH 连接，之后都是通过 Shell 脚本的方式实现 k8s 集群部署，当然 Shell 脚本最终调用的命令是 kubeadm。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读 vsphere provider 代码，我们大概了解了实现一个 Cluster-API provider 需要做哪些事情，最主要的资源控制工作都是在 Cluster-API 实现的，而 provider 主要根据各个场景不同，通过 actuator 实现对应工作，代码量和实现方式上也是千差万别。比如 aws 全部代码可能要 2w 行，而 IBM 的加一起可能不到2k，全看各家的重视程度了。</p>
<p>在写这篇博客的间隙，Cluster-API 开始了 alpha2 的实质性工作： <a href="https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/developer/v1alpha1-compared-to-v1alpha2.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/developer/v1alpha1-compared-to-v1alpha2.md</a> ，还没有了解具体的改动，等 beta 之后再看吧。</p>
<hr>
<p>吐槽：</p>
<p>因为 Cluster-API 处于 v1alpha1 阶段，master 分支代码改动非常大，前几天看的代码今天再看就跟记忆中对不上了，之后看代码的时候一定要注意去一个稳定分支上看，免得费时费力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/08/09/Kubernetes-实战-Cluster-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/Kubernetes-实战-Cluster-API/" itemprop="url">Kubernetes 实战-Cluster API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T19:41:49+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/09/Kubernetes-实战-Cluster-API/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/09/Kubernetes-实战-Cluster-API/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在当前 Kubernetes 生态中，生命周期管理相关工具官方的有 kubeadm、kubespray（部署集群部分通过 kubeadm） ，开源社区还有很多其他的实现，我们可以通过这类工具来实现 k8s 集群的部署，升级，增删节点，但是使用一个工具的前提是：基础设施已经准备完成。只有当基础设施准备完成后，kubeadm 之类工具才可以正常工作。</p>
<p>当我们在部署 Kubernetes 集群时，节点可能在任何环境上，比如 AWS、OpenStack、Vsphere、Azure 等，那么想要自动化配置基础设施，通常我们根据自己的环境不同，编写不通的代码来支持我们的虚拟化（or 服务器）场景。</p>
<p>基础设施包括不限于：</p>
<ul>
<li>OS 安装</li>
<li>Load Balance 配置</li>
<li>网络配置</li>
<li>IP 分配</li>
<li>…</li>
</ul>
<h2 id="Cluster-API"><a href="#Cluster-API" class="headerlink" title="Cluster-API"></a>Cluster-API</h2><p>Kubernetes 社区针对基础设施问题，发起了一个项目：cluster-api，目前处于 alpha1 版本，项目目标：</p>
<ol>
<li>使用声明式API管理 Kubernetes 集群的生命周期</li>
<li>支持多种环境，私有云或公有云</li>
<li>使用社区中现有的工具完成相应功能</li>
<li>…</li>
</ol>
<h3 id="功能简述"><a href="#功能简述" class="headerlink" title="功能简述"></a>功能简述</h3><ol>
<li>无需创建额外基础设施前提下创建 bootstrap cluster</li>
<li>通过 bootstrap cluster 创建目标 k8s 集群</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>cluster-api 使用声明式 API 管理 k8s 集群，需要环境中先存在一个 k8s 集群，通常成为 bootstrap cluster，若不存在，也可通过提供的命令行工具 clusterctl 创建 bootstrap cluster</li>
<li>在 bootstrap cluster 中，部署 CRD 及相应的 cluster api 控制器及 provider 控制器</li>
<li>在 bootstrap cluster 中，开始创建我们真正想要创建的资源：k8s 集群<br>创建资源类型为 Cluster、Machine 或 MachineDeployment ，对应的控制器会自动为我们创建好虚拟机</li>
<li>在虚拟机创建完成后，通过 kubeadm 创建 k8s 集群</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><p>目前看到的几个 Cluster-API Provider 项目实现，虚拟机均通过克隆的方式创建出来的。</p>
<h4 id="虚拟机创建失败处理"><a href="#虚拟机创建失败处理" class="headerlink" title="虚拟机创建失败处理"></a>虚拟机创建失败处理</h4><p>百度：每次等待 30s 查询一次，重试10次，若仍未成功，则创建失败</p>
<p>腾讯：每 2s 查询一次，若不成功，则一直循环</p>
<p>vsphere：提交虚拟机创建任务后未检查是否正确创建，未发现重试逻辑</p>
<p>OpenStack：每 10s 检测一次，若超过设定 timeout ，则创建失败</p>
<h4 id="虚拟机控制方式"><a href="#虚拟机控制方式" class="headerlink" title="虚拟机控制方式"></a>虚拟机控制方式</h4><p>如果虚拟化平台支持 Cloud-init（或类似功能），后续 k8s 部署通过 Cloud-init 实现；</p>
<p>若虚拟化平台不支持，则 bootstrap cluster 中的 Pod 通过 ssh 方式进入倒虚拟机内部执行命令。</p>
<p>通过 Clout-init 实现的好处是Controller 只需要控制虚拟机开机即可，后续无需再主动与虚拟机进行通信，由 Cloud-init 自行触发部署 k8s集群任务；若没有 Cloud-init，则 Controller 在提交虚拟机创建任务后，需要循环等待虚拟机是否正常，等待正常后还需通过 ssh 主动与虚拟机进行连接控制，过于繁琐。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cluster API 目前还处于 Alpha1 版本，但是已经有很多厂家对其进行适配了，目前看到完成度比较高的公有云是 AWS，私有云是 Vsphere，之后好好读一下 Vsphere 的代码，了解下具体实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/08/09/代码统计工具-cloc-基本使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/代码统计工具-cloc-基本使用/" itemprop="url">代码统计工具 cloc 基本使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T19:35:14+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/09/代码统计工具-cloc-基本使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/09/代码统计工具-cloc-基本使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在看一个新项目的时候，通常我都会了解下这个项目的代码量，然后心里给个预期，大概需要多久了解这个项目。</p>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>在以前，我一般都是使用 <code>find</code> 配合 <code>wc</code> 来完成，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:/tmp/cloc </span><br><span class="line"> $ find . -name <span class="string">"*.go"</span> | xargs wc -l &#123;&#125; </span><br><span class="line">  81 ./installer.go</span><br><span class="line">  81 total</span><br></pre></td></tr></table></figure>
<p>显示有一个 <code>installer.go</code> 的文件，一共有 81行。但是这里有个问题，就是 wc 是不会统计代码里面的具体内容的，比如注释、空白行等。</p>
<p>这时候我们就需要一个更高级的工具了： <code>cloc</code></p>
<h2 id="cloc"><a href="#cloc" class="headerlink" title="cloc"></a>cloc</h2><p><a href="https://github.com/AlDanial/cloc" target="_blank" rel="noopener">cloc</a> 是一个 Perl 语言实现的项目，用途就像它的名字全称：Count Lines of Code。</p>
<p>使用方法的话最简单的直接加上项目路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~/go/src/github.com/kubermatic/kubeone </span><br><span class="line">master ✗ $ <span class="built_in">pwd</span>        </span><br><span class="line">/root/go/src/github.com/kubermatic/kubeone</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubermatic/kubeone </span><br><span class="line">master ✗ $ cloc .                   </span><br><span class="line">     292 text files.</span><br><span class="line">     274 unique files.                                          </span><br><span class="line">      78 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=0.80 s (269.1 files/s, 32223.3 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Go                             122           2861           2791          14374</span><br><span class="line">Markdown                        38           1003              0           3172</span><br><span class="line">YAML                            41             14            158            524</span><br><span class="line">Bourne Shell                     5             44             89            206</span><br><span class="line">Python                           4             66             76            186</span><br><span class="line">XML                              4              0              0            100</span><br><span class="line">make                             1             17             13             52</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                           215           4005           3127          18614</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>可以看到统计结果，其中默认会按照语言分类。</p>
<p>如果是 Golang 的项目，且使用了 vendor ，那么可以通过 <code>--exclude-dir</code> 来过滤掉某些路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">aster ✗ $ cloc . </span><br><span class="line">    3304 text files.</span><br><span class="line">    3170 unique files.                                          </span><br><span class="line">     429 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=12.40 s (232.7 files/s, 101850.0 lines/s)</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Language                      files          blank        comment           code</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Go                             2501         101422         113437        1007168</span><br><span class="line">Markdown                        108           2688              0           6786</span><br><span class="line">Protocol Buffers                 53           3006           9076           5133</span><br><span class="line">YAML                            108            305            377           4032</span><br><span class="line">Bourne Shell                     38            381            839           1897</span><br><span class="line">JSON                              7              0              0           1748</span><br><span class="line">Assembly                         35            271            320           1603</span><br><span class="line">Python                            5            277            113            588</span><br><span class="line">make                             23            165            162            556</span><br><span class="line">Bourne Again Shell                3             45             56            378</span><br><span class="line">XML                               4              0              0            106</span><br><span class="line">C                                 1              8              7             24</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">SUM:                           2886         108568         124387        1030019</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $ ls    </span><br><span class="line">boilerplate.go.txt  cmd                 config           Dockerfile  go.mod  hack     Makefile  OWNERS_ALIASES  PROJECT    RELEASE.md  SECURITY_CONTACTS</span><br><span class="line">build               code-of-conduct.md  CONTRIBUTING.md  docs        go.sum  LICENSE  OWNERS    pkg             README.md  scripts     vendor</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $ cloc . --exclude-dir=vendor</span><br><span class="line">     234 text files.</span><br><span class="line">     234 unique files.                                          </span><br><span class="line">      73 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=0.55 s (294.2 files/s, 26466.9 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Go                              64           1110           1355           5106</span><br><span class="line">YAML                            37            150            302           1907</span><br><span class="line">Bourne Shell                    22            256            475           1125</span><br><span class="line">Markdown                        17            332              0            895</span><br><span class="line">Python                           5            277            113            588</span><br><span class="line">make                             9             57            112            177</span><br><span class="line">JSON                             4              0              0            131</span><br><span class="line">XML                              4              0              0            106</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                           162           2182           2357          10035</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $</span><br></pre></td></tr></table></figure>
<p>有时候仅仅按照语言分类还不够，我们想看到具体的那些文件代码量比较大，可以使用 <code>--by-file</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~/go/src/github.com/kubermatic/kubeone </span><br><span class="line">master ✗ $ cloc . --by-file |head -n 30</span><br><span class="line">     292 text files.</span><br><span class="line">     274 unique files.                                          </span><br><span class="line">      78 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=0.70 s (307.5 files/s, 36823.9 lines/s)</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line">File                                                                             blank        comment           code</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line">./pkg/templates/machinecontroller/deployment.go                                     52             24            762</span><br><span class="line">./pkg/apis/kubeone/v1alpha1/zz_generated.conversion.go                              86             54            614</span><br><span class="line">./pkg/apis/kubeone/validation/validation_test.go                                    22             12            530</span><br><span class="line">./pkg/cmd/config.go                                                                 81             42            477</span><br><span class="line">./pkg/apis/kubeadm/v1beta2/zz_generated.deepcopy.go                                 53             60            443</span><br><span class="line">./pkg/apis/kubeadm/v1beta1/zz_generated.deepcopy.go                                 53             60            439</span><br><span class="line">./pkg/templates/weave/weave-net.go                                                  32             13            433</span><br><span class="line">./pkg/config/cluster.go                                                             80             69            417</span><br><span class="line">./pkg/terraform/config.go                                                           76             30            368</span><br><span class="line">./pkg/templates/canal/daemonset.go                                                   9             42            344</span><br><span class="line">./pkg/yamled/document_test.go                                                      113             15            344</span><br><span class="line">./pkg/apis/kubeone/v1alpha1/zz_generated.deepcopy.go                                47             53            340</span><br><span class="line">./pkg/apis/kubeone/zz_generated.deepcopy.go                                         47             53            340</span><br><span class="line">./pkg/templates/machinecontroller/webhook.go                                        35             22            332</span><br><span class="line">./pkg/installer/installation/prerequisites.go                                       73             21            281</span><br><span class="line">./pkg/templates/canal/prerequisites.go                                              16             40            257</span><br><span class="line">./pkg/upgrader/upgrade/preflight_checks.go                                          44             30            247</span><br><span class="line">./pkg/yamled/document.go                                                            70             31            240</span><br><span class="line">./pkg/upgrader/upgrade/preflight_checks_test.go                                     14             12            237</span><br><span class="line">./pkg/templates/metricsserver/deployment.go                                         22             13            227</span><br><span class="line">./pkg/templates/externalccm/packet.go                                               20             12            222</span><br><span class="line">./docs/quickstart-vsphere.md                                                        59              0            222</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/08/02/Linux-下磁盘设备自动发现方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/02/Linux-下磁盘设备自动发现方式/" itemprop="url">Linux 下磁盘设备自动发现方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-02T23:10:04+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/02/Linux-下磁盘设备自动发现方式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/02/Linux-下磁盘设备自动发现方式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果在 PC 上安装过 Linux，那么通常会遇到过硬件设备无法发现的问题，这类问题最终都可以通过 google 来解决掉。那么当我们在服务器场景下，如何做到设备自动发现且在设备发现后执行某些动作呢？</p>
<p>最近看了几个关于存储系统的 Operator 部分实现，记录一下。</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>最简单的肯定是我们写一个循环，永远检测我们要发现的设备，比如 lsblk 可以列举当前服务器所有 block 设备，那么我们就在循环内部执行 lsblk，diff 每次执行的结果，如果有新的设备，那么执行某些操作。</p>
<p>lsblk 是通过读取 /sys/block 下的具体目录判断的，那么我么也可以直接读取该路径下的目录来实现。</p>
<p>如果是网络设备也是一样，我们可以在循环内部执行 <code>ip link list</code> 来获取所有网络设备。</p>
<h2 id="UDEV"><a href="#UDEV" class="headerlink" title="UDEV"></a>UDEV</h2><p>照常先引用维基百科的解释：</p>
<blockquote>
<p>udev 是Linux kernel 2.6系列的设备管理器。它主要的功能是管理/dev目錄底下的设备节点。它同时也是用来接替devfs及hotplug的功能，这意味着它要在添加/删除硬件时处理/dev目录以及所有用户空间的行为，包括加载firmware时。</p>
</blockquote>
<p>如果你的 OS 是通过 systemd 来管理所有进程的话，那么可以发现一个服务叫做 <code>systemd-udevd</code> ，这个是 udev 的守护进程:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:58:10 ~]<span class="variable">$systemctl</span> status systemd-udevd</span><br><span class="line">● systemd-udevd.service - udev Kernel Device Manager</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/systemd-udevd.service; static; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Fri 2019-06-14 15:25:55 CST; 1 months 18 days ago</span><br><span class="line">     Docs: man:systemd-udevd.service(8)</span><br><span class="line">           man:udev(7)</span><br><span class="line"> Main PID: 698 (systemd-udevd)</span><br><span class="line">   Status: <span class="string">"Processing with 56 children at max"</span></span><br><span class="line">    Tasks: 1</span><br><span class="line">   Memory: 24.0M</span><br><span class="line">   CGroup: /system.slice/systemd-udevd.service</span><br><span class="line">           └─698 /usr/lib/systemd/systemd-udevd</span><br><span class="line"></span><br><span class="line">Aug 02 10:29:17 node90 python[4395]: detected unhandled Python exception <span class="keyword">in</span> <span class="string">'/usr/lib/python2.7/site-packages/cpuinfo/cpuinfo.py'</span></span><br><span class="line">Aug 02 10:29:17 node90 python[4395]: can<span class="string">'t communicate with ABRT daemon, is it running? [Errno 2] No such file or directory</span></span><br><span class="line"><span class="string">Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable.</span></span><br></pre></td></tr></table></figure>
<p>udev 可以让我们对硬件的使用限制大大减少，除了常见的硬件发现，还有一个场景就是网卡改名，比如 82599 网卡，在 CentOS 上大概率识别为 <code>enp4s0f1</code> 之类的网卡名，如果我们想要统一服务器网卡名称，那么我们可以通过设置 udev 规则，匹配 mac 地址来做到，这里不细说。</p>
<p>我们来说说 udev 自动发现设备。udev 提供了完整的工具集，可以共我们使用，比如 udevadm：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@node 20:02:41 ~]<span class="variable">$udevadm</span> --<span class="built_in">help</span></span><br><span class="line">udevadm [--<span class="built_in">help</span>] [--version] [--debug] COMMAND [COMMAND OPTIONS]</span><br><span class="line"></span><br><span class="line">Send control commands or <span class="built_in">test</span> the device manager.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  info          Query sysfs or the udev database</span><br><span class="line">  trigger       Request events from the kernel</span><br><span class="line">  settle        Wait <span class="keyword">for</span> pending udev events</span><br><span class="line">  control       Control the udev daemon</span><br><span class="line">  monitor       Listen to kernel and udev events</span><br><span class="line">  <span class="built_in">test</span>          Test an event run</span><br><span class="line">  <span class="built_in">test</span>-builtin  Test a built-in <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 udevadm 来查看硬件设备的具体信息，也可以通过 udevadm 来进行显示的设备监控。</p>
<p>除了通过 udevadm 命令，我们还可以通过编写 udev 配置文件来实现设备发现后的具体动作，在 <code>/etc/udev/rules.d/</code> 路径下可以防止我们自己的配置文件。</p>
<p>比如我们想实现功能：节点上插入磁盘后，执行某条命令，那么我们可以这么定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 20:05:21 rules.d]<span class="variable">$pwd</span></span><br><span class="line">/etc/udev/rules.d</span><br><span class="line">[root@node 20:06:29 rules.d]<span class="variable">$cat</span> 98-disk-udev.rules </span><br><span class="line">KERNEL==<span class="string">"sd[a-z]"</span>, SUBSYSTEM==<span class="string">"block"</span>, ACTION==<span class="string">"add"</span>, RUN+=<span class="string">"echo add"</span></span><br><span class="line"></span><br><span class="line">KERNEL==<span class="string">"sd[a-z]"</span>, SUBSYSTEM==<span class="string">"block"</span>, ACTION==<span class="string">"remove"</span>, RUN+=<span class="string">"echo remove"</span></span><br></pre></td></tr></table></figure>
<p>这个规则具体含义为：</p>
<ul>
<li><p>当检测到设备 <code>sd[a-z]</code> , 类型为 <code>block</code>且动作为 <code>add</code> ，那么执行 <code>echo add</code> 操作。</p>
</li>
<li><p>当检测到设备 <code>sd[a-z]</code> ，类型为 <code>block</code>且动作为 <code>remove</code> ，那么执行 <code>echo add</code> 操作。</p>
</li>
</ul>
<p>我们来看一个具体的例子，执行 <code>udevadm monito</code> 来监控节点设备，然后插入一块 scsi 磁盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@node 20:14:04 rules.d]<span class="variable">$udevadm</span> monitor</span><br><span class="line">monitor will <span class="built_in">print</span> the received events <span class="keyword">for</span>:</span><br><span class="line">UDEV - the event <span class="built_in">which</span> udev sends out after rule processing</span><br><span class="line">KERNEL - the kernel uevent</span><br><span class="line">KERNEL[4250923.838205] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0 (scsi)</span><br><span class="line">KERNEL[4250923.838232] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0 (scsi)</span><br><span class="line">KERNEL[4250923.838241] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0 (scsi_disk)</span><br><span class="line">KERNEL[4250923.838248] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_device/6:0:0:0 (scsi_device)</span><br><span class="line">KERNEL[4250923.838344] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_generic/sg6 (scsi_generic)</span><br><span class="line">KERNEL[4250923.838355] add      /devices/virtual/bdi/8:96 (bdi)</span><br><span class="line">KERNEL[4250923.838364] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/bsg/6:0:0:0 (bsg)</span><br><span class="line">UDEV  [4250923.844166] add      /devices/virtual/bdi/8:96 (bdi)</span><br><span class="line">UDEV  [4250923.844180] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0 (scsi)</span><br><span class="line">UDEV  [4250923.844189] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0 (scsi)</span><br><span class="line">UDEV  [4250923.844196] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_device/6:0:0:0 (scsi_device)</span><br><span class="line">UDEV  [4250923.844203] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0 (scsi_disk)</span><br><span class="line">UDEV  [4250923.848018] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_generic/sg6 (scsi_generic)</span><br><span class="line">UDEV  [4250923.851041] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/bsg/6:0:0:0 (bsg)</span><br><span class="line">KERNEL[4250923.882845] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg (block)</span><br><span class="line">KERNEL[4250923.882863] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg/sdg1 (block)</span><br><span class="line">UDEV  [4250928.290659] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg (block)</span><br><span class="line">UDEV  [4250928.379634] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg/sdg1 (block)</span><br></pre></td></tr></table></figure>
<p>可以看到 udev 监控到了设备名称，设备 pci id 以及设备触发的动作，这里与我们定义的规则相对应。</p>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="命令行-1"><a href="#命令行-1" class="headerlink" title="命令行"></a>命令行</h3><p>在 OpenShift 的 local storage operator 中，是通过不断的执行 lsblk 比较结果来判断的，相关代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run and create disk config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DiskMaker)</span> <span class="title">Run</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(checkDuration)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	err := os.MkdirAll(d.symlinkLocation, <span class="number">0755</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"error creating local-storage directory %s: %v"</span>, d.symlinkLocation, err)</span><br><span class="line">		os.Exit(<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			diskConfig, err := d.loadConfig()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"error loading configuration: %v"</span>, err)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			d.symLinkDisks(diskConfig)</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			klog.Infof(<span class="string">"exiting, received message on stop channel"</span>)</span><br><span class="line">			os.Exit(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DiskMaker)</span> <span class="title">symLinkDisks</span><span class="params">(diskConfig *DiskConfig)</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"lsblk"</span>, <span class="string">"--list"</span>, <span class="string">"-o"</span>, <span class="string">"NAME,MOUNTPOINT"</span>, <span class="string">"--noheadings"</span>)</span><br><span class="line">	<span class="keyword">var</span> out bytes.Buffer</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	cmd.Stdout = &amp;out</span><br><span class="line">	err = cmd.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"error running lsblk: %v"</span>, err)</span><br><span class="line">		e := newEvent(ErrorRunningBlockList, msg, <span class="string">""</span>)</span><br><span class="line">		d.eventSync.report(e, d.localVolume)</span><br><span class="line">		klog.Errorf(msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	deviceSet, err := d.findNewDisks(out.String())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"error reading blocklist: %v"</span>, err)</span><br><span class="line">		e := newEvent(ErrorReadingBlockList, msg, <span class="string">""</span>)</span><br><span class="line">		d.eventSync.report(e, d.localVolume)</span><br><span class="line">		klog.Errorf(msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(deviceSet) == <span class="number">0</span> &#123;</span><br><span class="line">		klog.V(<span class="number">3</span>).Infof(<span class="string">"unable to find any new disks"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h3 id="UDEV-1"><a href="#UDEV-1" class="headerlink" title="UDEV"></a>UDEV</h3><p>在 Rook 项目中，除了通过 lsblk 来获取设备，还监控了 udev 规则，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Scans `udevadm monitor` output for block sub-system events. Each line of</span></span><br><span class="line"><span class="comment">// output matching a set of substrings is sent to the provided channel. An event</span></span><br><span class="line"><span class="comment">// is returned if it passes any matches tests, and passes all exclusion tests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawUdevBlockMonitor</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>, matches, exclusions []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stdbuf -oL performs line bufferred output</span></span><br><span class="line">	<span class="comment">// 后台执行 udevadm monitor 命令</span></span><br><span class="line">	cmd := exec.Command(<span class="string">"stdbuf"</span>, <span class="string">"-oL"</span>, <span class="string">"udevadm"</span>, <span class="string">"monitor"</span>, <span class="string">"-u"</span>, <span class="string">"-k"</span>, <span class="string">"-s"</span>, <span class="string">"block"</span>)</span><br><span class="line">	stdout, err := cmd.StdoutPipe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Warningf(<span class="string">"Cannot open udevadm stdout: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = cmd.Start()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Warningf(<span class="string">"Cannot start udevadm monitoring: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 bufio.NewScanner 实时获取 udevadm monitor 命令输出结果</span></span><br><span class="line">	scanner := bufio.NewScanner(stdout)</span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		text := scanner.Text()</span><br><span class="line">		logger.Debugf(<span class="string">"udevadm monitor: %s"</span>, text)</span><br><span class="line">		<span class="comment">// 对输出结果进行正则匹配</span></span><br><span class="line">		match, err := matchUdevEvent(text, matches, exclusions)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">"udevadm filtering failed: %v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> match &#123;</span><br><span class="line">		    <span class="comment">// 若匹配成功，则将结果发送到对应 channel，即 events</span></span><br><span class="line">			c &lt;- text</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Warningf(<span class="string">"udevadm monitor scanner error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Info(<span class="string">"udevadm monitor finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitors udev for block device changes, and collapses these events such that</span></span><br><span class="line"><span class="comment">// only one event is emitted per period in order to deal with flapping.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">udevBlockMonitor</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>, period time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return any add or remove events, but none that match device mapper</span></span><br><span class="line">	<span class="comment">// events. string matching is case-insensitve</span></span><br><span class="line">	<span class="comment">// 定义 events channel，用于传输匹配结果</span></span><br><span class="line">	events := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> rawUdevBlockMonitor(events,</span><br><span class="line">	    <span class="comment">// 正则表达式，用于获取设备名称</span></span><br><span class="line">		[]<span class="keyword">string</span>&#123;<span class="string">"(?i)add"</span>, <span class="string">"(?i)remove"</span>&#125;,</span><br><span class="line">		[]<span class="keyword">string</span>&#123;<span class="string">"(?i)dm-[0-9]+"</span>, <span class="string">"(?i)rbd[0-9]+"</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	    <span class="comment">// 死循环，不断从 events channel 中获取匹配后的结果</span></span><br><span class="line">		event, ok := &lt;-events</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		timeout := time.NewTimer(period)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">		    <span class="comment">// 这里如果在 timeout 时间周期内，出现多次 events，貌似会丢弃掉后续 event 信息，不知道出于什么考虑。。</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">case</span> _, ok := &lt;-events:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		c &lt;- event</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.reactivated.net/writing_udev_rules.html" target="_blank" rel="noopener">http://www.reactivated.net/writing_udev_rules.html</a> </li>
<li><a href="https://www.thegeekdiary.com/beginners-guide-to-udev-in-linux/" target="_blank" rel="noopener">https://www.thegeekdiary.com/beginners-guide-to-udev-in-linux/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/08/01/Kubernetes-实战-平滑移除节点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/01/Kubernetes-实战-平滑移除节点/" itemprop="url">Kubernetes 实战-平滑移除节点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-01T23:07:29+08:00">
                2019-08-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/01/Kubernetes-实战-平滑移除节点/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/01/Kubernetes-实战-平滑移除节点/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己玩 K8S 以来，搭建的环境没有10几套，也有5，6套了，当环境测试完成后，基本上直接删除掉了，也没有想着一直维护，最近在维护一个集群的时候，想要删除一个节点，发现自己一直不知道如何删除节点，特此记录。</p>
<h2 id="平滑移除"><a href="#平滑移除" class="headerlink" title="平滑移除"></a>平滑移除</h2><h3 id="获取节点列表"><a href="#获取节点列表" class="headerlink" title="获取节点列表"></a>获取节点列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure>
<h3 id="设置不可调度"><a href="#设置不可调度" class="headerlink" title="设置不可调度"></a>设置不可调度</h3><p>由于节点目前处于正常工作状态，集群中新建资源还是有可能创建到该节点的，所以先将节点设置为不可调度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon <span class="variable">$node_name</span></span><br></pre></td></tr></table></figure>
<h3 id="将节点上资源调度到其他节点"><a href="#将节点上资源调度到其他节点" class="headerlink" title="将节点上资源调度到其他节点"></a>将节点上资源调度到其他节点</h3><p>目前集群已经不会分配新的资源在该节点上了，但是节点还运行着现有的业务，所以我们需要将节点上的业务分配到其他节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain <span class="variable">$node_name</span></span><br></pre></td></tr></table></figure>
<p>注意：DaemonSet Pod 和 Static Pod 是不会在集群中其他节点重建的。</p>
<h3 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h3><p>当前集群中已经没有任何资源分配在节点上了，那么我们可以直接移除节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete <span class="variable">$node_name</span></span><br></pre></td></tr></table></figure>
<p>至此，我们平滑移除了一个 k8s 节点。如果移除的是一个 master 节点，那么记得之后还要添加一个新的 master 节点到集群中，避免集群可靠性降低。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://stackoverflow.com/questions/35757620/how-to-gracefully-remove-a-node-from-kubernetes" target="_blank" rel="noopener">https://stackoverflow.com/questions/35757620/how-to-gracefully-remove-a-node-from-kubernetes</a> </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/07/28/Heap-In-Python-Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/28/Heap-In-Python-Golang/" itemprop="url">Heap In Python & Golang</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-28T12:11:45+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/28/Heap-In-Python-Golang/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/28/Heap-In-Python-Golang/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近使用到了 heap 这个数据结构，记录一下在 Python 和 Golang 中最基本的使用方法～ </p>
<blockquote>
<p>堆（英语：Heap）是计算机科学中的一種特別的樹狀数据结构。若是滿足以下特性，即可稱為堆積：「給定堆積中任意節點P和C，若P是C的母節點，那麼P的值會小於等於（或大於等於）C的值」。若母節點的值恆小於等於子節點的值，此堆積稱為最小堆積（min heap）；反之，若母節點的值恆大於等於子節點的值，此堆積稱為最大堆積（max heap）。在堆積中最頂端的那一個節點，稱作根節點（root node），根節點本身沒有母節點（parent node）。</p>
</blockquote>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: heapq.heapify(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: a</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: b = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: heapq.heappu</span><br><span class="line">heapq.heappush     heapq.heappushpop</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: heapq.heappush(b, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: heapq.heappush(b, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: heapq.heappush(b, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: heapq.heappush(b, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: heapq.heappush(b, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: b</span><br><span class="line">Out[<span class="number">11</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: b</span><br><span class="line">Out[<span class="number">28</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: heapq.nlargest(<span class="number">3</span>, b)</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: heapq.nsmallest(<span class="number">2</span>, b)</span><br><span class="line">Out[<span class="number">30</span>]: [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: heapq.heappush(b, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: b</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: heapq.heapreplace(b, <span class="number">7</span>)</span><br><span class="line">Out[<span class="number">39</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: b</span><br><span class="line">Out[<span class="number">40</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: a = [<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: heapq.heapify(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: b</span><br><span class="line">Out[<span class="number">43</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: c = heapq.merge(a,b)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: list(c)</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: b</span><br><span class="line">Out[<span class="number">50</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: heapq.heappop(b)</span><br><span class="line">Out[<span class="number">51</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: b</span><br><span class="line">Out[<span class="number">52</span>]: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Golang 中没有 heapq 这种封装好的库可以直接使用，不过有 <code>container/heap</code> ，提供了同样的方法，只是我们需要先对我们的操作对象实现搜有的 <code>heap.Interface</code>  方法。</p>
<h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice's length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取最后一个元素，在 `container/heap.Pop` 中，将堆顶的元素放置在最后，然后调用 `container/heap.Down` 将当前堆顶元素下沉到适当位置。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // An IntHeap is a max-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> MaxHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	IntHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h.IntHeap[i] &gt; h.IntHeap[j] &#125;</span><br></pre></td></tr></table></figure>
<h3 id="create-1"><a href="#create-1" class="headerlink" title="create"></a>create</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">	heap.Init(h)</span><br><span class="line">	heap.Push(h, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"minimum: %d\n"</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">	heap.Init(h)</span><br><span class="line">	heap.Push(h, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"minimum: %d\n"</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	h1 := &amp;MaxHeap&#123;[]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line">	heap.Init(h1)</span><br><span class="line">	heap.Push(h1, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"maximum: %d\n"</span>, h1.IntHeap[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> h1.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h1))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">	heap.Init(h)</span><br><span class="line">	heap.Push(h, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice's length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">	heap.Init(h)</span><br><span class="line">	heap.Push(h, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(h)</span><br><span class="line">	heap.Remove(h, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Heap 的使用场景有：优先级队列、TopK 等等。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://godoc.org/container/heap" target="_blank" rel="noopener">https://godoc.org/container/heap</a></li>
<li><a href="https://docs.python.org/3.7/library/heapq.html" target="_blank" rel="noopener">https://docs.python.org/3.7/library/heapq.html</a></li>
<li><a href="https://ieevee.com/tech/2018/01/29/go-heap.html" target="_blank" rel="noopener">https://ieevee.com/tech/2018/01/29/go-heap.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/07/21/CentOS定制-软件源错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/CentOS定制-软件源错误/" itemprop="url">CentOS定制-软件源错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T19:58:43+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/21/CentOS定制-软件源错误/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/21/CentOS定制-软件源错误/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我一直在维护一个公司内部的 OS 发行版，是基于 CentOS 的，最近接到了一个需求，是需要更新 Kernel 及一些软件包，但是遇到了无法安装 OS 的问题，记录一下解决方式。</p>
<h2 id="定制-OS"><a href="#定制-OS" class="headerlink" title="定制 OS"></a>定制 OS</h2><p>关于定制 OS，在之前的博客中已经提到过几次了，CentOS 是比较容易改动的一个发行版，因为有着 RHEL 红（爸）帽（爸），有着完善的文档可以参考。</p>
<p>主要需要注意的是两点：  </p>
<ol>
<li>分区方式</li>
<li>软件包选择</li>
</ol>
<p>今天遇到的问题是第二点。</p>
<p>先说下前提，由于是 2B 产品，所以对于每次的 BaseOS 版本升级都非常谨慎，每次 BaseOS 版本都会进行各种测试。但是如果仅仅是升级部分所需要的软件包，就不用这么麻烦了，我们可以定制自己所需要的软件组（group），来进行安装/升级。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这次接到的需要是升级 Kernel、libiscsi、qemu 三个软件，后两个是虚拟化相关的，相关依赖较少；kernel 是跟 BaseOS 版本关联性很大的。</p>
<p>比如 CentOS 7.6 中，kernel 版本为：kernel-3.10.0-957.el7.x86_64.rpm，这个版本对 selinux 等相关软件是有依赖要求的，我在这里翻车了。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>像往常一样，将对应的 rpm 放置到了对应的 yum 源中，更新 yum 源，制作 ISO，在安装过程中报错：</p>
<img src="/2019/07/21/CentOS定制-软件源错误/os1.png" title="OS1">
<p>报错显示是软件源出了问题，但是没有更多的信息了，这时候我们可以通过 console 连接到其他的 pty 中，查看对应的日志，比如 CentOS 默认的日志在： <code>/tmp/packaging.log</code> 中：</p>
<img src="/2019/07/21/CentOS定制-软件源错误/os2.png" title="OS2">
<p>我们可以看到日志中提示 kernel 与当前软件源中的 selinux-policy-targeted 冲突，因为安装 OS 所用的软件源就是 ISO ，所以这里肯定是我们打包 ISO 时遗漏了依赖关系导致的，我们将对应的 Kernel 所需依赖更新，重新构建 ISO 就可以了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zdyxry.github.io/2019/07/13/Kubernetes-实战-踩坑记录（持续更新）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yiran">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yiran.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yiran's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/Kubernetes-实战-踩坑记录（持续更新）/" itemprop="url">Kubernetes 实战-踩坑记录（持续更新）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-13T09:34:45+08:00">
                2019-07-13
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/13/Kubernetes-实战-踩坑记录（持续更新）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/13/Kubernetes-实战-踩坑记录（持续更新）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在对现有服务进行容器话改造的过程中，随着对 K8S 使用程度越来越深，也渐渐的遇到了一些坑，所以开一篇博客，记录自己所遇到的坑，应该会长期更新。</p>
<h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><ul>
<li>2019.07.13 02:00 来自加班中的 yiran</li>
<li>2019.07.19 06:52 早起不想去公司的 yiran</li>
</ul>
<h2 id="coredns-无法解析域名"><a href="#coredns-无法解析域名" class="headerlink" title="coredns 无法解析域名"></a>coredns 无法解析域名</h2><p>在 Kubernetes 环境中，使用 kubeadm 工具部署的集群，会自动部署 coredns 作为集群的域名服务，每当我们创建了自己的 service，都可以通过域名直接访问，不用再考虑自己多个 Pod 的 IP 不同如何连接的问题。</p>
<p>最近遇到多个环境出现无法解析域名的问题，具体现象如下：</p>
<ol>
<li>集群部署完成后，部署 daemonset 资源，每个节点均运行一个 busybox；</li>
<li>在 busybox 中对 <code>kubernetes</code> 默认域名进行解析，查看解析结果。</li>
</ol>
<p>正常情况应该是所有的 busybox 都可以正常解析才对，但是最近几个环境中均出现了 3 个node 中1个node 上的 pod 无法解析的问题，示例代码如下：</p>
<p>daemonset.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"extensions/v1beta1"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">"DaemonSet"</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"ds"</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">"default"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">ds</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      tolerations:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">        effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">"apply-sysctl"</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">"busybox:1.28.4"</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">        command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"-c"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">|</span></span><br><span class="line"><span class="string">          set -o errexit</span></span><br><span class="line"><span class="string">          set -o xtrace</span></span><br><span class="line"><span class="string">          while true</span></span><br><span class="line"><span class="string">          do</span></span><br><span class="line"><span class="string">            sleep 2s</span></span><br><span class="line"><span class="string">            date</span></span><br><span class="line"><span class="string">            echo "diu~"</span></span><br><span class="line"><span class="string">          done</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node11 21:28:40 ~]<span class="variable">$for</span> i <span class="keyword">in</span> `kubectl get pod  -o wide  |grep ds | awk <span class="string">'&#123;print $1&#125;'</span>`;<span class="keyword">do</span> kubectl <span class="built_in">exec</span> <span class="variable">$i</span> nslookup kubernetes;<span class="built_in">echo</span> ;<span class="keyword">done</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10</span><br><span class="line"></span><br><span class="line">nslookup: can<span class="string">'t resolve '</span>kubernetes<span class="string">'</span></span><br><span class="line"><span class="string">command terminated with exit code 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server:    10.96.0.10</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Name:      kubernetes</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server:    10.96.0.10</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Name:      kubernetes</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span></span><br></pre></td></tr></table></figure>
<p>在第一个节点的 Pod 解析时失效，最后命令执行 1min 超时退出。</p>
<p>经过查看发现节点的 NetFilter 相关系统配置未生效，导致 iptables 相关功能失效，具体可以参考 <a href="https://github.com/kubernetes/kubernetes/issues/21613" target="_blank" rel="noopener">issue</a>。</p>
<p>解决方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'1'</span> &gt; /proc/sys/net/bridge/bridge-nf-call-iptables</span><br></pre></td></tr></table></figure>
<h2 id="Flannel-OOM"><a href="#Flannel-OOM" class="headerlink" title="Flannel OOM"></a>Flannel OOM</h2><p>在配置好集群业务后，发现业务时不时的出现中断情况，最开始排查业务自身问题，未发现 Pod 出现重启或异常的日志，开始排查 k8s 状态，发现在节点 <code>/var/log/messages</code> 日志中，Flannel 一直处于 OOM 状态，惨不忍睹。</p>
<p>之前还略微惊奇，Flannel 默认的计算资源中，内存只要 50MiB，且上限也是 50MiB，没有给自己留一丝余地，看到 <a href="https://github.com/coreos/flannel/issues/963" target="_blank" rel="noopener">issue</a> 中的描述，感觉这个不是一个偶发事件，最终我将 Flannel 的内存调整为 250MiB 后，未出现 OOM 情况。</p>
<p>issue 中提到的 <code>kubectl patch</code> 命令未自动生效，我通过更新 ds 配置，然后依次手动删除节点上的 Flannel Pod 使其生效。</p>
<h2 id="Nginx-Ingress"><a href="#Nginx-Ingress" class="headerlink" title="Nginx Ingress"></a>Nginx Ingress</h2><p>Nginx Ingress 有多个版本，在编写 Ingress 规则的时候一定要看清自己集群中的 Nginx Ingress 版本，我最开始就是因为这个看错了文档。。</p>
<p>主要的版本有： <code>kubernetes/ingress-nginx</code> , <code>nginxinc/kubernetes-ingress with NGINX</code> 和 <code>nginxinc/kubernetes-ingress with NGINX PLUS</code> ，具体的对比规则可以在 <a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md" target="_blank" rel="noopener">Github</a> 中了解。</p>
<p>在 <code>kubernetes/ingress-nginx</code> 中，默认 <code>ssl-redirect</code> 参数是 <code>true</code> ，如果自己的服务不支持 https，那么需要显示的声明该参数为 false 才可以，这里需要注意一下。</p>
<p>在配置 nginx 参数的时候，要注意语法，正确的书写方式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      &#123;"apiVersion":"networking.k8s.io/v1beta1","kind":"Ingress","metadata":&#123;"annotations":&#123;"kubernetes.io/ingress.class":"nginx","nginx.ingress.kubernetes.io/proxy-read-timeout":"3600","nginx.ingress.kubernetes.io/proxy-send-timeout":"3600","nginx.ingress.kubernetes.io/ssl-redirect":"true","nginx.ingress.kubernetes.io/use-regex":"true","nginx.org/websocket-services":"websockify"&#125;,"name":"websockify","namespace":"default"&#125;,"spec":&#123;"rules":[&#123;"http":&#123;"paths":[&#123;"backend":&#123;"serviceName":"websockify","servicePort":8000&#125;,"path":"/websockify"&#125;]&#125;&#125;]&#125;&#125;</span></span><br><span class="line"><span class="string">    kubernetes.io/ingress.class: nginx</span></span><br><span class="line"><span class="string">    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"</span></span><br><span class="line"><span class="string">    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"</span></span><br></pre></td></tr></table></figure>
<p>相关 issue 链接： <a href="https://github.com/kubernetes/ingress-nginx/issues/2007" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx/issues/2007</a> </p>
<h2 id="Docker-稳定性"><a href="#Docker-稳定性" class="headerlink" title="Docker 稳定性"></a>Docker 稳定性</h2><p>在修改 Docker 配置后，需要重启 Docker.service 使配置生效，在一次重启操作中，直接导致物理节点宕机，自动重启了。。。</p>
<p>重启后观察物理节点日志，未发现异常日志，目前待复现调查，很坑很诡异。</p>
<h2 id="Helm-values-为空更新错误"><a href="#Helm-values-为空更新错误" class="headerlink" title="Helm values 为空更新错误"></a>Helm values 为空更新错误</h2><p>今天在给应用编写 Helm Charts 的时候，在 Values 中通过 resources.requests.cpu 方式指定了 cpu 和内存，在测试的时候忘记填写具体数值了，像这面这样：</p>
<p>values:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default values for test.</span></span><br><span class="line"><span class="comment"># This is a YAML-formatted file.</span></span><br><span class="line"><span class="comment"># Declare variables to be passed into your templates.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">  limits:</span></span><br><span class="line"><span class="attr">   cpu:</span></span><br><span class="line"><span class="attr">   memory:</span></span><br><span class="line"><span class="attr">  requests:</span></span><br><span class="line"><span class="attr">   cpu:</span></span><br><span class="line"><span class="attr">   memory:</span></span><br></pre></td></tr></table></figure></p>
<p>在 helm templates 中定义 daemonset，指定使用 resources 字段。</p>
<p>直接执行 helm 命令安装成功了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node11 20:44:09 <span class="built_in">test</span>]<span class="variable">$helm</span> install . --name-template <span class="built_in">test</span></span><br><span class="line">NAME: <span class="built_in">test</span></span><br><span class="line">LAST DEPLOYED: 2019-07-15 20:44:18.151073881 +0800 CST m=+0.092592446</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  <span class="built_in">export</span> POD_NAME=$(kubectl get pods -l <span class="string">"app=test,release=test"</span> -o jsonpath=<span class="string">"&#123;.items[0].metadata.name&#125;"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Visit http://127.0.0.1:8080 to use your application"</span></span><br><span class="line">  kubectl port-forward <span class="variable">$POD_NAME</span> 8080:80</span><br></pre></td></tr></table></figure>
<p>我们查看创建出来的 daemonset 资源状态：</p>
<p>daemonset/test</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">Name:</span>           <span class="string">test</span></span><br><span class="line"><span class="attr">Selector:</span>       <span class="string">app=test</span></span><br><span class="line"><span class="attr">Node-Selector:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="string">Pods</span> <span class="attr">Status:</span>  <span class="number">3</span> <span class="string">Running</span> <span class="string">/</span> <span class="number">0</span> <span class="string">Waiting</span> <span class="string">/</span> <span class="number">0</span> <span class="string">Succeeded</span> <span class="string">/</span> <span class="number">0</span> <span class="string">Failed</span></span><br><span class="line"><span class="string">Pod</span> <span class="attr">Template:</span></span><br><span class="line"><span class="attr">  Labels:</span>  <span class="string">app=test</span></span><br><span class="line"><span class="attr">  Containers:</span></span><br><span class="line"><span class="attr">   test:</span></span><br><span class="line"><span class="attr">    Image:</span>      <span class="string">harbor.zdyxry.com/test/test:0.1.2</span></span><br><span class="line"><span class="attr">    Port:</span>       <span class="number">10402</span><span class="string">/TCP</span></span><br><span class="line">    <span class="string">Host</span> <span class="attr">Port:</span>  <span class="number">10402</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">    Command:</span></span><br><span class="line">      <span class="string">/bin/sh</span></span><br><span class="line"><span class="bullet">      -</span><span class="string">c</span></span><br><span class="line"><span class="attr">    Args:</span></span><br><span class="line">      <span class="string">gunicorn</span> <span class="bullet">-b</span> <span class="string">:10402</span> <span class="bullet">-k</span> <span class="string">gevent</span> <span class="string">test.main:flask_app</span> <span class="bullet">-w</span> <span class="number">2</span> <span class="bullet">--timeout</span> <span class="number">40</span> <span class="bullet">--pid</span> <span class="string">/var/run/test.pid</span></span><br><span class="line"><span class="attr">    Limits:</span></span><br><span class="line"><span class="attr">      cpu:</span>     <span class="number">0</span></span><br><span class="line"><span class="attr">      memory:</span>  <span class="number">0</span></span><br><span class="line"><span class="attr">    Requests:</span></span><br><span class="line"><span class="attr">      cpu:</span>        <span class="number">0</span></span><br><span class="line"><span class="attr">      memory:</span>     <span class="number">0</span></span><br><span class="line"><span class="attr">    Environment:</span>  <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时候我在检查资源的时候发现自己忘记设置资源了，我计划通过更新 values 数值来更新 daemonset：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default values for test.</span></span><br><span class="line"><span class="comment"># This is a YAML-formatted file.</span></span><br><span class="line"><span class="comment"># Declare variables to be passed into your templates.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">  limits:</span></span><br><span class="line"><span class="attr">   cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">   memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">  requests:</span></span><br><span class="line"><span class="attr">   cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">   memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure>
<p>执行 helm upgrade 时候报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node11 20:49:36 <span class="built_in">test</span>]<span class="variable">$helm</span> upgrade <span class="built_in">test</span> .</span><br><span class="line">Error: UPGRADE FAILED: error validating <span class="string">""</span>: error validating data: [unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.limits.cpu, unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.limits.memory, unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.requests.cpu, unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.requests.memory]</span><br></pre></td></tr></table></figure>
<p>根据报错信息可以看到这个字段之前是 <code>nil</code> ，现在我们要更新为有效类型更新失败，只能通过 <code>helm uninstall</code> 卸载后再次安装修复该问题。</p>
<p>这个问题只在 daemonset 类型下会出现。</p>
<h2 id="Flannel-网卡丢失"><a href="#Flannel-网卡丢失" class="headerlink" title="Flannel 网卡丢失"></a>Flannel 网卡丢失</h2><p>在通常情况下，我们的 k8s 节点都只有单一的网络环境，也就是有一块网卡，在部署 Flannel 插件的时候，默认会找默认路由所在的网卡，并将其绑定在上面。</p>
<p>由于内部测试环境较为特殊，我将其绑定在一个 ovs port 上，这个具体配置在 flannel yaml 中：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">kube-flannel</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">quay.io/coreos/flannel:v0.11.0-amd64</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/opt/bin/flanneld</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="bullet">--ip-masq</span></span><br><span class="line"><span class="bullet">  -</span> <span class="bullet">--kube-subnet-mgr</span></span><br><span class="line"><span class="bullet">  -</span> <span class="bullet">--iface=port-storage</span>  <span class="comment"># 在这里我强制指定了 iface</span></span><br></pre></td></tr></table></figure>
<p>正常运行时时没有问题的，但是对 ovs port 进行了 <code>ifdown</code> 操作后，在 OS 层面就无法找到这个 ovs port 了，flannel 默认的 <code>flannel.1</code> 这个 link 也丢失了，当我尝试 <code>ifup</code> ovs port，这个 port 正常恢复工作了，但是 <code>flannel.1</code> 无法自动恢复，目前找到的办法是手动重建 flannel pod。</p>
<p>猜测这个动作在 flannel 的init 相关步骤执行的，在之后 container 正常运行时没有考虑 <code>flannel.1</code> 不存在的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用经验通常是踩了一个又一个坑过来的~ </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/yiran.png" alt="yiran">
            
              <p class="site-author-name" itemprop="name">yiran</p>
              <p class="site-description motion-element" itemprop="description">Normal is boring</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zdyxry" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zdyxry@gmail.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/zhouyiran1994" target="_blank" title="Twitter">
                      Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/62229099/" target="_blank" title="Douban">
                      Douban</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://winkidney.com/" title="amao" target="_blank">amao</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jiajunhuang.com/" title="jiajun" target="_blank">jiajun</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://liuliqiang.info/" title="liqiang" target="_blank">liqiang</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiran</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zdyxry.disqus.com/count.js" async></script>
    

    

  

















  





  

  

  

  
  

  

  

  

</body>
</html>
