<!doctype html><html lang=zh-cn><head><title>Kubernetes 实战-Cluster API · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="背景 链接到标题 在当前 Kubernetes 生态中，生命周期管理相关工具官方的有 kubeadm、kubespray（部署集群部分通过 kubeadm） ，开源社区还有很多其他的实现，我们可以通过这类工具来实现 k8s 集群的部署，升级，增删节点，但是使用一个工具的前提是：基础设施已经准备完成。只有当基础设施准备完成后，kubeadm 之类工具才可以正常工作。
当我们在部署 Kubernetes 集群时，节点可能在任何环境上，比如 AWS、OpenStack、Vsphere、Azure 等，那么想要自动化配置基础设施，通常我们根据自己的环境不同，编写不通的代码来支持我们的虚拟化（or 服务器）场景。
基础设施包括不限于：
OS 安装 Load Balance 配置 网络配置 IP 分配 … Cluster-API 链接到标题 Kubernetes 社区针对基础设施问题，发起了一个项目：cluster-api，目前处于 alpha1 版本，项目目标：
使用声明式API管理 Kubernetes 集群的生命周期 支持多种环境，私有云或公有云 使用社区中现有的工具完成相应功能 … 功能简述 链接到标题 无需创建额外基础设施前提下创建 bootstrap cluster 通过 bootstrap cluster 创建目标 k8s 集群 工作流程 链接到标题 cluster-api 使用声明式 API 管理 k8s 集群，需要环境中先存在一个 k8s 集群，通常成为 bootstrap cluster，若不存在，也可通过提供的命令行工具 clusterctl 创建 bootstrap cluster 在 bootstrap cluster 中，部署 CRD 及相应的 cluster api 控制器及 provider 控制器 在 bootstrap cluster 中，开始创建我们真正想要创建的资源：k8s 集群 创建资源类型为 Cluster、Machine 或 MachineDeployment ，对应的控制器会自动为我们创建好虚拟机 在虚拟机创建完成后，通过 kubeadm 创建 k8s 集群 具体实现 链接到标题 虚拟机创建 链接到标题 目前看到的几个 Cluster-API Provider 项目实现，虚拟机均通过克隆的方式创建出来的。"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes 实战-Cluster API"><meta name=twitter:description content="背景 链接到标题 在当前 Kubernetes 生态中，生命周期管理相关工具官方的有 kubeadm、kubespray（部署集群部分通过 kubeadm） ，开源社区还有很多其他的实现，我们可以通过这类工具来实现 k8s 集群的部署，升级，增删节点，但是使用一个工具的前提是：基础设施已经准备完成。只有当基础设施准备完成后，kubeadm 之类工具才可以正常工作。
当我们在部署 Kubernetes 集群时，节点可能在任何环境上，比如 AWS、OpenStack、Vsphere、Azure 等，那么想要自动化配置基础设施，通常我们根据自己的环境不同，编写不通的代码来支持我们的虚拟化（or 服务器）场景。
基础设施包括不限于：
OS 安装 Load Balance 配置 网络配置 IP 分配 … Cluster-API 链接到标题 Kubernetes 社区针对基础设施问题，发起了一个项目：cluster-api，目前处于 alpha1 版本，项目目标：
使用声明式API管理 Kubernetes 集群的生命周期 支持多种环境，私有云或公有云 使用社区中现有的工具完成相应功能 … 功能简述 链接到标题 无需创建额外基础设施前提下创建 bootstrap cluster 通过 bootstrap cluster 创建目标 k8s 集群 工作流程 链接到标题 cluster-api 使用声明式 API 管理 k8s 集群，需要环境中先存在一个 k8s 集群，通常成为 bootstrap cluster，若不存在，也可通过提供的命令行工具 clusterctl 创建 bootstrap cluster 在 bootstrap cluster 中，部署 CRD 及相应的 cluster api 控制器及 provider 控制器 在 bootstrap cluster 中，开始创建我们真正想要创建的资源：k8s 集群 创建资源类型为 Cluster、Machine 或 MachineDeployment ，对应的控制器会自动为我们创建好虚拟机 在虚拟机创建完成后，通过 kubeadm 创建 k8s 集群 具体实现 链接到标题 虚拟机创建 链接到标题 目前看到的几个 Cluster-API Provider 项目实现，虚拟机均通过克隆的方式创建出来的。"><meta property="og:title" content="Kubernetes 实战-Cluster API"><meta property="og:description" content="背景 链接到标题 在当前 Kubernetes 生态中，生命周期管理相关工具官方的有 kubeadm、kubespray（部署集群部分通过 kubeadm） ，开源社区还有很多其他的实现，我们可以通过这类工具来实现 k8s 集群的部署，升级，增删节点，但是使用一个工具的前提是：基础设施已经准备完成。只有当基础设施准备完成后，kubeadm 之类工具才可以正常工作。
当我们在部署 Kubernetes 集群时，节点可能在任何环境上，比如 AWS、OpenStack、Vsphere、Azure 等，那么想要自动化配置基础设施，通常我们根据自己的环境不同，编写不通的代码来支持我们的虚拟化（or 服务器）场景。
基础设施包括不限于：
OS 安装 Load Balance 配置 网络配置 IP 分配 … Cluster-API 链接到标题 Kubernetes 社区针对基础设施问题，发起了一个项目：cluster-api，目前处于 alpha1 版本，项目目标：
使用声明式API管理 Kubernetes 集群的生命周期 支持多种环境，私有云或公有云 使用社区中现有的工具完成相应功能 … 功能简述 链接到标题 无需创建额外基础设施前提下创建 bootstrap cluster 通过 bootstrap cluster 创建目标 k8s 集群 工作流程 链接到标题 cluster-api 使用声明式 API 管理 k8s 集群，需要环境中先存在一个 k8s 集群，通常成为 bootstrap cluster，若不存在，也可通过提供的命令行工具 clusterctl 创建 bootstrap cluster 在 bootstrap cluster 中，部署 CRD 及相应的 cluster api 控制器及 provider 控制器 在 bootstrap cluster 中，开始创建我们真正想要创建的资源：k8s 集群 创建资源类型为 Cluster、Machine 或 MachineDeployment ，对应的控制器会自动为我们创建好虚拟机 在虚拟机创建完成后，通过 kubeadm 创建 k8s 集群 具体实现 链接到标题 虚拟机创建 链接到标题 目前看到的几个 Cluster-API Provider 项目实现，虚拟机均通过克隆的方式创建出来的。"><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2019/08/09/Kubernetes-%E5%AE%9E%E6%88%98-Cluster-API/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-09T19:41:49+00:00"><meta property="article:modified_time" content="2019-08-09T19:41:49+00:00"><link rel=canonical href=https://zdyxry.github.io/2019/08/09/Kubernetes-%E5%AE%9E%E6%88%98-Cluster-API/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.76ce9bad7ac9bd368d486c6e91e7e0906fff71d9d35ccbf93959a375e2bf50e5.css integrity="sha256-ds6brXrJvTaNSGxukefgkG//cdnTXMv5OVmjdeK/UOU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2019/08/09/Kubernetes-%E5%AE%9E%E6%88%98-Cluster-API/>Kubernetes 实战-Cluster API</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-08-09T19:41:49Z>August 9, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：1 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/Kubernetes/>Kubernetes</a></span></div></div></header><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#cluster-api>Cluster-API</a><ul><li><a href=#功能简述>功能简述</a></li><li><a href=#工作流程>工作流程</a></li><li><a href=#具体实现>具体实现</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav><div class=post-content><h2 id=背景>背景
<a class=heading-link href=#%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>在当前 Kubernetes 生态中，生命周期管理相关工具官方的有 kubeadm、kubespray（部署集群部分通过 kubeadm） ，开源社区还有很多其他的实现，我们可以通过这类工具来实现 k8s 集群的部署，升级，增删节点，但是使用一个工具的前提是：基础设施已经准备完成。只有当基础设施准备完成后，kubeadm 之类工具才可以正常工作。</p><p>当我们在部署 Kubernetes 集群时，节点可能在任何环境上，比如 AWS、OpenStack、Vsphere、Azure 等，那么想要自动化配置基础设施，通常我们根据自己的环境不同，编写不通的代码来支持我们的虚拟化（or 服务器）场景。</p><p>基础设施包括不限于：</p><ul><li>OS 安装</li><li>Load Balance 配置</li><li>网络配置</li><li>IP 分配</li><li>…</li></ul><h2 id=cluster-api>Cluster-API
<a class=heading-link href=#cluster-api><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>Kubernetes 社区针对基础设施问题，发起了一个项目：cluster-api，目前处于 alpha1 版本，项目目标：</p><ol><li>使用声明式API管理 Kubernetes 集群的生命周期</li><li>支持多种环境，私有云或公有云</li><li>使用社区中现有的工具完成相应功能</li><li>…</li></ol><h3 id=功能简述>功能简述
<a class=heading-link href=#%e5%8a%9f%e8%83%bd%e7%ae%80%e8%bf%b0><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><ol><li>无需创建额外基础设施前提下创建 bootstrap cluster</li><li>通过 bootstrap cluster 创建目标 k8s 集群</li></ol><h3 id=工作流程>工作流程
<a class=heading-link href=#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><ol><li>cluster-api 使用声明式 API 管理 k8s 集群，需要环境中先存在一个 k8s 集群，通常成为 bootstrap cluster，若不存在，也可通过提供的命令行工具 clusterctl 创建 bootstrap cluster</li><li>在 bootstrap cluster 中，部署 CRD 及相应的 cluster api 控制器及 provider 控制器</li><li>在 bootstrap cluster 中，开始创建我们真正想要创建的资源：k8s 集群
创建资源类型为 Cluster、Machine 或 MachineDeployment ，对应的控制器会自动为我们创建好虚拟机</li><li>在虚拟机创建完成后，通过 kubeadm 创建 k8s 集群</li></ol><h3 id=具体实现>具体实现
<a class=heading-link href=#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><h4 id=虚拟机创建>虚拟机创建
<a class=heading-link href=#%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%88%9b%e5%bb%ba><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>目前看到的几个 Cluster-API Provider 项目实现，虚拟机均通过克隆的方式创建出来的。</p><h4 id=虚拟机创建失败处理>虚拟机创建失败处理
<a class=heading-link href=#%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%88%9b%e5%bb%ba%e5%a4%b1%e8%b4%a5%e5%a4%84%e7%90%86><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>百度：每次等待 30s 查询一次，重试10次，若仍未成功，则创建失败</p><p>腾讯：每 2s 查询一次，若不成功，则一直循环</p><p>vsphere：提交虚拟机创建任务后未检查是否正确创建，未发现重试逻辑</p><p>OpenStack：每 10s 检测一次，若超过设定 timeout ，则创建失败</p><h4 id=虚拟机控制方式>虚拟机控制方式
<a class=heading-link href=#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>如果虚拟化平台支持 Cloud-init（或类似功能），后续 k8s 部署通过 Cloud-init 实现；</p><p>若虚拟化平台不支持，则 bootstrap cluster 中的 Pod 通过 ssh 方式进入倒虚拟机内部执行命令。</p><p>通过 Clout-init 实现的好处是Controller 只需要控制虚拟机开机即可，后续无需再主动与虚拟机进行通信，由 Cloud-init 自行触发部署 k8s集群任务；若没有 Cloud-init，则 Controller 在提交虚拟机创建任务后，需要循环等待虚拟机是否正常，等待正常后还需通过 ssh 主动与虚拟机进行连接控制，过于繁琐。</p><h2 id=总结>总结
<a class=heading-link href=#%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>Cluster API 目前还处于 Alpha1 版本，但是已经有很多厂家对其进行适配了，目前看到完成度比较高的公有云是 AWS，私有云是 Vsphere，之后好好读一下 Vsphere 的代码，了解下具体实现。</p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2024
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>