<!doctype html><html lang=zh-cn><head><title>2020 第33周 LeetCode 记录 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="1544. Make The String Great 链接到标题 使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。
class Solution: def makeGood(self, s: str) -> str: stack = [] for i in s: if stack and ((ord(stack[-1])-32) == ord(i) or (ord(stack[-1])+32) == ord(i)): stack.pop() else: stack.append(i) return ''.join(stack) 1545. Find Kth Bit in Nth Binary String 链接到标题 找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。
class Solution: def findKthBit(self, n: int, k: int) -> str: if (n == 1): return '0' l = (1 << n) - 1 mid = (l >> 1) + 1 if k == mid: return '1' elif k < mid: return self."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="2020 第33周 LeetCode 记录"><meta name=twitter:description content="1544. Make The String Great 链接到标题 使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。
class Solution: def makeGood(self, s: str) -> str: stack = [] for i in s: if stack and ((ord(stack[-1])-32) == ord(i) or (ord(stack[-1])+32) == ord(i)): stack.pop() else: stack.append(i) return ''.join(stack) 1545. Find Kth Bit in Nth Binary String 链接到标题 找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。
class Solution: def findKthBit(self, n: int, k: int) -> str: if (n == 1): return '0' l = (1 << n) - 1 mid = (l >> 1) + 1 if k == mid: return '1' elif k < mid: return self."><meta property="og:title" content="2020 第33周 LeetCode 记录"><meta property="og:description" content="1544. Make The String Great 链接到标题 使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。
class Solution: def makeGood(self, s: str) -> str: stack = [] for i in s: if stack and ((ord(stack[-1])-32) == ord(i) or (ord(stack[-1])+32) == ord(i)): stack.pop() else: stack.append(i) return ''.join(stack) 1545. Find Kth Bit in Nth Binary String 链接到标题 找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。
class Solution: def findKthBit(self, n: int, k: int) -> str: if (n == 1): return '0' l = (1 << n) - 1 mid = (l >> 1) + 1 if k == mid: return '1' elif k < mid: return self."><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-16T10:27:06+00:00"><meta property="article:modified_time" content="2020-08-16T10:27:06+00:00"><link rel=canonical href=https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.a1f1da6f0baa626de1763fc8157fdea088797379b7bbeb845799f2fffd5d0c82.css integrity="sha256-ofHabwuqYm3hdj/IFX/eoIh5c3m3u+uEV5ny//1dDII=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/>2020 第33周 LeetCode 记录</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-08-16T10:27:06Z>August 16, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：3 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/LeetCode/>LeetCode</a></span></div></div></header><nav id=TableOfContents><ul><li><ul><li><a href=#1544-make-the-string-great>1544. Make The String Great</a></li><li><a href=#1545-find-kth-bit-in-nth-binary-string>1545. Find Kth Bit in Nth Binary String</a></li><li><a href=#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</a></li><li><a href=#1541-minimum-insertions-to-balance-a-parentheses-string>1541. Minimum Insertions to Balance a Parentheses String</a></li><li><a href=#147-insertion-sort-list>147. Insertion Sort List</a></li></ul></li></ul></nav><div class=post-content><h3 id=1544-make-the-string-great>1544. Make The String Great
<a class=heading-link href=#1544-make-the-string-great><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> makeGood(self, s: str) -&gt; str:
</span></span><span style=display:flex><span>        stack = []
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> i <span style=font-weight:700>in</span> s:
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> stack <span style=font-weight:700>and</span> ((ord(stack[-1])-32) == ord(i) <span style=font-weight:700>or</span> (ord(stack[-1])+32) == ord(i)):
</span></span><span style=display:flex><span>                stack.pop()
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                stack.append(i)
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;&#39;</span>.join(stack)
</span></span></code></pre></div><h3 id=1545-find-kth-bit-in-nth-binary-string>1545. Find Kth Bit in Nth Binary String
<a class=heading-link href=#1545-find-kth-bit-in-nth-binary-string><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> findKthBit(self, n: int, k: int) -&gt; str:
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> (n == 1):
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;0&#39;</span>
</span></span><span style=display:flex><span>        l = (1 &lt;&lt; n) - 1
</span></span><span style=display:flex><span>        mid = (l &gt;&gt; 1) + 1
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> k == mid:
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;1&#39;</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>elif</span> k &lt; mid:
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> self.findKthBit(n - 1, k)
</span></span><span style=display:flex><span>        <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>            k = l + 1 -k
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;1&#39;</span> <span style=font-weight:700>if</span> self.findKthBit(n - 1, k) == <span style=font-style:italic>&#39;0&#39;</span> <span style=font-weight:700>else</span> <span style=font-style:italic>&#39;0&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> findKthBit(self, n: int, k: int) -&gt; str:
</span></span><span style=display:flex><span>        s = [0] * (n+1)
</span></span><span style=display:flex><span>        s[0] = <span style=font-style:italic>&#39;0&#39;</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> i <span style=font-weight:700>in</span> range(1, n+1):
</span></span><span style=display:flex><span>            s[i] = s[i-1] + <span style=font-style:italic>&#39;1&#39;</span> + self.reverse(s[i-1])
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> s[n][k-1]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> reverse(self, s):
</span></span><span style=display:flex><span>        res = []
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> i <span style=font-weight:700>in</span> s:
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> i == <span style=font-style:italic>&#39;1&#39;</span>:
</span></span><span style=display:flex><span>                res.append(<span style=font-style:italic>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                res.append(<span style=font-style:italic>&#39;1&#39;</span>)
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> <span style=font-style:italic>&#39;&#39;</span>.join(res[::-1])
</span></span></code></pre></div><h3 id=1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target
<a class=heading-link href=#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>这是一道告诉你方法就会立刻做出来的题目，前缀和，因为要求不重叠，因此在遍历过的结果中找到 target，那么就需要将 set 重置，cur_sum 清零。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> maxNonOverlapping(self, nums: List[int], target: int) -&gt; int:
</span></span><span style=display:flex><span>        s = {0}
</span></span><span style=display:flex><span>        cur_sum = 0
</span></span><span style=display:flex><span>        ans = 0
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> num <span style=font-weight:700>in</span> nums:
</span></span><span style=display:flex><span>            cur_sum += num
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> cur_sum - target <span style=font-weight:700>in</span> s:
</span></span><span style=display:flex><span>                s = {0}
</span></span><span style=display:flex><span>                cur_sum = 0
</span></span><span style=display:flex><span>                ans += 1
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                s.add(cur_sum)
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> ans
</span></span></code></pre></div><h3 id=1541-minimum-insertions-to-balance-a-parentheses-string>1541. Minimum Insertions to Balance a Parentheses String
<a class=heading-link href=#1541-minimum-insertions-to-balance-a-parentheses-string><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>看完题目第一想法是用栈来做，但是写了半天发现题目理解错了，这题跟 #1544 不同的是，它不会因为栈中某个时刻符合平衡括号的条件就全部出栈，比如 <code>"(()))(()))()())))"</code> 这个用例，如果自己计算理解了这个用例这道题也就做出来了。</p><p>使用栈记录当前遍历字符为 <code>(</code> 的情况，如果为 <code>(</code> 那么直接入栈，如果为 <code>)</code> ，那么此时有两种情况：</p><ul><li>如果栈不存在，意味着左边缺少 <code>(</code> ，那么就至少需要补充一个 <code>(</code> ，此时判断当前字符的右侧是否为 <code>)</code> ，如果是，那么只需要添加一个 <code>(</code> ，如果不是 <code>)</code> ，那么就需要添加一个 <code>(</code> 和一个 <code>)</code>；</li><li>如果栈存在，意味着左侧存在 <code>(</code> ，此时判断当前字符右侧是否为 <code>)</code> ，如果是，那么将左侧字符出栈，此时已经满足了平衡括号情况，无须添加，如果不是 <code>)</code> ，那么需要添加一个 <code>)</code> 满足平衡。</li></ul><p>最终判断 stack 是否还存在，如果存在，则每个 <code>(</code> 需要添加两个 <code>)</code> 满足条件。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> minInsertions(self, s: str) -&gt; int:
</span></span><span style=display:flex><span>        <span style=font-style:italic># use stack</span>
</span></span><span style=display:flex><span>        stack = []
</span></span><span style=display:flex><span>        count = 0
</span></span><span style=display:flex><span>        i=0
</span></span><span style=display:flex><span>        <span style=font-weight:700>while</span> i &lt; len(s):
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> s[i] == <span style=font-style:italic>&#39;(&#39;</span>:
</span></span><span style=display:flex><span>                stack.append(s[i])
</span></span><span style=display:flex><span>                i += 1
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                <span style=font-style:italic># when facing empty stack</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> stack:
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> i+1 &lt; len(s) <span style=font-weight:700>and</span> s[i+1] == <span style=font-style:italic>&#34;)&#34;</span>:
</span></span><span style=display:flex><span>                        count += 1  <span style=font-style:italic># add one &#34;(&#34;</span>
</span></span><span style=display:flex><span>                        i += 2
</span></span><span style=display:flex><span>                    <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                        count += 2   <span style=font-style:italic># add one &#34;(&#34;  and one &#34;)&#34;</span>
</span></span><span style=display:flex><span>                        i += 1
</span></span><span style=display:flex><span>                <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                    <span style=font-style:italic># check two positions</span>
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> i + 1 &lt; len(s) <span style=font-weight:700>and</span> s[i+1] == <span style=font-style:italic>&#34;)&#34;</span>:
</span></span><span style=display:flex><span>                        stack.pop()
</span></span><span style=display:flex><span>                        i += 2
</span></span><span style=display:flex><span>                    <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                        count += 1   <span style=font-style:italic># add one &#34;)&#34;</span>
</span></span><span style=display:flex><span>                        stack.pop()
</span></span><span style=display:flex><span>                        i += 1
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        rest = len(stack)*2  <span style=font-style:italic># still have &#34;(&#34; on the stack. one &#34;(&#34; pairs with two &#34;)&#34;</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> count + rest
</span></span></code></pre></div><h3 id=147-insertion-sort-list>147. Insertion Sort List
<a class=heading-link href=#147-insertion-sort-list><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p><a href=https://leetcode-cn.com/problems/insertion-sort-list/solution/da-lao-de-dai-ma-kan-ming-bai-hou-ji-ge-bi-ji-yong/>leetcode-cn</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-style:italic># Definition for singly-linked list.</span>
</span></span><span style=display:flex><span><span style=font-style:italic># class ListNode:</span>
</span></span><span style=display:flex><span><span style=font-style:italic>#     def __init__(self, val=0, next=None):</span>
</span></span><span style=display:flex><span><span style=font-style:italic>#         self.val = val</span>
</span></span><span style=display:flex><span><span style=font-style:italic>#         self.next = next</span>
</span></span><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> insertionSortList(self, head: ListNode) -&gt; ListNode:
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> head:                            
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> head
</span></span><span style=display:flex><span>        dummy=ListNode(float(-inf))             <span style=font-style:italic>#首项负无穷保证插的数据不在最前头</span>
</span></span><span style=display:flex><span>        dummy.next=head                         <span style=font-style:italic>#用于返回答案</span>
</span></span><span style=display:flex><span>        pre=head                                    
</span></span><span style=display:flex><span>        nxt=head.next
</span></span><span style=display:flex><span>        <span style=font-weight:700>while</span> nxt:                              <span style=font-style:italic>#最后一项为None结束循环</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> nxt.val&gt;pre.val:                 <span style=font-style:italic>#从头开始，如果后一项大于前一项不改变节点</span>
</span></span><span style=display:flex><span>               pre=nxt                          <span style=font-style:italic>#这两行移动指针（往后挪一格）</span>
</span></span><span style=display:flex><span>               nxt=nxt.next
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:                               <span style=font-style:italic>#如果后项小需要把后项nxt的节点插到正确位置</span>
</span></span><span style=display:flex><span>                pre.next=nxt.next               <span style=font-style:italic>#把nxt指向的节点拿出来</span>
</span></span><span style=display:flex><span>                cp1=dummy                       <span style=font-style:italic>#这两个指针负责从头开始比较nxt的位置</span>
</span></span><span style=display:flex><span>                cp2=dummy.next                  <span style=font-style:italic>#使用dummy的原因见11行注释</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>while</span> nxt.val&gt;cp2.val:          <span style=font-style:italic>#因为前面是排好序的循环结束nxt正好在cp1和cp2中间</span>
</span></span><span style=display:flex><span>                    cp1=cp2                     <span style=font-style:italic>#</span>
</span></span><span style=display:flex><span>                    cp2=cp2.next                <span style=font-style:italic>#</span>
</span></span><span style=display:flex><span>                nxt.next=cp2                    <span style=font-style:italic>#这两行负责插</span>
</span></span><span style=display:flex><span>                cp1.next=nxt                    <span style=font-style:italic>#把nxt指向的节点查到cp1和cp2中间</span>
</span></span><span style=display:flex><span>                nxt=pre.next                    <span style=font-style:italic>#指针从哪来回哪去 准备下一个循环</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> dummy.next
</span></span></code></pre></div></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2023
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>