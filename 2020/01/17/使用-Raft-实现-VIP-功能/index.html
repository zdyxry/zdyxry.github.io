<!doctype html><html lang=zh-cn><head><title>使用 Raft 实现 VIP 功能 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="背景 链接到标题 在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HAProxy 也存在单点故障，因此需要多个 HAProxy 来保证业务不中断，这时候我们需要另一个软件配合：Keepalived。通常我用 Keepalived 仅用来提供 VIP，保证当一个 Keepalived 故障，VIP 自动在其他 Keepalived 节点配置。
Keepalived 有一个问题是 virtual route ID 必须是同一网段内唯一的，当我们想要在一个网段内部署多个集群时，就需要人为的介入去分配 virtual route ID，不方便。这次来使用 Raft 自己实现 VIP 逻辑。
hashicorp/raft 链接到标题 Raft 有很多开源实现，其中 Hashicorp 实现的 Raft 库 已经被 Consul 等软件使用，且接口友善，选择使用它来实现。在 Github 上有很多 Raft 的使用示例，比较简单且完整的是 otoolep/hraftd，我们来看看他是怎么使用的。
otoolep/hraftd 链接到标题 main.go 链接到标题 在 main.go 中主要做了 4 件事情：store.New, store.Open, http.New, http.Start，先来看看程序是如何启动的：
func init() { // 设置命令行参数 flag.BoolVar(&inmem, &#34;inmem&#34;, false, &#34;Use in-memory storage for Raft&#34;) ."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用 Raft 实现 VIP 功能"><meta name=twitter:description content="背景 链接到标题 在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HAProxy 也存在单点故障，因此需要多个 HAProxy 来保证业务不中断，这时候我们需要另一个软件配合：Keepalived。通常我用 Keepalived 仅用来提供 VIP，保证当一个 Keepalived 故障，VIP 自动在其他 Keepalived 节点配置。
Keepalived 有一个问题是 virtual route ID 必须是同一网段内唯一的，当我们想要在一个网段内部署多个集群时，就需要人为的介入去分配 virtual route ID，不方便。这次来使用 Raft 自己实现 VIP 逻辑。
hashicorp/raft 链接到标题 Raft 有很多开源实现，其中 Hashicorp 实现的 Raft 库 已经被 Consul 等软件使用，且接口友善，选择使用它来实现。在 Github 上有很多 Raft 的使用示例，比较简单且完整的是 otoolep/hraftd，我们来看看他是怎么使用的。
otoolep/hraftd 链接到标题 main.go 链接到标题 在 main.go 中主要做了 4 件事情：store.New, store.Open, http.New, http.Start，先来看看程序是如何启动的：
func init() { // 设置命令行参数 flag.BoolVar(&inmem, &#34;inmem&#34;, false, &#34;Use in-memory storage for Raft&#34;) ."><meta property="og:title" content="使用 Raft 实现 VIP 功能"><meta property="og:description" content="背景 链接到标题 在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HAProxy 也存在单点故障，因此需要多个 HAProxy 来保证业务不中断，这时候我们需要另一个软件配合：Keepalived。通常我用 Keepalived 仅用来提供 VIP，保证当一个 Keepalived 故障，VIP 自动在其他 Keepalived 节点配置。
Keepalived 有一个问题是 virtual route ID 必须是同一网段内唯一的，当我们想要在一个网段内部署多个集群时，就需要人为的介入去分配 virtual route ID，不方便。这次来使用 Raft 自己实现 VIP 逻辑。
hashicorp/raft 链接到标题 Raft 有很多开源实现，其中 Hashicorp 实现的 Raft 库 已经被 Consul 等软件使用，且接口友善，选择使用它来实现。在 Github 上有很多 Raft 的使用示例，比较简单且完整的是 otoolep/hraftd，我们来看看他是怎么使用的。
otoolep/hraftd 链接到标题 main.go 链接到标题 在 main.go 中主要做了 4 件事情：store.New, store.Open, http.New, http.Start，先来看看程序是如何启动的：
func init() { // 设置命令行参数 flag.BoolVar(&inmem, &#34;inmem&#34;, false, &#34;Use in-memory storage for Raft&#34;) ."><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2020/01/17/%E4%BD%BF%E7%94%A8-Raft-%E5%AE%9E%E7%8E%B0-VIP-%E5%8A%9F%E8%83%BD/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-17T22:48:28+00:00"><meta property="article:modified_time" content="2020-01-17T22:48:28+00:00"><link rel=canonical href=https://zdyxry.github.io/2020/01/17/%E4%BD%BF%E7%94%A8-Raft-%E5%AE%9E%E7%8E%B0-VIP-%E5%8A%9F%E8%83%BD/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.01bd429dda63a16d76996eaf0b8da061429b76e714515cb1b246aac7fe7f4b2a.css integrity="sha256-Ab1CndpjoW12mW6vC42gYUKbducUUVyxskaqx/5/Syo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-dark"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2020/01/17/%E4%BD%BF%E7%94%A8-Raft-%E5%AE%9E%E7%8E%B0-VIP-%E5%8A%9F%E8%83%BD/>使用 Raft 实现 VIP 功能</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-01-17T22:48:28Z>January 17, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：6 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/Linux/>Linux</a></span></div></div></header><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#hashicorpraft>hashicorp/raft</a><ul><li><a href=#otoolephraftd>otoolep/hraftd</a></li></ul></li><li><a href=#vip>VIP</a><ul><li><a href=#network>network</a></li><li><a href=#raft-1>raft</a></li><li><a href=#serve>serve</a></li><li><a href=#arp>ARP</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考链接>参考链接</a></li></ul></nav><div class=post-content><h2 id=背景>背景
<a class=heading-link href=#%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HAProxy 也存在单点故障，因此需要多个 HAProxy 来保证业务不中断，这时候我们需要另一个软件配合：Keepalived。通常我用 Keepalived 仅用来提供 VIP，保证当一个 Keepalived 故障，VIP 自动在其他 Keepalived 节点配置。</p><p>Keepalived 有一个问题是 virtual route ID 必须是同一网段内唯一的，当我们想要在一个网段内部署多个集群时，就需要人为的介入去分配 virtual route ID，不方便。这次来使用 Raft 自己实现 VIP 逻辑。</p><h2 id=hashicorpraft>hashicorp/raft
<a class=heading-link href=#hashicorpraft><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>Raft 有很多开源实现，其中 Hashicorp 实现的 <a href=https://github.com/hashicorp/raft>Raft 库</a> 已经被 Consul 等软件使用，且接口友善，选择使用它来实现。在 Github 上有很多 Raft 的使用示例，比较简单且完整的是 <a href=https://github.com/otoolep/hraftd>otoolep/hraftd</a>，我们来看看他是怎么使用的。</p><h3 id=otoolephraftd>otoolep/hraftd
<a class=heading-link href=#otoolephraftd><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><h4 id=maingo>main.go
<a class=heading-link href=#maingo><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>在 main.go 中主要做了 4 件事情：<code>store.New</code>, <code>store.Open</code>, <code>http.New</code>, <code>http.Start</code>，先来看看程序是如何启动的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> init() {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 设置命令行参数
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	flag.BoolVar(&amp;inmem, <span style=font-style:italic>&#34;inmem&#34;</span>, <span style=font-weight:700>false</span>, <span style=font-style:italic>&#34;Use in-memory storage for Raft&#34;</span>)
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>	flag.Usage = <span style=font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		fmt.Fprintf(os.Stderr, <span style=font-style:italic>&#34;Usage: %s [options] &lt;raft-data-path&gt; \n&#34;</span>, os.Args[0])
</span></span><span style=display:flex><span>		flag.PrintDefaults()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 解析命令行参数
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	flag.Parse()
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 创建一个 Store 对象
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	s := store.New(inmem)
</span></span><span style=display:flex><span>	s.RaftDir = raftDir
</span></span><span style=display:flex><span>    s.RaftBind = raftAddr
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 运行 Store 
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	<span style=font-weight:700>if</span> err := s.Open(joinAddr == <span style=font-style:italic>&#34;&#34;</span>, nodeID); err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		log.Fatalf(<span style=font-style:italic>&#34;failed to open store: %s&#34;</span>, err.Error())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 新建一个 http 对象并运行
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	h := httpd.New(httpAddr, s)
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err := h.Start(); err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		log.Fatalf(<span style=font-style:italic>&#34;failed to start HTTP service: %s&#34;</span>, err.Error())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>// 如果 joinAddr 参数不为空，则处理 join 请求
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	<span style=font-weight:700>if</span> joinAddr != <span style=font-style:italic>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> err := join(joinAddr, raftAddr, nodeID); err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			log.Fatalf(<span style=font-style:italic>&#34;failed to join node at %s: %s&#34;</span>, joinAddr, err.Error())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	log.Println(<span style=font-style:italic>&#34;hraftd started successfully&#34;</span>)
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 监听系统信号，若接收到 os.Interrupt 则程序退出
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	terminate := make(<span style=font-weight:700>chan</span> os.Signal, 1)
</span></span><span style=display:flex><span>	signal.Notify(terminate, os.Interrupt)
</span></span><span style=display:flex><span>	&lt;-terminate
</span></span><span style=display:flex><span>	log.Println(<span style=font-style:italic>&#34;hraftd exiting&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=http>http
<a class=heading-link href=#http><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>看了 main.go 我们知道调用了 <code>http.Start</code>， 先不管 Store 是什么，先来看看 http 相关实现：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-style:italic>// Start starts the service.
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>func</span> (s *Service) Start() <span>error</span> {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// Service 实现了 ServeHTTP 方法
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	http.Handle(<span style=font-style:italic>&#34;/&#34;</span>, s)
</span></span><span style=display:flex><span>	<span style=font-weight:700>go</span> <span style=font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		err := server.Serve(s.ln)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (s *Service) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> strings.HasPrefix(r.URL.Path, <span style=font-style:italic>&#34;/key&#34;</span>) {
</span></span><span style=display:flex><span>		s.handleKeyRequest(w, r)
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 先忽略其他分支
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>主要处理请求的是 <code>s.handleKeyRequest</code> 方法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (s *Service) handleKeyRequest(w http.ResponseWriter, r *http.Request) {
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>	<span style=font-weight:700>switch</span> r.Method {
</span></span><span style=display:flex><span>	<span style=font-weight:700>case</span> <span style=font-style:italic>&#34;GET&#34;</span>:
</span></span><span style=display:flex><span>		k := getKey()
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> k == <span style=font-style:italic>&#34;&#34;</span> {
</span></span><span style=display:flex><span>			w.WriteHeader(http.StatusBadRequest)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		v, err := s.store.Get(k)
</span></span><span style=display:flex><span>		...
</span></span><span style=display:flex><span>		io.WriteString(w, string(b))
</span></span><span style=display:flex><span>	<span style=font-weight:700>case</span> <span style=font-style:italic>&#34;POST&#34;</span>:
</span></span><span style=display:flex><span>		<span style=font-style:italic>// Read the value from the POST body.
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>		m := <span style=font-weight:700>map</span>[<span>string</span>]<span>string</span>{}
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> err := json.NewDecoder(r.Body).Decode(&amp;m); err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			w.WriteHeader(http.StatusBadRequest)
</span></span><span style=display:flex><span>			<span style=font-weight:700>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=font-weight:700>for</span> k, v := <span style=font-weight:700>range</span> m {
</span></span><span style=display:flex><span>			<span style=font-weight:700>if</span> err := s.store.Set(k, v); err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>				w.WriteHeader(http.StatusInternalServerError)
</span></span><span style=display:flex><span>				<span style=font-weight:700>return</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>在 <code>s.handleKeyRequest</code> 中根据请求方法，去调用 store 对应的方法，那么 store 实现了哪些接口呢？这也是在 http 模块中定义的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>type</span> Store <span style=font-weight:700>interface</span> {
</span></span><span style=display:flex><span>	Get(key <span>string</span>) (<span>string</span>, <span>error</span>)
</span></span><span style=display:flex><span>	Set(key, value <span>string</span>) <span>error</span>
</span></span><span style=display:flex><span>	Delete(key <span>string</span>) <span>error</span>
</span></span><span style=display:flex><span>	Join(nodeID <span>string</span>, addr <span>string</span>) <span>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>除了 Join 看着比较奇怪，其他的都是一个 K/V 系统该有的接口，接下来就看看 Store 具体方法的实现。</p><h4 id=store>store
<a class=heading-link href=#store><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>这个模块的编写涉及到了 Raft 中的具体概念，建议先阅读 siddontang 写的 Raft 相关博客快速了解（链接在参考链接列出）。</p><p>以下以设置 Key 为例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (s *Store) Set(key, value <span>string</span>) <span>error</span> {
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> s.raft.State() != raft.Leader {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> fmt.Errorf(<span style=font-style:italic>&#34;not leader&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 封装具体执行的动作
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	c := &amp;command{
</span></span><span style=display:flex><span>		Op:    <span style=font-style:italic>&#34;set&#34;</span>,
</span></span><span style=display:flex><span>		Key:   key,
</span></span><span style=display:flex><span>		Value: value,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	b, err := json.Marshal(c)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 将 command 应用于 FSM
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	f := s.raft.Apply(b, raftTimeout)
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> f.Error()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>查看 FSM Apply 方法实现：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-style:italic>// Apply applies a Raft log entry to the key-value store.
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>func</span> (f *fsm) Apply(l *raft.Log) <span style=font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=font-weight:700>var</span> c command
</span></span><span style=display:flex><span>	<span style=font-style:italic>// 根据操作动作的不同，执行不同的方法，这里以设置 Key 为例
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	<span style=font-weight:700>switch</span> c.Op {
</span></span><span style=display:flex><span>	<span style=font-weight:700>case</span> <span style=font-style:italic>&#34;set&#34;</span>:
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> f.applySet(c.Key, c.Value)
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (f *fsm) applySet(key, value <span>string</span>) <span style=font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 互斥锁
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    f.mu.Lock()
</span></span><span style=display:flex><span>    <span style=font-weight:700>defer</span> f.mu.Unlock()
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 设置 Map 中的 Key/Value
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	f.m[key] = value
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=raft>raft
<a class=heading-link href=#raft><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h4><p>看了上面的具体动作实现，接下来看看 Raft 具体启动：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (s *Store) Open(enableSingle <span>bool</span>, localID <span>string</span>) <span>error</span> {
</span></span><span style=display:flex><span>	<span style=font-style:italic>// 设置 Raft 配置
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	config := raft.DefaultConfig()
</span></span><span style=display:flex><span>	config.LocalID = raft.ServerID(localID)
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 设置 Raft 通信
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	addr, err := net.ResolveTCPAddr(<span style=font-style:italic>&#34;tcp&#34;</span>, s.RaftBind)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>	transport, err := raft.NewTCPTransport(s.RaftBind, addr, 3, 10*time.Second, os.Stderr)
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 设置 Raft 存储对象
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	snapshots, err := raft.NewFileSnapshotStore(s.RaftDir, retainSnapshotCount, os.Stderr)
</span></span><span style=display:flex><span>	<span style=font-weight:700>var</span> logStore raft.LogStore
</span></span><span style=display:flex><span>	<span style=font-weight:700>var</span> stableStore raft.StableStore
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> s.inmem {
</span></span><span style=display:flex><span>		logStore = raft.NewInmemStore()
</span></span><span style=display:flex><span>		stableStore = raft.NewInmemStore()
</span></span><span style=display:flex><span>	} <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>		boltDB, err := raftboltdb.NewBoltStore(filepath.Join(s.RaftDir, <span style=font-style:italic>&#34;raft.db&#34;</span>))
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			<span style=font-weight:700>return</span> fmt.Errorf(<span style=font-style:italic>&#34;new bolt store: %s&#34;</span>, err)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		logStore = boltDB
</span></span><span style=display:flex><span>		stableStore = boltDB
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 创建 raft 示例，并使用该 raft 实例启动集群
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	ra, err := raft.NewRaft(config, (*fsm)(s), logStore, stableStore, snapshots, transport)
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> fmt.Errorf(<span style=font-style:italic>&#34;new raft: %s&#34;</span>, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	s.raft = ra
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> enableSingle {
</span></span><span style=display:flex><span>		...
</span></span><span style=display:flex><span>		ra.BootstrapCluster(configuration)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里可以看到 Raft 所需接口为 FSM 和 Snapshot，具体的实现方式根据需求来实现，一般与 hraftd 相仿，大概了解了 hashicorp/raft 的使用，那么我们来实现具体的 VIP 功能。</p><h2 id=vip>VIP
<a class=heading-link href=#vip><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><h3 id=network>network
<a class=heading-link href=#network><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>既然是跟 IP 相关，那么肯定需要给对应网卡配置时间，在 Linux 中我们可以通过 <code>ip</code> 命令来设置，Golang 中使用 <a href=https://github.com/vishvananda/netlink>vishvananda/netlink</a> 来实现。</p><p><code>netlink.AddrAdd</code> 可以在指定的网络设备上添加 IP 地址。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (nc *NetworkConfig) addIP() <span>error</span> {
</span></span><span style=display:flex><span>	res, err := nc.IsSet()
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> errors.Wrap(err, <span style=font-style:italic>&#34;ip check in AddIP failed&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> res {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err := netlink.AddrAdd(nc.link, nc.address); err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> errors.Wrap(err, <span style=font-style:italic>&#34;could not add ip&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>netlink.AddrDel</code> 可以将 IP 从指定网络设备上删除：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (nc *NetworkConfig) delIP() <span>error</span> {
</span></span><span style=display:flex><span>	res, err := nc.IsSet()
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> errors.Wrap(err, <span style=font-style:italic>&#34;ip check in DelIP failed&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> !res {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err := netlink.AddrDel(nc.link, nc.address); err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> errors.Wrap(err, <span style=font-style:italic>&#34;could not delete ip&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=raft-1>raft
<a class=heading-link href=#raft-1><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>实现了 IP 设置相关，我们不需要提供 HTTP 接口，直接编写 Raft 相关实现，跟 hraftd 实现不同，在 hraftd 中需要进行信息写入读取，而我们的 VIP 仅依赖于 Raft 选举 Leader，所以只需要编写好对应的方法，不需要做额外操作：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>type</span> FSM <span style=font-weight:700>struct</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> (fsm FSM) Apply(log *raft.Log) <span style=font-weight:700>interface</span>{} {
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> (fsm FSM) Restore(snap io.ReadCloser) <span>error</span> {
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> (fsm FSM) Snapshot() (raft.FSMSnapshot, <span>error</span>) {
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> Snapshot{}, <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>type</span> Snapshot <span style=font-weight:700>struct</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> (snapshot Snapshot) Persist(sink raft.SnapshotSink) <span>error</span> {
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> <span style=font-weight:700>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> (snapshot Snapshot) Release() {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=serve>serve
<a class=heading-link href=#serve><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>基础方法都已经实现了，那么接下来编写集群启动逻辑：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> (manager *VIPManager) Start() <span>error</span> {
</span></span><span style=display:flex><span>	<span style=font-style:italic>// 初始化 raft 配置、存储对象、通信
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	<span style=font-weight:700>for</span> id, ip := <span style=font-weight:700>range</span> manager.peers {
</span></span><span style=display:flex><span>		configuration.Servers = append(configuration.Servers, raft.Server{ID: raft.ServerID(id), Address: raft.ServerAddress(ip)})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>// 启动 Raft 集群，这里与 hraftd 不同，需要注意
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	<span style=font-weight:700>if</span> <span>error</span> := raft.BootstrapCluster(config, logStore, stableStore, snapshots, transport, configuration); <span>error</span> != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> <span>error</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>// 创建 raft 实例
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	raftServer, <span>error</span> := raft.NewRaft(config, manager.fsm, logStore, stableStore, snapshots, transport)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>	ticker := time.NewTicker(time.Second)
</span></span><span style=display:flex><span>	isLeader := <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span>    <span style=font-style:italic>// 服务启动时先删除 VIP，防止集群中同时存在节点都配置了 VIP
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	manager.deleteIP(<span style=font-weight:700>false</span>)
</span></span><span style=display:flex><span>	<span style=font-weight:700>go</span> <span style=font-weight:700>func</span>() {
</span></span><span style=display:flex><span>		<span style=font-weight:700>for</span> {
</span></span><span style=display:flex><span>			<span style=font-weight:700>select</span> {
</span></span><span style=display:flex><span>            <span style=font-style:italic>// 如果 当前节点是 Leader 节点，则设置 VIP
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>			<span style=font-weight:700>case</span> leader := &lt;-raftServer.LeaderCh():
</span></span><span style=display:flex><span>				<span style=font-weight:700>if</span> leader {
</span></span><span style=display:flex><span>					isLeader = <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>					log.Info(<span style=font-style:italic>&#34;Leading&#34;</span>)
</span></span><span style=display:flex><span>					manager.addIP(<span style=font-weight:700>true</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            <span style=font-style:italic>// 定时检测，如果是 Leader，则检测 VIP 是否正确设置，如果没有就再次配置 VIP
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>			<span style=font-weight:700>case</span> &lt;-ticker.C:
</span></span><span style=display:flex><span>				<span style=font-weight:700>if</span> isLeader {
</span></span><span style=display:flex><span>					result, <span>error</span> := manager.networkConfigurator.IsSet()
</span></span><span style=display:flex><span>					<span style=font-weight:700>if</span> <span>error</span> != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>						log.WithFields(log.Fields{<span style=font-style:italic>&#34;error&#34;</span>: <span>error</span>, <span style=font-style:italic>&#34;ip&#34;</span>: manager.networkConfigurator.IP(), <span style=font-style:italic>&#34;interface&#34;</span>: manager.networkConfigurator.Interface()}).Error(<span style=font-style:italic>&#34;Could not check ip&#34;</span>)
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					<span style=font-weight:700>if</span> result == <span style=font-weight:700>false</span> {
</span></span><span style=display:flex><span>						log.Error(<span style=font-style:italic>&#34;Lost IP&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>						manager.addIP(<span style=font-weight:700>true</span>)
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里与 hraftd 的实现不同，hraftd 先实例 raft，然后使用该 raft 实例启动集群，这样做的好处是哪怕集群只有一个节点，就是第一个节点，那么集群也是可以正常工作的，坏处是集群启动顺序是固定的，必须要先启动第一个节点，然后其他节点通过 Join 请求添加到 Raft 集群中（我们忽略了 Join 的走读）。</p><p>重新想一下我们的需求：集群、高可用、故障。当这几个词放在一起，我们就知道 hraftd 的方法不适合我们，有以下原因：</p><ol><li>集群节点启动顺序要求</li><li>各个节点配置文件不同，有的需要 Join 参数</li></ol><p>所以我们是直接使用 <code>raft.BootstrapCluster</code> 来启动集群，虽然只有一个节点集群无法正常工作，但是这个是可以容忍的。</p><h3 id=arp>ARP
<a class=heading-link href=#arp><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>在实现完上述功能后，我以为大功告成了，就开始自测，但是测试过程中发现了很诡异的现象，虽然我们通过 Raft 自身选举实现了 VIP 的故障自动漂移，但是实际测试中发现业务访问随着 VIP 的重建并没有立即恢复，，检查 ARP 记录发现集群中各个节点关于 VIP 的 ARP 记录各不相同，甚至是完全不同。</p><p>我们来重温下 ARP 协议内容：</p><blockquote><p>地址解析协议（英語：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。ARP最初在1982年的RFC 826（征求意见稿）[1]中提出并纳入互联网标准 STD 37. ARP 也可能指是在多数操作系统中管理其相关地址的一个进程。</p></blockquote><blockquote><p>在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p></blockquote><p>如果 VIP 与真实节点对应的 MAC 地址不同，就相当于 ARP 攻击了，所以我们的 Leader 节点设置完 VIP 后，还需要发送 ARP 请求广播，告诉广播域中的其他节点 VIP 正确的 MAC 地址。采用的方式是 gratuitous ARP（免费 ARP）。这里我们直接找一个开源的 ARP 实现来完成这个需求：</p><p><a href=https://github.com/google/seesaw>google/seesaw</a> 是一个负载均衡器，里面实现了这个功能：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-style:italic>// ARPSendGratuitous sends a gratuitous ARP message via the specified interface.
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>func</span> (ncc *SeesawNCC) ARPSendGratuitous(arp *ncctypes.ARPGratuitous, out *<span>int</span>) <span>error</span> {
</span></span><span style=display:flex><span>	iface, err := net.InterfaceByName(arp.IfaceName)
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> fmt.Errorf(<span style=font-style:italic>&#34;failed to get interface %q: %v&#34;</span>, arp.IfaceName, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	log.V(2).Infof(<span style=font-style:italic>&#34;Sending gratuitous ARP for %s (%s) via %s&#34;</span>, arp.IP, iface.HardwareAddr, iface.Name)
</span></span><span style=display:flex><span>	m, err := gratuitousARPReply(arp.IP, iface.HardwareAddr)
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> sendARP(iface, m)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=总结>总结
<a class=heading-link href=#%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>使用 hashicorp/raft 可以很简单方便的实现需要选举 Leader 的分布式应用，虽然我司的 Slogan 是 <code>Make IT Simple</code> ，但是愈发感觉 Hashicorp 才是这句话的忠实体现，他们的 Terraform、Vault、Consul、Nomad、Vagrant 等软件，都是让基础设施的适用与管理更简单方便的，还是很爽的。</p><p>本文的具体实现在 <a href=https://github.com/zdyxry/sparrow>sparrow</a> 可以看到。</p><h2 id=参考链接>参考链接
<a class=heading-link href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li><a href=https://www.jianshu.com/p/138b4d267084>https://www.jianshu.com/p/138b4d267084</a></li><li><a href=https://www.jianshu.com/p/2b60542640e2>https://www.jianshu.com/p/2b60542640e2</a></li><li><a href=https://www.jianshu.com/p/1bbd7162727d>https://www.jianshu.com/p/1bbd7162727d</a></li><li><a href=https://www.jianshu.com/p/99562bfec5c2>https://www.jianshu.com/p/99562bfec5c2</a></li><li><a href=https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE>https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE</a></li><li><a href=https://github.com/darxkies/virtual-ip/blob/master/pkg/manager.go>https://github.com/darxkies/virtual-ip/blob/master/pkg/manager.go</a></li></ul></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2023
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>