<!doctype html><html lang=zh-cn><head><title>2020 第29周 LeetCode 记录 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="1509. Minimum Difference Between Largest and Smallest Value in Three Moves 链接到标题 要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。
class Solution: def minDifference(self, nums: List[int]) -> int: nums.sort() return min(b - a for a, b in zip(nums[:4], nums[-4:])) 1512. Number of Good Pairs 链接到标题 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 ，返回好数对的数目。 只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。
class Solution: def numIdenticalPairs(self, A: List[int]) -> int: return sum(k * (k - 1) / 2 for k in collections."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="2020 第29周 LeetCode 记录"><meta name=twitter:description content="1509. Minimum Difference Between Largest and Smallest Value in Three Moves 链接到标题 要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。
class Solution: def minDifference(self, nums: List[int]) -> int: nums.sort() return min(b - a for a, b in zip(nums[:4], nums[-4:])) 1512. Number of Good Pairs 链接到标题 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 ，返回好数对的数目。 只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。
class Solution: def numIdenticalPairs(self, A: List[int]) -> int: return sum(k * (k - 1) / 2 for k in collections."><meta property="og:title" content="2020 第29周 LeetCode 记录"><meta property="og:description" content="1509. Minimum Difference Between Largest and Smallest Value in Three Moves 链接到标题 要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。
class Solution: def minDifference(self, nums: List[int]) -> int: nums.sort() return min(b - a for a, b in zip(nums[:4], nums[-4:])) 1512. Number of Good Pairs 链接到标题 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 ，返回好数对的数目。 只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。
class Solution: def numIdenticalPairs(self, A: List[int]) -> int: return sum(k * (k - 1) / 2 for k in collections."><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-19T11:19:38+00:00"><meta property="article:modified_time" content="2020-07-19T11:19:38+00:00"><link rel=canonical href=https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.01bd429dda63a16d76996eaf0b8da061429b76e714515cb1b246aac7fe7f4b2a.css integrity="sha256-Ab1CndpjoW12mW6vC42gYUKbducUUVyxskaqx/5/Syo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-dark"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/>2020 第29周 LeetCode 记录</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-07-19T11:19:38Z>July 19, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：2 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/LeetCode/>LeetCode</a></span></div></div></header><nav id=TableOfContents><ul><li><ul><li><a href=#1509-minimum-difference-between-largest-and-smallest-value-in-three-moves>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</a></li><li><a href=#1512-number-of-good-pairs>1512. Number of Good Pairs</a></li><li><a href=#1513-number-of-substrings-with-only-1s>1513. Number of Substrings With Only 1s</a></li><li><a href=#1114-print-in-order>1114. Print in Order</a></li><li><a href=#1209-remove-all-adjacent-duplicates-in-string-ii>1209. Remove All Adjacent Duplicates in String II</a></li></ul></li></ul></nav><div class=post-content><h3 id=1509-minimum-difference-between-largest-and-smallest-value-in-three-moves>1509. Minimum Difference Between Largest and Smallest Value in Three Moves
<a class=heading-link href=#1509-minimum-difference-between-largest-and-smallest-value-in-three-moves><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> minDifference(self, nums: List[int]) -&gt; int:
</span></span><span style=display:flex><span>        nums.sort()
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> min(b - a <span style=font-weight:700>for</span> a, b <span style=font-weight:700>in</span> zip(nums[:4], nums[-4:]))
</span></span></code></pre></div><h3 id=1512-number-of-good-pairs>1512. Number of Good Pairs
<a class=heading-link href=#1512-number-of-good-pairs><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 ，返回好数对的数目。
只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> numIdenticalPairs(self, A: List[int]) -&gt; int:
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> sum(k * (k - 1) / 2 <span style=font-weight:700>for</span> k <span style=font-weight:700>in</span> collections.Counter(A).values())
</span></span></code></pre></div><h3 id=1513-number-of-substrings-with-only-1s>1513. Number of Substrings With Only 1s
<a class=heading-link href=#1513-number-of-substrings-with-only-1s><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>判断连续 1 的个数，每当遇到 1 时计数 +1， 遇到 0 时对现有计数进行求和公式，并加到最终结果中，重置计数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> numSub(self, s: str) -&gt; int:
</span></span><span style=display:flex><span>        cnt = 0
</span></span><span style=display:flex><span>        res = 0
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> i <span style=font-weight:700>in</span> s:
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> i == <span style=font-style:italic>&#39;1&#39;</span>:
</span></span><span style=display:flex><span>                cnt += 1
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                res += cnt * (cnt +1) /2
</span></span><span style=display:flex><span>                cnt = 0
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> cnt &gt; 0:
</span></span><span style=display:flex><span>            res += cnt * (cnt + 1)/ 2
</span></span><span style=display:flex><span>        res %= 1e9+7
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> int(res)
</span></span></code></pre></div><h3 id=1114-print-in-order>1114. Print in Order
<a class=heading-link href=#1114-print-in-order><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>将各个线程按照顺序执行，有很多实现方式，挑一种方式实现就可以了，这里直接使用 <code>threading.Event</code> 。</p><p><code>threading.Event</code> 定义如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false.
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>threading</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Foo</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> __init__(self):
</span></span><span style=display:flex><span>        self.b1 = threading.Event()
</span></span><span style=display:flex><span>        self.b2 = threading.Event()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> first(self, printFirst: <span style=font-style:italic>&#39;Callable[[], None]&#39;</span>) -&gt; <span style=font-weight:700>None</span>:
</span></span><span style=display:flex><span>        printFirst()
</span></span><span style=display:flex><span>        self.b1.set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> second(self, printSecond: <span style=font-style:italic>&#39;Callable[[], None]&#39;</span>) -&gt; <span style=font-weight:700>None</span>:
</span></span><span style=display:flex><span>        self.b1.wait()
</span></span><span style=display:flex><span>        printSecond()
</span></span><span style=display:flex><span>        self.b2.set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> third(self, printThird: <span style=font-style:italic>&#39;Callable[[], None]&#39;</span>) -&gt; <span style=font-weight:700>None</span>:
</span></span><span style=display:flex><span>        self.b2.wait()
</span></span><span style=display:flex><span>        printThird()
</span></span></code></pre></div><h3 id=1209-remove-all-adjacent-duplicates-in-string-ii>1209. Remove All Adjacent Duplicates in String II
<a class=heading-link href=#1209-remove-all-adjacent-duplicates-in-string-ii><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>这题描述有点别扭，给一个字符串，如果字符串中包含 k 个相邻且相等的字母，那么就原地删除，然后继续检测是否满足条件，重复执行操作。使用栈来记录最终结果，遍历字符串，如果当前自负和栈顶相同，且长度等于 k，那么就出栈，最终将栈中记录拼接为字符串。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> removeDuplicates(self, s: str, k: int) -&gt; str:
</span></span><span style=display:flex><span>        stack = []
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> i <span style=font-weight:700>in</span> s:
</span></span><span style=display:flex><span>            print(i)
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> len(stack) == 0 <span style=font-weight:700>or</span> stack[-1][0] != i:
</span></span><span style=display:flex><span>                stack.append([i, 1])
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                stack[-1][1] += 1
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> stack[-1][1] == k:
</span></span><span style=display:flex><span>                    stack.pop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ret = <span style=font-style:italic>&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> t <span style=font-weight:700>in</span> stack:
</span></span><span style=display:flex><span>            ret += t[0] * t[1]
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> ret
</span></span></code></pre></div></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2023
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>