<!doctype html><html lang=zh-cn><head><title>2020 第24周 LeetCode 记录 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="1470. Shuffle the Array 链接到标题 重新排列数组，使用 zip 对两个切分后的数组进行聚合
class Solution: def shuffle(self, nums: List[int], n: int) -> List[int]: res = [] for i, j in zip(nums[0:n],nums[n:]): res+=[i,j] return res 1471. The k Strongest Values in an Array 链接到标题 找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。
class Solution: def getStrongest(self, arr: List[int], k: int) -> List[int]: arr.sort() i, j = 0, len(arr) - 1 median = arr[(len(arr) - 1) // 2] while len(arr) + i - j <= k: if median - arr[i] > arr[j] - median: i = i + 1 else: j = j - 1 return arr[:i] + arr[j + 1:] 1472."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="2020 第24周 LeetCode 记录"><meta name=twitter:description content="1470. Shuffle the Array 链接到标题 重新排列数组，使用 zip 对两个切分后的数组进行聚合
class Solution: def shuffle(self, nums: List[int], n: int) -> List[int]: res = [] for i, j in zip(nums[0:n],nums[n:]): res+=[i,j] return res 1471. The k Strongest Values in an Array 链接到标题 找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。
class Solution: def getStrongest(self, arr: List[int], k: int) -> List[int]: arr.sort() i, j = 0, len(arr) - 1 median = arr[(len(arr) - 1) // 2] while len(arr) + i - j <= k: if median - arr[i] > arr[j] - median: i = i + 1 else: j = j - 1 return arr[:i] + arr[j + 1:] 1472."><meta property="og:title" content="2020 第24周 LeetCode 记录"><meta property="og:description" content="1470. Shuffle the Array 链接到标题 重新排列数组，使用 zip 对两个切分后的数组进行聚合
class Solution: def shuffle(self, nums: List[int], n: int) -> List[int]: res = [] for i, j in zip(nums[0:n],nums[n:]): res+=[i,j] return res 1471. The k Strongest Values in an Array 链接到标题 找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。
class Solution: def getStrongest(self, arr: List[int], k: int) -> List[int]: arr.sort() i, j = 0, len(arr) - 1 median = arr[(len(arr) - 1) // 2] while len(arr) + i - j <= k: if median - arr[i] > arr[j] - median: i = i + 1 else: j = j - 1 return arr[:i] + arr[j + 1:] 1472."><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-13T07:38:57+00:00"><meta property="article:modified_time" content="2020-06-13T07:38:57+00:00"><link rel=canonical href=https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.76ce9bad7ac9bd368d486c6e91e7e0906fff71d9d35ccbf93959a375e2bf50e5.css integrity="sha256-ds6brXrJvTaNSGxukefgkG//cdnTXMv5OVmjdeK/UOU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/>2020 第24周 LeetCode 记录</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-06-13T07:38:57Z>June 13, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：2 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/LeetCode/>LeetCode</a></span></div></div></header><nav id=TableOfContents><ul><li><ul><li><a href=#1470-shuffle-the-array>1470. Shuffle the Array</a></li><li><a href=#1471-the-k-strongest-values-in-an-array>1471. The k Strongest Values in an Array</a></li><li><a href=#1472-design-browser-history>1472. Design Browser History</a></li><li><a href=#754-reach-a-number>754. Reach a Number</a></li><li><a href=#1038-binary-search-tree-to-greater-sum-tree>1038. Binary Search Tree to Greater Sum Tree</a></li></ul></li></ul></nav><div class=post-content><h3 id=1470-shuffle-the-array>1470. Shuffle the Array
<a class=heading-link href=#1470-shuffle-the-array><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>重新排列数组，使用 zip 对两个切分后的数组进行聚合</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> shuffle(self, nums: List[int], n: int) -&gt; List[int]:
</span></span><span style=display:flex><span>        res = []
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> i, j <span style=font-weight:700>in</span> zip(nums[0:n],nums[n:]):
</span></span><span style=display:flex><span>            res+=[i,j]
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> res
</span></span></code></pre></div><h3 id=1471-the-k-strongest-values-in-an-array>1471. The k Strongest Values in an Array
<a class=heading-link href=#1471-the-k-strongest-values-in-an-array><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> getStrongest(self, arr: List[int], k: int) -&gt; List[int]:
</span></span><span style=display:flex><span>        arr.sort()
</span></span><span style=display:flex><span>        i, j = 0, len(arr) - 1
</span></span><span style=display:flex><span>        median = arr[(len(arr) - 1) // 2]
</span></span><span style=display:flex><span>        <span style=font-weight:700>while</span> len(arr) + i - j &lt;= k:
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> median - arr[i] &gt; arr[j] - median:
</span></span><span style=display:flex><span>                i = i + 1
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                j = j - 1
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> arr[:i] + arr[j + 1:]
</span></span></code></pre></div><h3 id=1472-design-browser-history>1472. Design Browser History
<a class=heading-link href=#1472-design-browser-history><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>用两个变量记录 homepage 和当前位置，处理几个场景：</p><ol><li>从当前页跳转访问 url 对应的页面，需要将当前位置之后的所有历史列表清空</li><li>在浏览历史中后退 steps 步，需要与 0 比较，如果小于 0，则将其置为 0</li><li>在浏览历史中前进 steps 步，需要与当前历史记录长度比较，如果超过长度，则取历史记录中最后一个</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>BrowserHistory</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> __init__(self, homepage: str):
</span></span><span style=display:flex><span>        self.hist = [homepage]
</span></span><span style=display:flex><span>        self.pos = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> visit(self, url: str) -&gt; <span style=font-weight:700>None</span>:
</span></span><span style=display:flex><span>        self.pos += 1
</span></span><span style=display:flex><span>        self.hist[self.pos:] = []
</span></span><span style=display:flex><span>        self.hist.append(url)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> back(self, steps: int) -&gt; str:
</span></span><span style=display:flex><span>        self.pos -= steps
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> self.pos &lt; 0:
</span></span><span style=display:flex><span>            self.pos = 0
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> self.hist[self.pos]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> forward(self, steps: int) -&gt; str:
</span></span><span style=display:flex><span>        self.pos += steps
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> self.pos &gt;= len(self.hist):
</span></span><span style=display:flex><span>            self.pos = len(self.hist) - 1
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> self.hist[self.pos]
</span></span></code></pre></div><h3 id=754-reach-a-number>754. Reach a Number
<a class=heading-link href=#754-reach-a-number><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><blockquote><p><a href=https://www.bilibili.com/video/av31621072/>https://www.bilibili.com/video/av31621072/</a></p></blockquote><blockquote><p><a href=https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/>https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/</a></p></blockquote><p>首先， 由于坐标轴是对称的，往左往右走的几率相等，因此可以只考虑右半轴。先递推一下可以知道:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>步数        能到达的位置
</span></span><span style=display:flex><span>1:          1
</span></span><span style=display:flex><span>2:          3, 1
</span></span><span style=display:flex><span>3:          6, 4, 2, 0
</span></span><span style=display:flex><span>4:          10, 8, 6, 4, 0
</span></span><span style=display:flex><span>5:          15, 13, 11, 9, 7, 5, 3, 1
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>可以看出来，每一步能到达的最大位置是上一步最大位置加上步数，而每一步所能达到的位置之间间隔都为2。<br>记f(n)为第n步能到达的位置，那么有：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>max(f(n)) = max(f(n-1)) + n
</span></span><span style=display:flex><span>f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]
</span></span></code></pre></div><p>如果target可以在第n步达到，那么target一定小于等于max(f(n))且max(f(n))与taget同奇同偶。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> reachNumber(self, target: int) -&gt; int:
</span></span><span style=display:flex><span>        target = abs(target)
</span></span><span style=display:flex><span>        p, i = 0, 0
</span></span><span style=display:flex><span>        <span style=font-weight:700>while</span> p &lt; target <span style=font-weight:700>or</span> (p + target) % 2 != 0:
</span></span><span style=display:flex><span>            i += 1
</span></span><span style=display:flex><span>            p = p + i
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> i
</span></span></code></pre></div><h3 id=1038-binary-search-tree-to-greater-sum-tree>1038. Binary Search Tree to Greater Sum Tree
<a class=heading-link href=#1038-binary-search-tree-to-greater-sum-tree><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>与 538 题相同，使用 dfs 遍历，优先遍历右节点，然后root 节点，最后左节点，使用 currSum 记录比当前节点数值大的数字和，然后将自身与数字和想家，并更新数字和。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-style:italic># Definition for a binary tree node.</span>
</span></span><span style=display:flex><span><span style=font-style:italic># class TreeNode:</span>
</span></span><span style=display:flex><span><span style=font-style:italic>#     def __init__(self, val=0, left=None, right=None):</span>
</span></span><span style=display:flex><span><span style=font-style:italic>#         self.val = val</span>
</span></span><span style=display:flex><span><span style=font-style:italic>#         self.left = left</span>
</span></span><span style=display:flex><span><span style=font-style:italic>#         self.right = right</span>
</span></span><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Solution</span>:
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> bstToGst(self, root: TreeNode) -&gt; TreeNode:
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> root <span style=font-weight:700>is</span> <span style=font-weight:700>None</span>:
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> <span style=font-weight:700>None</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        currSum = [0]
</span></span><span style=display:flex><span>        self.recurse(root, currSum)
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> root
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> recurse(self, root, currSum):
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> root <span style=font-weight:700>is</span> <span style=font-weight:700>None</span>:
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span>
</span></span><span style=display:flex><span>        self.recurse(root.right, currSum)
</span></span><span style=display:flex><span>        root.val = root.val + currSum[0]
</span></span><span style=display:flex><span>        currSum[0] = root.val
</span></span><span style=display:flex><span>        self.recurse(root.left, currSum)
</span></span></code></pre></div></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2023
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>