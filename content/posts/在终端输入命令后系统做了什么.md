---
title: 在终端输入命令后系统做了什么
date: 2020-04-25 15:18:03
tags:
- Linux
---


## 背景

无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。

## Shell

shell 是一个程序，也是一种编程语言，一个管理进程和运行程序的程序，在 Linux 中有很多 shell 可选，比如 bash、zsh、fish 等等，shell 主要有 3 个功能：

1. 运行程序
2. 管理输入和输出
3. 可编程

运行程序很容易理解，在终端上输入的每个命令都是一个可执行程序，我们在 shell 中输入并执行程序；管理输入和输出，在 shell 中可以使用 `<` `>` `|` 符合控制输入、输出重定向，可以告诉 shell 将进程的输入和输出连接到一个文件或者其他的进程；编程，shell 是一种编程语言，可以进行变量赋值、循环、条件判断等操作。

### 如何运行程序

shell 永远在等待用户输入，输入完成按下回车键后，开始执行相应命令（程序），然后等待程序执行完成后打印相应输出，伪代码：

```
while (! end_of_input)
    get command
    execute command
    wait for command to finish
```

在 shell 中因为需要执行其他的程序，需要用到 `execvp` ，`execvp` 会将指定的程序复制到调用它的进程，将指定的字符串组作为参数传递给程序，然后运行程序。这里存在一个问题， `execvp` 的执行过程是内核将程序加载到当前进程，替换当前进程的代码和数据，然后执行，那么原有进程的状态都被替换掉，在执行完程序就直接退出，不会再回到原程序等待下次输入。

为了保证我们在执行程序后回到 shell 中，需要每次创建新的进程来执行程序，调用 `fork` 指令，进程调用 fork 后，内核分配新的内存块和内核数据结构，复制原进程到新的进程，向运行进程添加新的进程，将控制返回给两个进程。通过 fork 返回值来判断当前进程是否为父进程或子进程。

shell 作为父进程通过调用 `fork` 创建子进程后，子进程通过 `execvp` 加载指定程序执行，父进程需要等待子进程退出，需要用到 `wait` ，在父进程 fork 出子进程后，父进程执行 `wait` 等待子进程执行，在调用时会传递一个整型变量地址，子进程执行完成后调用 `exit` 退出，内核将子进程的退出状态保存在这个变量中，用于父进程感知子进程退出状态。

## Golang 简易实现

在 Golang 中可以调用 `os/exec` 来执行其他程序，然后在 main 中死循环不断的检测用户输入字符，同时也需要注意处理各种信号，比如 Ctrl-C 或者 Ctrl-D 之类的，下面是 Simon Jürgensmeyer 实现的一个简单的样例，可以了解一下：

```go
package main

import (
    "bufio"
    "errors"
    "fmt"
    "os"
    "os/exec"
    "strings"
)

func main() {
    reader := bufio.NewReader(os.Stdin)
    for {
        fmt.Print("> ")
        // Read the keyboad input.
        input, err := reader.ReadString('\n')
        if err != nil {
            fmt.Fprintln(os.Stderr, err)
        }

        // Handle the execution of the input.
        if err = execInput(input); err != nil {
            fmt.Fprintln(os.Stderr, err)
        }
    }
}

// ErrNoPath is returned when 'cd' was called without a second argument.
var ErrNoPath = errors.New("path required")

func execInput(input string) error {
    // Remove the newline character.
    input = strings.TrimSuffix(input, "\n")

    // Split the input separate the command and the arguments.
    args := strings.Split(input, " ")

    // Check for built-in commands.
    switch args[0] {
    case "cd":
        // 'cd' to home with empty path not yet supported.
        if len(args) < 2 {
            return ErrNoPath
        }
        // Change the directory and return the error.
        return os.Chdir(args[1])
    case "exit":
        os.Exit(0)
    }

    // Prepare the command to execute.
    cmd := exec.Command(args[0], args[1:]...)

    // Set the correct output device.
    cmd.Stderr = os.Stderr
    cmd.Stdout = os.Stdout

    // Execute the command and return the error.
    return cmd.Run()
}
```


## 参考链接
* https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/
* https://book.douban.com/subject/1219329/