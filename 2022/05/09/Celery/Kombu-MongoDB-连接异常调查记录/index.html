<!doctype html><html lang=zh-cn><head><title>Celery/Kombu MongoDB 连接异常调查记录 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="背景 链接到标题 产品组件 JobCenter 使用 Celery 实现异步任务中心，同时会运行 job-center-worker （celery worker） 和 job-center-scheduler(celery beat) 两个进程，使用 MongoDB 作为 Backend 存储 message 等信息（Celery 官方已说明不再维护对 MongoDB 的支持）。其中 MongoDB 配置了 ReplicaSet 保证高可用。
近期 Celery/Kombu 中遇到了 No free channel ids 问题，经过排查在这个 PR 中解决了该问题，在考虑 cherry-pick 的工作量和可维护性考虑，最终将产品中的 celery 和 kombu 组件从 3.x 统一升级到了 4.x 版本。
测试同学反馈近期在进行可靠性测试时，发现将 MongoDB 节点的存储网络 ifdown 会导致 JobCenter hang. 针对该问题进行调查。
调查 链接到标题 Celery 链接到标题 先尝试复现该问题，首先尝试 ifdown Primary 节点存储网络，现象复现；尝试 ifdown Secondary 节点存储网络，无法复现； 尝试 stop MongoDB service 替代 ifdown，Primary 或 Secondary 均无法复现。推测与 MongoDB 连接处理有关。"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Celery/Kombu MongoDB 连接异常调查记录"><meta name=twitter:description content="背景 链接到标题 产品组件 JobCenter 使用 Celery 实现异步任务中心，同时会运行 job-center-worker （celery worker） 和 job-center-scheduler(celery beat) 两个进程，使用 MongoDB 作为 Backend 存储 message 等信息（Celery 官方已说明不再维护对 MongoDB 的支持）。其中 MongoDB 配置了 ReplicaSet 保证高可用。
近期 Celery/Kombu 中遇到了 No free channel ids 问题，经过排查在这个 PR 中解决了该问题，在考虑 cherry-pick 的工作量和可维护性考虑，最终将产品中的 celery 和 kombu 组件从 3.x 统一升级到了 4.x 版本。
测试同学反馈近期在进行可靠性测试时，发现将 MongoDB 节点的存储网络 ifdown 会导致 JobCenter hang. 针对该问题进行调查。
调查 链接到标题 Celery 链接到标题 先尝试复现该问题，首先尝试 ifdown Primary 节点存储网络，现象复现；尝试 ifdown Secondary 节点存储网络，无法复现； 尝试 stop MongoDB service 替代 ifdown，Primary 或 Secondary 均无法复现。推测与 MongoDB 连接处理有关。"><meta property="og:title" content="Celery/Kombu MongoDB 连接异常调查记录"><meta property="og:description" content="背景 链接到标题 产品组件 JobCenter 使用 Celery 实现异步任务中心，同时会运行 job-center-worker （celery worker） 和 job-center-scheduler(celery beat) 两个进程，使用 MongoDB 作为 Backend 存储 message 等信息（Celery 官方已说明不再维护对 MongoDB 的支持）。其中 MongoDB 配置了 ReplicaSet 保证高可用。
近期 Celery/Kombu 中遇到了 No free channel ids 问题，经过排查在这个 PR 中解决了该问题，在考虑 cherry-pick 的工作量和可维护性考虑，最终将产品中的 celery 和 kombu 组件从 3.x 统一升级到了 4.x 版本。
测试同学反馈近期在进行可靠性测试时，发现将 MongoDB 节点的存储网络 ifdown 会导致 JobCenter hang. 针对该问题进行调查。
调查 链接到标题 Celery 链接到标题 先尝试复现该问题，首先尝试 ifdown Primary 节点存储网络，现象复现；尝试 ifdown Secondary 节点存储网络，无法复现； 尝试 stop MongoDB service 替代 ifdown，Primary 或 Secondary 均无法复现。推测与 MongoDB 连接处理有关。"><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2022/05/09/Celery/Kombu-MongoDB-%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-09T14:44:42+00:00"><meta property="article:modified_time" content="2022-05-09T14:44:42+00:00"><link rel=canonical href=https://zdyxry.github.io/2022/05/09/Celery/Kombu-MongoDB-%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.76ce9bad7ac9bd368d486c6e91e7e0906fff71d9d35ccbf93959a375e2bf50e5.css integrity="sha256-ds6brXrJvTaNSGxukefgkG//cdnTXMv5OVmjdeK/UOU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2022/05/09/Celery/Kombu-MongoDB-%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95/>Celery/Kombu MongoDB 连接异常调查记录</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-05-09T14:44:42Z>May 9, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：6 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/Python/>Python</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/Celery/>Celery</a></span></div></div></header><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#调查>调查</a><ul><li><a href=#celery>Celery</a></li><li><a href=#kombu>Kombu</a></li><li><a href=#celery-与-kombu-参数传递>Celery 与 Kombu 参数传递</a></li></ul></li><li><a href=#celery-改动背景>Celery 改动背景</a></li><li><a href=#总结>总结</a></li></ul></nav><div class=post-content><h2 id=背景>背景
<a class=heading-link href=#%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>产品组件 JobCenter 使用 Celery 实现异步任务中心，同时会运行 job-center-worker （celery worker） 和 job-center-scheduler(celery beat) 两个进程，使用 MongoDB 作为 Backend 存储 message 等信息（Celery 官方已说明不再维护对 MongoDB 的支持）。其中 MongoDB 配置了 ReplicaSet 保证高可用。</p><p>近期 Celery/Kombu 中遇到了 <a href=https://github.com/celery/kombu/issues/1504#event-6304977800><code>No free channel ids</code> 问题</a>，经过排查在这个 <a href=https://github.com/celery/kombu/commit/1c2b9723851db3caa913b8da19d6ccad447f3568>PR</a> 中解决了该问题，在考虑 cherry-pick 的工作量和可维护性考虑，最终将产品中的 celery 和 kombu 组件从 3.x 统一升级到了 4.x 版本。</p><p>测试同学反馈近期在进行可靠性测试时，发现将 MongoDB 节点的存储网络 <code>ifdown</code> 会导致 JobCenter hang. 针对该问题进行调查。</p><h2 id=调查>调查
<a class=heading-link href=#%e8%b0%83%e6%9f%a5><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><h3 id=celery>Celery
<a class=heading-link href=#celery><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>先尝试复现该问题，首先尝试 ifdown Primary 节点存储网络，现象复现；尝试 ifdown Secondary 节点存储网络，无法复现；
尝试 stop MongoDB service 替代 ifdown，Primary 或 Secondary 均无法复现。推测与 MongoDB 连接处理有关。</p><p>观察现象复现的日志，在存储网络异常时，日志无任何输出，在存储网络恢复正常后，可以看到 Celery 记录在尝试连接 Broker （MongoDB）时发生了异常，尝试重连。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>[2022-05-07 10:13:01,362: WARNING/MainProcess] consumer: Connection to broker lost. Trying to re-establish the connection...
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/celery/worker/consumer/consumer.py&#34;</span>, line 318, in start
</span></span><span style=display:flex><span>    blueprint.start(self)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/celery/bootsteps.py&#34;</span>, line 119, in start
</span></span><span style=display:flex><span>    step.start(parent)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/celery/worker/consumer/consumer.py&#34;</span>, line 596, in start
</span></span><span style=display:flex><span>    c.loop(*c.loop_args())
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/celery/worker/loops.py&#34;</span>, line 121, in synloop
</span></span><span style=display:flex><span>    connection.drain_events(timeout=2.0)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/connection.py&#34;</span>, line 315, in drain_events
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> self.transport.drain_events(self.connection, **kwargs)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py&#34;</span>, line 963, in drain_events
</span></span><span style=display:flex><span>    get(self._deliver, timeout=timeout)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/utils/scheduling.py&#34;</span>, line 56, in get
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> self.fun(resource, callback, **kwargs)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py&#34;</span>, line 1001, in _drain_channel
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> channel.drain_events(callback=callback, timeout=timeout)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py&#34;</span>, line 745, in drain_events
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> self._poll(self.cycle, callback, timeout=timeout)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py&#34;</span>, line 402, in _poll
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> cycle.get(callback)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/utils/scheduling.py&#34;</span>, line 56, in get
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> self.fun(resource, callback, **kwargs)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py&#34;</span>, line 405, in _get_and_deliver
</span></span><span style=display:flex><span>    message = self._get(queue)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib/python2.7/site-packages/kombu/transport/mongodb.py&#34;</span>, line 141, in _get
</span></span><span style=display:flex><span>    remove=True,
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib64/python2.7/site-packages/pymongo/collection.py&#34;</span>, line 2315, in find_and_modify
</span></span><span style=display:flex><span>    allowable_errors=[_NO_OBJ_ERROR])
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib64/python2.7/site-packages/pymongo/collection.py&#34;</span>, line 205, in _command
</span></span><span style=display:flex><span>    read_concern=read_concern)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib64/python2.7/site-packages/pymongo/pool.py&#34;</span>, line 218, in command
</span></span><span style=display:flex><span>    self._raise_connection_failure(error)
</span></span><span style=display:flex><span>  File <span style=font-style:italic>&#34;/usr/lib64/python2.7/site-packages/pymongo/pool.py&#34;</span>, line 346, in _raise_connection_failure
</span></span><span style=display:flex><span>    raise error
</span></span><span style=display:flex><span>AutoReconnect: connection closed
</span></span><span style=display:flex><span>[2022-05-07 10:13:01,363: WARNING/MainProcess] Restoring 1 unacknowledged message(s)
</span></span></code></pre></div><p>对应 Celery 代码在 worker/consumer/consumer.py，Blueprint 是 Celery 启动入口，可以看到在 <code>blueprint.start(self)</code> 阶段进行了异常处理，针对 <code>self.connection_errors</code> 来触发重连接。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    CONNECTION_RETRY = <span style=font-style:italic>&#34;&#34;&#34;</span><span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span><span style=font-style:italic>    consumer: Connection to broker lost. </span><span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span><span style=font-style:italic>    Trying to re-establish the connection...</span><span style=font-weight:700;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic></span><span style=font-style:italic>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> start(self):
</span></span><span style=display:flex><span>        blueprint = self.blueprint
</span></span><span style=display:flex><span>        <span style=font-weight:700>while</span> blueprint.state != CLOSE:
</span></span><span style=display:flex><span>            maybe_shutdown()
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> self.restart_count:
</span></span><span style=display:flex><span>                <span style=font-weight:700>try</span>:
</span></span><span style=display:flex><span>                    self._restart_state.step()
</span></span><span style=display:flex><span>                <span style=font-weight:700>except</span> RestartFreqExceeded <span style=font-weight:700>as</span> exc:
</span></span><span style=display:flex><span>                    crit(<span style=font-style:italic>&#39;Frequent restarts detected: </span><span style=font-weight:700;font-style:italic>%r</span><span style=font-style:italic>&#39;</span>, exc, exc_info=1)
</span></span><span style=display:flex><span>                    sleep(1)
</span></span><span style=display:flex><span>            self.restart_count += 1
</span></span><span style=display:flex><span>            <span style=font-weight:700>try</span>:
</span></span><span style=display:flex><span>                blueprint.start(self)
</span></span><span style=display:flex><span>            <span style=font-weight:700>except</span> self.connection_errors <span style=font-weight:700>as</span> exc:
</span></span><span style=display:flex><span>                <span style=font-style:italic># If we&#39;re not retrying connections, no need to catch</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># connection errors</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> self.app.conf.broker_connection_retry:
</span></span><span style=display:flex><span>                    <span style=font-weight:700>raise</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> isinstance(exc, <span style=font-weight:700>OSError</span>) <span style=font-weight:700>and</span> exc.errno == errno.EMFILE:
</span></span><span style=display:flex><span>                    <span style=font-weight:700>raise</span>  <span style=font-style:italic># Too many open files</span>
</span></span><span style=display:flex><span>                maybe_shutdown()
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> blueprint.state != CLOSE:
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> self.connection:
</span></span><span style=display:flex><span>                        self.on_connection_error_after_connected(exc)
</span></span><span style=display:flex><span>                    <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                        self.on_connection_error_before_connected(exc)
</span></span><span style=display:flex><span>                    self.on_close()
</span></span><span style=display:flex><span>                    blueprint.restart(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> on_connection_error_before_connected(self, exc):
</span></span><span style=display:flex><span>        error(CONNECTION_ERROR, self.conninfo.as_uri(), exc,
</span></span><span style=display:flex><span>              <span style=font-style:italic>&#39;Trying to reconnect...&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> on_connection_error_after_connected(self, exc):
</span></span><span style=display:flex><span>        warn(CONNECTION_RETRY, exc_info=<span style=font-weight:700>True</span>)
</span></span><span style=display:flex><span>        <span style=font-weight:700>try</span>:
</span></span><span style=display:flex><span>            self.connection.collect()
</span></span><span style=display:flex><span>        <span style=font-weight:700>except</span> <span style=font-weight:700>Exception</span>:
</span></span><span style=display:flex><span>            <span style=font-weight:700>pass</span>
</span></span></code></pre></div><p><code>self.connection_errors</code> 对应的其实是 Kombu 中 Transport 定义的 ，可以在 <code>kombu/kombu/transport/mongodb.py</code> 中查看，在当前版本中，定义为 <code>pymongo.errors.ConnectionFailure</code> ，pymongo 中常见的网络连接异常 <code>AutoReconnect</code> 或 <code>NetworkTimeout</code> 均继承自 <code>ConnectionFailure</code> 。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Transport</span>(virtual.Transport):
</span></span><span style=display:flex><span>    Channel = Channel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    can_parse_url = <span style=font-weight:700>True</span>
</span></span><span style=display:flex><span>    polling_interval = 1
</span></span><span style=display:flex><span>    default_port = DEFAULT_PORT
</span></span><span style=display:flex><span>    connection_errors = (
</span></span><span style=display:flex><span>        virtual.Transport.connection_errors + (errors.ConnectionFailure, )
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><p>从目前来看，Celery 可以正确处理 kombu 上报的异常，但是在存储网络异常时，Kombu 没有抛出异常，于是问题调查从 Celery 转到 Kombu。</p><h3 id=kombu>Kombu
<a class=heading-link href=#kombu><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>主要看 MongoDB Transport 关于建立连接部分的处理，代码执行路径依次是： <code>client</code> -> <code>_create_client</code> -> <code>_open</code> -> <code>_parse_uri</code> ，其中 <code>_open</code> 是真正建立连接的处理，连接所采用的参数是在 <code>_parse_uri</code> 返回的，<code>_parse_uri</code> 最终调用的是 <code>pymongo.uri_parser.parse_uri</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=font-weight:700>def</span> _open(self, scheme=<span style=font-style:italic>&#39;mongodb://&#39;</span>):
</span></span><span style=display:flex><span>        hostname, dbname, options = self._parse_uri(scheme=scheme)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        conf = self._prepare_client_options(options)
</span></span><span style=display:flex><span>        conf[<span style=font-style:italic>&#39;host&#39;</span>] = hostname
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        env = _detect_environment()
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> env == <span style=font-style:italic>&#39;gevent&#39;</span>:
</span></span><span style=display:flex><span>            <span style=font-weight:700>from</span> <span style=font-weight:700>gevent</span> <span style=font-weight:700>import</span> monkey
</span></span><span style=display:flex><span>            monkey.patch_all()
</span></span><span style=display:flex><span>        <span style=font-weight:700>elif</span> env == <span style=font-style:italic>&#39;eventlet&#39;</span>:
</span></span><span style=display:flex><span>            <span style=font-weight:700>from</span> <span style=font-weight:700>eventlet</span> <span style=font-weight:700>import</span> monkey_patch
</span></span><span style=display:flex><span>            monkey_patch()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        mongoconn = MongoClient(**conf)
</span></span><span style=display:flex><span>        database = mongoconn[dbname]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        version_str = mongoconn.server_info()[<span style=font-style:italic>&#39;version&#39;</span>]
</span></span><span style=display:flex><span>        version = tuple(map(int, version_str.split(<span style=font-style:italic>&#39;.&#39;</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> version &lt; (1, 3):
</span></span><span style=display:flex><span>            <span style=font-weight:700>raise</span> VersionMismatch(E_SERVER_VERSION.format(version_str))
</span></span><span style=display:flex><span>        <span style=font-weight:700>elif</span> self.ttl <span style=font-weight:700>and</span> version &lt; (2, 2):
</span></span><span style=display:flex><span>            <span style=font-weight:700>raise</span> VersionMismatch(E_NO_TTL_INDEXES.format(version_str))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> database
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> _parse_uri(self, scheme=<span style=font-style:italic>&#39;mongodb://&#39;</span>):
</span></span><span style=display:flex><span>        <span style=font-style:italic># See mongodb uri documentation:</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># http://docs.mongodb.org/manual/reference/connection-string/</span>
</span></span><span style=display:flex><span>        client = self.connection.client
</span></span><span style=display:flex><span>        hostname = client.hostname
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> hostname.startswith(scheme):
</span></span><span style=display:flex><span>            hostname = scheme + hostname
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> hostname[len(scheme):]:
</span></span><span style=display:flex><span>            hostname += self.default_hostname
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> client.userid <span style=font-weight:700>and</span> <span style=font-style:italic>&#39;@&#39;</span> <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> hostname:
</span></span><span style=display:flex><span>            head, tail = hostname.split(<span style=font-style:italic>&#39;://&#39;</span>)
</span></span><span style=display:flex><span>            credentials = client.userid
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> client.password:
</span></span><span style=display:flex><span>                credentials += <span style=font-style:italic>&#39;:&#39;</span> + client.password
</span></span><span style=display:flex><span>            hostname = head + <span style=font-style:italic>&#39;://&#39;</span> + credentials + <span style=font-style:italic>&#39;@&#39;</span> + tail
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        port = client.port <span style=font-weight:700>if</span> client.port <span style=font-weight:700>else</span> self.default_port
</span></span><span style=display:flex><span>        parsed = uri_parser.parse_uri(hostname, port)
</span></span><span style=display:flex><span>        dbname = parsed[<span style=font-style:italic>&#39;database&#39;</span>] <span style=font-weight:700>or</span> client.virtual_host
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> dbname <span style=font-weight:700>in</span> (<span style=font-style:italic>&#39;/&#39;</span>, <span style=font-weight:700>None</span>):
</span></span><span style=display:flex><span>            dbname = self.default_database
</span></span><span style=display:flex><span>        options = {
</span></span><span style=display:flex><span>            <span style=font-style:italic>&#39;auto_start_request&#39;</span>: <span style=font-weight:700>True</span>,
</span></span><span style=display:flex><span>            <span style=font-style:italic>&#39;ssl&#39;</span>: self.ssl,
</span></span><span style=display:flex><span>            <span style=font-style:italic>&#39;connectTimeoutMS&#39;</span>: (int(self.connect_timeout * 1000)
</span></span><span style=display:flex><span>                                 <span style=font-weight:700>if</span> self.connect_timeout <span style=font-weight:700>else</span> <span style=font-weight:700>None</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        options.update(parsed[<span style=font-style:italic>&#39;options&#39;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> hostname, dbname, options
</span></span></code></pre></div><p>假设我们连接参数是 <code>mongodb://192.168.1.1:27017,192.168.1.2:27017/yiran</code> ，那么 <code>pymongo.uri_parser.parse_uri</code> 解析的结果会是： <code>{'username': None, 'nodelist': [('192.168.1.1', 27017), ('192.168.1.2', 27017)], 'database': 'yiran', 'collection': None, 'password': None, 'options': {}}</code> 。</p><p>socketTimeoutMS在我们的环境中，MongoDB 的 URI 中并没有指定 options，所以 <code>pymongo.uri_parser.parse_uri</code> 结果的 <code>options</code> 为空。最终连接所使用的 <code>options</code> 就是在 <code>_parse_uri</code> 中定义的 options ，其中类变量 <code>connect_timeout</code> 在 Channel 定义为 None，所以最终 Kombu 建立 MongoDB 连接并没有设置 <code>socketTimeoutMS</code>，如果不设置 <code>socketTimeoutMS</code> ，默认是 None，永久等待。当网络出现异常时，直观看到的现象会是 hang 住。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Channel</span>(virtual.Channel):
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;MongoDB Channel.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    supports_fanout = <span style=font-weight:700>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-style:italic># Mutable container. Shared by all class instances</span>
</span></span><span style=display:flex><span>    _fanout_queues = {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-style:italic># Options</span>
</span></span><span style=display:flex><span>    ssl = <span style=font-weight:700>False</span>
</span></span><span style=display:flex><span>    ttl = <span style=font-weight:700>False</span>
</span></span><span style=display:flex><span>    connect_timeout = <span style=font-weight:700>None</span>
</span></span><span style=display:flex><span>    capped_queue_size = 100000
</span></span><span style=display:flex><span>    calc_queue_size = <span style=font-weight:700>True</span>
</span></span></code></pre></div><h3 id=celery-与-kombu-参数传递>Celery 与 Kombu 参数传递
<a class=heading-link href=#celery-%e4%b8%8e-kombu-%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>现在观察到连接参数不符合预期，为什么之前的 3.x 版本没有问题？切换到 3.x 分支查看对应的代码，可以看到大体逻辑都是类似的，关于 options 的处理，3.x 存在一行 ： <code>options.update(client.transport_options)</code> ，这里的 client 在函数最开始赋值，对应的是 <code>self.connection.client</code> ，<code>self.connection</code> 是 Transport 构造传入的参数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=font-weight:700>def</span> _parse_uri(self, scheme=<span style=font-style:italic>&#39;mongodb://&#39;</span>):
</span></span><span style=display:flex><span>        <span style=font-style:italic># See mongodb uri documentation:</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># http://docs.mongodb.org/manual/reference/connection-string/</span>
</span></span><span style=display:flex><span>        client = self.connection.client
</span></span><span style=display:flex><span>        hostname = client.hostname
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> hostname.startswith(scheme):
</span></span><span style=display:flex><span>            hostname = scheme + hostname
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> hostname[len(scheme):]:
</span></span><span style=display:flex><span>            hostname += DEFAULT_HOST
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> client.userid <span style=font-weight:700>and</span> <span style=font-style:italic>&#39;@&#39;</span> <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> hostname:
</span></span><span style=display:flex><span>            head, tail = hostname.split(<span style=font-style:italic>&#39;://&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            credentials = client.userid
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> client.password:
</span></span><span style=display:flex><span>                credentials += <span style=font-style:italic>&#39;:&#39;</span> + client.password
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            hostname = head + <span style=font-style:italic>&#39;://&#39;</span> + credentials + <span style=font-style:italic>&#39;@&#39;</span> + tail
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        port = client.port <span style=font-weight:700>if</span> client.port <span style=font-weight:700>is</span> <span style=font-weight:700>not</span> <span style=font-weight:700>None</span> <span style=font-weight:700>else</span> DEFAULT_PORT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        parsed = uri_parser.parse_uri(hostname, port)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        dbname = parsed[<span style=font-style:italic>&#39;database&#39;</span>] <span style=font-weight:700>or</span> client.virtual_host
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> dbname <span style=font-weight:700>in</span> (<span style=font-style:italic>&#39;/&#39;</span>, <span style=font-weight:700>None</span>):
</span></span><span style=display:flex><span>            dbname = <span style=font-style:italic>&#39;kombu_default&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        options = {
</span></span><span style=display:flex><span>            <span style=font-style:italic>&#39;auto_start_request&#39;</span>: <span style=font-weight:700>True</span>,
</span></span><span style=display:flex><span>            <span style=font-style:italic>&#39;ssl&#39;</span>: client.ssl,
</span></span><span style=display:flex><span>            <span style=font-style:italic>&#39;connectTimeoutMS&#39;</span>: (int(client.connect_timeout * 1000)
</span></span><span style=display:flex><span>                                 <span style=font-weight:700>if</span> client.connect_timeout <span style=font-weight:700>else</span> <span style=font-weight:700>None</span>),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        options.update(client.transport_options)
</span></span><span style=display:flex><span>        options.update(parsed[<span style=font-style:italic>&#39;options&#39;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> hostname, dbname, options
</span></span></code></pre></div><p><code>connection</code> 对应的就是 Kombu 中的 <code>Connection</code> ，Kombu 对外隐藏了 Transport ，Celery 在初始化阶段，会建立连接，调用路径是 <code>celery/app/base.py:Celery._connection</code> -> <code>celery/app/amqp.py:AMQP.Connection</code> -> <code>kombu/connection.py:Connection</code> 。传递参数 <code>transport_options</code> 就是在 Celery app 声明时配置的参数，具体可配置参数可以参考文档： <a href=https://docs.celeryq.dev/en/stable/userguide/configuration.html>https://docs.celeryq.dev/en/stable/userguide/configuration.html</a>。</p><p>在我们的场景中，声明了以下参数：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>BROKER_TRANSPORT_OPTIONS = {
</span></span><span style=display:flex><span>    &#34;connect&#34;: False,
</span></span><span style=display:flex><span>    &#34;maxPoolSize&#34;: 5 if &#34;worker&#34; in process_cmdline else 2,
</span></span><span style=display:flex><span>    &#34;socketTimeoutMS&#34;: 5000,
</span></span><span style=display:flex><span>    &#34;connectTimeoutMS&#34;: 5000,
</span></span><span style=display:flex><span>    &#34;serverSelectionTimeoutMS&#34;: 5000,
</span></span><span style=display:flex><span>    &#34;w&#34;: 0,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Kombu 使用 MongoDB Transport 时，最终会带有这些参数创建 MongoDB 连接，所以不会出现此问题说描述的现象。</p><h2 id=celery-改动背景>Celery 改动背景
<a class=heading-link href=#celery-%e6%94%b9%e5%8a%a8%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>@rmihael 上报了一个问题： <a href=https://github.com/celery/celery/issues/1047>Celery events are not removed from MongoDB broker #1047</a> ，表示在使用 Celery Flower（Celery 监控组件）后，<code>messages</code> 中的事件不会清除，导致占用了大量的 MongoDB 存储空间。该 Issue 中讨论最终决定使用 MongoDB TTL 来解决此问题。</p><p>在 Kombu 4.x 开发周期中，@daevaorn 提交了 <a href=https://github.com/celery/kombu/pull/537>MongoDB TTL support and refactorings #537</a> 用来支持 MongoDB TTL，在该 PR 中包含了大量与 TTL 无关的 commit，并且包含了一定的重构，commit 如下：</p><ul><li>Complete unit tests suit for MongoDB transport</li><li>Optional TTL support for MongoDB transport. AMQP TTL headers: x-messa…</li><li>Rearrange methods at MongoDB channel class</li><li>Another MongoDB transport clean up and refactor. Use of transport opt…</li><li>Opt-out for queue size calculation</li><li>Use natural sort for more FIFO semantic</li><li>Fix docstrings</li></ul><p>其中 <code>Optional TTL support for MongoDB transport.</code> 是最关键的改动，忽略 TTL 的改动，主要看建立 MongoDB 连接的改动。在 <code>Channel</code> Class 中新增了一些类变量用于标识当前配置，在 <code>_parse_uri</code> 中，将 SSL,connectTImeoutMS 从 <code>client</code> 替换为了 <code>self</code> ，并删除了 <code>options.update(client.transport_options)</code> 。其中删除了 <code>options.update(client.transport_options)</code> 是导致这个问题的关键。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span> class Channel(virtual.Channel):
</span></span><span style=display:flex><span>     _client = None
</span></span><span style=display:flex><span>     supports_fanout = True
</span></span><span style=display:flex><span>+
</span></span><span style=display:flex><span>+    # Mutable containers. Shared by all class instances
</span></span><span style=display:flex><span>     _fanout_queues = {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>+    # Options
</span></span><span style=display:flex><span>+    connect_timeout = None
</span></span><span style=display:flex><span>+    ssl = False
</span></span><span style=display:flex><span>+    capped_queue_size = 100000
</span></span><span style=display:flex><span>+    ttl = False
</span></span><span style=display:flex><span>+
</span></span><span style=display:flex><span>+    from_transport_options = (
</span></span><span style=display:flex><span>+        virtual.Channel.from_transport_options
</span></span><span style=display:flex><span>+        + (&#39;connect_timeout&#39;, &#39;ssl&#39;, &#39;ttl&#39;, &#39;capped_queue_size&#39;))
</span></span><span style=display:flex><span>+
</span></span><span style=display:flex><span>+
</span></span><span style=display:flex><span>     def __init__(self, *vargs, **kwargs):
</span></span><span style=display:flex><span>         super(Channel, self).__init__(*vargs, **kwargs)
</span></span><span style=display:flex><span>         ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    def _parse_uri(self, scheme=&#39;mongodb://&#39;):
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>         options = {
</span></span><span style=display:flex><span>             &#39;auto_start_request&#39;: True,
</span></span><span style=display:flex><span>-            &#39;ssl&#39;: client.ssl,
</span></span><span style=display:flex><span>-            &#39;connectTimeoutMS&#39;: (int(client.connect_timeout * 1000)
</span></span><span style=display:flex><span>-                                 if client.connect_timeout else None),
</span></span><span style=display:flex><span>+            &#39;ssl&#39;: self.ssl,
</span></span><span style=display:flex><span>+            &#39;connectTimeoutMS&#39;: (int(self.connect_timeout * 1000)
</span></span><span style=display:flex><span>+                                 if self.connect_timeout else None),
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>-        options.update(client.transport_options)
</span></span><span style=display:flex><span>         options.update(parsed[&#39;options&#39;])
</span></span></code></pre></div><h2 id=总结>总结
<a class=heading-link href=#%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>Celery Kombu 代码管理感觉有些不清晰，在多个分支上想要对比非常困难。必要组件升级大版本进行全集测试是必要的。</p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2024
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>