<!doctype html><html lang=zh-cn><head><title>编写一个友好的命令行工具 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="背景 链接到标题 关于命令行设计的一点总结。
有用的帮助信息 链接到标题 提供的命令行中所有的命令、子命令、选项都有明确的帮助信息，便于用户在使用过程中查看。帮助信息查看方式最好统一，比如统一使用 -h 格式、 COMMAND help 或者 COMMAND --help 。
尽量使用 Flags 而不是 Args 链接到标题 命令行可以接受 2 种类型的参数输入：Flags 和 Args。Flags 需要更多的输入，但会使命令行更清晰。我在实现一个命令行时，通常会将必选项设置为 Args ，将可选项设置为 Flags，但是有时候会导致用户在使用过程中觉得传递参数方式不统一，而且当 Args 有多个时（是的，我之前设计的一个命令行输入的 Args 多达 5 个）用户敲着敲着就不知道自己该输入什么了。如果在后续对命令行进行重构时，为了保证接口的兼容性，Args 通常是需要保证不变的，而 Flags 没有这个困扰。
明确显示当前版本 链接到标题 在使用过程中，如果遇到了问题，那么通常需要上报命令行版本反馈，需要明确给出当前命令行所指定的版本。通常会有 -v, -V, --version, version 等子命令，其中 -v 和 -V 有可能会跟 verbose 混淆，建议将版本作为一个独立的子命令 version 来实现。
针对 stdint, stdout, stderr 正确处理 链接到标题 如果已知一个命令行的执行耗时较长，那么用户通常执行命令时会选择将 stdout 重定向到指定文件中，便于后续查看执行过程输出，留存。但是如果在执行过程中出现异常，那么尽量将异常信息通过 stderr 输出，及时暴露给用户。默认情况下 stdout 被重定向之后，stderr 仍会打印在终端中。
明确的错误信息 链接到标题 当用户在执行命令过程中遇到错误，需要尽可能的显示多的、有用的信息出来：错误码、错误描述、错误信息。给出的信息是人类友好的，毕竟针对错误进行调试的是我们自己。尽量保证自己的命令行提供调试模式（类似于 Shell 中的 set -x ），便于 debug。"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="编写一个友好的命令行工具"><meta name=twitter:description content="背景 链接到标题 关于命令行设计的一点总结。
有用的帮助信息 链接到标题 提供的命令行中所有的命令、子命令、选项都有明确的帮助信息，便于用户在使用过程中查看。帮助信息查看方式最好统一，比如统一使用 -h 格式、 COMMAND help 或者 COMMAND --help 。
尽量使用 Flags 而不是 Args 链接到标题 命令行可以接受 2 种类型的参数输入：Flags 和 Args。Flags 需要更多的输入，但会使命令行更清晰。我在实现一个命令行时，通常会将必选项设置为 Args ，将可选项设置为 Flags，但是有时候会导致用户在使用过程中觉得传递参数方式不统一，而且当 Args 有多个时（是的，我之前设计的一个命令行输入的 Args 多达 5 个）用户敲着敲着就不知道自己该输入什么了。如果在后续对命令行进行重构时，为了保证接口的兼容性，Args 通常是需要保证不变的，而 Flags 没有这个困扰。
明确显示当前版本 链接到标题 在使用过程中，如果遇到了问题，那么通常需要上报命令行版本反馈，需要明确给出当前命令行所指定的版本。通常会有 -v, -V, --version, version 等子命令，其中 -v 和 -V 有可能会跟 verbose 混淆，建议将版本作为一个独立的子命令 version 来实现。
针对 stdint, stdout, stderr 正确处理 链接到标题 如果已知一个命令行的执行耗时较长，那么用户通常执行命令时会选择将 stdout 重定向到指定文件中，便于后续查看执行过程输出，留存。但是如果在执行过程中出现异常，那么尽量将异常信息通过 stderr 输出，及时暴露给用户。默认情况下 stdout 被重定向之后，stderr 仍会打印在终端中。
明确的错误信息 链接到标题 当用户在执行命令过程中遇到错误，需要尽可能的显示多的、有用的信息出来：错误码、错误描述、错误信息。给出的信息是人类友好的，毕竟针对错误进行调试的是我们自己。尽量保证自己的命令行提供调试模式（类似于 Shell 中的 set -x ），便于 debug。"><meta property="og:title" content="编写一个友好的命令行工具"><meta property="og:description" content="背景 链接到标题 关于命令行设计的一点总结。
有用的帮助信息 链接到标题 提供的命令行中所有的命令、子命令、选项都有明确的帮助信息，便于用户在使用过程中查看。帮助信息查看方式最好统一，比如统一使用 -h 格式、 COMMAND help 或者 COMMAND --help 。
尽量使用 Flags 而不是 Args 链接到标题 命令行可以接受 2 种类型的参数输入：Flags 和 Args。Flags 需要更多的输入，但会使命令行更清晰。我在实现一个命令行时，通常会将必选项设置为 Args ，将可选项设置为 Flags，但是有时候会导致用户在使用过程中觉得传递参数方式不统一，而且当 Args 有多个时（是的，我之前设计的一个命令行输入的 Args 多达 5 个）用户敲着敲着就不知道自己该输入什么了。如果在后续对命令行进行重构时，为了保证接口的兼容性，Args 通常是需要保证不变的，而 Flags 没有这个困扰。
明确显示当前版本 链接到标题 在使用过程中，如果遇到了问题，那么通常需要上报命令行版本反馈，需要明确给出当前命令行所指定的版本。通常会有 -v, -V, --version, version 等子命令，其中 -v 和 -V 有可能会跟 verbose 混淆，建议将版本作为一个独立的子命令 version 来实现。
针对 stdint, stdout, stderr 正确处理 链接到标题 如果已知一个命令行的执行耗时较长，那么用户通常执行命令时会选择将 stdout 重定向到指定文件中，便于后续查看执行过程输出，留存。但是如果在执行过程中出现异常，那么尽量将异常信息通过 stderr 输出，及时暴露给用户。默认情况下 stdout 被重定向之后，stderr 仍会打印在终端中。
明确的错误信息 链接到标题 当用户在执行命令过程中遇到错误，需要尽可能的显示多的、有用的信息出来：错误码、错误描述、错误信息。给出的信息是人类友好的，毕竟针对错误进行调试的是我们自己。尽量保证自己的命令行提供调试模式（类似于 Shell 中的 set -x ），便于 debug。"><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2022/02/26/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%8B%E5%A5%BD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-26T19:50:44+00:00"><meta property="article:modified_time" content="2022-02-26T19:50:44+00:00"><link rel=canonical href=https://zdyxry.github.io/2022/02/26/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%8B%E5%A5%BD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.76ce9bad7ac9bd368d486c6e91e7e0906fff71d9d35ccbf93959a375e2bf50e5.css integrity="sha256-ds6brXrJvTaNSGxukefgkG//cdnTXMv5OVmjdeK/UOU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2022/02/26/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%8B%E5%A5%BD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/>编写一个友好的命令行工具</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-02-26T19:50:44Z>February 26, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：1 分钟</span></div></div></header><nav id=TableOfContents><ul><li><a href=#背景>背景</a><ul><li><a href=#有用的帮助信息>有用的帮助信息</a></li><li><a href=#尽量使用-flags-而不是-args>尽量使用 Flags 而不是 Args</a></li><li><a href=#明确显示当前版本>明确显示当前版本</a></li><li><a href=#针对-stdint-stdout-stderr-正确处理>针对 stdint, stdout, stderr 正确处理</a></li><li><a href=#明确的错误信息>明确的错误信息</a></li><li><a href=#不要过分花里胡哨>不要过分花里胡哨</a></li><li><a href=#如果可能的话不要输出表格>（如果可能的话）不要输出表格</a></li><li><a href=#保证执行速度>保证执行速度</a></li><li><a href=#处理好信号>处理好信号</a></li><li><a href=#幂等>幂等</a></li></ul></li><li><a href=#参考链接>参考链接</a></li></ul></nav><div class=post-content><h2 id=背景>背景
<a class=heading-link href=#%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>关于命令行设计的一点总结。</p><h3 id=有用的帮助信息>有用的帮助信息
<a class=heading-link href=#%e6%9c%89%e7%94%a8%e7%9a%84%e5%b8%ae%e5%8a%a9%e4%bf%a1%e6%81%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>提供的命令行中所有的命令、子命令、选项都有明确的帮助信息，便于用户在使用过程中查看。帮助信息查看方式最好统一，比如统一使用 <code>-h</code> 格式、 <code>COMMAND help</code> 或者 <code>COMMAND --help</code> 。</p><h3 id=尽量使用-flags-而不是-args>尽量使用 Flags 而不是 Args
<a class=heading-link href=#%e5%b0%bd%e9%87%8f%e4%bd%bf%e7%94%a8-flags-%e8%80%8c%e4%b8%8d%e6%98%af-args><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>命令行可以接受 2 种类型的参数输入：Flags 和 Args。Flags 需要更多的输入，但会使命令行更清晰。我在实现一个命令行时，通常会将必选项设置为 Args ，将可选项设置为 Flags，但是有时候会导致用户在使用过程中觉得传递参数方式不统一，而且当 Args 有多个时（是的，我之前设计的一个命令行输入的 Args 多达 5 个）用户敲着敲着就不知道自己该输入什么了。如果在后续对命令行进行重构时，为了保证接口的兼容性，Args 通常是需要保证不变的，而 Flags 没有这个困扰。</p><h3 id=明确显示当前版本>明确显示当前版本
<a class=heading-link href=#%e6%98%8e%e7%a1%ae%e6%98%be%e7%a4%ba%e5%bd%93%e5%89%8d%e7%89%88%e6%9c%ac><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>在使用过程中，如果遇到了问题，那么通常需要上报命令行版本反馈，需要明确给出当前命令行所指定的版本。通常会有 <code>-v</code>, <code>-V</code>, <code>--version</code>, <code>version</code> 等子命令，其中 <code>-v</code> 和 <code>-V</code> 有可能会跟 <code>verbose</code> 混淆，建议将版本作为一个独立的子命令 <code>version</code> 来实现。</p><h3 id=针对-stdint-stdout-stderr-正确处理>针对 stdint, stdout, stderr 正确处理
<a class=heading-link href=#%e9%92%88%e5%af%b9-stdint-stdout-stderr-%e6%ad%a3%e7%a1%ae%e5%a4%84%e7%90%86><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>如果已知一个命令行的执行耗时较长，那么用户通常执行命令时会选择将 stdout 重定向到指定文件中，便于后续查看执行过程输出，留存。但是如果在执行过程中出现异常，那么尽量将异常信息通过 stderr 输出，及时暴露给用户。默认情况下 stdout 被重定向之后，stderr 仍会打印在终端中。</p><h3 id=明确的错误信息>明确的错误信息
<a class=heading-link href=#%e6%98%8e%e7%a1%ae%e7%9a%84%e9%94%99%e8%af%af%e4%bf%a1%e6%81%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>当用户在执行命令过程中遇到错误，需要尽可能的显示多的、有用的信息出来：错误码、错误描述、错误信息。给出的信息是人类友好的，毕竟针对错误进行调试的是我们自己。尽量保证自己的命令行提供调试模式（类似于 Shell 中的 <code>set -x</code> ），便于 debug。</p><h3 id=不要过分花里胡哨>不要过分花里胡哨
<a class=heading-link href=#%e4%b8%8d%e8%a6%81%e8%bf%87%e5%88%86%e8%8a%b1%e9%87%8c%e8%83%a1%e5%93%a8><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>现在许多命令行会在执行过程中，为了保证自己的输出尽可能的“好看”，可能会做各种丧心病狂的事情（比如塞入 emoji），我建议尽量不要做这种事情，会带来很多心智负担。</p><h3 id=如果可能的话不要输出表格>（如果可能的话）不要输出表格
<a class=heading-link href=#%e5%a6%82%e6%9e%9c%e5%8f%af%e8%83%bd%e7%9a%84%e8%af%9d%e4%b8%8d%e8%a6%81%e8%be%93%e5%87%ba%e8%a1%a8%e6%a0%bc><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>有时候命令执行结果返回中，包含的信息量很大，那么通常会使用各种 table lib 来“友好”的展示信息。这类信息可能会导致在后续进行二次处理（sed, awk）过程中增加工作量，需要额外的过滤表格中的字符。如果一定需要展，那么尽可能提供可选项，给出一个其他的输出格式，比如 json，比如 yaml 等等。</p><h3 id=保证执行速度>保证执行速度
<a class=heading-link href=#%e4%bf%9d%e8%af%81%e6%89%a7%e8%a1%8c%e9%80%9f%e5%ba%a6><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>尽量保证命令行执行耗时较短，如果耗时较长，那么可能遇到的网络问题导致命令执行中断的概率增加。在执行过程中，尽量让用户感受到命令是在执行的，给出明确的交互状态，不要让用户感觉命令 hang 住。</p><h3 id=处理好信号>处理好信号
<a class=heading-link href=#%e5%a4%84%e7%90%86%e5%a5%bd%e4%bf%a1%e5%8f%b7><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>当用户在执行一个命令的时候，保证用户可以最终停止它。在处理信号的过程中，可以合理的输出一些有用的提示告知用户当前正在进行什么动作。</p><h3 id=幂等>幂等
<a class=heading-link href=#%e5%b9%82%e7%ad%89><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>尽量保证命令行幂等，当命令执行失败之后，可以让用户再次执行该命令以完成最终目的，否则会相当痛苦。</p><h2 id=参考链接>参考链接
<a class=heading-link href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><ul><li><a href="https://clig.dev/?utm_source=pocket_mylist">https://clig.dev/?utm_source=pocket_mylist</a></li><li><a href=https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46>https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46</a></li></ul></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2024
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>