<!doctype html><html lang=zh-cn><head><title>Yum 寻找 Best Package 评分机制 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="背景 链接到标题 公司产品最终交付形态是 ISO，在涉及一个产品的多个 OEM 场景时，会选择在标准版本的基础上，删除某些软件包，新增某些软件包的形式来减少构建时间。产品的 BaseOS 是 CentOS，包管理器是 RPM 系，也就需要使用 rpm / yum 等命令来实现。 其中新增某些软件包是使用 yumdownloader 来完成的。在 Yum Repository 中会包含同一软件包的多个版本，预期 yumdownloader 会下载 Yum Repository 中某个软件最新版本的包，比如 yumdownloader zbs-5.1.2* ，则会下载 zbs-5.1.2 大版本的最新 release 版本。
但是最近发现，从某个版本开始 yumdownloader 没有下载最新的软件包，反而停在了一个两个月之前构建的版本，于是开始调查原因。
Yumdownloader 链接到标题 yumdownloader 工具集是由 yum-utils 提供，同时还提供了 repotrack，repoquery, reposync 等有用的工具。yumdownloader 使用方式是 yumdownloader $pkg 即可。在 yum-utils 中会大量引用 yum module，因此需要同时查找两个 Git repo。
yum-utils 代码仓库地址： https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py
yum 代码仓库地址：https://github.com/rpm-software-management/yum
下载逻辑 链接到标题 def main(self): # Add command line option specific to yumdownloader self."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Yum 寻找 Best Package 评分机制"><meta name=twitter:description content="背景 链接到标题 公司产品最终交付形态是 ISO，在涉及一个产品的多个 OEM 场景时，会选择在标准版本的基础上，删除某些软件包，新增某些软件包的形式来减少构建时间。产品的 BaseOS 是 CentOS，包管理器是 RPM 系，也就需要使用 rpm / yum 等命令来实现。 其中新增某些软件包是使用 yumdownloader 来完成的。在 Yum Repository 中会包含同一软件包的多个版本，预期 yumdownloader 会下载 Yum Repository 中某个软件最新版本的包，比如 yumdownloader zbs-5.1.2* ，则会下载 zbs-5.1.2 大版本的最新 release 版本。
但是最近发现，从某个版本开始 yumdownloader 没有下载最新的软件包，反而停在了一个两个月之前构建的版本，于是开始调查原因。
Yumdownloader 链接到标题 yumdownloader 工具集是由 yum-utils 提供，同时还提供了 repotrack，repoquery, reposync 等有用的工具。yumdownloader 使用方式是 yumdownloader $pkg 即可。在 yum-utils 中会大量引用 yum module，因此需要同时查找两个 Git repo。
yum-utils 代码仓库地址： https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py
yum 代码仓库地址：https://github.com/rpm-software-management/yum
下载逻辑 链接到标题 def main(self): # Add command line option specific to yumdownloader self."><meta property="og:title" content="Yum 寻找 Best Package 评分机制"><meta property="og:description" content="背景 链接到标题 公司产品最终交付形态是 ISO，在涉及一个产品的多个 OEM 场景时，会选择在标准版本的基础上，删除某些软件包，新增某些软件包的形式来减少构建时间。产品的 BaseOS 是 CentOS，包管理器是 RPM 系，也就需要使用 rpm / yum 等命令来实现。 其中新增某些软件包是使用 yumdownloader 来完成的。在 Yum Repository 中会包含同一软件包的多个版本，预期 yumdownloader 会下载 Yum Repository 中某个软件最新版本的包，比如 yumdownloader zbs-5.1.2* ，则会下载 zbs-5.1.2 大版本的最新 release 版本。
但是最近发现，从某个版本开始 yumdownloader 没有下载最新的软件包，反而停在了一个两个月之前构建的版本，于是开始调查原因。
Yumdownloader 链接到标题 yumdownloader 工具集是由 yum-utils 提供，同时还提供了 repotrack，repoquery, reposync 等有用的工具。yumdownloader 使用方式是 yumdownloader $pkg 即可。在 yum-utils 中会大量引用 yum module，因此需要同时查找两个 Git repo。
yum-utils 代码仓库地址： https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py
yum 代码仓库地址：https://github.com/rpm-software-management/yum
下载逻辑 链接到标题 def main(self): # Add command line option specific to yumdownloader self."><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2022/04/29/Yum-%E5%AF%BB%E6%89%BE-Best-Package-%E8%AF%84%E5%88%86%E6%9C%BA%E5%88%B6/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-29T23:04:16+00:00"><meta property="article:modified_time" content="2022-04-29T23:04:16+00:00"><link rel=canonical href=https://zdyxry.github.io/2022/04/29/Yum-%E5%AF%BB%E6%89%BE-Best-Package-%E8%AF%84%E5%88%86%E6%9C%BA%E5%88%B6/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.a1f1da6f0baa626de1763fc8157fdea088797379b7bbeb845799f2fffd5d0c82.css integrity="sha256-ofHabwuqYm3hdj/IFX/eoIh5c3m3u+uEV5ny//1dDII=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2022/04/29/Yum-%E5%AF%BB%E6%89%BE-Best-Package-%E8%AF%84%E5%88%86%E6%9C%BA%E5%88%B6/>Yum 寻找 Best Package 评分机制</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-04-29T23:04:16Z>April 29, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：10 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/Linux/>Linux</a></span></div></div></header><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#yumdownloader>Yumdownloader</a><ul><li><a href=#下载逻辑>下载逻辑</a></li></ul></li><li><a href=#yum>Yum</a></li><li><a href=#总结>总结</a></li></ul></nav><div class=post-content><h2 id=背景>背景
<a class=heading-link href=#%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>公司产品最终交付形态是 ISO，在涉及一个产品的多个 OEM 场景时，会选择在标准版本的基础上，删除某些软件包，新增某些软件包的形式来减少构建时间。产品的 BaseOS 是 CentOS，包管理器是 RPM 系，也就需要使用 <code>rpm</code> / <code>yum</code> 等命令来实现。
其中新增某些软件包是使用 <code>yumdownloader</code> 来完成的。在 Yum Repository 中会包含同一软件包的多个版本，预期 <code>yumdownloader</code> 会下载 Yum Repository 中某个软件最新版本的包，比如 <code>yumdownloader zbs-5.1.2*</code> ，则会下载 zbs-5.1.2 大版本的最新 release 版本。</p><p>但是最近发现，从某个版本开始 <code>yumdownloader</code> 没有下载最新的软件包，反而停在了一个两个月之前构建的版本，于是开始调查原因。</p><h2 id=yumdownloader>Yumdownloader
<a class=heading-link href=#yumdownloader><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p><code>yumdownloader</code> 工具集是由 <code>yum-utils</code> 提供，同时还提供了 <code>repotrack</code>，<code>repoquery</code>, <code>reposync</code> 等有用的工具。<code>yumdownloader</code> 使用方式是 <code>yumdownloader $pkg</code> 即可。在 <code>yum-utils</code> 中会大量引用 <code>yum</code> module，因此需要同时查找两个 Git repo。</p><p><code>yum-utils</code> 代码仓库地址： <a href=https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py>https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py</a><br><code>yum</code> 代码仓库地址：https://github.com/rpm-software-management/yum</p><h3 id=下载逻辑>下载逻辑
<a class=heading-link href=#%e4%b8%8b%e8%bd%bd%e9%80%bb%e8%be%91><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>def main(self):
</span></span><span style=display:flex><span>    # Add command line option specific to yumdownloader
</span></span><span style=display:flex><span>    self.addCmdOptions()
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    # make yumdownloader work as non root user.
</span></span><span style=display:flex><span>    if not self.setCacheDir():
</span></span><span style=display:flex><span>        self.logger.error(&#34;Error: Could not make cachedir, exiting&#34;)
</span></span><span style=display:flex><span>        sys.exit(50)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    # Setup yum (Ts, RPM db, Repo &amp; Sack)
</span></span><span style=display:flex><span>    self.doUtilYumSetup()
</span></span><span style=display:flex><span>    # Do the real action
</span></span><span style=display:flex><span>    self.exit_code = self.downloadPackages(opts)
</span></span></code></pre></div><ul><li>解析命令行参数</li><li>检查执行用户权限</li><li>配置 Yum Repo 正确性</li><li>下载 RPM</li></ul><p>其中前几项不是很重要，直接看 <code>self.downloadPackages(opts)</code> 逻辑。主要做了以下几件事情：</p><ol><li>根据 PKG 列表进行 Repo 中的查询，查询出所有的软件包；</li><li>根据查询结果，进行解析匹配，其中精确匹配和模糊匹配会进行后续处理；</li><li>根据 RPM <code>name+arch</code> 作为 key 来将所有的 Pkg 列表转换为 Dict；</li><li>遍历 Dict，从列表中找到 Best Package ，并将其添加到下载列表中；</li><li>根据下载列表信息进行下载。</li></ol><p>Github: <a href=https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py#L136>https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py#L136</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>def</span> downloadPackages(self,opts):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    toDownload = [] <span style=font-style:italic># 最终要下载的 RPM</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    packages = self.cmds
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> pkg <span style=font-weight:700>in</span> packages:
</span></span><span style=display:flex><span>        toActOn = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> pkg <span style=font-weight:700>or</span> pkg[0] != <span style=font-style:italic>&#39;@&#39;</span>:
</span></span><span style=display:flex><span>            pkgnames = [pkg] <span style=font-style:italic># 如果 PKG 名称不以 `@` 开头，那么就是单个软件包；如果以 `@` 开头，那么表示是一个 Group；</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>            <span style=font-style:italic># Group 处理逻辑，忽略</span>
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pos = self.pkgSack.returnPackages(patterns=pkgnames) <span style=font-style:italic># 在 Yum repo 中根据 pkgnames 来获取查询到的包列表</span>
</span></span><span style=display:flex><span>        exactmatch, matched, unmatched = parsePackages(pos, pkgnames) <span style=font-style:italic># 根据 pkgnames 名称 从 pos 中解析具体的匹配结果，其中如果精确匹配则添加到 exactmatch，如果模糊匹配则添加到 matched。在本文场景下所有匹配为模糊匹配，所以在 matched 列表中</span>
</span></span><span style=display:flex><span>        installable = (exactmatch + matched) <span style=font-style:italic># 最终可安装的是精确匹配和模糊匹配的集合</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> installable:
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> newpkg <span style=font-weight:700>in</span> installable:
</span></span><span style=display:flex><span>            toActOn.extend(_best_convert_pkg2srcpkgs(self, opts, newpkg)) <span style=font-style:italic># 根据解析结果，将所有处于 installable 中的包都找到具体来源</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> toActOn:
</span></span><span style=display:flex><span>            pkgGroups = self._groupPackages(toActOn) <span style=font-style:italic># 使用 RPM `name` 和 `arch` 针对 toActOn 列表进行初步分组，转换为 dict</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> group <span style=font-weight:700>in</span> pkgGroups:
</span></span><span style=display:flex><span>                pkgs = pkgGroups[group]
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> opts.source:
</span></span><span style=display:flex><span>                    ...     <span style=font-style:italic># 根据 yumdownloader 命令参数进行额外的处理，忽略</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                    toDownload.extend(self.bestPackagesFromList(pkgs)) <span style=font-style:italic># 从 pkgs 列表中选择 best Package，然后添加到 toDownload 列表中</span>
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=font-style:italic># set localpaths</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> pkg <span style=font-weight:700>in</span> toDownload:
</span></span><span style=display:flex><span>        pkg.repo.copy_local = <span style=font-weight:700>True</span>
</span></span><span style=display:flex><span>        pkg.repo.cache = 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-style:italic># use downloader from YumBase</span>
</span></span><span style=display:flex><span>    exit_code = 0
</span></span><span style=display:flex><span>    probs = self.downloadPkgs(toDownload) <span style=font-style:italic># 下载具体 RPM </span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> probs:
</span></span><span style=display:flex><span>        exit_code = 2
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> key <span style=font-weight:700>in</span> probs:
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> error <span style=font-weight:700>in</span> probs[key]:
</span></span><span style=display:flex><span>                self.logger.error(<span style=font-style:italic>&#39;</span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>: </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span>, key, error)
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> exit_code
</span></span></code></pre></div><p>在我的场景中，问题出在查找 Best Package 步骤中，相关日志如下，可以观察到在 Yum repo 中查询到了 zbs-5.1.2 所有的 release RPM，分别为 rc1 ,rc2 一直到 rc14 ，排序方式是字母序。 parsePackages 解析出所有的 PKG 均在 matched 中，因为都是模糊匹配，最终传入 bestPackagesFromList 方法中的参数是所有到的 release RPM，预期是返回最新的 release RPM ，即 zbs-5.1.2-rc14，但是返回的是 rc7 。接下来需要调查 bestPackagesFromList 是如何判断的。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>[<span style=font-style:italic>&#39;zbs-5.1.2*&#39;</span>]
</span></span><span style=display:flex><span>pos: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;]
</span></span><span style=display:flex><span>exactmatch: []
</span></span><span style=display:flex><span>matched: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;]
</span></span><span style=display:flex><span>unmatched: []
</span></span><span style=display:flex><span>pkgGroups: {<span style=font-style:italic>&#39;zbs.x86_64&#39;</span>: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;]}
</span></span><span style=display:flex><span>pkgs: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;]
</span></span><span style=display:flex><span>toDownload: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;]
</span></span></code></pre></div><h2 id=yum>Yum
<a class=heading-link href=#yum><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p><code>yumdownloader</code> 是 <code>yum</code> module 的功能分装，具体的 <code>bestPackagesFromList</code> 是在 <code>yum</code> module 中实现的。<code>bestPackagesFromList</code> 自身先根据 pkg arch 来进行分类，其中判断依据为：</p><p>Github： <a href=https://github.com/rpm-software-management/yum/blob/master/rpmUtils/arch.py#L153:5>https://github.com/rpm-software-management/yum/blob/master/rpmUtils/arch.py#L153:5</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># dict mapping arch -&gt; ( multicompat, best personality, biarch personality )
</span></span><span style=display:flex><span>multilibArches = { &#34;x86_64&#34;:  ( &#34;athlon&#34;, &#34;x86_64&#34;, &#34;athlon&#34; ),
</span></span><span style=display:flex><span>                   &#34;sparc64v&#34;: ( &#34;sparcv9v&#34;, &#34;sparcv9v&#34;, &#34;sparc64v&#34; ),
</span></span><span style=display:flex><span>                   &#34;sparc64&#34;: ( &#34;sparcv9&#34;, &#34;sparcv9&#34;, &#34;sparc64&#34; ),
</span></span><span style=display:flex><span>                   &#34;ppc64&#34;:   ( &#34;ppc&#34;, &#34;ppc&#34;, &#34;ppc64&#34; ),
</span></span><span style=display:flex><span>                   &#34;s390x&#34;:   ( &#34;s390&#34;, &#34;s390x&#34;, &#34;s390&#34; ),
</span></span><span style=display:flex><span>                   }
</span></span></code></pre></div><p>Github: <a href=https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4432>https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4432</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>def</span> bestPackagesFromList(self, pkglist, arch=<span style=font-weight:700>None</span>, single_name=<span style=font-weight:700>False</span>,
</span></span><span style=display:flex><span>                            req=<span style=font-weight:700>None</span>):
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;Return the best packages from a list of packages.  This
</span></span></span><span style=display:flex><span><span style=font-style:italic>    function is multilib aware, so that it will not compare
</span></span></span><span style=display:flex><span><span style=font-style:italic>    multilib to singlelib packages.
</span></span></span><span style=display:flex><span><span style=font-style:italic>    :param pkglist: the list of packages to return the best
</span></span></span><span style=display:flex><span><span style=font-style:italic>        packages from
</span></span></span><span style=display:flex><span><span style=font-style:italic>    :param arch: packages will be selected that are compatible
</span></span></span><span style=display:flex><span><span style=font-style:italic>        with the architecture specified by *arch*
</span></span></span><span style=display:flex><span><span style=font-style:italic>    :param single_name: whether to return a single package name
</span></span></span><span style=display:flex><span><span style=font-style:italic>    :param req: the requirement from the user
</span></span></span><span style=display:flex><span><span style=font-style:italic>    :return: a list of the best packages from *pkglist*
</span></span></span><span style=display:flex><span><span style=font-style:italic>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    returnlist = []
</span></span><span style=display:flex><span>    compatArchList = self.arch.get_arch_list(arch)
</span></span><span style=display:flex><span>    multiLib = []
</span></span><span style=display:flex><span>    singleLib = []
</span></span><span style=display:flex><span>    noarch = []
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> po <span style=font-weight:700>in</span> pkglist: <span style=font-style:italic># 根据架构来进行筛选，x86_64 是 multiLibArch</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> po.arch <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> compatArchList:
</span></span><span style=display:flex><span>            <span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>elif</span> po.arch <span style=font-weight:700>in</span> (<span style=font-style:italic>&#34;noarch&#34;</span>):
</span></span><span style=display:flex><span>            noarch.append(po)
</span></span><span style=display:flex><span>        <span style=font-weight:700>elif</span> isMultiLibArch(arch=po.arch):
</span></span><span style=display:flex><span>            multiLib.append(po) <span style=font-style:italic># 最终所有 pkg 添加到 multiLib 中</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>            singleLib.append(po)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=font-style:italic># we now have three lists.  find the best package(s) of each</span>
</span></span><span style=display:flex><span>    multi = self._bestPackageFromList(multiLib, req=req) <span style=font-style:italic># 根据不同架构找到 best package</span>
</span></span><span style=display:flex><span>    single = self._bestPackageFromList(singleLib, req=req)
</span></span><span style=display:flex><span>    no = self._bestPackageFromList(noarch, req=req)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> returnlist
</span></span></code></pre></div><p>继续追踪 <code>_bestPackageFromList</code> 的实现，可以看到</p><p>Github: <a href=https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4409>https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4409</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>def</span> _bestPackageFromList(self, pkglist, req=<span style=font-weight:700>None</span>):
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;take list of package objects and return the best package object.
</span></span></span><span style=display:flex><span><span style=font-style:italic>        If the list is empty, return None. 
</span></span></span><span style=display:flex><span><span style=font-style:italic>        
</span></span></span><span style=display:flex><span><span style=font-style:italic>        Note: this is not aware of multilib so make sure you&#39;re only
</span></span></span><span style=display:flex><span><span style=font-style:italic>        passing it packages of a single arch group.
</span></span></span><span style=display:flex><span><span style=font-style:italic>        :param pkglist: the list of packages to return the best
</span></span></span><span style=display:flex><span><span style=font-style:italic>            packages from
</span></span></span><span style=display:flex><span><span style=font-style:italic>        :param req: the requirement from the user
</span></span></span><span style=display:flex><span><span style=font-style:italic>        :return: a list of the best packages from *pkglist*
</span></span></span><span style=display:flex><span><span style=font-style:italic>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    bestlist = self._compare_providers(pkglist, reqpo=<span style=font-weight:700>None</span>, req=req)
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> bestlist[0][0]
</span></span></code></pre></div><p>终于找到最关键的部分： <code>_compare_providers</code> ，这是一个巨大的函数，300行，根据注释可以看到主要用户给 pkg 打分：</p><p>Github: <a href=https://github.com/rpm-software-management/yum/blob/master/yum/depsolve.py#L1465>https://github.com/rpm-software-management/yum/blob/master/yum/depsolve.py#L1465</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=font-weight:700>def</span> _compare_providers(self, pkgs, reqpo, req=<span style=font-weight:700>None</span>):
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;take the list of pkgs and score them based on the requesting package
</span></span></span><span style=display:flex><span><span style=font-style:italic>        return a dictionary of po=score&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>            _(<span style=font-style:italic>&#34;Running compare_providers() for </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#34;</span>) %(str(pkgs)))
</span></span></code></pre></div><p>接下来是具体的打分流程，先根据 repo id 的字母序进行过滤，如果多个 repo 均提供了同一版本的 PKG，那么会根据 repo 字母序进行选取：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=font-style:italic># Do a NameArch filtering, based on repo. __cmp__</span>
</span></span><span style=display:flex><span>    unique_nevra_pkgs = {}
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> pkg <span style=font-weight:700>in</span> pkgs:
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> (pkg.pkgtup <span style=font-weight:700>in</span> unique_nevra_pkgs <span style=font-weight:700>and</span>
</span></span><span style=display:flex><span>            unique_nevra_pkgs[pkg.pkgtup].repo &lt;= pkg.repo):
</span></span><span style=display:flex><span>            <span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>        unique_nevra_pkgs[pkg.pkgtup] = pkg
</span></span><span style=display:flex><span>    pkgs = unique_nevra_pkgs.values()
</span></span></code></pre></div><p>其中 pkg.repo 的实现如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Repository</span>:
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;this is an actual repository object&#34;&#34;&#34;</span>       
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> __init__(self, repoid):
</span></span><span style=display:flex><span>        self.id = repoid
</span></span><span style=display:flex><span>        self.quick_enable_disable = {}
</span></span><span style=display:flex><span>        self.disable()
</span></span><span style=display:flex><span>        self._xml2sqlite_local = <span style=font-weight:700>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> __cmp__(self, other):
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#34;&#34;&#34; Sort base class repos. by alphanumeric on their id, also
</span></span></span><span style=display:flex><span><span style=font-style:italic>            see __cmp__ in YumRepository(). &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> self.id &gt; other.id:
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> 1
</span></span><span style=display:flex><span>        <span style=font-weight:700>elif</span> self.id &lt; other.id:
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> -1
</span></span><span style=display:flex><span>        <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> 0
</span></span></code></pre></div><p>初始化 pkgresults ，其中 value 是对应的分数，第一步打分是检查目标 pkg 是否已经存在于当前主机上，会通过查询 rpmdb 来获取信息，如果已经存在了，那么这种情况是升级情况，需要与当前主机上 newest 的 pkg 进行比较，如果当前主机上最新的包版本小于 pkg，则 +5 分，如果等于则 +1000 分，如果小于则 -1024 分。如果当前主机上没有，则跳过。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>        pkgresults = {}
</span></span><span style=display:flex><span>        penalize = set()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> pkg <span style=font-weight:700>in</span> pkgs:
</span></span><span style=display:flex><span>            pkgresults[pkg] = 0 <span style=font-style:italic># 初始化各个 pkg 的分数为 0 </span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-style:italic># hand this off to our plugins</span>
</span></span><span style=display:flex><span>        self.plugins.run(<span style=font-style:italic>&#34;compare_providers&#34;</span>, providers_dict=pkgresults, 
</span></span><span style=display:flex><span>                                      reqpo=reqpo)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> pkg <span style=font-weight:700>in</span> pkgresults.keys():
</span></span><span style=display:flex><span>            rpmdbpkgs = self.rpmdb.searchNevra(name=pkg.name)
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> rpmdbpkgs:
</span></span><span style=display:flex><span>                <span style=font-style:italic>#  We only want to count things as &#34;installed&#34; if they are</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># older than what we are comparing, because this then an update</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># so we give preference. If they are newer then obsoletes/etc.</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># could play a part ... this probably needs a better fix.</span>
</span></span><span style=display:flex><span>                newest = sorted(rpmdbpkgs)[-1]
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> newest.verLT(pkg):
</span></span><span style=display:flex><span>                    <span style=font-style:italic># give pkgs which are updates just a SLIGHT edge</span>
</span></span><span style=display:flex><span>                    <span style=font-style:italic># we should also make sure that any pkg</span>
</span></span><span style=display:flex><span>                    <span style=font-style:italic># we are giving an edge to is not obsoleted by</span>
</span></span><span style=display:flex><span>                    <span style=font-style:italic># something else in the transaction. :(</span>
</span></span><span style=display:flex><span>                    <span style=font-style:italic># there are many ways I hate this - this is but one</span>
</span></span><span style=display:flex><span>                    pkgresults[pkg] += 5
</span></span><span style=display:flex><span>                <span style=font-weight:700>elif</span> newest.verEQ(pkg):
</span></span><span style=display:flex><span>                    <span style=font-style:italic>#  We get here from bestPackagesFromList(), give a giant</span>
</span></span><span style=display:flex><span>                    <span style=font-style:italic># bump to stuff that is already installed.</span>
</span></span><span style=display:flex><span>                    pkgresults[pkg] += 1000
</span></span><span style=display:flex><span>                <span style=font-weight:700>elif</span> newest.verGT(pkg):
</span></span><span style=display:flex><span>                    <span style=font-style:italic># if the version we&#39;re looking at is older than what we have installed</span>
</span></span><span style=display:flex><span>                    <span style=font-style:italic># score it down like we would an obsoleted pkg</span>
</span></span><span style=display:flex><span>                    pkgresults[pkg] -= 1024
</span></span><span style=display:flex><span>            <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                <span style=font-style:italic># just b/c they&#39;re not installed pkgs doesn&#39;t mean they should</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># be ignored entirely. Just not preferred</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>pass</span>
</span></span></code></pre></div><p>O(n^2)遍历 pkgs，先获取 Yum repo 中 newest version，然后保存下来，进行比对，如果当前 pkg 不等于 newest version，则 -1024 分。当前 repo 中匹配的 pkgs 列表一共 14 个， 遍历结束后每个 pkg 的分数应该是 13 * (-1024) = -13312。如果 pkg 被 nextpkg 所废除，那么 pkg 分数继续 -1024。如果传递了 arch 相关参数，那么会根据 arch 进行比较，如果哪个 pkg 提供了当前 arch 的包，那么会 +5 分。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>        lpos = {}
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> po <span style=font-weight:700>in</span> pkgs:
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> nextpo <span style=font-weight:700>in</span> pkgs:
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> po == nextpo:
</span></span><span style=display:flex><span>                    <span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=font-style:italic>#  If this package isn&#39;t the latest version of said package,</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># treat it like it&#39;s obsoleted. The problem here is X-1</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># accidentally provides FOO, so you release X-2 without the</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># provide, but X-1 is still picked over a real provider.</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> po.name <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> lpos:
</span></span><span style=display:flex><span>                    lpos[po.name] = self.pkgSack.returnNewestByName(po.name)[:1]
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> lpos[po.name] <span style=font-weight:700>or</span> <span style=font-weight:700>not</span> po.verEQ(lpos[po.name][0]):
</span></span><span style=display:flex><span>                    pkgresults[po] -= 1024
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                obsoleted = <span style=font-weight:700>False</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> po.obsoletedBy([nextpo]):
</span></span><span style=display:flex><span>                    obsoleted = <span style=font-weight:700>True</span>
</span></span><span style=display:flex><span>                    pkgresults[po] -= 1024
</span></span><span style=display:flex><span>                                
</span></span><span style=display:flex><span>                    self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                        _(<span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> obsoletes </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#34;</span>) % (nextpo, po))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> reqpo:
</span></span><span style=display:flex><span>                    arches = (reqpo.arch, self.arch.bestarch)
</span></span><span style=display:flex><span>                <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                    arches = (self.arch.bestarch,)
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=font-weight:700>for</span> thisarch <span style=font-weight:700>in</span> arches:
</span></span><span style=display:flex><span>                    res = _compare_arch_distance(po, nextpo, thisarch)
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> res:
</span></span><span style=display:flex><span>                        <span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>                    self.verbose_logger.log(logginglevels.DEBUG_4,                   
</span></span><span style=display:flex><span>                       _(<span style=font-style:italic>&#39;archdist compared </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> to </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> on </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-weight:700;font-style:italic>\n</span><span style=font-style:italic>  Winner: </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (po, nextpo, thisarch, res)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> res == po:
</span></span><span style=display:flex><span>                        pkgresults[po] += 5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-style:italic># End of O(N*N): for nextpo in pkgs:</span>
</span></span></code></pre></div><p>接下来会根据 pkg 是否存在 source rpm，是否是弱引用，是否是直接引用，是否存在冲突等进行分数的增减。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>            <span style=font-style:italic># End of O(N*N): for nextpo in pkgs:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-style:italic># Respect the repository priority for each provider, the default is 80</span>
</span></span><span style=display:flex><span>            pkgresults[po] += (100 - po.repo.compare_providers_priority) * 10
</span></span><span style=display:flex><span>            self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                _(<span style=font-style:italic>&#39;compare_providers_priority for </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> is </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (po, po.repo.compare_providers_priority)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> _common_sourcerpm(po, reqpo):
</span></span><span style=display:flex><span>                self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                    _(<span style=font-style:italic>&#39;common sourcerpm </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> and </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (po, reqpo)))
</span></span><span style=display:flex><span>                pkgresults[po] += 20
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> _weak_req(po, reqpo):
</span></span><span style=display:flex><span>                self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                    _(<span style=font-style:italic>&#39;weak req </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> and </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (po, reqpo)))
</span></span><span style=display:flex><span>                pkgresults[po] += 666
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> _info_req(po, reqpo):
</span></span><span style=display:flex><span>                self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                    _(<span style=font-style:italic>&#39;informational req </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> and </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (po, reqpo)))
</span></span><span style=display:flex><span>                pkgresults[po] += 333
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> _conflict_req(po, reqpo):
</span></span><span style=display:flex><span>                self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                    _(<span style=font-style:italic>&#39;conflict req </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> and </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (po, reqpo)))
</span></span><span style=display:flex><span>                penalize.add(po)
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> self.isPackageInstalled(po.base_package_name):
</span></span><span style=display:flex><span>                self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                    _(<span style=font-style:italic>&#39;base package </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> is installed for </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (po.base_package_name, po)))
</span></span><span style=display:flex><span>                pkgresults[po] += 5 <span style=font-style:italic># Same as before - - but off of base package name</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> reqpo:
</span></span><span style=display:flex><span>                cpl = _common_prefix_len(po.name, reqpo.name)
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> cpl &gt; 2:
</span></span><span style=display:flex><span>                    self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                        _(<span style=font-style:italic>&#39;common prefix of </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> between </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic> and </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % (cpl, po, reqpo)))
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                    pkgresults[po] += cpl*2
</span></span></code></pre></div><p>当基本分数进行打分完成后， 还存在多个 best pkg，那么会根据当前 OS 安装 pkg 所需依赖数量进行判定，依赖数量越少，则分数越高，最终依赖数量少的 pkg 分数 +1。此时部分 pkg 分数从 -13112 变为 -13111。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>        <span style=font-style:italic>#  If we have more than one &#34;best&#34;, see what would happen if we picked</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># each package ... ie. what things do they require that _aren&#39;t_ already</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># installed/to-be-installed. In theory this can screw up due to:</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic>#   pkgA =&gt; requires pkgX</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic>#   pkgB =&gt; requires pkgY, requires pkgZ</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># ...but pkgX requires 666 other things. Going recursive is</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># &#34;non-trivial&#34; though, python != prolog. This seems to do &#34;better&#34;</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># from simple testing though.</span>
</span></span><span style=display:flex><span>        bestnum = max(pkgresults.values()) <span style=font-style:italic># 将当前 pkg 分数最大的置为 bestnum</span>
</span></span><span style=display:flex><span>        rec_depsolve = {}
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> po <span style=font-weight:700>in</span> pkgs:
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> pkgresults[po] != bestnum: <span style=font-style:italic># 如果当前 pkg 分数不等于最高分，跳过</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>            rec_depsolve[po] = 0
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> len(rec_depsolve) &gt; 1: <span style=font-style:italic># 如果仍有多个 pkg，则进行依赖判定</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> po <span style=font-weight:700>in</span> rec_depsolve:
</span></span><span style=display:flex><span>                fake_txmbr = TransactionMember(po)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=font-style:italic>#  Note that this is just requirements, so you could also have</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># 4 requires for a single package. This might be fixable, if</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># needed, but given the above it&#39;s probably better to leave it</span>
</span></span><span style=display:flex><span>                <span style=font-style:italic># like this.</span>
</span></span><span style=display:flex><span>                reqs = self._checkInstall(fake_txmbr) <span style=font-style:italic># 检查安装 pkg 所需依赖</span>
</span></span><span style=display:flex><span>                rec_depsolve[po] = len(reqs) <span style=font-style:italic># 将依赖数量置为当前 pkg 的分数</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            bestnum = min(rec_depsolve.values()) <span style=font-style:italic># 找到依赖数量最少的分数作为 bestnum </span>
</span></span><span style=display:flex><span>            self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                                    _(<span style=font-style:italic>&#39;requires minimal: </span><span style=font-weight:700;font-style:italic>%d</span><span style=font-style:italic>&#39;</span>) % bestnum)
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> po <span style=font-weight:700>in</span> rec_depsolve:
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> rec_depsolve[po] == bestnum: 
</span></span><span style=display:flex><span>                    self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                            _(<span style=font-style:italic>&#39; Winner: </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span>) % po)
</span></span><span style=display:flex><span>                    pkgresults[po] += 1 <span style=font-style:italic># 将依赖数量结果填充会 pkgresults 中，依赖数量最少的分数 +1</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>else</span>:
</span></span><span style=display:flex><span>                    num = rec_depsolve[po]
</span></span><span style=display:flex><span>                    self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                            _(<span style=font-style:italic>&#39; Loser(with </span><span style=font-weight:700;font-style:italic>%d</span><span style=font-style:italic>): </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span>) % (num, po))
</span></span></code></pre></div><p>将当前分数最高的置为 bestnum，遍历 pkgs，如果当前 pkg 分数等于 bestnum，则将其分数 +1000，并将其分数 +(pkg.name)*-1 。如果 -13111 + 1000 +(-3) = -12114。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>        <span style=font-style:italic>#  We don&#39;t want to decide to use a &#34;shortest first&#34;, if something else</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># has told us to pick something else. But we want to pick between</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># multiple &#34;best&#34; packages. So we spike all the best packages (so</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># only those can win) and then bump them down by package name length.</span>
</span></span><span style=display:flex><span>        bestnum = max(pkgresults.values())
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> po <span style=font-weight:700>in</span> pkgs:
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> pkgresults[po] != bestnum:
</span></span><span style=display:flex><span>                <span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>            pkgresults[po] += 1000
</span></span><span style=display:flex><span>            pkgresults[po] += (len(po.name)*-1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># Bump down any packages that we identified as &#34;last-resort&#34; in such a</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># way that they all score below the worst overall score whilst keeping</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic># their relative differences.</span>
</span></span><span style=display:flex><span>        shift = max(pkgresults.values()) - min(pkgresults.values()) + 1
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> po <span style=font-weight:700>in</span> penalize:
</span></span><span style=display:flex><span>            pkgresults[po] -= shift
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        bestorder = sorted(pkgresults.items(),
</span></span><span style=display:flex><span>                           key=<span style=font-weight:700>lambda</span> x: (x[1], x[0]), reverse=<span style=font-weight:700>True</span>)
</span></span><span style=display:flex><span>        self.verbose_logger.log(logginglevels.DEBUG_4,
</span></span><span style=display:flex><span>                _(<span style=font-style:italic>&#39;Best Order: </span><span style=font-weight:700;font-style:italic>%s</span><span style=font-style:italic>&#39;</span> % str(bestorder)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>return</span> bestorder
</span></span></code></pre></div><p>最终根据 pkg 分数进行重新排序，返回第一个结果。</p><h2 id=总结>总结
<a class=heading-link href=#%e6%80%bb%e7%bb%93><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>发现这个问题最初是猜测是 Yum Repository 配置问题，阅读代码之后判定是 RPM 在某个版本依赖发生了改变，增加了某些依赖项，导致了 Yum 打分认为其分数较低，从而无法通过 yumdownloader 下载最新的 RPM。与相关同事确认，rc8 版本开始增加了部分依赖，调查结束。</p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2023
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>