<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Yiran's Blog</title><link>https://zdyxry.github.io/tags/Golang/</link><description>Recent content in Golang on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 09 Feb 2022 11:57:51 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/Golang/atom.xml" rel="self" type="application/rss+xml"/><item><title>基于 Yamux 的内网穿透简易实现</title><link>https://zdyxry.github.io/2022/02/09/%E5%9F%BA%E4%BA%8E-Yamux-%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 09 Feb 2022 11:57:51 +0000</pubDate><guid>https://zdyxry.github.io/2022/02/09/%E5%9F%BA%E4%BA%8E-Yamux-%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</guid><description>基于 Yamux 的内网穿透简易实现 链接到标题 Server 链接到标题 模拟真实服务器，假设运行在内网环境，端口 8881。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/hello&amp;#34;, HelloHandler) fmt.Println(&amp;#34;Server started at port 8881&amp;#34;) log.Fatal(http.ListenAndServe(&amp;#34;:8881&amp;#34;, nil)) } func HelloHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Hello, there\n&amp;#34;) } Hub 链接到标题 运行在公网环境的 Hub，用于 Agent 连接，并保持会话。端口 8882。
提供 session 管理机制，主要用来保存 Yamux session 和 Agent 对应关系。 每个内网可以运行多个 Agent，每次新建连接会从已有的 Agent session 列表中随机选择一个 session，并通过创建一个新的 Yamux Stream 机制复用连接。
type SessionManager interface { AddSession(key string, sess *yamux.</description></item><item><title>Server-Sent Events 简单使用</title><link>https://zdyxry.github.io/2020/02/03/Server-Sent-Events-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 03 Feb 2020 07:36:46 +0000</pubDate><guid>https://zdyxry.github.io/2020/02/03/Server-Sent-Events-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid><description>背景 链接到标题 最近在刷 Twitter 的时候，发现 Twitter 会实时更新已加载页面的内容，以为是 Websocket，看了下请求发现是 Server-sent events，之前没有了解过这个，今天来学习一下。
Server-sent events 链接到标题 引用维基百科：
Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via HTTP connection. The Server-Sent Events EventSource API is standardized as part of HTML5[1] by the W3C.
SSE 通常与 Websocket 相比较：
SSE 提供单向通信，Websocket 提供双向通信； SSE 是通过 HTTP 协议实现的，Websocket 是单独的协议； 实现上来说 SSE 比较容易，Websocket 复杂一些； 对浏览器来说，IE/Edge 不支持 SSE，其它的都是支持的。 SSE 有最大连接数限制 WS 可以传输二进制数据和文本数据，而 SSE 只有文本数据 SSE 使用场景：</description></item><item><title>如何捕捉 Ctrl+C 指令</title><link>https://zdyxry.github.io/2019/11/23/%E5%A6%82%E4%BD%95%E6%8D%95%E6%8D%89-Ctrl-C-%E6%8C%87%E4%BB%A4/</link><pubDate>Sat, 23 Nov 2019 21:23:24 +0000</pubDate><guid>https://zdyxry.github.io/2019/11/23/%E5%A6%82%E4%BD%95%E6%8D%95%E6%8D%89-Ctrl-C-%E6%8C%87%E4%BB%A4/</guid><description>背景 链接到标题 有时候在运行代码的时候，想要程序在接收到 Ctrl+C 指令的时候做一些平滑的处理，来写一下在 Python 和 Golang 中如何接收 Ctrl+C 指令。
Python 链接到标题 import signal import time import sys def run_program(): while True: print(&amp;#34;Test code...&amp;#34;) time.sleep(1) def exit_gracefully(signum, frame): signal.signal(signal.SIGINT, original_sigint) print(&amp;#34;Receive Ctrl+C.&amp;#34;) sys.exit(1) if __name__ == &amp;#39;__main__&amp;#39;: original_sigint = signal.getsignal(signal.SIGINT) signal.signal(signal.SIGINT, exit_gracefully) run_program() Golang 链接到标题 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func WaitForCtrlC() { var end_waiter sync.WaitGroup end_waiter.Add(1) var signal_channel chan os.Signal signal_channel = make(chan os.</description></item><item><title>Golang context 使用</title><link>https://zdyxry.github.io/2019/09/30/Golang-context-%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 30 Sep 2019 18:33:32 +0000</pubDate><guid>https://zdyxry.github.io/2019/09/30/Golang-context-%E4%BD%BF%E7%94%A8/</guid><description>背景 链接到标题 前段时间在写 Cluster API Provider 的时候，经常会使用 context 传递参数，当时只是按照其他项目中的方式快速的实现，并没有认真的了解 context 具体包含什么，为了解决什么问题，这次来聊一下。
P.S. 虽然写了一周的 Golang，但是对于标准库有什么还一无所知，找时间应该认真过一遍的。。
定义与使用 链接到标题 先看定义：
Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.
当一个 goroutine 调用其他 goroutine，随着层级变多，我们想要在外层达到控制的效果 在必要场景下传递 必需 的数据 其中 Context 这个 interface 中定义了 4 个方法，具体如下：
type Context interface { Deadline() (deadline time.Time, ok bool) Done() &amp;lt;-chan struct{} Err() error Value(key interface{}) interface{} } 在 context 包中实现了4个函数，平时也都是使用这些函数：</description></item><item><title>Linux 下磁盘设备自动发现方式</title><link>https://zdyxry.github.io/2019/08/02/Linux-%E4%B8%8B%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E6%96%B9%E5%BC%8F/</link><pubDate>Fri, 02 Aug 2019 23:10:04 +0000</pubDate><guid>https://zdyxry.github.io/2019/08/02/Linux-%E4%B8%8B%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid><description>背景 链接到标题 如果在 PC 上安装过 Linux，那么通常会遇到过硬件设备无法发现的问题，这类问题最终都可以通过 google 来解决掉。那么当我们在服务器场景下，如何做到设备自动发现且在设备发现后执行某些动作呢？
最近看了几个关于存储系统的 Operator 部分实现，记录一下。
命令行 链接到标题 最简单的肯定是我们写一个循环，永远检测我们要发现的设备，比如 lsblk 可以列举当前服务器所有 block 设备，那么我们就在循环内部执行 lsblk，diff 每次执行的结果，如果有新的设备，那么执行某些操作。
lsblk 是通过读取 /sys/block 下的具体目录判断的，那么我么也可以直接读取该路径下的目录来实现。
如果是网络设备也是一样，我们可以在循环内部执行 ip link list 来获取所有网络设备。
UDEV 链接到标题 照常先引用维基百科的解释：
udev 是Linux kernel 2.6系列的设备管理器。它主要的功能是管理/dev目錄底下的设备节点。它同时也是用来接替devfs及hotplug的功能，这意味着它要在添加/删除硬件时处理/dev目录以及所有用户空间的行为，包括加载firmware时。
如果你的 OS 是通过 systemd 来管理所有进程的话，那么可以发现一个服务叫做 systemd-udevd ，这个是 udev 的守护进程:
[root@node90 19:58:10 ~]$systemctl status systemd-udevd ● systemd-udevd.service - udev Kernel Device Manager Loaded: loaded (/usr/lib/systemd/system/systemd-udevd.service; static; vendor preset: disabled) Active: active (running) since Fri 2019-06-14 15:25:55 CST; 1 months 18 days ago Docs: man:systemd-udevd.</description></item><item><title>Heap In Python &amp; Golang</title><link>https://zdyxry.github.io/2019/07/28/Heap-In-Python-Golang/</link><pubDate>Sun, 28 Jul 2019 12:11:45 +0000</pubDate><guid>https://zdyxry.github.io/2019/07/28/Heap-In-Python-Golang/</guid><description>背景 链接到标题 最近使用到了 heap 这个数据结构，记录一下在 Python 和 Golang 中最基本的使用方法～
堆（英语：Heap）是计算机科学中的一種特別的樹狀数据结构。若是滿足以下特性，即可稱為堆積：「給定堆積中任意節點P和C，若P是C的母節點，那麼P的值會小於等於（或大於等於）C的值」。若母節點的值恆小於等於子節點的值，此堆積稱為最小堆積（min heap）；反之，若母節點的值恆大於等於子節點的值，此堆積稱為最大堆積（max heap）。在堆積中最頂端的那一個節點，稱作根節點（root node），根節點本身沒有母節點（parent node）。
Python 链接到标题 create 链接到标题 In [1]: import heapq In [2]: a = [1,3,2,5,4] In [3]: heapq.heapify(a) In [4]: a Out[4]: [1, 3, 2, 5, 4] In [5]: b = [] In [6]: heapq.heappu heapq.heappush heapq.heappushpop In [6]: heapq.heappush(b, 1) In [7]: heapq.heappush(b, 3) In [8]: heapq.heappush(b, 2) In [9]: heapq.heappush(b, 5) In [10]: heapq.heappush(b, 4) In [11]: b Out[11]: [1, 3, 2, 5, 4] read 链接到标题 In [28]: b Out[28]: [1, 3, 2, 5, 4] In [29]: heapq.</description></item></channel></rss>