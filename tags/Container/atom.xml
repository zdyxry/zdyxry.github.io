<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Container on Yiran's Blog</title><link>https://zdyxry.github.io/tags/Container/</link><description>Recent content in Container on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 05 Mar 2022 15:10:39 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/Container/atom.xml" rel="self" type="application/rss+xml"/><item><title>使用 init 进程运行 Container</title><link>https://zdyxry.github.io/2022/03/05/%E4%BD%BF%E7%94%A8-init-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C-Container/</link><pubDate>Sat, 05 Mar 2022 15:10:39 +0000</pubDate><guid>https://zdyxry.github.io/2022/03/05/%E4%BD%BF%E7%94%A8-init-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C-Container/</guid><description>背景 链接到标题 关注过 Bare Metal 相关项目的同学应该都了解过系统的启动流程、如何快速的置备一台物理服务器等之类的实现方式，通常都需要运行一个 LiveOS 来实现某些动作。 在 Tinkerbell 项目中，使用 Linuxkit 来作为 LiveOS，Plunder 项目中使用 BOOTy 来作为 LiveOS。前几天 @thebsdbox 将 BOOTy 中的一部分抽离了出来，作为 ginit 展示主要的实现方式，可以更好的让我们理解安装环节中的具体细节。 今天来看一下这个项目。
如果安装一个 CentOS，那么通常是会通过 kernel + initramfs.img 启动，initramfs.img 中会包含 systemd 、anaconda、dracut 等一些列组件，然后通过 systemd 指定不同的 Target 所属/依赖/顺序来完成最终 Anaconda 调用。Anaconda 通过解析 /proc/cmdline 中的 KickStart 参数来决定自己的安装方式。
ginit 项目展示了以下内容：
制作 initramfs.img 通过 Container image 制作一个 RAW image 通过 QEMU 使用 RAW image 和 Linux Kernel 来运行一个虚拟机 ginit 自动运行 Container 中 entrypoint 指令 流程演示 链接到标题 通过 Container image 制作一个 RAW image 链接到标题 RAW image 中最终不会包含 Kernel 部分，以 Nginx Container 为例。提取 nginx:latest image 中的 Entrypoint ，通过 dd 置备一个 RAW image，并格式化为 ext4 ，raw image 作为 loop 设备挂载到本地，通过 docker export 将 Nginx Image 拷贝到挂载点下，卸载挂载点，最终 RAW image 包含了 Nginx Container 的所有内容。这里的 RAW image 因为不包含 kernel，所以无法直接启动，只是作为后续动作的依赖。</description></item><item><title>Container Optimized OS(COS) 简单对比</title><link>https://zdyxry.github.io/2021/07/30/Container-Optimized-OSCOS-%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</link><pubDate>Fri, 30 Jul 2021 21:39:04 +0000</pubDate><guid>https://zdyxry.github.io/2021/07/30/Container-Optimized-OSCOS-%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</guid><description>背景 链接到标题 之前简单调研过一些 Container Optimized OS，进行了一些简单的对比，最近又被同事问到了，整理一下发出来。
COS 链接到标题 结论 链接到标题 如果让我来选择一个 COS 作为 BaseOS 来进行定制，那我会根据以下几个条件来进行选择：
是否支持 OSTree 是否有明星公司做背后支持，如 RedHat、VMware 社区活跃度 根据以上几个条件，如果是我自己使用的话，我会选择 Fedora CoreOS，或者 VMware Photo（OSTree） 。</description></item><item><title>Podman(Docker) Compose 学习记录</title><link>https://zdyxry.github.io/2021/01/09/PodmanDocker-Compose-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 09 Jan 2021 18:56:30 +0000</pubDate><guid>https://zdyxry.github.io/2021/01/09/PodmanDocker-Compose-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid><description>Compose 链接到标题 最近因为一些需求可能需要用到 Compose，看了看 Podman Compose 和 Docker Compose，记录一下。
Compose 主要功能：
环境隔离(docker) 一组服务的起停控制 服务之间的依赖管理 Podman compose 链接到标题 项目地址：https://github.com/containers/podman-compose
用爱发电的项目，所有的实现都在 podman_compose.py 中，由于 Podman 没有一个好用的 client ，所以 compose 中所有的 Podman 相关的交互都是通过命令行来完成的，目前处于一个非常早期的状态，最基本的服务依赖都没有实现，不建议使用。
Docker compose 链接到标题 cli/ # 命令行解析 config/ # 配置文件格式、校验方式、辅助函数 const.py # constants container.py # 使用 docker client 对 container 命令及属性进行封装 errors.py # error code network.py # 网络相关配置 parallel.py # 并发操作封装 progress_stream.py # stream 相关 project.py # project，project 与 service 是一对多的关系 service.</description></item><item><title>runc nsenter 源码阅读</title><link>https://zdyxry.github.io/2020/04/12/runc-nsenter-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Sun, 12 Apr 2020 14:57:29 +0000</pubDate><guid>https://zdyxry.github.io/2020/04/12/runc-nsenter-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>背景 链接到标题 最近在阅读 runc 的实现，发现在 runc 中比较重要的一个逻辑是在设置 namespace 过程中的 nsenter 模块，其中逻辑有些绕，也发现了一段很长很有意思的注释，分享一下。
What 链接到标题 什么是 nsenter，nsenter 是 runc 中的一个 package，它包含了一个特殊的构造函数，用来在 Go runtime 启动之前做一些事情，比如 setns()。nsenter 会引入 C 并使用 cgo 实现相关逻辑。在cgo中，如果在 C 的 import 后紧跟注释，则在编译程序包的 C 语言实现部分时，该注释将用作 header。因此，每次 import nsenter 时，nsexec()都会调用 C 函数。
在 runc 中只有 init.go import 了 nsenter。
Why 链接到标题 容器技术最关键的就是 namespace 和 cgroup，其中 namespace 是通过 setns() 函数来实现的，但是 setns() 有一个问题： A multithreaded process may not change user namespace with setns(). 。而 go runtime 是多线程的，所以需要在 go runtime 启动前执行 setns() 设置好 namespace，然后再走 go 相关实现流程。</description></item></channel></rss>