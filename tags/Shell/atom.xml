<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shell on Yiran's Blog</title><link>https://zdyxry.github.io/tags/Shell/</link><description>Recent content in Shell on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 01 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/Shell/atom.xml" rel="self" type="application/rss+xml"/><item><title>Shell 携带通配符执行顺序</title><link>https://zdyxry.github.io/2023/04/01/Shell-%E6%90%BA%E5%B8%A6%E9%80%9A%E9%85%8D%E7%AC%A6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate><guid>https://zdyxry.github.io/2023/04/01/Shell-%E6%90%BA%E5%B8%A6%E9%80%9A%E9%85%8D%E7%AC%A6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>背景 链接到标题 这周有同事在 Slack 问了一个问题： 发现在v505和v503的集群主机上 sudo的配置有一点点小问题：普通用户使用sudo时 shell中的 wildcard不生效 。
环境状态大概是这样的： 系统存在普通用户 yiran ，并配置了 sudo 权限，同时系统存在 /var/log/libvirt/qemu/ 路径，其中 libvirt 和 qemu 的目录 owner 是 root，权限是700， qemu 下存在很多以 .log 为结尾的文件，owner 是 root，权限是 600，具体示例如下：
[yiran@node11 11:09:35 ~]$id yiran uid=1002(yiran) gid=1002(yiran) groups=1002(yiran) [yiran@node11 11:09:40 ~]$sudo ls -l /var/log/ |grep libvirt drwx------. 3 root root 4096 Sep 16 2022 libvirt [yiran@node11 11:09:45 ~]$sudo ls -l /var/log/libvirt |grep qemu drwx------. 2 root root 319488 Mar 26 03:07 qemu [yiran@node11 11:09:48 ~]$sudo ls -l /var/log/libvirt/qemu/ |egrep *.</description></item><item><title>Shell cat 保存文件方式</title><link>https://zdyxry.github.io/2019/01/05/Shell-cat-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F/</link><pubDate>Sat, 05 Jan 2019 20:12:30 +0000</pubDate><guid>https://zdyxry.github.io/2019/01/05/Shell-cat-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F/</guid><description>背景 链接到标题 在 Shell 中保存文件可以通过 echo 保存一个字符串， cat 保存一个字符片段，最近在用 cat 编写 Nginx 配置文件的时候，想要写入 $test 类似字段，但是 Shell 会自动将其识别为变量而忽略，记录下该方式。
cat 编写文件 链接到标题 root@yiran-30-250:/tmp $ cat cat.sh #!/usr/bin/env bash cat &amp;lt;&amp;lt; EOF &amp;gt; /tmp/yiran aaa bbb ccc ddd $eee $fff EOF root@yiran-30-250:/tmp $ bash cat.sh root@yiran-30-250:/tmp $ cat yiran aaa bbb ccc ddd root@yiran-30-250:/tmp $ cat cat2.sh #!/usr/bin/env bash cat &amp;lt;&amp;lt; &amp;#39;EOF&amp;#39; &amp;gt; /tmp/yiran aaa bbb ccc ddd $eee $fff EOF root@yiran-30-250:/tmp $ bash cat2.</description></item><item><title>奇怪的 Shell 作用域</title><link>https://zdyxry.github.io/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84-Shell-%E4%BD%9C%E7%94%A8%E5%9F%9F/</link><pubDate>Fri, 08 Jun 2018 21:51:55 +0000</pubDate><guid>https://zdyxry.github.io/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84-Shell-%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid><description>工作中很多脚本都是用 Shell 和 Python 完成的，在上周环境中遇到了一个 Bug，导致部分功能失败，最后发现是 Shell 作用域的问题。
举例 链接到标题 $ tree . . ├── test.sh └── utils.sh 0 directories, 2 files $ cat utils.sh #!/usr/bin/env bash function echo_test { for i in `seq 2 3`;do echo &amp;#34;utils.sh&amp;#34; $i done } $ cat test.sh #!#/usr/bin/env bash . utils.sh for i in `seq 1 5`;do echo &amp;#34;before utils.sh&amp;#34; $i echo_test echo &amp;#34;after utils.sh&amp;#34; $i echo &amp;#34;#################&amp;#34; done $ bash test.sh before utils.</description></item></channel></rss>