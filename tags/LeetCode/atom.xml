<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Yiran's Blog</title><link>https://zdyxry.github.io/tags/LeetCode/</link><description>Recent content in LeetCode on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 26 Sep 2020 17:08:07 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/LeetCode/atom.xml" rel="self" type="application/rss+xml"/><item><title>2020 第39周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/09/26/2020-%E7%AC%AC39%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 26 Sep 2020 17:08:07 +0000</pubDate><guid>https://zdyxry.github.io/2020/09/26/2020-%E7%AC%AC39%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1588. Sum of All Odd Length Subarrays 链接到标题 处理当长度为 1 时特殊情况，其他都遍历长度为奇数情况然后求和。
class Solution: def sumOddLengthSubarrays(self, arr: List[int]) -&amp;gt; int: res = 0 for i in range(len(arr)+1): if i % 2: if i == 1: res += sum(arr) else: j = 0 while j + i &amp;lt;= len(arr): res += sum(arr[j:j+i]) j += 1 return res 1592. Rearrange Spaces Between Words 链接到标题 统计空格出现的次数，然后求出平均空格数进行字符串拼接。
class Solution: def reorderSpaces(self, text: str) -&amp;gt; str: cnt=text.</description></item><item><title>2020 第38周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/09/20/2020-%E7%AC%AC38%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 20 Sep 2020 07:45:55 +0000</pubDate><guid>https://zdyxry.github.io/2020/09/20/2020-%E7%AC%AC38%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1582. Special Positions in a Binary Matrix 链接到标题 直接遍历二维数组之后，如果某个位置是 1，再去统计每行的和和每列的和是否为 1 时间复杂度太高，可以先统计每行每列的和，然后再遍历二维数组。
class Solution: def numSpecial(self, mat: List[List[int]]) -&amp;gt; int: m, n, ans = len(mat), len(mat[0]), 0 row, col = [0] * m, [0] * n for i in range(m): for j in range(n): if mat[i][j]: row[i] += 1 col[j] += 1 pool = [j for j in range(n) if col[j] == 1] for i in range(m): if row[i] !</description></item><item><title>2020 第37周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/09/13/2020-%E7%AC%AC37%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 13 Sep 2020 10:51:05 +0000</pubDate><guid>https://zdyxry.github.io/2020/09/13/2020-%E7%AC%AC37%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1572. Matrix Diagonal Sum 链接到标题 对角线之和，需要注意当行为奇数和偶数时候的去重处理。
class Solution: def diagonalSum(self, mat: List[List[int]]) -&amp;gt; int: n = len(mat) if n == 1: return mat[0][0] ans = 0 for i in range(n): if i != n-1-i: ans += mat[i][i] ans += mat[i][n-1-i] else: ans += mat[i][i] return ans 1576. Replace All ?&amp;rsquo;s to Avoid Consecutive Repeating Characters 链接到标题 题目中说的是不能出现连续相同的字符，整个字符串中是可以出现重复字符的，只需要遍历字符串，然后判断前后是否相同替换。
class Solution: def modifyString(self, s: str) -&amp;gt; str: l = list(s) alphabet = list(string.</description></item><item><title>2020 第36周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/09/06/2020-%E7%AC%AC36%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 06 Sep 2020 15:04:19 +0000</pubDate><guid>https://zdyxry.github.io/2020/09/06/2020-%E7%AC%AC36%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1566. Detect Pattern of Length M Repeated K or More Times 链接到标题 判断数组中是否存在连续长度为 m 且重复次数为 k 的字符串，直接对 arr 进行切片判断。
class Solution: def containsPattern(self, arr: List[int], m: int, k: int) -&amp;gt; bool: i = 0 while i &amp;lt; len(arr): p = arr[i:i+m] if p * k == arr[i:i+m*k]: return True i += 1 return False 1567. Maximum Length of Subarray With Positive Product 链接到标题 给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。使用数组记录数值为负数的索引值，当数字为 0 时则重置数组，当负数数量为偶数时，则更新最大值，最大值为当前索引减去第一个非 0 数字索引，如果负数数量为奇数时，则最大值为当前索引减去第一个负数索引。</description></item><item><title>2020 第35周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/08/29/2020-%E7%AC%AC35%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 29 Aug 2020 18:42:34 +0000</pubDate><guid>https://zdyxry.github.io/2020/08/29/2020-%E7%AC%AC35%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1560. Most Visited Sector in a Circular Track 链接到标题 在中间走过多少圈，对于各个扇区来说是相同的，只需要考虑起点和终点的位置关系。
class Solution: def mostVisited(self, n: int, rounds: List[int]) -&amp;gt; List[int]: s, d = rounds[0], rounds[-1] if s &amp;lt;= d: return list(range(s, d+1)) else: return list(range(1, d+1)) + list(range(s, n+1)) 1557. Minimum Number of Vertices to Reach All Nodes 链接到标题 如果某个节点出现在到达节点，那么这个节点一定不在结果中，相反则一定在结果中。
class Solution: def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: return list(set(range(n)) - set(e[1] for e in edges)) 1558. Minimum Numbers of Function Calls to Make Target Array 链接到标题 一共有两种操作：1.</description></item><item><title>2020 第34周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/08/23/2020-%E7%AC%AC34%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 23 Aug 2020 16:37:12 +0000</pubDate><guid>https://zdyxry.github.io/2020/08/23/2020-%E7%AC%AC34%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1550. Three Consecutive Odds 链接到标题 判断数组是否存在连续 3 个奇数的情况存在，直接遍历判断，使用变量记录当前奇数个数。
class Solution: def threeConsecutiveOdds(self, arr: List[int]) -&amp;gt; bool: cnt = 0 for i in arr: if i &amp;amp; 1: cnt += 1 else: cnt = 0 if cnt == 3: return True return False 1551. Minimum Operations to Make Array Equal 链接到标题 一道数学题，等差数列求和公式变形。
n=3 最小操作数是 2 n=4 最小操作数是 1 + 3 n=5 最小操作数是 2 + 4 n=6 最小操作数是 1 + 3 + 5 n=7 最小操作数是 2 + 4 + 6 class Solution: def minOperations(self, n: int) -&amp;gt; int: return n*n // 4 410.</description></item><item><title>2020 第33周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 16 Aug 2020 10:27:06 +0000</pubDate><guid>https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1544. Make The String Great 链接到标题 使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。
class Solution: def makeGood(self, s: str) -&amp;gt; str: stack = [] for i in s: if stack and ((ord(stack[-1])-32) == ord(i) or (ord(stack[-1])+32) == ord(i)): stack.pop() else: stack.append(i) return &amp;#39;&amp;#39;.join(stack) 1545. Find Kth Bit in Nth Binary String 链接到标题 找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。
class Solution: def findKthBit(self, n: int, k: int) -&amp;gt; str: if (n == 1): return &amp;#39;0&amp;#39; l = (1 &amp;lt;&amp;lt; n) - 1 mid = (l &amp;gt;&amp;gt; 1) + 1 if k == mid: return &amp;#39;1&amp;#39; elif k &amp;lt; mid: return self.</description></item><item><title>2020 第32周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/08/08/2020-%E7%AC%AC32%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 08 Aug 2020 16:17:20 +0000</pubDate><guid>https://zdyxry.github.io/2020/08/08/2020-%E7%AC%AC32%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1534. Count Good Triplets 链接到标题 数据规模很小，暴力循环解。
class Solution: def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -&amp;gt; int: if len(arr) &amp;lt; 3: return 0 ans = 0 for i in range(0, len(arr)): for j in range(i+1, len(arr)): for k in range(j+1, len(arr)): if abs(arr[i] - arr[j]) &amp;lt;= a and abs(arr[j] - arr[k]) &amp;lt;= b and abs(arr[i] - arr[k]) &amp;lt;= c: ans += 1 return ans 1535. Find the Winner of an Array Game 链接到标题 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。</description></item><item><title>2020 第31周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/08/01/2020-%E7%AC%AC31%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 01 Aug 2020 07:26:24 +0000</pubDate><guid>https://zdyxry.github.io/2020/08/01/2020-%E7%AC%AC31%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1523. Count Odd Numbers in an Interval Range 链接到标题 数学题，数据范围是10^9，O(n) 会超时，统计 high 中有多少个奇数，减去 low-1 中的奇数个数，需要考虑边界条件：low/high 自身为奇数情况。
class Solution: def countOdds(self, low: int, high: int) -&amp;gt; int: res = high // 2 if high % 2 == 1: res += 1 if low - 1 &amp;gt;= 0: res -= (low - 1) // 2 if (low - 1) % 2 == 1: res -= 1 return res 1528. Shuffle String 链接到标题 按照指定顺序调整字符串，直接定义一个新的长度为 len(s)字符串，然后按照 indices 的索引顺序进行对应调整。</description></item><item><title>2020 第30周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/07/26/2020-%E7%AC%AC30%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 26 Jul 2020 09:36:03 +0000</pubDate><guid>https://zdyxry.github.io/2020/07/26/2020-%E7%AC%AC30%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1518. Water Bottles 链接到标题 小学数学题，用几个空瓶子可以换一瓶新的，问最后能喝到几瓶，在小学场景下可以先借再喝，在这道题没有这种场景，所以正常计算就好。
class Solution: def numWaterBottles(self, numBottles: int, numExchange: int) -&amp;gt; int: res = numBottles while numBottles &amp;gt;= numExchange: cnt = numBottles // numExchange res += cnt numBottles = numBottles - (cnt * numExchange) numBottles += cnt return res 1108. Defanging an IP Address 链接到标题 将 IPv4 地址 &amp;ldquo;1.1.1.1&amp;rdquo; 转换为 &amp;ldquo;1[.]1[.]1[.]1&amp;rdquo; ，不知道这道题的意义在哪里。。
class Solution: def defangIPaddr(self, address: str) -&amp;gt; str: return address.replace(&amp;#39;.&amp;#39;, &amp;#39;[.]&amp;#39;) 1519. Number of Nodes in the Sub-Tree With the Same Label 链接到标题 题目很绕，最好自己根据给的 edges 和 labels 构建出对应的树，了解是如何构建的，最终要求的 ans 中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数，记录所有节点的相邻节点，从 0 节点开始 dfs，如果节点已经访问过，则跳过对应节点，最终汇总 ans[i] 中的数值。</description></item><item><title>2020 第29周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 19 Jul 2020 11:19:38 +0000</pubDate><guid>https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1509. Minimum Difference Between Largest and Smallest Value in Three Moves 链接到标题 要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。
class Solution: def minDifference(self, nums: List[int]) -&amp;gt; int: nums.sort() return min(b - a for a, b in zip(nums[:4], nums[-4:])) 1512. Number of Good Pairs 链接到标题 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &amp;lt; j ，就可以认为这是一组 好数对 ，返回好数对的数目。 只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。
class Solution: def numIdenticalPairs(self, A: List[int]) -&amp;gt; int: return sum(k * (k - 1) / 2 for k in collections.</description></item><item><title>2020 第28周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/07/11/2020-%E7%AC%AC28%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 11 Jul 2020 21:50:54 +0000</pubDate><guid>https://zdyxry.github.io/2020/07/11/2020-%E7%AC%AC28%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1502. Can Make Arithmetic Progression From Sequence 链接到标题 判断是否可以组成等差数列，将数组排序后，比较两两数字差是否一致。
class Solution: def canMakeArithmeticProgression(self, arr: List[int]) -&amp;gt; bool: if len(arr) == 2: return True arr.sort(reverse=True) diff = arr[0] - arr[1] pre = arr[1] for i in arr[2:]: if pre - i != diff: return False pre = i return True 1503. Last Moment Before All Ants Fall Out of a Plank 链接到标题 标签是“脑筋急转弯”，蚂蚁只要在一个点碰到，那么就会调换方向，但是蚂蚁始终是蚂蚁，因此可以忽略掉这个条件，直接找到最大值就可以了。
再次怀疑自己智商。
class Solution: def getLastMoment(self, n: int, left: List[int], right: List[int]) -&amp;gt; int: time = 0 if left: time = max(time, max(left)) if right: time = max(time, n - min(right)) return time 939.</description></item><item><title>2020 第27周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/07/04/2020-%E7%AC%AC27%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 04 Jul 2020 09:17:15 +0000</pubDate><guid>https://zdyxry.github.io/2020/07/04/2020-%E7%AC%AC27%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1492. The kth Factor of n 链接到标题 计算 n 的第 k 个因子，i 从 1 开始递增，如果 i 可以被 n 整除，则 k&amp;ndash;，当 k == 0 时， i为所求值。
class Solution: def kthFactor(self, n: int, k: int) -&amp;gt; int: for i in range(1, n+1): if n % i == 0: k -= 1 if k == 0: return i return -1 1493. Longest Subarray of 1&amp;rsquo;s After Deleting One Element 链接到标题 用 cnt1 记录删除一个元素之后当前最长全为 1 的数组长度，用 cnt2 记录当前最长全为 1 的数组长度。</description></item><item><title>2020 第26周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/06/28/2020-%E7%AC%AC26%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 28 Jun 2020 21:57:10 +0000</pubDate><guid>https://zdyxry.github.io/2020/06/28/2020-%E7%AC%AC26%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1486. XOR Operation in an Array 链接到标题 遍历进行异或操作。
class Solution: def xorOperation(self, n: int, start: int) -&amp;gt; int: ans = 0 for i in range(n): ans ^= start + 2 * i return ans 1487. Making File Names Unique 链接到标题 一道实际环境中会遇到的场景，使用哈希表记录已有的文件名，如果该文件已经存在在哈希表中，那么循环判断文件名 + () 数字是否也在哈希表中，如果还在，那么数字 + 1，直到数字不在。然后将结果记录到返回列表中。
class Solution: def getFolderNames(self, names: List[str]) -&amp;gt; List[str]: nameMap = {} # baseName : largest k suffix res = [] for n in names: if n in nameMap: # find k k = nameMap[n] + 1 while ( n + &amp;#34;(&amp;#34; + str(k) + &amp;#34;)&amp;#34; ) in nameMap: k += 1 nameMap[n] = k n = n + &amp;#34;(&amp;#34; + str(k) + &amp;#34;)&amp;#34; # with suffix is now considered a base name nameMap[n] = 0 # first time seeing this base name res.</description></item><item><title>2020 第25周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/06/20/2020-%E7%AC%AC25%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 20 Jun 2020 06:53:40 +0000</pubDate><guid>https://zdyxry.github.io/2020/06/20/2020-%E7%AC%AC25%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1476. Subrectangle Queries 链接到标题 二维数组的更新与查找。
class SubrectangleQueries: def __init__(self, rectangle: List[List[int]]): self.rect = rectangle self.rows, self.cols = len(self.rect), len(self.rect[0]) def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -&amp;gt; None: for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): self.rect[i][j] = newValue def getValue(self, row: int, col: int) -&amp;gt; int: return self.rect[row][col] # Your SubrectangleQueries object will be instantiated and called as such: # obj = SubrectangleQueries(rectangle) # obj.</description></item><item><title>2020 第24周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 13 Jun 2020 07:38:57 +0000</pubDate><guid>https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1470. Shuffle the Array 链接到标题 重新排列数组，使用 zip 对两个切分后的数组进行聚合
class Solution: def shuffle(self, nums: List[int], n: int) -&amp;gt; List[int]: res = [] for i, j in zip(nums[0:n],nums[n:]): res+=[i,j] return res 1471. The k Strongest Values in an Array 链接到标题 找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。
class Solution: def getStrongest(self, arr: List[int], k: int) -&amp;gt; List[int]: arr.sort() i, j = 0, len(arr) - 1 median = arr[(len(arr) - 1) // 2] while len(arr) + i - j &amp;lt;= k: if median - arr[i] &amp;gt; arr[j] - median: i = i + 1 else: j = j - 1 return arr[:i] + arr[j + 1:] 1472.</description></item><item><title>2020 第23周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/06/06/2020-%E7%AC%AC23%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 06 Jun 2020 13:25:41 +0000</pubDate><guid>https://zdyxry.github.io/2020/06/06/2020-%E7%AC%AC23%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1460. Make Two Arrays Equal by Reversing Sub-arrays 链接到标题 比较两个列表是否可以通过翻转等价，统计列表中字母出现的次数判断，或者可以直接排序判断。
class Solution: def canBeEqual(self, target: List[int], arr: List[int]) -&amp;gt; bool: c = collections.Counter(target) for a in arr: c[a] -= 1 if c[a] &amp;lt; 0: return False return True 1464. Maximum Product of Two Elements in an Array 链接到标题 找到数组中最大的两个数字，分别将其数值 -1 然后相乘返回。可以直接升序排序后取最后两个数字。
func maxProduct(nums []int) int { max:=0 secondMax:=0 for i:=0;i&amp;lt;len(nums);i++{ e:=nums[i] if e&amp;gt;max{ secondMax = max max = e }else if e&amp;gt;secondMax{ secondMax = e } } return (max-1)*(secondMax-1) } 1461.</description></item><item><title>2020 第22周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/06/01/2020-%E7%AC%AC22%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jun 2020 05:44:57 +0000</pubDate><guid>https://zdyxry.github.io/2020/06/01/2020-%E7%AC%AC22%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence 链接到标题 切分句子然后遍历判断是否为前缀，需要返回索引 + 1。
class Solution: def isPrefixOfWord(self, sentence: str, searchWord: str) -&amp;gt; int: for idx, w in enumerate(sentence.split(&amp;#39; &amp;#39;)): if w.startswith(searchWord): return idx + 1 else: return -1 1456. Maximum Number of Vowels in a Substring of Given Length 链接到标题 滑动窗口，使用字典统计每个元音出现的次数，每次更新最大值。
class Solution: def maxVowels(self, s: str, k: int) -&amp;gt; int: d = {&amp;#39;a&amp;#39;: 0, &amp;#39;e&amp;#39;: 0, &amp;#39;i&amp;#39;: 0, &amp;#39;o&amp;#39;: 0, &amp;#39;u&amp;#39;: 0} for c in s[:k]: if c in d: d[c] += 1 res = sum(d.</description></item><item><title>2020 第21周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/05/22/2020-%E7%AC%AC21%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 22 May 2020 22:28:29 +0000</pubDate><guid>https://zdyxry.github.io/2020/05/22/2020-%E7%AC%AC21%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1446. Consecutive Characters 链接到标题 判断最长连续相同字符的长度，记录下当前字母，然后比较与 flag 是否相同，如果相同则 +1，不相同则重置为 1。
也可以通过 itertools.groupby 来实现（新学习的。。）
class Solution: def maxPower(self, s: str) -&amp;gt; int: if len(s) == 1: return 1 tmp = s[0] cnt = 1 max_cnt = 0 for i in s[1:]: if i == tmp: cnt += 1 else: tmp = i cnt = 1 max_cnt = max(max_cnt, cnt) return max_cnt 1447. Simplified Fractions 链接到标题 遍历分子与分母，求最大公约数，如果最大公约数为1，则将结果保存下来。分母从 2 开始计算。
func simplifiedFractions(n int) []string { ret := []string{} for i := 2; i &amp;lt;= n; i++ { for j := 1; j &amp;lt; i; j++ { if gcd(i, j) == 1 { ret = append(ret, fmt.</description></item><item><title>2020 第20周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/05/16/2020-%E7%AC%AC20%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 16 May 2020 10:17:49 +0000</pubDate><guid>https://zdyxry.github.io/2020/05/16/2020-%E7%AC%AC20%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1441. Build an Array With Stack Operations 链接到标题 遍历数组，比较当前值与目标值是否相同，如果相同，则在结果追加 Push ，如果不同，则追加 Push, Pop 。
class Solution: def buildArray(self, target: List[int], n: int) -&amp;gt; List[str]: res = [] keep = 0 for num in range(1, n+1): res.append(&amp;#34;Push&amp;#34;) keep += 1 if num not in target: res.append(&amp;#34;Pop&amp;#34;) keep -= 1 if keep == len(target): break return res 1442. Count Triplets That Can Form Two Arrays of Equal XOR 链接到标题 求子数组中是否存在左侧部分异或值与右侧部分异或值相等的情况，a==b -&amp;gt; a ^ b = 0，也就是是否存在子数组所有元素异或值为0 的情况，如果存在，那么子数组所有的元素都可以符合条件。</description></item><item><title>2020 第19周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/05/08/2020-%E7%AC%AC19%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 08 May 2020 07:48:12 +0000</pubDate><guid>https://zdyxry.github.io/2020/05/08/2020-%E7%AC%AC19%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1436. Destination City 链接到标题 使用 set() 来计算每个城市是否处于起始和终止，集合差为终点站。
class Solution: def destCity(self, paths: List[List[str]]) -&amp;gt; str: a = set() b = set() for path in paths: x, y = path a.add(x) b.add(y) b = b - a assert len(b) == 1 return b.pop() 1432. Max Difference You Can Get From Changing an Integer 链接到标题 分别求出给定数字可以转换的最大值和最小值，然后求差，最大值是将数字从前向后遍历，当数值不为9时，将其替换为 9；最小值要求首位不能为 0，则需要特殊判断，如果首位不为1，则将其替换为1，如果首位为1，则遍历后续数字，如果数字不为0，则替换为0，需要注意此时首位为1，如果数字为1然后替换为0会出现首位为0 情况，因此需要判断数字不为0且不为1，然后替换为 0。
class Solution: def maxDiff(self, num: int) -&amp;gt; int: a = b = str(num) for digit in a: if digit !</description></item><item><title>2020 第18周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/05/01/2020-%E7%AC%AC18%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 01 May 2020 06:43:57 +0000</pubDate><guid>https://zdyxry.github.io/2020/05/01/2020-%E7%AC%AC18%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1422. Maximum Score After Splitting a String 链接到标题 求出左侧 0 数量和右侧 1 数量之和最多的情况，遍历一次，每次更新最大值，注意要保证字符串始终被切分为 2 个子字符串。
class Solution: def maxScore(self, s: str) -&amp;gt; int: right = s.count(&amp;#39;1&amp;#39;) left = 0 score = 0 for idx in range(len(s) - 1): if s[idx] == &amp;#39;1&amp;#39;: score = max(score, (left + right - 1)) right -= 1 else: score = max(score, (left + 1 + right)) left += 1 return score 1423. Maximum Points You Can Obtain from Cards 链接到标题 先假设所有的数字都是从左侧获取的，然后依次遍历 k 个数值，每次遍历将左侧数字剔除，将右侧数字加入，比较最大值。</description></item><item><title>2020 第17周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/04/24/2020-%E7%AC%AC17%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 24 Apr 2020 20:47:03 +0000</pubDate><guid>https://zdyxry.github.io/2020/04/24/2020-%E7%AC%AC17%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1417. Reformat The String 链接到标题 重新格式化字符串，使得字母与数字交叉连接，先分别找出字母与数据，使用 zip_longest 来生成交叉后的元组，然后拼接得到目标字符串。
class Solution: def reformat(self, s: str) -&amp;gt; str: a=re.findall(r&amp;#39;\d&amp;#39;,s) b=re.findall(r&amp;#39;[a-z]&amp;#39;,s) if abs(len(a)-len(b))&amp;gt;1: return &amp;#39;&amp;#39; a,b=sorted([a,b],key=len) return &amp;#39;&amp;#39;.join(map(&amp;#39;&amp;#39;.join,itertools.zip_longest(b,a,fillvalue=&amp;#39;&amp;#39;))) 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K 链接到标题 参考：https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/tan-xin-jian-dan-zheng-ming-by-wyjoutstanding/
判定性：保证K一定能由斐波那契数组成，数据归纳法可证明
最小性：什么样的组合能最短？
相邻合并：2个相邻的数可合并为二者的和，长度-1，因为f(n)=f(n-1)+f(n-2)。满足该条件的组合必定是间隔出现，但是又可能重现重复的值，这对于编程很不利。 重值转换：两个相同的值一定可以转换为两个不同的值，因为f(n)+f(n)=f(n)+f(n-1)+f(n-2)=f(n+1)+f(n-2)，一个比f(n)大，一个更小，这是等价转换，不会减小组合长度，但是会带来一个很好的性质，即单调递增性质。 因此，重复使用以上两个操作后的组合数列，必定是一个无相邻值的递增数列，由于数列均为正数且和为K，因此值越大个数自然越小。
问：
那会不会出现一种情况呢，就是如果减去最大的斐波那契数的话，剩下的数只能拆分成两个斐波那契数，而如果减去第二大的斐波那契数或者更小的斐波那契数的话，剩下的数刚好是斐波那契数？
答：
可用反证法，假设总和为k，且f(m-1)&amp;lt;k&amp;lt;f(m)
那么对应你的第一种情况是k=f(m-1)+f(i)+f(j)，1&amp;lt;=f(i),f(j)&amp;lt;=f(m-2)；
对应你的第二种情况是k=f(m-2)+f(l)，其中,1&amp;lt;=f(l)&amp;lt;=f(m-3)。
假设你说的情况成立，那么以上两个等式必定相等，即f(m-1)+f(i)+f(j)=f(m-2)+f(l)，
因为f(m-1) = f(m-2) + f(m-3), f(l)&amp;lt;=f(m-3)，而f(i)和f(j)均不可能为0，因此等式不可能成立。
（左侧恒大于右侧，只有消去f(i)和f(j)才有可能取等）
当第二个等式的f(m-2)取更小值时更不可能成立。因此，推翻假设。
class Solution: def findMinFibonacciNumbers(self, k: int) -&amp;gt; int: ls=self.fib(k) res=0 while k: if k&amp;gt;=ls[-1]: k-=ls[-1] res+=1 else: ls.</description></item><item><title>2020 第16周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/04/18/2020-%E7%AC%AC16%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Sat, 18 Apr 2020 05:34:09 +0000</pubDate><guid>https://zdyxry.github.io/2020/04/18/2020-%E7%AC%AC16%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1408. String Matching in an Array 链接到标题 先按照单词长度进行排序，然后遍历判断当前单词是否被其他单词包含，要注意最终结果应该是去重之后的。
Golang 中可以直接使用 strings.Contains 判断。
type ByLen []string func (a ByLen) Len() int { return len(a) } func (a ByLen) Less(i, j int) bool { return len(a[i]) &amp;lt; len(a[j]) } func (a ByLen) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func stringMatching(words []string) []string { sort.Sort(ByLen(words)) res := []string{} for i := range words { for j := i + 1; j &amp;lt; len(words); j++ { if strings.</description></item><item><title>2020 第15周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/04/10/2020-%E7%AC%AC15%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 10 Apr 2020 20:44:44 +0000</pubDate><guid>https://zdyxry.github.io/2020/04/10/2020-%E7%AC%AC15%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1403. Minimum Subsequence in Non-Increasing Order 链接到标题 对数组进行排序，然后依次取出当前最大值，比较当前取出数值和与剩余数值和，如果大于，则返回取出数字。
class Solution: def minSubsequence(self, nums: List[int]) -&amp;gt; List[int]: N = len(nums) total = sum(nums) nums.sort() ret = [] t = 0 while True: x = nums.pop() t += x ret.append(x) if t * 2 &amp;gt; total: return ret 1400. Construct K Palindrome Strings 链接到标题 构造指定个数的回文字符串，检查出现次数为奇数的字母次数是否超过了k即可。可以直接用 Counter 计算。
class Solution: def canConstruct(self, s: str, k: int) -&amp;gt; bool: digit_count = {} if len(s) &amp;lt; k: return False elif len(s) == k: return True else: odd = 0 for i in set(s): digit_count[i] = s.</description></item><item><title>2020 第14周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/04/03/2020-%E7%AC%AC14%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 03 Apr 2020 21:49:38 +0000</pubDate><guid>https://zdyxry.github.io/2020/04/03/2020-%E7%AC%AC14%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1394. Find Lucky Integer in an Array 链接到标题 找幸运数字，可以维护一个数组，然后统计出现过的次数，也可以直接使用 collections.Counter 实现。
class Solution(object): def findLucky(self, arr): &amp;#34;&amp;#34;&amp;#34; :type arr: List[int] :rtype: int &amp;#34;&amp;#34;&amp;#34; cnt = [0] * 501 for a in arr: cnt[a] += 1 for i in range(500, 0, -1): if cnt[i] == i: return i return -1 1395. Count Number of Teams 链接到标题 遍历数组，假设当前数值是中间位置，因为要考虑到倒序排序，所以要找到左边比当前数值小的和比当前数值大的，找到右边比当前数值小的和比当前数值大的，然后进行排列组合。
class Solution(object): def numTeams(self, rating): &amp;#34;&amp;#34;&amp;#34; :type rating: List[int] :rtype: int &amp;#34;&amp;#34;&amp;#34; n = len(rating) ans = 0 for i in range(1,n-1): l1,r1= 0,0 l2,r2 =0,0 for j in range(i-1,-1,-1): if rating[j] &amp;lt; rating[i]: l1 += 1 else: l2 += 1 for j in range(i+1,n): if rating[j] &amp;gt; rating[i]: r1 += 1 else: r2 += 1 ans += l1*r1 + l2*r2 return ans 1396.</description></item><item><title>2020 第13周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/03/27/2020-%E7%AC%AC13%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 27 Mar 2020 22:27:32 +0000</pubDate><guid>https://zdyxry.github.io/2020/03/27/2020-%E7%AC%AC13%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1387. Sort Integers by The Power Value 链接到标题 给定一个区间，让你求出这个区间内所有数字的权重，然后按照权重进行排序，权重计算方式为：
如果 x 是偶数，那么 x = x / 2 如果 x 是奇数，那么 x = 3 * x + 1 在计算过程中，肯定会有重复计算，所以使用 dict 记录已经计算过的数值权重。当计算完成后，对结果进行排序，优先使用权重排序，如果权重相同，则按照数值本身大小进行排序，取第 k 个。
class Solution(object): def getKth(self, lo, hi, k): &amp;#34;&amp;#34;&amp;#34; :type lo: int :type hi: int :type k: int :rtype: int &amp;#34;&amp;#34;&amp;#34; self.memo = {} def helper(n): if n==1: return 0 if n in self.memo: return self.memo[n] if n%2: ans=helper((n*3+1)/2)+2 else: ans=helper(n/2)+1 self.</description></item><item><title>2020 第12周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/03/20/2020-%E7%AC%AC12%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 20 Mar 2020 20:08:24 +0000</pubDate><guid>https://zdyxry.github.io/2020/03/20/2020-%E7%AC%AC12%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1380. Lucky Numbers in a Matrix 链接到标题 给一个二维数组，分别求每行最小值，每列最大值，然后找到幸运数字。（遇到二维数组善用 zip 来解决
class Solution(object): def luckyNumbers (self, matrix): &amp;#34;&amp;#34;&amp;#34; :type matrix: List[List[int]] :rtype: List[int] &amp;#34;&amp;#34;&amp;#34; mins = {min(rows) for rows in matrix} maxes = {max(columns) for columns in zip(*matrix)} return list(mins &amp;amp; maxes) 1381. Design a Stack With Increment Operation 链接到标题 相比与 stack 多了一个 inc 操作，一般想法是每次遇到 inc 操作，那么我们遍历一次，将对应值进行加操作就可以了，但是这个操作是 O(n) 的，我们可以使用一个辅助 list ，保存 inc 的数值，当 pop 的时候，进行相加处理。
以示例展示处理过程：
[&amp;#34;CustomStack&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;pop&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;push&amp;#34;,&amp;#34;increment&amp;#34;,&amp;#34;increment&amp;#34;,&amp;#34;pop&amp;#34;,&amp;#34;pop&amp;#34;,&amp;#34;pop&amp;#34;,&amp;#34;pop&amp;#34;] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] stack, inc [1], [0] [1,2], [0] [1], [0] [1,2], [0,0] [1,2,3], [0,0,0] [1,2,3], [0,0, 100] [1,2,3], [0, 100, 100] [1,2], [0,200] [1], [200] class CustomStack(object): def __init__(self, maxSize): self.</description></item><item><title>2020 第11周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/03/13/2020-%E7%AC%AC11%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 13 Mar 2020 21:09:45 +0000</pubDate><guid>https://zdyxry.github.io/2020/03/13/2020-%E7%AC%AC11%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1370. Increasing Decreasing String 链接到标题 题目描述很复杂，但其实就是排序和字典，先顺序遍历再反向遍历。（熟练使用 Counter）
Python 链接到标题 class Solution(object): def sortString(self, s): &amp;#34;&amp;#34;&amp;#34; :type s: str :rtype: str &amp;#34;&amp;#34;&amp;#34; set_s = set() for c in s: set_s.add(c) characters = sorted(set_s) d = collections.Counter(s) res = &amp;#34;&amp;#34; while sum(d.values()) != 0: for c in characters: if c in s and d[c] &amp;gt; 0: res += c d[c] -= 1 for c in characters[::-1]: if c in s and d[c] &amp;gt; 0: res += c d[c] -= 1 return res Golang 链接到标题 func sortString(s string) string { sMap := make(map[string]int, len(s)) for _, c := range s { sMap[string(c)]++ } chars := []string{} for c, _ := range sMap { chars = append(chars, string(c)) } sort.</description></item><item><title>2020 第10周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/03/06/2020-%E7%AC%AC10%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 06 Mar 2020 21:10:06 +0000</pubDate><guid>https://zdyxry.github.io/2020/03/06/2020-%E7%AC%AC10%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1365. How Many Numbers Are Smaller Than the Current Number 链接到标题 对数组升序排序，遍历排序后数组，判断是否与前一数字相同，若相同则该数字结果与前一结果相同，否则为当前索引。
class Solution(object): def smallerNumbersThanCurrent(self, nums): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :rtype: List[int] &amp;#34;&amp;#34;&amp;#34; nums2 = sorted(nums) mapping = {} for i, num in enumerate(nums2): if i &amp;gt; 0 and nums2[i] == nums2[i-1]: mapping[nums2[i]] = mapping[nums2[i-1]] else: mapping[nums2[i]] = i res = [] for num in nums: res.append(mapping[num]) return res 1366. Rank Teams by Votes 链接到标题 考察排序，通过 dict 或者 list 统计所有字母的投票数值，然后进行排序，优先按照票数排序，如果票数相同，则按照字母序排序。</description></item><item><title>2020 第9周 LeetCode 记录</title><link>https://zdyxry.github.io/2020/02/28/2020-%E7%AC%AC9%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 28 Feb 2020 19:35:45 +0000</pubDate><guid>https://zdyxry.github.io/2020/02/28/2020-%E7%AC%AC9%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/</guid><description>1300. Sum of Mutated Array Closest to Target 链接到标题 对 arr 进行降序排序，将 arr 中的最小值乘以 arr 长度与 target比较，若比 target 小，则将其丢弃，并将其从 target 中减去。 若 arr 为空，则表示 arr 中最大值乘以 arr 长度仍比 target 小，则返回 arr 中的最大值。 若 arr 不为空，则表示 arr 中存在大于目标值的数值，取 target 除以此时 arr 长度（arr 中所有数值均大于目标值），最终值四舍五入得到目标值。
class Solution(object): def findBestValue(self, arr, target): &amp;#34;&amp;#34;&amp;#34; :type arr: List[int] :type target: int :rtype: int &amp;#34;&amp;#34;&amp;#34; arr.sort(reverse = True) while arr and target &amp;gt;= arr[-1]*len(arr): temp = arr[-1] target -= arr.</description></item></channel></rss>