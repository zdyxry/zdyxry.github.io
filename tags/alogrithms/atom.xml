<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>alogrithms on Yiran's Blog</title><link>https://zdyxry.github.io/tags/alogrithms/</link><description>Recent content in alogrithms on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 11 May 2019 20:17:57 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/alogrithms/atom.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode Shell 题解</title><link>https://zdyxry.github.io/2019/05/11/LeetCode-Shell-%E9%A2%98%E8%A7%A3/</link><pubDate>Sat, 11 May 2019 20:17:57 +0000</pubDate><guid>https://zdyxry.github.io/2019/05/11/LeetCode-Shell-%E9%A2%98%E8%A7%A3/</guid><description>工作上用 Shell 的频率是很高的，哪怕现在有了 Ansible 或者其他配置工具，Shell 仍是一个以 Linux 作为工作环境的同学的必备技能。 之前写过 GitHub 上的 Pure Bash Bible 的博客，看到 LeetCode 上的 Shell 题目好久不更新了，只有 4 道，今天记录一下题解。
192. Word Frequency 链接到标题 统计文本文件中单词出现次数，倒序输出。
words.txt
the day is sunny the the the sunny is is 利用 tr sort uniq awk 解决。
# Read from the file words.txt and output the word frequency list to stdout. cat words.txt | tr -s &amp;#39; &amp;#39; &amp;#39;\n&amp;#39; | sort | uniq -c | sort -rn | awk &amp;#39;{ print $2, $1 }&amp;#39; 193.</description></item><item><title>剑指-Offer（七）</title><link>https://zdyxry.github.io/2018/12/15/%E5%89%91%E6%8C%87-Offer%E4%B8%83/</link><pubDate>Sat, 15 Dec 2018 08:44:06 +0000</pubDate><guid>https://zdyxry.github.io/2018/12/15/%E5%89%91%E6%8C%87-Offer%E4%B8%83/</guid><description>反转链表 链接到标题 class ListNode(object): def __init__(self, x): self.val = x self.next = None def reverse_list(list_head): if not list_head or not list_head.next: return list_head reverse_node = None node_pre = None node = list_head while node: node_next = node.next if node_next == None: reverse_node = node node.next = node_pre node_pre = node node = node_next return reverse_node node1 = ListNode(10) node2 = ListNode(11) node3 = ListNode(13) node1.next = node2 node2.next = node3 reverse_list(node1) 合并两个排序的链表 链接到标题 class ListNode(object): def __init__(self, x): self.</description></item><item><title>剑指 Offer（六）</title><link>https://zdyxry.github.io/2018/12/06/%E5%89%91%E6%8C%87-Offer%E5%85%AD/</link><pubDate>Thu, 06 Dec 2018 22:34:54 +0000</pubDate><guid>https://zdyxry.github.io/2018/12/06/%E5%89%91%E6%8C%87-Offer%E5%85%AD/</guid><description>链表中倒数第k个结点 链接到标题 # 使用两个指针，a 先遍历 k-1，之后一起遍历，直到a 指针到最后一个节点，则 b 为倒数 k 节点 class ListNode(object): def __init__(self, x): self.val = x self.next = None class Solution: def find_k_to_tail(self, head, k): if not head and k &amp;lt;= 0: return None a_head = head b_head = None for i in range(k - 1): if a_head.next != None: a_head = a_head.next else: return None b_head = head while a_head.next != None: a_head = a_head.next b_head = b_head.</description></item><item><title>剑指 Offer（五）</title><link>https://zdyxry.github.io/2018/12/05/%E5%89%91%E6%8C%87-Offer%E4%BA%94/</link><pubDate>Wed, 05 Dec 2018 20:25:38 +0000</pubDate><guid>https://zdyxry.github.io/2018/12/05/%E5%89%91%E6%8C%87-Offer%E4%BA%94/</guid><description> 调整数组顺序使奇数位于偶数前面 链接到标题 def reorder(nums, func): left, right = 0, len(nums) - 1 while left &amp;lt; right: while not func(nums[left]): left += 1 while func(nums[right]): right -= 1 if left &amp;lt; right: nums[left], nums[right] = nums[right], nums[left] def is_even(num): return (num &amp;amp; 1) == 0 调整数组顺序使奇数位于偶数前面，保持相对位置不变 链接到标题 def reorder2(nums): left = [num for num in nums if num &amp;amp; 1 != 0] right = [num for num in nums if num &amp;amp; 1 == 0] return left + right nums = [1,2,3,4,5,6,7] print reorder2(nums)</description></item><item><title>剑指 Offer（四）</title><link>https://zdyxry.github.io/2018/12/02/%E5%89%91%E6%8C%87-Offer%E5%9B%9B/</link><pubDate>Sun, 02 Dec 2018 20:11:24 +0000</pubDate><guid>https://zdyxry.github.io/2018/12/02/%E5%89%91%E6%8C%87-Offer%E5%9B%9B/</guid><description>在O(1)时间内删除链表结点 链接到标题 class ListNode(object): def __init__(self, x=None): self.val = x self.next = None def __del__(self): self.val = None self.next = None class Solution(object): def delete_list(self, list_head, to_delete): if not list_head or not to_delete: return False if to_delete.next != None: next_node = to_delete.next to_delete.val = next_node.val to_delete.next = next_node.next next_node.__del__() elif list_head == to_delete: list_head.__del__() to_delete.__del__() else: list_node = list_head while list_node.next != to_delete: list_node = list_node.next list_node.next = None to_delete.</description></item><item><title>剑指 Offer（三）</title><link>https://zdyxry.github.io/2018/11/25/%E5%89%91%E6%8C%87-Offer%E4%B8%89/</link><pubDate>Sun, 25 Nov 2018 10:29:46 +0000</pubDate><guid>https://zdyxry.github.io/2018/11/25/%E5%89%91%E6%8C%87-Offer%E4%B8%89/</guid><description> 打印1到最大的n位数 链接到标题 # 将数组转换为字符 def print_number(number): is_beginning_0 = True num_len = len(number) for i in range(num_len): if is_beginning_0 and number[i] != &amp;#34;0&amp;#34;: is_beginning_0 = False if not is_beginning_0: print(&amp;#34;%c&amp;#34; % number[i], end=&amp;#34;&amp;#34;) print(&amp;#34;&amp;#34;) # 边界条件：n &amp;gt; 0 def print_1_to_max_of_n1(n): if n &amp;lt;= 0: return number = [&amp;#34;0&amp;#34;] * n while not increment(number): print_number(number) # 从最后一位开始计算，如果 最后一位增长为10，则重置为 0，且进位；如果首位增长为 10，则溢出 def increment(number): is_carry = 0 is_overflow = False sum = 0 num_len = len(number) for i in range(num_len - 1, -1, -1): sum = int(number[i]) + is_carry if i == num_len - 1: sum += 1 if sum &amp;gt;= 10: if i == 0: is_overflow = True else: sum -= 10 number[i] = str(sum) is_carry = 1 else: number[i] = str(sum) break return is_overflow def print_1_to_max_of_n2(n): if n &amp;lt;= 0: return number = [&amp;#34;0&amp;#34;] * n for i in range(10): number[0] = str(i) print_1_to_max_of_n_recursively(number, n, 0) # 始终找到最后一位，并将其计算 def print_1_to_max_of_n_recursively(number, num_len, index): if index == num_len - 1: print_number(number) return for i in range(10): number[index + 1] = str(i) print_1_to_max_of_n_recursively(number, num_len, index +1) print_number([&amp;#34;0&amp;#34;, &amp;#34;1&amp;#34;, &amp;#34;1&amp;#34;]) print_1_to_max_of_n1(2) print_1_to_max_of_n2(2)</description></item><item><title>剑指 Offer（二）</title><link>https://zdyxry.github.io/2018/11/20/%E5%89%91%E6%8C%87-Offer%E4%BA%8C/</link><pubDate>Tue, 20 Nov 2018 21:08:14 +0000</pubDate><guid>https://zdyxry.github.io/2018/11/20/%E5%89%91%E6%8C%87-Offer%E4%BA%8C/</guid><description> 数值的整数次方 链接到标题 # 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 # 考虑边界情况，base = 0, exponent &amp;lt; 0, exponent = 0 场景。 def equal_zero(num): if abs(num - 0.0) &amp;lt; 0.0000001: return True def power(base, exponent): if equal_zero(base): result = False if exponent == 0: result = 1 result = power(base, abs(exponent) &amp;gt;&amp;gt; 1) result *= result if abs(exponent) &amp;amp; 1 == 1: result *= base if exponent &amp;lt; 0: result = 1.0 / result return result power_value(2, 2)</description></item><item><title>剑指 Offer（一）</title><link>https://zdyxry.github.io/2018/11/18/%E5%89%91%E6%8C%87-Offer%E4%B8%80/</link><pubDate>Sun, 18 Nov 2018 12:23:07 +0000</pubDate><guid>https://zdyxry.github.io/2018/11/18/%E5%89%91%E6%8C%87-Offer%E4%B8%80/</guid><description>Python 单实例模式 链接到标题 class Singleton(object): _instances = {} def __new__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls._instances[cls] class MySingleton(Singleton): def __init__(self, val): self.val = val a = MySingleton(1) b = MySingleton(1) print a.val print b.val 二维数组查找 链接到标题 def find_num(matrix, num): if not matrix: return False rows = len(matrix) cols = len(matrix[0]) row, col = rows - 1, 0 while row &amp;gt;= 0 or col &amp;lt;= cols -1: if matrix[row][col] == num: return num elif matrix[row][col] &amp;gt; num: row -= 1 else: col += 1 return False matrix = [[1,2,3,4], [5,6,7,8] ] print find_num(matrix, 7) 打印链表 链接到标题 class Links(self): def __init__(self, x): self.</description></item></channel></rss>