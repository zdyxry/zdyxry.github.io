<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ansible on Yiran's Blog</title><link>https://zdyxry.github.io/tags/Ansible/</link><description>Recent content in Ansible on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 22 Nov 2019 20:15:17 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/Ansible/atom.xml" rel="self" type="application/rss+xml"/><item><title>使用 Ansible 传输文件的几种方式</title><link>https://zdyxry.github.io/2019/11/22/%E4%BD%BF%E7%94%A8-Ansible-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link><pubDate>Fri, 22 Nov 2019 20:15:17 +0000</pubDate><guid>https://zdyxry.github.io/2019/11/22/%E4%BD%BF%E7%94%A8-Ansible-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid><description>背景 链接到标题 Ansible 作为一款配置管理和应用部署的软件，日常使用的场景很多，我自己也是重度用户。最近在使用 Ansible 进行文件传输的时候踩了个坑，借此机会整理下 Ansible 传输文件的几种方式。
实验环境：
[root@yiran ~]# ansible --version ansible 2.7.12 config file = None configured module search path = [u&amp;#39;/root/.ansible/plugins/modules&amp;#39;, u&amp;#39;/usr/share/ansible/plugins/modules&amp;#39;] ansible python module location = /usr/lib/python2.7/site-packages/ansible executable location = /usr/bin/ansible python version = 2.7.5 (default, Aug 7 2019, 00:51:29) [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] Template 链接到标题 https://docs.ansible.com/ansible/latest/modules/template_module.html
Ansible 一个常用的功能就是配置管理，通过 Ansible 批量分发配置文件，达到统一版本管理的效果，如果我们想要进行少量的文件传输，从控制节点传输到被管理节点，那么可以采用这种方式来完成。
具体的使用官方文档 已经讲的很详细了，这里不再啰嗦。
因为版本是通过 Jinja2 模板传输，支持模板渲染 虽然我们可以在模版中不制定任何参数，直接将其拷贝，但是相比 Copy/Fetch 模块还是需要有模版渲染的一步，速度要慢一些
Copy/Fetch 模块 链接到标题 https://docs.</description></item><item><title>关于Ansible的一点经验</title><link>https://zdyxry.github.io/2019/07/05/%E5%85%B3%E4%BA%8EAnsible%E7%9A%84%E4%B8%80%E7%82%B9%E7%BB%8F%E9%AA%8C/</link><pubDate>Fri, 05 Jul 2019 20:55:19 +0000</pubDate><guid>https://zdyxry.github.io/2019/07/05/%E5%85%B3%E4%BA%8EAnsible%E7%9A%84%E4%B8%80%E7%82%B9%E7%BB%8F%E9%AA%8C/</guid><description>背景 链接到标题 先介绍下 Kubespray，Kubespray 是 K8S SIG 下的项目，目标是帮助用户创建 生产环境级别 的 k8s 集群。
是通过 Ansible Playbook 实现的，是的，这又是一个 Ansible 项目，其中 YAML 文件就有 15k 行，名副其实的大项目。
花费了几天时间陆陆续续看完了整个项目，大概了解了其中的工作流程，具体内容不提，感觉 Ansible 90% 的使用例子都可以在这个项目中找到，是一个值得阅读的项目。
之前写过一篇当时理解的最佳实践，今天趁此机会再总结下最近使用 Ansible 的一些经验。
Tag 链接到标题 使用 tag 对 ansible task 进行划分，比如在重启某些服务的时候，我们只希望在初次安装的时候重启，在后续升级的时候不进行重启，那么我们就可以对这个重启服务的 task 进行tag 区分。
tag 使用示例如下：
[root@node111 16:35:56 ansible]$tree . . ├── ansible.cfg ├── inventory ├── templates │ └── src.j2 └── test.yaml 1 directory, 4 files [root@node111 16:35:58 ansible]$cat test.yaml - hosts: cluster gather_facts: no become: yes become_user: root become_method: sudo tasks: - yum: name: &amp;#34;{{ item }}&amp;#34; state: present loop: - httpd - memcached tags: - packages - template: src: templates/src.</description></item><item><title>PingCAP tidb-ansible 源码阅读</title><link>https://zdyxry.github.io/2019/04/20/PingCAP-tidb-ansible-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Sat, 20 Apr 2019 11:50:41 +0000</pubDate><guid>https://zdyxry.github.io/2019/04/20/PingCAP-tidb-ansible-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>了解我的同学应该知道，我目前负责公司产品的运维工具开发相关的工作，作为一款 2B 的产品，在产品运维过程中，总是有一些不愉快（又不能让客户知道）的繁琐操作：这些操作可能是为了防止过程中出现错误，而不断添加的检测条件；也有可能是历史问题，随着产品发布迭代而一直遗留至今。
所以我平时也在关注一些开源的 2B 产品的配套运维工具，比如 ZStack、PingCAP 之类的公司。
但是 ZStack 的开源生态不是很好，感觉只是在保持代码更新（不知道哪个分支）的状态。相比之下 PingCAP 就好很多了，可以很直接的从文档中看到差别，而且社区很活跃。
最近看到 PingCAP 的一个关于部署维护的 视频讲解 ，可能时间有限，并没有很深入的讲解细节，有兴趣的同学可以看下。
在讲解过程中，一个比较核心的工具就是 Ansible，通过 Ansible Playbook 来定义各个步骤，我最近也在使用 Ansible 来进行二次开发，特此学习下 PingCAP 的 tidb-ansible 。
安装方式 链接到标题 TiDB 目前支持 4 种安装方式：
Ansible Online Ansible Offline Docker Docker compose 其中最佳实践应该是 Ansible Online 方式，通过控制机联网下载所需依赖及 TiDB binary 文件。当然如果所在环境无法访问互联网，那么只能采用 Offline 方式了。后两种部署方式，感觉只是用于开发测试或者给用户“看看”的情况。
如果要学习的话肯定要学习最佳实践了，那么我们来看看 Ansible Online 方式。
环境准备 链接到标题 TiDB 作为一个 开源分布式关系型数据库 ，所需要的物理环境是很比较苛刻的，官方最佳实践的需求如下：
组件 CPU 内存 硬盘类型 网络 数量(最低要求) TiDB 16 32GB SAS 10GbE * 2 2 PD 4 8GB SSD 10 GbE * 2 3 TiKV 16 32GB SSD 10 GbE * 2 3 监控 8 16GB SAS 1GbE * 1 1 对于 CPU、内存和磁盘的要求我们暂时忽略，这里注意网卡数量都是推荐的 2 块网卡，应该是会做 bonding，到时候看下代码中是否处理。</description></item><item><title>Ansible最佳实践</title><link>https://zdyxry.github.io/2018/11/24/Ansible%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 24 Nov 2018 21:18:28 +0000</pubDate><guid>https://zdyxry.github.io/2018/11/24/Ansible%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>背景 链接到标题 说起来我真正负责过大批量服务器线上管理的时间，还是在16年负责运维的时候，那时候还都是通过 Shell 脚本来完成一些自动化的工作，当时觉得还不错，至少我觉得可定制化上还是很好的。
目前负责公司产品中一部分功能目前是通过 Shell 来完成的，但是 Shell 脚本在使用中存在一些弊端，最近在用 Ansible 来重写这部分功能，在重写过程中感受负责，又爱又恨，也有一些疑惑，特此记录。
Ansible 链接到标题 相信大家都或多或少听过 Ansible,Puppet,SaltStack 等等自动管理工具，它们的功能都很强大，但使用起来又不简单，Ansible 可以说是这里面上手最快的一个。
这里我不讲述 Ansible 具体的使用规则，大家看文档就好，我讲下我常用的几个场景：
批量查看、操作、拷贝 链接到标题 无论是作为一名开发，还是测试、运维，应该都碰到过需要管理多台服务器的情况，比如我们想要查看一个集群中所有节点的负责情况，那么我们可以执行：
$ ansible yiran-cluster -m raw -a &amp;#39;uptime&amp;#39; 192.168.67.39 | SUCCESS | rc=0 &amp;gt;&amp;gt; 20:23:24 up 3 days, 7:32, 4 users, load average: 14.97, 13.81, 12.55 Shared connection to 192.168.67.39 closed. 192.168.67.40 | SUCCESS | rc=0 &amp;gt;&amp;gt; 20:23:24 up 3 days, 7:32, 1 user, load average: 11.</description></item><item><title>Ansible 配置 IPv6 连接</title><link>https://zdyxry.github.io/2018/08/17/Ansible-%E9%85%8D%E7%BD%AE-IPv6-%E8%BF%9E%E6%8E%A5/</link><pubDate>Fri, 17 Aug 2018 13:43:40 +0000</pubDate><guid>https://zdyxry.github.io/2018/08/17/Ansible-%E9%85%8D%E7%BD%AE-IPv6-%E8%BF%9E%E6%8E%A5/</guid><description>背景 链接到标题 平时工作中因为通常需要远程操作较多 Linux 环境，引入了 Ansible，但是大都是通过 Ansible 远程命令的方式执行，少数的封装为 Playbook 也是很简单的配置。 最早的时候用过简单的 SaltStack，但是要安装 Agent，觉得不好用，在 16年早期的时候使用 Ansible，简单快捷（当然我对性能没有要求）。 最近需要把之前由 Shell &amp;amp; Python 拼装的一个服务统一用 Ansible 进行重写，又花了些时间看了看相关文档。发现大家操作远程机器无论是通过秘钥还是通过密码，都是基于 IPv4 的地址链接的，而有些机器是没有 IPv4 地址的，于是花费了些时间验证 Ansible IPv6 配置方式。
IPv6 链接到标题 IPv6 维基百科的解释是：网际协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是网际协议（IP）的最新版本，用作互联网的网络层协议，用它来取代IPv4主要是为了解决IPv4地址枯竭问题，不过它也在其他很多方面对IPv4有所改进。我们目前日常中使用的地址都是 IPv4 的地址（比如：192.168.1.1）。 使用 IPv6 有一个好处是，可以通过 NDP（Neighbor Discovery Protocol）扫描二层网络内的所有的 IPv6 地址，方便我们使用，那么我们如何判断 IPv6 是否可以连通呢？ 可以通过 ping6 的方式判断，比如：
[root@node111 14:00:44 ~]$ping6 fe80::2487:93ff:fe9a:c546%port-mgt PING fe80::2487:93ff:fe9a:c546%port-mgt(fe80::2487:93ff:fe9a:c546%port-mgt) 56 data bytes 64 bytes from fe80::2487:93ff:fe9a:c546%port-mgt: icmp_seq=1 ttl=64 time=0.443 ms 64 bytes from fe80::2487:93ff:fe9a:c546%port-mgt: icmp_seq=2 ttl=64 time=0.</description></item></channel></rss>