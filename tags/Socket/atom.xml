<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Socket on Yiran's Blog</title><link>https://zdyxry.github.io/tags/Socket/</link><description>Recent content in Socket on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 30 Sep 2018 20:33:00 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/Socket/atom.xml" rel="self" type="application/rss+xml"/><item><title>Python socket 编程</title><link>https://zdyxry.github.io/2018/09/30/Python-socket-%E7%BC%96%E7%A8%8B/</link><pubDate>Sun, 30 Sep 2018 20:33:00 +0000</pubDate><guid>https://zdyxry.github.io/2018/09/30/Python-socket-%E7%BC%96%E7%A8%8B/</guid><description>背景 链接到标题 平时工作很少涉及到 Socket 相关，基本上都是 HTTP 之上的业务，最近看到 Real Python 的一篇博客，非常详细的讲解了 Python 下的 socket 编程，其中有两个示例觉得很好，帮助我理解了一些要点，记录一下。
多连接情况 链接到标题 Server 链接到标题 multiconn-server.py
#!/usr/bin/env python3 import sys import socket import selectors import types sel = selectors.DefaultSelector() def accept_wrapper(sock): conn, addr = sock.accept() # 前提条件：可读状态 print(&amp;#39;accepted connection from&amp;#39;, addr) conn.setblocking(False) # 置为非阻塞 data = types.SimpleNamespace(addr=addr, inb=b&amp;#39;&amp;#39;, outb=b&amp;#39;&amp;#39;) events = selectors.EVENT_READ | selectors.EVENT_WRITE sel.register(conn, events, data=data) # 注册事件到 select def service_connection(key, mask): sock = key.fileobj data = key.</description></item></channel></rss>