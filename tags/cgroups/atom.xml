<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cgroups on Yiran's Blog</title><link>https://zdyxry.github.io/tags/cgroups/</link><description>Recent content in cgroups on Yiran's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 01 Jan 2021 18:28:00 +0000</lastBuildDate><atom:link href="https://zdyxry.github.io/tags/cgroups/atom.xml" rel="self" type="application/rss+xml"/><item><title>cgroups notification API demo</title><link>https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/</link><pubDate>Fri, 01 Jan 2021 18:28:00 +0000</pubDate><guid>https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/</guid><description>cgroups notification API demo Link to heading package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;golang.org/x/sys/unix&amp;#34; ) func main() { cgName := flag.String(&amp;#34;cgName&amp;#34;, &amp;#34;yiran&amp;#34;, &amp;#34;cgroup path&amp;#34;) flag.Parse() level := &amp;#34;critical&amp;#34; cgDir := filepath.Join(&amp;#34;/sys/fs/cgroup/memory/&amp;#34;, *cgName) evName := &amp;#34;memory.pressure_level&amp;#34; fmt.Printf(&amp;#34;cgroup name is: %s\n&amp;#34;, *cgName) fmt.Printf(&amp;#34;cgroup path is: %s\n&amp;#34;, cgDir) fmt.Printf(&amp;#34;cgroup event name is: %s\n&amp;#34;, evName) evFile, err := os.Open(filepath.Join(cgDir, evName)) if err != nil { panic(err) } fd, err := unix.</description></item><item><title>记一次 libcgroup 配置失败</title><link>https://zdyxry.github.io/2019/04/11/%E8%AE%B0%E4%B8%80%E6%AC%A1-libcgroup-%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/</link><pubDate>Thu, 11 Apr 2019 22:04:47 +0000</pubDate><guid>https://zdyxry.github.io/2019/04/11/%E8%AE%B0%E4%B8%80%E6%AC%A1-libcgroup-%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/</guid><description>cgroup 配置失败解决方案 Link to heading 看过之前博客的同学应该知道，我一直使用的 libcgroup 来进行 cgroup 配置，简单方便。 最近遇到了一个报错，很坑，记录一下。
报错 Link to heading 接到反馈说有个环境在产品升级之后， cgconfig.service 无法启动，当时的配置如下：
[root@yiran-test 21:31:59 ~]$cat /etc/cgconfig.conf # yiran cgroups configuration group . { cpuset { cpuset.memory_pressure_enabled = &amp;#34;1&amp;#34;; } } group yiran { cpuset { cpuset.cpus = &amp;#34;0,1,2,3,4,5&amp;#34;; cpuset.mems = &amp;#34;0-1&amp;#34;; cpuset.cpu_exclusive = &amp;#34;1&amp;#34;; cpuset.mem_hardwall = &amp;#34;1&amp;#34;; } } group yiran/bb-main { cpuset { cpuset.cpus = &amp;#34;0&amp;#34;; cpuset.mems = &amp;#34;0-1&amp;#34;; cpuset.cpu_exclusive = &amp;#34;1&amp;#34;; cpuset.</description></item><item><title>cgroups 常用配置</title><link>https://zdyxry.github.io/2018/09/23/cgroups-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 23 Sep 2018 11:40:19 +0000</pubDate><guid>https://zdyxry.github.io/2018/09/23/cgroups-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</guid><description>背景 Link to heading 在软件运行过程中，我们经常需要限制 CPU 、内存、磁盘的使用，方式程序超出了限定边界范围。在 Linux 中，我们可以通过 cgroups 来进行限制。
cgroups Link to heading 中文名称为控制组群，具体功能分类为：
资源限制：组可以被设置不超过设定的内存限制；这也包括虚拟内存。 优先级：一些组可能会得到大量的CPU或磁盘IO吞吐量。 结算：用来衡量系统确实把多少资源用到适合的目的上。 控制：冻结组或检查点和重启动。 下面来说下常见的使用方式
CPU Link to heading RedHat 官方文档中描述 cgroups 在 RHEL7/CentOS7 之后的版本需要通过 systemd 配置，不再使用 libcgconfig 方式。 但是在 systemd 的配置中，CPU 相关的配置项比较简单，或者说 OS 自动配置了很多，没有暴露出来。所以我们这里还是采用 libcgconfig 的配置方式。
在进行 CPU 限制之前，我们需要了解一下 NUMA 结构。什么是 NUMA？ NUMA 是一种为多处理器的计算机设计的内存，内存访问时间取决于内存相对于处理器的位置。在NUMA下，处理器访问它自己的本地内存的速度比非本地内存快一些。 不同的 Thread 在同一个 Core 上也会发生抢占情况，具体可以通过 sysbench 进行测试。
相关概念定义：
Socket：物理服务器上的 CPU 插槽 Core：物理 CPU 核心数 Thread：超线程 简单的说就是如果你的程序是计算密集型，那么尽可能的要让 CPU 限制在同一个 NUMA node 上。 查看 NUMA node 方式：</description></item></channel></rss>