<!doctype html><html lang=zh-cn><head><title>证书 CommonName 和 subjectAltName 的关系 · Yiran's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Yiran Zhou"><meta name=description content="背景 链接到标题 因为产品中的 HTTPS 所用证书是自签发证书，不满足一些场景的安全要求，需要导入用户证书。本身这个变更很容易，只需要按照Nginx 官方文档 配置下指定证书即可，但遇到了一个特殊的场景：集群存在3个节点，每个节点用户配置了相应的 Domain Name，其中集群中存在 VIP(Virtual IP Address) ，用户给对应的 VIP 配置了相应的 Domain Name。用户在签发证书时，使用的 CN(CommonName) 是 VIP 对应的 Domain Name，subjectAltName 是集群中3个节点的 Domain Name。此时如果通过各个节点相应的 Domain Name 访问，证书有效，但是通过 VIP 对应的 Domain Name 访问，证书无效（因环境特殊，未能看到具体错误提示）。
印象中 CommonName 必须指定对应的 Domain Name，subjectAltName 是 CommonName 的补充，所以这个现象感觉不合理，然后查阅了相关资料进行调查。
GPT4 链接到标题 在调查之前，按照现在的主流操作，遇事不决先问 GPT，于是得到了如下答复，也符合我的理解：
问：
在 https 证书中，如果 CommonName 一定存在于 SubjectAltName 中么？如果同时存在 CommonName 和 SubjectName ，使用哪个作为唯一标识校验？
答：
在HTTPS证书中，CommonName（CN）和Subject Alternative Name（SAN）是用于标识证书所表示的域名的字段。在早期的SSL/TLS证书中，CommonName通常用于表示证书关联的单个域名。然而，随着时间的推移，Subject Alternative Name扩展被广泛采用，它允许证书关联多个域名和子域名。
从技术上讲，CommonName不一定需要出现在Subject Alternative Name列表中。但是，实际上，许多现代浏览器和客户端会首先检查Subject Alternative Name字段，如果没有找到匹配的域名，才会检查CommonName字段。因此，为了确保证书的兼容性和正确性，建议将CommonName包含在Subject Alternative Name字段中。"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="证书 CommonName 和 subjectAltName 的关系"><meta name=twitter:description content="背景 链接到标题 因为产品中的 HTTPS 所用证书是自签发证书，不满足一些场景的安全要求，需要导入用户证书。本身这个变更很容易，只需要按照Nginx 官方文档 配置下指定证书即可，但遇到了一个特殊的场景：集群存在3个节点，每个节点用户配置了相应的 Domain Name，其中集群中存在 VIP(Virtual IP Address) ，用户给对应的 VIP 配置了相应的 Domain Name。用户在签发证书时，使用的 CN(CommonName) 是 VIP 对应的 Domain Name，subjectAltName 是集群中3个节点的 Domain Name。此时如果通过各个节点相应的 Domain Name 访问，证书有效，但是通过 VIP 对应的 Domain Name 访问，证书无效（因环境特殊，未能看到具体错误提示）。
印象中 CommonName 必须指定对应的 Domain Name，subjectAltName 是 CommonName 的补充，所以这个现象感觉不合理，然后查阅了相关资料进行调查。
GPT4 链接到标题 在调查之前，按照现在的主流操作，遇事不决先问 GPT，于是得到了如下答复，也符合我的理解：
问：
在 https 证书中，如果 CommonName 一定存在于 SubjectAltName 中么？如果同时存在 CommonName 和 SubjectName ，使用哪个作为唯一标识校验？
答：
在HTTPS证书中，CommonName（CN）和Subject Alternative Name（SAN）是用于标识证书所表示的域名的字段。在早期的SSL/TLS证书中，CommonName通常用于表示证书关联的单个域名。然而，随着时间的推移，Subject Alternative Name扩展被广泛采用，它允许证书关联多个域名和子域名。
从技术上讲，CommonName不一定需要出现在Subject Alternative Name列表中。但是，实际上，许多现代浏览器和客户端会首先检查Subject Alternative Name字段，如果没有找到匹配的域名，才会检查CommonName字段。因此，为了确保证书的兼容性和正确性，建议将CommonName包含在Subject Alternative Name字段中。"><meta property="og:title" content="证书 CommonName 和 subjectAltName 的关系"><meta property="og:description" content="背景 链接到标题 因为产品中的 HTTPS 所用证书是自签发证书，不满足一些场景的安全要求，需要导入用户证书。本身这个变更很容易，只需要按照Nginx 官方文档 配置下指定证书即可，但遇到了一个特殊的场景：集群存在3个节点，每个节点用户配置了相应的 Domain Name，其中集群中存在 VIP(Virtual IP Address) ，用户给对应的 VIP 配置了相应的 Domain Name。用户在签发证书时，使用的 CN(CommonName) 是 VIP 对应的 Domain Name，subjectAltName 是集群中3个节点的 Domain Name。此时如果通过各个节点相应的 Domain Name 访问，证书有效，但是通过 VIP 对应的 Domain Name 访问，证书无效（因环境特殊，未能看到具体错误提示）。
印象中 CommonName 必须指定对应的 Domain Name，subjectAltName 是 CommonName 的补充，所以这个现象感觉不合理，然后查阅了相关资料进行调查。
GPT4 链接到标题 在调查之前，按照现在的主流操作，遇事不决先问 GPT，于是得到了如下答复，也符合我的理解：
问：
在 https 证书中，如果 CommonName 一定存在于 SubjectAltName 中么？如果同时存在 CommonName 和 SubjectName ，使用哪个作为唯一标识校验？
答：
在HTTPS证书中，CommonName（CN）和Subject Alternative Name（SAN）是用于标识证书所表示的域名的字段。在早期的SSL/TLS证书中，CommonName通常用于表示证书关联的单个域名。然而，随着时间的推移，Subject Alternative Name扩展被广泛采用，它允许证书关联多个域名和子域名。
从技术上讲，CommonName不一定需要出现在Subject Alternative Name列表中。但是，实际上，许多现代浏览器和客户端会首先检查Subject Alternative Name字段，如果没有找到匹配的域名，才会检查CommonName字段。因此，为了确保证书的兼容性和正确性，建议将CommonName包含在Subject Alternative Name字段中。"><meta property="og:type" content="article"><meta property="og:url" content="https://zdyxry.github.io/2023/03/25/%E8%AF%81%E4%B9%A6-CommonName-%E5%92%8C-subjectAltName-%E7%9A%84%E5%85%B3%E7%B3%BB/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-25T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-25T00:00:00+00:00"><link rel=canonical href=https://zdyxry.github.io/2023/03/25/%E8%AF%81%E4%B9%A6-CommonName-%E5%92%8C-subjectAltName-%E7%9A%84%E5%85%B3%E7%B3%BB/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.76ce9bad7ac9bd368d486c6e91e7e0906fff71d9d35ccbf93959a375e2bf50e5.css integrity="sha256-ds6brXrJvTaNSGxukefgkG//cdnTXMv5OVmjdeK/UOU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.593028e7f7ac55c003b79c230d1cd411bb4ca53b31556c3abb7f027170e646e9.css integrity="sha256-WTAo5/esVcADt5wjDRzUEbtMpTsxVWw6u38CcXDmRuk=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/yiran.png sizes=32x32><link rel=icon type=image/png href=/images/yiran.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Yiran's Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/tags/>Tags</a></li><li class=navigation-item><a class=navigation-link href=/friends/>Friends</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://zdyxry.github.io/2023/03/25/%E8%AF%81%E4%B9%A6-CommonName-%E5%92%8C-subjectAltName-%E7%9A%84%E5%85%B3%E7%B3%BB/>证书 CommonName 和 subjectAltName 的关系</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-03-25T00:00:00Z>March 25, 2023</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：4 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/HTTPS/>HTTPS</a></span></div></div></header><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#gpt4>GPT4</a></li><li><a href=#rfc-调查>RFC 调查</a></li><li><a href=#浏览器支持调查>浏览器支持调查</a><ul><li><a href=#chrome>Chrome</a></li><li><a href=#firefox>Firefox</a></li></ul></li><li><a href=#结论>结论</a></li></ul></nav><div class=post-content><h2 id=背景>背景
<a class=heading-link href=#%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>因为产品中的 HTTPS 所用证书是自签发证书，不满足一些场景的安全要求，需要导入用户证书。本身这个变更很容易，只需要按照<a href=%5Bhttp://nginx.org/en/docs/http/configuring_https_servers.html%5D(http://nginx.org/en/docs/http/configuring_https_servers.html)>Nginx 官方文档</a> 配置下指定证书即可，但遇到了一个特殊的场景：集群存在3个节点，每个节点用户配置了相应的 Domain Name，其中集群中存在 VIP(Virtual IP Address) ，用户给对应的 VIP 配置了相应的 Domain Name。用户在签发证书时，使用的 CN(CommonName) 是 VIP 对应的 Domain Name，subjectAltName 是集群中3个节点的 Domain Name。此时如果通过各个节点相应的 Domain Name 访问，证书有效，但是通过 VIP 对应的 Domain Name 访问，证书无效（因环境特殊，未能看到具体错误提示）。</p><p>印象中 <code>CommonName</code> 必须指定对应的 Domain Name，<code>subjectAltName</code> 是 <code>CommonName</code> 的补充，所以这个现象感觉不合理，然后查阅了相关资料进行调查。</p><h2 id=gpt4>GPT4
<a class=heading-link href=#gpt4><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>在调查之前，按照现在的主流操作，遇事不决先问 GPT，于是得到了如下答复，也符合我的理解：</p><p>问：</p><blockquote><p>在 https 证书中，如果 <code>CommonName</code> 一定存在于 <code>SubjectAltName</code> 中么？如果同时存在 <code>CommonName</code> 和 <code>SubjectName</code> ，使用哪个作为唯一标识校验？</p></blockquote><p>答：</p><blockquote><p>在HTTPS证书中，<code>CommonName</code>（CN）和<code>Subject Alternative Name</code>（SAN）是用于标识证书所表示的域名的字段。在早期的SSL/TLS证书中，<code>CommonName</code>通常用于表示证书关联的单个域名。然而，随着时间的推移，<code>Subject Alternative Name</code>扩展被广泛采用，它允许证书关联多个域名和子域名。<br>从技术上讲，<code>CommonName</code>不一定需要出现在<code>Subject Alternative Name</code>列表中。但是，实际上，许多现代浏览器和客户端会首先检查<code>Subject Alternative Name</code>字段，如果没有找到匹配的域名，才会检查<code>CommonName</code>字段。因此，为了确保证书的兼容性和正确性，建议将<code>CommonName</code>包含在<code>Subject Alternative Name</code>字段中。<br>RFC 6125（表示和确认服务器标识的通用方法）建议在比较服务器标识时使用<code>Subject Alternative Name</code>，并认为<code>CommonName</code>已经过时。因此，如果<code>CommonName</code>和<code>Subject Alternative Name</code>同时存在，客户端应首先使用<code>Subject Alternative Name</code>进行匹配和校验。</p></blockquote><h2 id=rfc-调查>RFC 调查
<a class=heading-link href=#rfc-%e8%b0%83%e6%9f%a5><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>在 X509 的相关RFC <a href=https://www.rfc-editor.org/rfc/rfc2459>https://www.rfc-editor.org/rfc/rfc2459</a> ，<a href=https://www.rfc-editor.org/rfc/rfc3280>https://www.rfc-editor.org/rfc/rfc3280</a> 和 <a href=https://www.rfc-editor.org/rfc/rfc5280>https://www.rfc-editor.org/rfc/rfc5280</a> 定义中没有很多关于 CommonName 与 SubjectAltName 关系描述。</p><p>在 <a href=https://www.rfc-editor.org/rfc/rfc6125>https://www.rfc-editor.org/rfc/rfc6125</a> 中，关于两者的关系有如下描述：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>For TLS authentication with X.509 certificates, an identity from the
</span></span><span style=display:flex><span>DNS namespace MUST be checked against each subjectAltName extension
</span></span><span style=display:flex><span>of type dNSName present in the certificate.  If no such extension is
</span></span><span style=display:flex><span>present, then the identity MUST be compared to the (most specific)
</span></span><span style=display:flex><span>Common Name in the Subject field of the certificate.  When matching
</span></span><span style=display:flex><span>DNS names against dNSName or Common Name fields, matching is case-
</span></span><span style=display:flex><span>insensitive.  Also, a &#34;*&#34; wildcard character MAY be used as the left-
</span></span><span style=display:flex><span>most name component in the certificate or identity in the APD.  For
</span></span><span style=display:flex><span>example, *.example.com in the APD would match certificates for
</span></span><span style=display:flex><span>a.example.com, foo.example.com, *.example.com, etc., but would not
</span></span><span style=display:flex><span>match example.com.  Similarly, a certificate for *.example.com would
</span></span><span style=display:flex><span>be valid for APD identities of a.example.com, foo.example.com,
</span></span><span style=display:flex><span>*.example.com, etc., but not example.com.
</span></span></code></pre></div><p>在 HTTPS 的 RFC <a href=https://www.rfc-editor.org/rfc/rfc2818>https://www.rfc-editor.org/rfc/rfc2818</a> 中，关于两者的关系有如下描述：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>If a subjectAltName extension of type dNSName is present, that MUST
</span></span><span style=display:flex><span>be used as the identity. Otherwise, the (most specific) Common Name
</span></span><span style=display:flex><span>field in the Subject field of the certificate MUST be used. Although
</span></span><span style=display:flex><span>the use of the Common Name is existing practice, it is deprecated and
</span></span><span style=display:flex><span>Certification Authorities are encouraged to use the dNSName instead.
</span></span></code></pre></div><p>TLS/SSL 证书中的 <code>subjectAltName</code> 扩展除了包含 <code>dNSName</code> 类型之外，还可以包含其他类型的名称，比如IP地址、电子邮件地址或URI等。当客户端使用 HTTPS 连接到服务器时，它首先检查服务器的证书以验证其身份。在这个过程中，客户端会检查证书中的subjectAltName扩展，如果证书中存在 <code>subjectAltName</code> 扩展， <code>subjectAltName</code> 扩展中的dNSName类型用于指定与证书相关联的域名，如果存在 dNSName，则使用 dNSName 作为身份校验方式。</p><p>如果客户端的目标域名与 <code>subjectAltName</code> 扩展中的域名匹配，则证书被视为有效，连接可以继续进行。如果没有匹配，则连接被视为不受信任。</p><p>如果证书中不存在 <code>subjectAltName</code> dNSName 字段，则使用证书的Subject字段中的Common Name字段来标识服务器。</p><h2 id=浏览器支持调查>浏览器支持调查
<a class=heading-link href=#%e6%b5%8f%e8%a7%88%e5%99%a8%e6%94%af%e6%8c%81%e8%b0%83%e6%9f%a5><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><h3 id=chrome>Chrome
<a class=heading-link href=#chrome><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>在 58 版本中，删除了对 CommonName 匹配的支持，<a href=https://chromestatus.com/feature/4981025180483584>https://chromestatus.com/feature/4981025180483584</a>：</p><blockquote><p>RFC 2818 describes two methods to match a domain name against a certificate - using the available names within the subjectAlternativeName extension, or, in the absence of a SAN extension, falling back to the commonName.<br>The fallback to the commonName was deprecated in RFC 2818 (published in 2000), but support still remains in a number of TLS clients, often incorrectly.</p></blockquote><p>在Chrome 论坛中关于这个改动的讨论写的非常清晰：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>Link to <span style=font-style:italic>&#34;Intent to Deprecate&#34;</span> thread
</span></span><span style=display:flex><span>No deprecate thread; it<span>&#39;</span>s been deprecated since HTTPS was first introduced (RFC 2818) in 2000.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Summary
</span></span><span style=display:flex><span>Certificates have two ways to express the domain/IP they<span>&#39;</span>re bound to - one which is unstructured and ambiguous (commonName), and one which is well-defined (subjectAltName). In the absence of any subjectAltNames, Chrome currently falls back to comparing the domain against the commonName, <span style=font-weight:700>if</span> present.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>This proposal is to remove that fallback path; in effect, requiring a subjectAltName. Ideally, we would do this <span style=font-weight:700>for</span> all certificates (publicly trusted and privately trusted), but <span style=font-weight:700>if</span> there are concerns about compat risk, we can restrict it to publicly trusted certificates.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Motivation
</span></span><span style=display:flex><span>Since 1997 (X.509v3<span>&#39;</span>s ratification), certificates have had two ways to express a binding to a domain name - either via the commonName attribute within the certificate<span>&#39;</span>s subject, or via the explicitly typed (dNSName or iPAddress) of the SubjectAlternativeName Extension.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Since RFC 2818 (published in 2000, first drafted in January 1998), the use of the commonName field has been considered deprecated, because it<span>&#39;</span>s ambiguous and untyped - that is, it might contain a human-readable name or it might be a domain name.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The use of the subjectAlternativeName fields leaves it unambiguous whether a certificate is expressing a binding to an IP address or a domain name, and is fully defined in terms of its interaction with Name Constraints. commonName, however, is ambiguous, and because of this, support <span style=font-weight:700>for</span> the commonName has been a source of security bugs - in both Chrome and the libraries it uses and within the TLS ecosystem at large.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Compatibility Risk
</span></span><span style=display:flex><span>Low. RFC 2818 has deprecated this <span style=font-weight:700>for</span> nearly two decades, and the Baseline Requirements (which all publicly trusted CAs must abide by) has required the presence of a subjectAltName since 2012.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Mozilla Firefox already requires the subjectAltName <span style=font-weight:700>for</span> any newly issued publicly trusted certificates since Firefox 48 ( https:<span style=font-style:italic>//bugzilla.mozilla.org/show_bug.cgi?id=1245280 ).
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span>Usage information
</span></span><span style=display:flex><span>From a metrics perspective, less than .002% of publicly trusted certificate validations would require this behaviour (Net.CertCommonNameFallback minus Net.CertCommonNameFallbackPrivateCA).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>As 1.57% of privately-trusted CA certificates rely on this behaviour (or 0.1% of all certificate validations), it may be premature to deprecate it <span style=font-weight:700>for</span> privately-trusted CAs; alternatively, we could remove it with an enterprise policy to allow it <span style=font-weight:700>for</span> a limited number of releases. Unfortunately, despite being deprecated <span style=font-weight:700>for</span> nearly 20 years, it<span>&#39;</span>s unlikely we<span>&#39;</span>d be able to drive this number down (and improve the security of the ecosystem) without taking further action.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>OWP launch tracking bug
</span></span><span style=display:flex><span>https:<span style=font-style:italic>//bugs.chromium.org/p/chromium/issues/detail?id=308330
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span>Entry on the feature dashboard
</span></span><span style=display:flex><span>https:<span style=font-style:italic>//www.chromestatus.com/feature/4981025180483584 (Apologies if I botched this; not sure how to capture &#34;The standard says this is deprecated, and Mozilla supports deprecating&#34;)
</span></span></span></code></pre></div><h3 id=firefox>Firefox
<a class=heading-link href=#firefox><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1245280">https://bugzilla.mozilla.org/show_bug.cgi?id=1245280</a></p><h2 id=结论>结论
<a class=heading-link href=#%e7%bb%93%e8%ae%ba><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>CommonName 已经不被作为身份验证标识，统一使用 SubjectAltName 。</p><p>参考链接：</p><ul><li><a href=https://chromestatus.com/feature/4981025180483584>https://chromestatus.com/feature/4981025180483584</a></li><li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1245280">https://bugzilla.mozilla.org/show_bug.cgi?id=1245280</a></li></ul></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//zdyxry.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article></section></div><footer class=footer><section class=container>©
2016 -
2024
Yiran Zhou
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0433XDZ3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G0433XDZ3V",{anonymize_ip:!1})}</script></body></html>