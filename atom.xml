<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2020-04-10T12:45:19.995Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 第15周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/10/2020-%E7%AC%AC15%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/10/2020-第15周-LeetCode-记录/</id>
    <published>2020-04-10T12:44:44.000Z</published>
    <updated>2020-04-10T12:45:19.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1403-Minimum-Subsequence-in-Non-Increasing-Order"><a href="#1403-Minimum-Subsequence-in-Non-Increasing-Order" class="headerlink" title="1403. Minimum Subsequence in Non-Increasing Order"></a>1403. Minimum Subsequence in Non-Increasing Order</h3><p>对数组进行排序，然后依次取出当前最大值，比较当前取出数值和与剩余数值和，如果大于，则返回取出数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubsequence</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        N = len(nums)</span><br><span class="line">        total = sum(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            x = nums.pop()</span><br><span class="line"></span><br><span class="line">            t += x</span><br><span class="line">            ret.append(x)</span><br><span class="line">            <span class="keyword">if</span> t * <span class="number">2</span> &gt; total: <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h3 id="1400-Construct-K-Palindrome-Strings"><a href="#1400-Construct-K-Palindrome-Strings" class="headerlink" title="1400. Construct K Palindrome Strings"></a>1400. Construct K Palindrome Strings</h3><p>构造指定个数的回文字符串，检查出现次数为奇数的字母次数是否超过了k即可。可以直接用 Counter 计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        digit_count = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> len(s) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            odd = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> set(s):</span><br><span class="line">                digit_count[i] = s.count(i)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> digit_count.values():</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                    odd += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> odd &gt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1401-Circle-and-Rectangle-Overlapping"><a href="#1401-Circle-and-Rectangle-Overlapping" class="headerlink" title="1401. Circle and Rectangle Overlapping"></a>1401. Circle and Rectangle Overlapping</h3><p>依次考虑圆心与矩形的位置关系，是否在矩形的上下左右，求出矩形到圆心距离最小的点，然后根据两点间距离公式来与半径相比较。</p><p>zhihu 上有一个问题可以解答这道题：<a href="https://www.zhihu.com/question/24251545" target="_blank" rel="noopener">https://www.zhihu.com/question/24251545</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkOverlap</span><span class="params">(radius <span class="keyword">int</span>, x_center <span class="keyword">int</span>, y_center <span class="keyword">int</span>, x1 <span class="keyword">int</span>, y1 <span class="keyword">int</span>, x2 <span class="keyword">int</span>, y2 <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dx, dy <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">if</span> x1 &gt; x_center &#123;</span><br><span class="line">        dx = x1 - x_center  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> x_center &gt; x2 &#123;</span><br><span class="line">        dx = x_center - x2 </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        dx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> y1 &gt; y_center &#123;</span><br><span class="line">        dy = y1 - y_center  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> y_center &gt; y2 &#123;</span><br><span class="line">        dy = y_center - y2 </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        dy = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dx * dx + dy * dy &lt;= radius * radius</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One"><a href="#1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One" class="headerlink" title="1404. Number of Steps to Reduce a Number in Binary Representation to One"></a>1404. Number of Steps to Reduce a Number in Binary Representation to One</h3><p>这道题如果直接把二进制转换为十进制数，然后判断奇偶就很容易了，但是这不是它本身的目的，主要需要考虑位进位换算，其中分为 4 种情况：</p><p>无进位，当前位是1，则步骤 +2，进位为1<br>无进位，当前位是0，则步骤 +1，进位为0<br>有进位，当前位是1，则步骤 +1，进位为1<br>有进位，当前位是0，则步骤 +2，进位为1</p><p>其中步骤 +2 的情况为当前位是 1，需要 +1 和 /2 两个操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(A []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(A)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">A[i], A[<span class="built_in">len</span>(A)<span class="number">-1</span>-i] = A[<span class="built_in">len</span>(A)<span class="number">-1</span>-i], A[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSteps</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">reverse(bs)</span><br><span class="line">step, carry, last := <span class="number">0</span>, <span class="number">0</span>, bs[<span class="built_in">len</span>(bs)<span class="number">-1</span>]</span><br><span class="line">bs = bs[:<span class="built_in">len</span>(bs)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> bs &#123;</span><br><span class="line"><span class="keyword">if</span> carry == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">'1'</span> &#123;</span><br><span class="line">step += <span class="number">2</span></span><br><span class="line">carry = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">'0'</span> &#123;</span><br><span class="line">step += <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> last == <span class="string">'1'</span> &#123;</span><br><span class="line">step += carry</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1405-Longest-Happy-String"><a href="#1405-Longest-Happy-String" class="headerlink" title="1405. Longest Happy String"></a>1405. Longest Happy String</h3><p>对字母按照次数进行降序排序，然后依次遍历字母，判断最后2位是否与当前字母 * 2 相同，如果相同，则跳过，如果不相同，则将其添加到结果中，并将次数 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDiverseString</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class="line">        x = [[a, <span class="string">'a'</span>],[b, <span class="string">'b'</span>],[c,<span class="string">'c'</span>]]</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> sorted(x,reverse=<span class="keyword">True</span>):</span><br><span class="line">                <span class="keyword">if</span> num[<span class="number">0</span>] &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">if</span> len(res) &gt;= <span class="number">2</span> <span class="keyword">and</span> res[<span class="number">-2</span>:] == num[<span class="number">1</span>] * <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res += num[<span class="number">1</span>]</span><br><span class="line">                num[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1403-Minimum-Subsequence-in-Non-Increasing-Order&quot;&gt;&lt;a href=&quot;#1403-Minimum-Subsequence-in-Non-Increasing-Order&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>fsck 是如何工作的</title>
    <link href="https://zdyxry.github.io/2020/04/05/fsck-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://zdyxry.github.io/2020/04/05/fsck-是如何工作的/</id>
    <published>2020-04-05T01:08:33.000Z</published>
    <updated>2020-04-05T02:13:46.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在平时会遇到不少系统崩溃之后文件系统异常的情况，通常我们会通过 fsck 工具进行修复，今天来了解下 fsck 做了什么，是怎么做的。</p><h2 id="工作负载示例"><a href="#工作负载示例" class="headerlink" title="工作负载示例"></a>工作负载示例</h2><p>假设现在存在一种工作负载，将单个数据块附加到原有文件。通过打开文件，调用 <code>lseek()</code> 将文件偏移量移动到文件末尾，然后在关闭文件之前，向文件发出单个 4KB 写入来完成追加。</p><p>假定磁盘上使用标准的简单文件系统结构，包括一个 inode 位图（inode bitmap，只有 8 位，每个 inode 一个），一个数据位图（databitmap，也是 8 位，每个数据块一个），inode（总共 8 个，编号为 0 到 7，分布在 4 个块上），以及数据块（总共 8 个，编号为 0～7）。以下是该文件系统的示意图：</p><img src="/2020/04/05/fsck-是如何工作的/fsck-1.png" title="fsck-1"><p>查看图中的结构，可以看到分配了一个 inode（inode 号为 2），它在 inode 位图中标记，单个分配的数据块（数据块 4）也在数据中标记位图。inode 表示为 I [v1]，因为它是此 inode 的第一个版本。它将很快更新（由于上述工作负载）。再来看看这个简化的 inode。在 I[v1]中，可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">owner : remzi</span><br><span class="line">permissions : read-write</span><br><span class="line">size : 1</span><br><span class="line">pointer : 4</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br></pre></td></tr></table></figure><p>在这个简化的 inode 中，文件的大小为 1（它有一个块位于其中），第一个直接指针指向块 4（文件的第一个数据块，Da），并且所有其他 3 个直接指针都被设置为 null（表示它们未被使用）。当然，真正的 inode 有更多的字段。</p><p>向文件追加内容时，要向它添加一个新数据块，因此必须更新 3 个磁盘上的结构：inode（必须指向新块，并且由于追加而具有更大的大小），新数据块 Db 和新版本的数据位图（称之为 B[v2]）表示新数据块已被分配。<br>因此，在系统的内存中，有 3 个块必须写入磁盘。更新的 inode（inode 版本 2，或简称为 I [v2]）现在看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">owner : remzi</span><br><span class="line">permissions : read-write</span><br><span class="line">size : 2</span><br><span class="line">pointer : 4</span><br><span class="line">pointer : 5</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br></pre></td></tr></table></figure><p>更新的数据位图（B[v2]）现在看起来像这样：00001100。最后，有数据块（Db），它只是用户放入文件的内容。希望文件系统的最终磁盘映像如下所示:</p><img src="/2020/04/05/fsck-是如何工作的/fsck-2.png" title="fsck-2"><p>要实现这种转变，文件系统必须对磁盘执行 3 次单独写入，分别针对 inode（I[v2]），位图（B[v2]）和数据块（Db）。请注意，当用户发出 write()系统调用时，这些写操作通常不会立即发生。脏的 inode、位图和新数据先在内存（页面缓存，page cache，或缓冲区缓存，buffer cache）中存在一段时间。</p><p>然后，当文件系统最终决定将它们写入磁盘时（比如说 5s 或 30s），文件系统将向磁盘发出必要的写入请求。遗憾的是，可能会发生崩溃，从而干扰磁盘的这些更新。特别是，如果这些写入中的一个或两个完成后发生崩溃，而不是全部 3 个，则文件系统可能处于异常的状态。</p><h2 id="崩溃场景"><a href="#崩溃场景" class="headerlink" title="崩溃场景"></a>崩溃场景</h2><p>想象一下，只有一次写入成功。因此有以下 3 种可能的结果：</p><ul><li>只将数据块（Db）写入磁盘。在这种情况下，数据在磁盘上，但是没有指向它的 inode，也没有表示块已分配的位图。因此，就好像写入从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题。</li><li>只有更新的 inode（I[v2]）写入了磁盘。在这种情况下，inode 指向磁盘地址（5），其中 Db 即将写入，但 Db 尚未写入。因此，如果信任该指针，那将从磁盘读取垃圾数据（磁盘地址 5 的旧内容）。</li></ul><p>此外，遇到了一个新问题，将它称为文件系统不一致（file-system inconsistency）。磁盘上的位图显示数据块 5 尚未分配，但是 inode 说它已经分配了。文件系统数据结构中的这种不同意见，是文件系统的数据结构不一致。要使用文件系统，必须以某种方式解决这个问题。</p><ul><li>只有更新后的位图（B [v2]）写入了磁盘。在这种情况下，位图指示已分配块 5，但没有指向它的 inode。因此文件系统再次不一致。如果不解决，这种写入将导致空间泄露（space leak），因为文件系统永远不会使用块 5。</li></ul><p>在这个向磁盘写入 3 次的尝试中，还有 3 种崩溃场景。在这些情况下，两次写入成功，最后一次失败。</p><ul><li>inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）。在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图指示 5 正在使用，因此从文件系统的元数据的角度来看，一切看起来都很正常。但是有一个问题：5 中又是垃圾。</li><li>写入了 inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）。在这种情况下，inode 指向了磁盘上的正确数据，但同样在 inode 和位图（B1）的旧版本之间存在不一致。因此，在使用文件系统之前，又需要解决问题。</li><li>写入了位图（B[v2]）和数据块（Db），但没有写入 inode（I[v2]）。在这种情况下，inode 和数据位图之间再次存在不一致。但是，即使写入块并且位图指示其使用，也不知道它属于哪个文件，因为没有 inode 指向该块。</li></ul><p>从这些崩溃场景中可以看到由于崩溃而导致磁盘文件系统映像可能出现的许<br>多问题：在文件系统数据结构中可能存在不一致性。可能有空间泄露，可能将垃圾数据返回给用户，等等。</p><p>理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地<br>（atomically）移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是，做到这一点不容易，因为磁盘一次只提交一次写入，而这些更新之间可能会发生崩溃或断电。将这个一般问题称为崩溃一致性问题（crash-consistency problem，也可以称为一致性更新问题，consistent-update problem）。</p><h2 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h2><p>早期的文件系统采用了一种简单的方法来处理崩溃一致性。基本上，它们决定让不一致的事情发生，然后再修复它们（重启时）。这种偷懒方法的典型例子可以在一个工具中找到：fsck。fsck 是一个 UNIX 工具，用于查找这些不一致并修复它们。在不同的系统上，存在检查和修复磁盘分区的类似工具。请注意，这种方法无法解决所有问题。例如，考虑上面的情况，文件系统看起来是一致的，但是 inode 指向垃圾数据。唯一真正的目标，是确保文件系统元数据内部一致。</p><p>工具 fsck 在许多阶段运行，它在文件系统挂载并可用之前运行（fsck 假定在运行时没有其他文件系统活动正在进行）。一旦完成，磁盘上的文件系统应该是一致的，因此可以让用户访问。以下是 fsck 的基本总结：</p><ul><li>超级块：fsck 首先检查超级块是否合理，主要是进行健全性检查，例如确保文件系统大小大于分配的块数。通常，这些健全性检查的目的是找到一个可疑的（冲突的）超级块。在这种情况下，系统（或管理员）可以决定使用超级块的备用副本。</li><li>空闲块：接下来，fsck 扫描 inode、间接块、双重间接块等，以了解当前在文件系统中分配的块。它利用这些知识生成正确版本的分配位图。因此，如果位图和 inode之间存在任何不一致，则通过信任 inode 内的信息来解决它。对所有 inode 执行相同类型的检查，确保所有看起来像在用的 inode，都在 inode 位图中有标记。</li><li>inode 状态：检查每个 inode 是否存在损坏或其他问题。例如，fsck 确保每个分配的 inode 具有有效的类型字段（即常规文件、目录、符号链接等）。如果 inode 字段存在问题，不易修复，则 inode 被认为是可疑的，并被 fsck 清除，inode 位图相应地更新。</li><li>inode 链接：fsck 还会验证每个已分配的 inode 的链接数。你可能还记得，链接计数表示包含此特定文件的引用（即链接）的不同目录的数量。为了验证链接计数，fsck 从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数。如果新计算的计数与 inode 中找到的计数不匹配，则必须采取纠正措施，通常是修复 inode 中的计数。如果发现已分配的 inode 但没有目录引用它，则会将其移动到 lost + found 目录。</li><li>重复：fsck 还检查重复指针，即两个不同的 inode 引用同一个块的情况。如果一个 inode 明显不好，可能会被清除。或者，可以复制指向的块，从而根据需要为每个 inode 提供其自己的副本。</li><li>坏块：在扫描所有指针列表时，还会检查坏块指针。如果指针显然指向超出其有效范围的某个指针，则该指针被认为是“坏的”，例如，它的地址指向大于分区大小的块。在这种情况下，fsck 不能做任何太智能的事情。它只是从 inode 或间接块中删除（清除）该指针。</li><li>目录检查：fsck 不了解用户文件的内容。但是，目录包含由文件系统本身创建的特定格式的信息。因此，fsck 对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前面的条目，目录条目中引用的每个 inode 都已分配，并确保整个层次结构中没有目录的引用超过一次。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上所述，构建有效工作的 fsck 需要复杂的文件系统知识。确保这样的代码在所有情况下都能正常工作可能具有挑战性。然而，fsck（和类似的方法）有一个更大的、也许更根本的问题：它们太慢了。</p><p>对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。随着磁盘容量的增长和 RAID 的普及，fsck 的性能变得令人望而却步。在更高的层面上，fsck 的基本前提似乎有点不合理。考虑上面的示例，其中只有 3 个块写入磁盘。扫描整个磁盘，仅修复更新 3 个块期间出现的问题，这是非常昂贵的。</p><p>这种情况类似于将你的钥匙放在卧室的地板上，然后从地下室开始，搜遍每个房间，执行“搜索整个房子找钥匙”的恢复算法。它有效，但很浪费。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在平时会遇到不少系统崩溃之后文件系统异常的情况，通常我们会通过 fsck 工具进行修复，今天来了解下 fsck 做了什么，是怎么做的。&lt;/p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第14周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/03/2020-%E7%AC%AC14%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/03/2020-第14周-LeetCode-记录/</id>
    <published>2020-04-03T13:49:38.000Z</published>
    <updated>2020-04-03T13:50:06.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1394-Find-Lucky-Integer-in-an-Array"><a href="#1394-Find-Lucky-Integer-in-an-Array" class="headerlink" title="1394. Find Lucky Integer in an Array"></a>1394. Find Lucky Integer in an Array</h3><p>找幸运数字，可以维护一个数组，然后统计出现过的次数，也可以直接使用 collections.Counter 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLucky</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">501</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            cnt[a] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> cnt[i] == i:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a>1395. Count Number of Teams</h3><p>遍历数组，假设当前数值是中间位置，因为要考虑到倒序排序，所以要找到左边比当前数值小的和比当前数值大的，找到右边比当前数值小的和比当前数值大的，然后进行排列组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTeams</span><span class="params">(self, rating)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rating: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(rating)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line">            l1,r1= <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            l2,r2 =<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &lt; rating[i]:</span><br><span class="line">                    l1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &gt; rating[i]:</span><br><span class="line">                    r1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r2 += <span class="number">1</span></span><br><span class="line">            ans += l1*r1 + l2*r2</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1396-Design-Underground-System"><a href="#1396-Design-Underground-System" class="headerlink" title="1396. Design Underground System"></a>1396. Design Underground System</h3><p>使用 dict ，在 checkin 的时候以 id 为key，记录地铁站和时间，在 checkout 的时候以 (checkin_station, checkout_station) 为 key，记录所用时间，需要注意多次的情况，记录次数，在 getAverageTime 的时候直接根据 (checkin_station, checkout_station) 从 dict 中读取所用时间总和和次数，进行除法计算每次结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = defaultdict(int)</span><br><span class="line">        self.time = defaultdict(int)</span><br><span class="line">        self.traveling = dict()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIn</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.traveling[id] = (stationName, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOut</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        (prev_station, prev_t) = self.traveling[id]</span><br><span class="line">        <span class="keyword">del</span> self.traveling[id]</span><br><span class="line">        key = (prev_station, stationName)</span><br><span class="line">        self.count[key] += <span class="number">1</span></span><br><span class="line">        self.time[key] += (t-prev_t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAverageTime</span><span class="params">(self, startStation: str, endStation: str)</span> -&gt; float:</span></span><br><span class="line">        key = (startStation, endStation)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.time[key] / self.count[key]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = UndergroundSystem()</span></span><br><span class="line"><span class="comment"># obj.checkIn(id,stationName,t)</span></span><br><span class="line"><span class="comment"># obj.checkOut(id,stationName,t)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getAverageTime(startStation,endStation)</span></span><br></pre></td></tr></table></figure><h3 id="1262-Greatest-Sum-Divisible-by-Three"><a href="#1262-Greatest-Sum-Divisible-by-Three" class="headerlink" title="1262. Greatest Sum Divisible by Three"></a>1262. Greatest Sum Divisible by Three</h3><p>可以用单纯的数学方式做，先统计所有数字的和，然后遍历数字，找出余数为 1 和余数为 2 的数值，当总和余数为 1 时，则减去余数为1 的最小的数字，当总和余数为 2 时，则减去余数为 2 的最小的数字。需要注意比较余数为 1 和余数为2 要进行大小相比，如果 两个余数为2的数值之和小于余数为1 的数值，那么此时应该减去的数字为前者。</p><p>也可以采用动态规划做，维护一个 dp，分别存储余数为 0，1，2 的最大数字和，遍历数字，更新相加后的余数最大和，最后返回余数为0 的最大和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            tmp_dp = dp[:]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">                c_sum = tmp_dp[i] + n</span><br><span class="line">                dp[c_sum % <span class="number">3</span>] = max(dp[c_sum % <span class="number">3</span>], c_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSumDivThree</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    one := <span class="number">10000</span></span><br><span class="line">    two := <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        res += nums[i]</span><br><span class="line">        <span class="keyword">if</span> nums[i] % <span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">            two = min(two, one + nums[i])</span><br><span class="line">            one = min(one, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] % <span class="number">3</span> == <span class="number">2</span> &#123;</span><br><span class="line">            one = min(one, two + nums[i])</span><br><span class="line">            two = min(two, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> res % <span class="number">3</span> == <span class="number">0</span> &#123; <span class="keyword">return</span> res &#125;</span><br><span class="line">    <span class="keyword">if</span> res % <span class="number">3</span> == <span class="number">1</span> &#123; <span class="keyword">return</span> res - one &#125;</span><br><span class="line">    <span class="keyword">return</span> res - two</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1232-Check-If-It-Is-a-Straight-Line"><a href="#1232-Check-If-It-Is-a-Straight-Line" class="headerlink" title="1232. Check If It Is a Straight Line"></a>1232. Check If It Is a Straight Line</h3><p>一道数学题，先用前两个点来计算出斜率，然后遍历之后的点，验证斜率是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkStraightLine</span><span class="params">(self, coordinates: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        same_slop = <span class="keyword">True</span></span><br><span class="line">        last_slop = <span class="keyword">None</span></span><br><span class="line">        intial_point = coordinates[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> coordinates[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                slop = (point[<span class="number">1</span>] - intial_point[<span class="number">1</span>])/(point[<span class="number">0</span>] - intial_point[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">except</span> ZeroDivisionError: </span><br><span class="line">                slop = float(inf)</span><br><span class="line">            <span class="keyword">if</span> last_slop== <span class="keyword">None</span>:last_slop = slop</span><br><span class="line">            <span class="keyword">elif</span> slop == last_slop:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                same_slop = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> same_slop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1394-Find-Lucky-Integer-in-an-Array&quot;&gt;&lt;a href=&quot;#1394-Find-Lucky-Integer-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1394. Find Lucky Integ
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第13周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/27/2020-%E7%AC%AC13%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/27/2020-第13周-LeetCode-记录/</id>
    <published>2020-03-27T14:27:32.000Z</published>
    <updated>2020-03-27T14:27:53.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1387-Sort-Integers-by-The-Power-Value"><a href="#1387-Sort-Integers-by-The-Power-Value" class="headerlink" title="1387. Sort Integers by The Power Value"></a>1387. Sort Integers by The Power Value</h3><p>给定一个区间，让你求出这个区间内所有数字的权重，然后按照权重进行排序，权重计算方式为：</p><ul><li>如果 x 是偶数，那么 x = x / 2</li><li>如果 x 是奇数，那么 x = 3 * x + 1</li></ul><p>在计算过程中，肯定会有重复计算，所以使用 dict 记录已经计算过的数值权重。当计算完成后，对结果进行排序，优先使用权重排序，如果权重相同，则按照数值本身大小进行排序，取第 k 个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKth</span><span class="params">(self, lo, hi, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lo: int</span></span><br><span class="line"><span class="string">        :type hi: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> self.memo:</span><br><span class="line">                <span class="keyword">return</span> self.memo[n]</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">                ans=helper((n*<span class="number">3</span>+<span class="number">1</span>)/<span class="number">2</span>)+<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans=helper(n/<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">            self.memo[n]=ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        tmp=sorted([[helper(n),n] <span class="keyword">for</span> n <span class="keyword">in</span> range(lo,hi+<span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">return</span> tmp[k<span class="number">-1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1389-Create-Target-Array-in-the-Given-Order"><a href="#1389-Create-Target-Array-in-the-Given-Order" class="headerlink" title="1389. Create Target Array in the Given Order"></a>1389. Create Target Array in the Given Order</h3><p>考察 insert 动作，可以直接用 insert 函数来做；也可以通过对 list 进行切片实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTargetArray</span><span class="params">(self, nums, index)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type index: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> n, i <span class="keyword">in</span> zip(nums, index):</span><br><span class="line">            target.insert(i, n)</span><br><span class="line">            <span class="comment"># target = target[:i] + [n] + target[i:]</span></span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure><h3 id="1390-Four-Divisors"><a href="#1390-Four-Divisors" class="headerlink" title="1390. Four Divisors"></a>1390. Four Divisors</h3><p>数学题，如果一个数的因数恰好是 4个因数，那么返回这4个因数的和，直接暴力求解会超时。</p><p>如果整数 x 有因数 y，那么也必有因数 x/y，并且 y 和 x/y 中至少有一个不大于 sqrt(x)。这样我们只需要在 [1, sqrt(x)] 的区间内枚举可能为整数 x 的因数 y，并通过 x/y 得到整数 x 的其它因数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumFourDivisors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">                s = set()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1</span> + int(math.sqrt(n))):</span><br><span class="line">                    <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                        s.add(i)</span><br><span class="line">                        s.add(n / i)</span><br><span class="line">                    <span class="keyword">if</span> len(s) &gt; <span class="number">4</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                cache[n] = sum(s) <span class="keyword">if</span> len(s) == <span class="number">4</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> cache[n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(map(fn, nums))</span><br></pre></td></tr></table></figure><h3 id="1386-Cinema-Seat-Allocation"><a href="#1386-Cinema-Seat-Allocation" class="headerlink" title="1386. Cinema Seat Allocation"></a>1386. Cinema Seat Allocation</h3><p>使用位运算，先按照每行拆分，统计出已经被预约的位置，置为1，然后分别与可能安排的3种方式进行与运算，如果为0 ，则表示可以安排。最终将结果求和。需要注意如果一行内所有作为都未安排的情况，此时应该按照每行 2 种方式相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfFamilies</span><span class="params">(self, n, reservedSeats)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type reservedSeats: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        seats = collections.defaultdict(int) </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row, col <span class="keyword">in</span> reservedSeats:</span><br><span class="line">            seats[row] = seats[row] | (<span class="number">1</span> &lt;&lt; (col<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> bin(seats[<span class="number">3</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> reserved <span class="keyword">in</span> seats.values():</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0111100000'</span>, <span class="number">2</span>)) == <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0000011110'</span>, <span class="number">2</span>)) == <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0001111000'</span>, <span class="number">2</span>)) == <span class="number">0</span> <span class="keyword">and</span> curr == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            res += curr    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">2</span> * (n - len(seats))</span><br></pre></td></tr></table></figure><h3 id="1329-Sort-the-Matrix-Diagonally"><a href="#1329-Sort-the-Matrix-Diagonally" class="headerlink" title="1329. Sort the Matrix Diagonally"></a>1329. Sort the Matrix Diagonally</h3><p>考察排序和数组，需要先找到对角线的数字集，可以使用（每行的索引 - 每列的索引）来表示，因为对角线上的数字该值是相同的，找到后对起进行排序，然后再次遍历填入排序后的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diagonalSort</span><span class="params">(self, mat)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type mat: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        diag = defaultdict(list)</span><br><span class="line">        N,M = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                diag[i-j].append(mat[i][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> diag.keys():</span><br><span class="line">            diag[k].sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                mat[i][j] = diag[i-j].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1387-Sort-Integers-by-The-Power-Value&quot;&gt;&lt;a href=&quot;#1387-Sort-Integers-by-The-Power-Value&quot; class=&quot;headerlink&quot; title=&quot;1387. Sort Integer
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 《Pingmesh: A Large-Scale System for Data Center Network Latency Measurement and Analysis》</title>
    <link href="https://zdyxry.github.io/2020/03/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E3%80%8APingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis%E3%80%8B/"/>
    <id>https://zdyxry.github.io/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/</id>
    <published>2020-03-26T12:24:09.000Z</published>
    <updated>2020-03-27T14:15:01.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们内部产品中，一直有关于网络性能数据监控需求，我们之前是直接使用 <code>ping</code> 命令收集结果，每台服务器去 ping (N-1) 台，也就是 N^2 的复杂度，稳定性和性能都存在一些问题，最近打算对这部分进行重写，在重新调研期间看到了 Pingmesh 这篇论文，Pingmesh 是微软用来监控数据中心网络情况而开发的软件，通过阅读这篇论文来学习下他们是怎么做的。</p><p>数据中心自身是极为复杂的，其中网络涉及到的设备很多就显得更为复杂，一个大型数据中心都有成百上千的节点、网卡、交换机、路由器以及无数的网线、光纤。在这些硬件设备基础上构建了很多软件，比如搜索引擎、分布式文件系统、分布式存储等等。在这些系统运行过程中，面临一些问题：如何判断一个故障是网络故障？如何定义和追踪网络的 SLA？出了故障如何去排查？</p><p>基于这几点问题，微软设计开发了 Pingmesh，用来记录和分析数据中心的网络情况。在微软内部 Pingmesh 每天会记录 24TB 数据，进行 2k 亿次 ping 探测，通过这些数据，微软可以很好的进行网络故障判定和及时的修复。</p><h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>常见的数据中心网络拓扑：</p><img src="/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/pingmesh-1.png" title="pingmesh-1"><p>网络延时计算方式：server A 发送消息到 server B 接受消息的时间。最终使用 RTT 时间，RTT 一个好处是绝对时间，与时钟不相关。</p><p>在大多数情况下，大家不会去关心延时具体是什么导致的，都是直接归结于网络原因，让网络团队去排查，实际上是浪费了很多人力成本。延时变高有很多原因：CPU 繁忙、服务自身 Bug、网络原因等等。往往丢包会伴随着延时升高，因为丢包意味着会发生重传，所以丢包也是需要观察的重点。</p><p>因为 Pingmesh 运行在微软内部，所以依托于微软自己的基础架构，有自动化管理系统 Autopilot，有大数据系统 Cosmos，也有类似于 SQL 的脚本语言 SCOPE。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>根据上面的需求，Pingmesh 先评估了现有的开源工具，不符合的原因有很多，大多数工具都是以命令行形式呈现，一般是出现故障了去使用工具排查，而且工具提供的数据也不全面，有可能正在运行工具问题已经解决了。当然这并不是说已有的工具没有用，只能说不适合 Pingmesh。</p><p>Pingmesh 是松耦合设计，每个组件都是可以独立运行的，分为 3 个组件。在设计的时候需要考虑几点：</p><ul><li>因为要运行在所有的 server 上，所以不能占用太多的计算资源或网络资源</li><li>需要是灵活配置的且高可用的的</li><li>记录的数据需要进行合理的汇总分析</li></ul><p>Pingmesh 架构设计：</p><img src="/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/pingmesh-2.png" title="pingmesh-2"><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller 主要负责生成 pinglist 文件，这个文件是 XML 格式的，pinglist 的生成是很重要的，需要根据实际的数据中心网络拓扑进行及时更新。</p><p>在生成 pinglist 时， Controller 为了避免开销，分为3 个级别：</p><ol><li>在机架内部，让所有的 server 互相 ping，每个 server ping （N-1） 个 server</li><li>在机架之间，则每个机架选几个 server ping 其他机架的 server，保证 server 所属的 ToR 不同</li><li>在数据中心之间，则选择不同的数据中心的几个不同机架的 server 来ping </li></ol><p>Controller 在生成 pinglist 文件后，通过 HTTP 提供出去，Agent 会定期获取 pinglist 来更新 agent 自己的配置，也就是我们说的“拉”模式。Controller 需要保证高可用，因此需要在 VIP 后面配置多个实例，每个实例的算法一致，pinglist 文件内容也一致，保证可用性。</p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>微软数据中心的每个 server 都会运行 Agent，用来真正做 ping 动作的服务。为了保证获取结果与真实的服务一致，Pingmesh 没有采用 ICMP ping，而是采用的 TCP/HTTP ping。所以每个 Agent 即是 Server 也是 Client。每个 ping 动作都开启一个新的连接，主要为了减少 Pingmesh 造成的 TCP 并发。</p><p>Agent 要保证自己是可靠的，不会造成一些严重的后果，其次要保证自己使用的资源要足够的少，毕竟要运行在每个 server 上。两个server ping 的周期最小是 10s，Packet 大小最大 64kb。针对灵活配置的需求，Agent 会定期去 Controller 上拉取 pinglist，如果 3 次拉取不到，那么就会删除本地已有 pinglist，停止 ping 动作。</p><p>在进行 ping 动作后，会将结果保存在内存中，当保存结果超过一定阈值或者到达了超时时间，就将结果上传到 Cosmos 中用于分析，如果上传失败，会有重试，超过重试次数则将数据丢弃，保证 Agent 的内存使用。</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>拿到了数据就要进行分析，Pingmesh 会以 10min，1hour，1天的粒度进行统计汇总，数据的实时性最快也就是 10min ，Pingmesh 还借助内部的基础设施能够拿到 5min 级别的数据结果，算是一种“实时”监控吧。</p><h2 id="网络状况"><a href="#网络状况" class="headerlink" title="网络状况"></a>网络状况</h2><p>根据论文中提到的，不同负载的数据中心的数据是有很大差异的，在 P99.9 时延时大概在 10-20ms，在 P99.99 延时大概在100+ms 。关于丢包率的计算，因为没有用 ICMP ping 的方式，所以这里是一种新的计算方式，（一次失败 + 二次失败）次数/（成功次数）= 丢包率。这里是每次 ping 的 timeout 是 3s，windows 重传机制等待时间是 3s，下一次 ping 的 timeout 时间是 3s，加一起也就是 9s。所以这里跟 Agent 最小探测周期 10s 是有关联的。二次失败的时间就是 （2 * RTT）+ RTO 时间。</p><p>Pingmesh 的判断依据有两个，如果超过就报警：</p><ul><li>延时超过 5ms</li><li>丢包率超过 10^(-3) </li></ul><p>在论文中还提到了其他的网络故障场景，交换机的静默丢包。有可能是 A 可以连通 B，但是不能连通 C。还有可能是 A 的 i 端口可以连通 B 的 j 端口，但是 A 的 m 端口不能连通 B 的 j 端口，这些都属于交换机的静默丢包的范畴。Pingmesh 通过统计这种数据，然后给交换机进行打分，当超过一定阈值时就会通过 Autopilot 来自动重启交换机，恢复交换机的能力。</p><h2 id="经验学习"><a href="#经验学习" class="headerlink" title="经验学习"></a>经验学习</h2><ol><li>找到可信数据，只有数据来源可信，那么分析才是有效的</li><li>让服务作为 daemon 运行，保证持续的收集数据</li><li>松耦合设计，每个组件都可以独立工作</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我们自己的系统是有 Prometheus 这样的监控系统的，但是当遇到交换机级别的间歇性故障时，Prometheus 也是故障的状态，所以也就不会收集 exporter 汇报的数据，也就更没办法产生告警了。所以如果遇到那种长时间持续的故障反而是好事，至少我们有一个足够的状态去排查哪里出了问题，否则真的是间歇性故障仅仅依靠 ping, traceroute, iperf, netstat 之类的工具去排查是没什么效果的，只有我们知道过去一段时间的网络情况，才能去排查。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p139.pdf" target="_blank" rel="noopener">https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p139.pdf</a></li><li><a href="http://ninjadq.com/2017/04/01/linux-rto" target="_blank" rel="noopener">http://ninjadq.com/2017/04/01/linux-rto</a></li><li><a href="https://yi-ran.github.io/2019/03/27/Pingmesh-SIGCOMM-2015/" target="_blank" rel="noopener">https://yi-ran.github.io/2019/03/27/Pingmesh-SIGCOMM-2015/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在我们内部产品中，一直有关于网络性能数据监控需求，我们之前是直接使用 &lt;code&gt;ping&lt;/code&gt; 命令收集结果，每台服务器去 pin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 第12周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/20/2020-%E7%AC%AC12%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/20/2020-第12周-LeetCode-记录/</id>
    <published>2020-03-20T12:08:24.000Z</published>
    <updated>2020-03-20T12:09:00.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1380-Lucky-Numbers-in-a-Matrix"><a href="#1380-Lucky-Numbers-in-a-Matrix" class="headerlink" title="1380. Lucky Numbers in a Matrix"></a>1380. Lucky Numbers in a Matrix</h3><p>给一个二维数组，分别求每行最小值，每列最大值，然后找到幸运数字。（遇到二维数组善用 zip 来解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span> <span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mins = &#123;min(rows) <span class="keyword">for</span> rows <span class="keyword">in</span> matrix&#125;</span><br><span class="line">        maxes = &#123;max(columns) <span class="keyword">for</span> columns <span class="keyword">in</span> zip(*matrix)&#125;</span><br><span class="line">        <span class="keyword">return</span> list(mins &amp; maxes)</span><br></pre></td></tr></table></figure><h3 id="1381-Design-a-Stack-With-Increment-Operation"><a href="#1381-Design-a-Stack-With-Increment-Operation" class="headerlink" title="1381. Design a Stack With Increment Operation"></a>1381. Design a Stack With Increment Operation</h3><p>相比与 stack 多了一个 inc 操作，一般想法是每次遇到 inc 操作，那么我们遍历一次，将对应值进行加操作就可以了，但是这个操作是 O(n) 的，我们可以使用一个辅助 list ，保存 inc 的数值，当 pop 的时候，进行相加处理。</p><p>以示例展示处理过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class="line">[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack, inc</span><br><span class="line">[1], [0]</span><br><span class="line">[1,2], [0]</span><br><span class="line">[1], [0]</span><br><span class="line">[1,2], [0,0]</span><br><span class="line">[1,2,3], [0,0,0]</span><br><span class="line">[1,2,3], [0,0, 100]</span><br><span class="line">[1,2,3], [0, 100, 100]</span><br><span class="line">[1,2], [0,200]</span><br><span class="line">[1], [200]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxSize)</span>:</span></span><br><span class="line">        self.n = maxSize</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.inc = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.inc) &lt; self.n:</span><br><span class="line">            self.stack.append(x)</span><br><span class="line">            self.inc.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.inc: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(self.inc) &gt; <span class="number">1</span>:</span><br><span class="line">            self.inc[<span class="number">-2</span>] += self.inc[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop() + self.inc.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, k, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.inc:</span><br><span class="line">            self.inc[min(k, len(self.inc)) - <span class="number">1</span>] += val</span><br></pre></td></tr></table></figure><h3 id="1382-Balance-a-Binary-Search-Tree"><a href="#1382-Balance-a-Binary-Search-Tree" class="headerlink" title="1382. Balance a Binary Search Tree"></a>1382. Balance a Binary Search Tree</h3><p>给一个二叉搜索树，使其变为平衡二叉搜索树，只需要一次性操作，不需要时刻考虑每次插入后的变化，根据二叉搜索树特性将其进行中序遍历，得到的结果是升序排序的，然后通过升序排序的结果构建平衡二叉搜索树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balanceBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="string">"""inorder depth-first traverse bst"""</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">            dfs(node.left)</span><br><span class="line">            value.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        </span><br><span class="line">        value = [] <span class="comment">#collect values</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(x)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            k = len(x)//<span class="number">2</span></span><br><span class="line">            ans = TreeNode(x[k])</span><br><span class="line">            ans.left = tree(x[:k])</span><br><span class="line">            ans.right = tree(x[k+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tree(value)</span><br></pre></td></tr></table></figure><h3 id="901-Online-Stock-Span"><a href="#901-Online-Stock-Span" class="headerlink" title="901. Online Stock Span"></a>901. Online Stock Span</h3><p>维护一个单调栈，遍历 prices：如果 price 比前一天要大，那么将前一天移除，并将前一天的权重与当天相加；如果 price 比前一天要小，那么直接追加当天 price，并将其权重置为 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, price)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type price: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        weight = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>] &lt;= price:</span><br><span class="line">            weight += self.stack.pop()[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">print</span> price, self.stack</span><br><span class="line">        self.stack.append((price, weight))</span><br><span class="line">        <span class="keyword">print</span> self.stack</span><br><span class="line">        <span class="keyword">return</span> weight</span><br></pre></td></tr></table></figure><h3 id="897-Increasing-Order-Search-Tree"><a href="#897-Increasing-Order-Search-Tree" class="headerlink" title="897. Increasing Order Search Tree"></a>897. Increasing Order Search Tree</h3><p>考察中序遍历，使用 dfs 直接求解，然后重新构造二叉搜索树。<br>也可以直接改动原有树结构，同样是中序遍历，当我们遍历到一个节点时，把它的左孩子设为空，并将其本身作为上一个遍历到的节点的右孩子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                inorder(node.left)</span><br><span class="line">                node.left = <span class="keyword">None</span></span><br><span class="line">                self.cur.right = node</span><br><span class="line">                self.cur = node</span><br><span class="line">                inorder(node.right)</span><br><span class="line"></span><br><span class="line">        ans = self.cur = TreeNode(<span class="keyword">None</span>)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> ans.right</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            dfs(node.left)</span><br><span class="line">            values.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        values = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        tmp = TreeNode(<span class="number">0</span>)</span><br><span class="line">        root = tmp</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> values:</span><br><span class="line">            tmp.right = TreeNode(node)</span><br><span class="line">            tmp = tmp.right</span><br><span class="line">        <span class="keyword">return</span> root.right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1380-Lucky-Numbers-in-a-Matrix&quot;&gt;&lt;a href=&quot;#1380-Lucky-Numbers-in-a-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1380. Lucky Numbers in a Matrix&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>理解网卡混杂模式</title>
    <link href="https://zdyxry.github.io/2020/03/18/%E7%90%86%E8%A7%A3%E7%BD%91%E5%8D%A1%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zdyxry.github.io/2020/03/18/理解网卡混杂模式/</id>
    <published>2020-03-18T11:49:04.000Z</published>
    <updated>2020-03-18T12:07:58.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我自己会在虚拟机验证一些网络配置，比如在虚拟机内部创建 OVS Bridge 之类的操作。当 Hypervisor 是 vSphere ESXi 时，通常需要在 ESXi 的虚拟交换机上开启混杂模式，今天来说一说网络的混杂模式。</p><h2 id="网卡工作模式"><a href="#网卡工作模式" class="headerlink" title="网卡工作模式"></a>网卡工作模式</h2><p>网卡有以下几种<a href="https://www.nowcoder.com/questionTerminal/242b0842bff9497988bda2676476dea3?toCommentId=9762" target="_blank" rel="noopener">工作模式</a>，通常网卡会配置广播和多播模式：</p><ol><li>广播模式（Broad Cast Model）:它的物理地址地址是 0Xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧。它将会接收所有目的地址为广播地址的数据包，一般所有的网卡都会设置为这个模式</li><li>多播传送（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员。当数据包的目的地址为多播地址，而且网卡地址是属于那个多播地址所代表的多播组时，网卡将接纳此数据包，即使一个网卡并不是一个多播组的成员，程序也可以将网卡设置为多播模式而接收那些多播的数据包。</li><li>直接模式（Direct Model）:工作在直接模式下的网卡只接收目地址是自己 Mac 地址的帧。只有当数据包的目的地址为网卡自己的地址时，网卡才接收它。</li><li>混杂模式（Promiscuous Model）:工作在混杂模式下的网卡接收所有的流过网卡的帧，抓包程序就是在这种模式下运行的。网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，网卡将接受同一网络内所有所发送的数据包，这样就可以到达对于网络信息监视捕获的目的。它将接收所有经过的数据包，这个特性是编写网络监听程序的关键。</li></ol><h2 id="混杂模式"><a href="#混杂模式" class="headerlink" title="混杂模式"></a>混杂模式</h2><img src="/2020/03/18/理解网卡混杂模式/nic1.png" title="nic1"><p>混杂模式（promiscuous mode）是计算机网络中的术语。是指一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。</p><blockquote><p>一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。网卡的混杂模式一般在网络管理员分析网络数据作为网络故障诊断手段时用到，同时这个模式也被网络黑客利用来作为网络数据窃听的入口。在Linux操作系统中设置网卡混杂模式时需要管理员权限。在Windows操作系统和Linux操作系统中都有使用混杂模式的抓包工具，比如著名的开源软件Wireshark。</p></blockquote><h3 id="查看网卡是否开启混杂模式"><a href="#查看网卡是否开启混杂模式" class="headerlink" title="查看网卡是否开启混杂模式"></a>查看网卡是否开启混杂模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 21:06:51 ~]$ifconfig ens192</span><br><span class="line">ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.17.88  netmask 255.255.240.0  broadcast 192.168.31.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe99:4eb2  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:99:4e:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 163692  bytes 10031607 (9.5 MiB)</span><br><span class="line">        RX errors 0  dropped 110  overruns 0  frame 0</span><br><span class="line">        TX packets 1751  bytes 175974 (171.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@node1 21:06:53 ~]$ifconfig ens192 promisc</span><br><span class="line">[root@node1 21:06:57 ~]$ifconfig ens192</span><br><span class="line">ens192: flags=4419&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.17.88  netmask 255.255.240.0  broadcast 192.168.31.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe99:4eb2  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:99:4e:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 171193  bytes 10482754 (9.9 MiB)</span><br><span class="line">        RX errors 0  dropped 110  overruns 0  frame 0</span><br><span class="line">        TX packets 1776  bytes 179091 (174.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>如果在虚拟化场景下，就像我在开头提到的，往往需要在 vSwitch 上开启混杂模式用于开发测试。但是大部分开启混杂模式都是为了抓包。如果二层是使用的集线器，那么只要网卡打开了混杂模式，就可以接受到其他主机发送的数据包，如果二层使用的是交换机，那么往往需要在交换机上配置镜像模式才可以抓到包，这里是需要注意的。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>关于 tcpdump 抓包和混杂模式的关系，这里引用wuyangchun博客的两个流程图来说明。</p><img src="/2020/03/18/理解网卡混杂模式/nic2.png" title="nic2"><p>混杂模式是为了让数据包能够完成步骤 1，进入到 OS 中，tcpdump 真正抓到的包是在下图中的第 15 步。</p><img src="/2020/03/18/理解网卡混杂模式/nic3.png" title="nic3"><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F</a></li><li><a href="https://segmentfault.com/a/1190000008836467" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008836467</a></li><li><a href="https://www.nowcoder.com/questionTerminal/242b0842bff9497988bda2676476dea3?toCommentId=9762" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/242b0842bff9497988bda2676476dea3?toCommentId=9762</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我自己会在虚拟机验证一些网络配置，比如在虚拟机内部创建 OVS Bridge 之类的操作。当 Hypervisor 是 vSphere ES
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第11周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/13/2020-%E7%AC%AC11%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/13/2020-第11周-LeetCode-记录/</id>
    <published>2020-03-13T13:09:45.000Z</published>
    <updated>2020-03-13T13:10:38.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1370-Increasing-Decreasing-String"><a href="#1370-Increasing-Decreasing-String" class="headerlink" title="1370. Increasing Decreasing String"></a>1370. Increasing Decreasing String</h3><p>题目描述很复杂，但其实就是排序和字典，先顺序遍历再反向遍历。（熟练使用 Counter）</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        set_s = set()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">set_s.add(c)</span><br><span class="line">        characters = sorted(set_s)</span><br><span class="line"></span><br><span class="line">        d = collections.Counter(s)</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> sum(d.values()) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> characters:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> s <span class="keyword">and</span> d[c] &gt; <span class="number">0</span>:</span><br><span class="line">                    res += c</span><br><span class="line">                    d[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> characters[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> s <span class="keyword">and</span> d[c] &gt; <span class="number">0</span>:</span><br><span class="line">                    res += c</span><br><span class="line">                    d[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">sMap[<span class="keyword">string</span>(c)]++</span><br><span class="line">&#125;</span><br><span class="line">chars := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c, _ := <span class="keyword">range</span> sMap &#123;</span><br><span class="line">chars = <span class="built_in">append</span>(chars, <span class="keyword">string</span>(c))</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(chars)</span><br><span class="line">res := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(sMap) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> chars &#123;</span><br><span class="line"><span class="keyword">if</span> sMap[chars[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">res += <span class="keyword">string</span>(chars[i])</span><br><span class="line">sMap[chars[i]]--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(sMap, chars[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> chars &#123;</span><br><span class="line"><span class="keyword">if</span> sMap[chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">res += <span class="keyword">string</span>(chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>])</span><br><span class="line">sMap[chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>]]--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(sMap, chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts"><a href="#1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts" class="headerlink" title="1371. Find the Longest Substring Containing Vowels in Even Counts"></a>1371. Find the Longest Substring Containing Vowels in Even Counts</h3><p>采用状态压缩的方式，将每个元音字母出现次数的奇偶作为一种状态，1 表示为奇数次，0表示偶数次，那么一共有 2^5=32 种状态。遍历所有的字符，如果当前字符是元音字母，那么就进行异或操作，并记录此时状态。如果子串[0，i]与字串[0,j]状态相同，那么字串[i+1,j]的状态一定是0，因此可以记录每个状态第一次出现的位置，此后再出现该状态时相减即可。</p><p>来源：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/</a></p><p>需要将状态 0 出现的位置设置为 -1，比如 “ele” ，当循环到第一个 e 时，e 出现奇数次，当循环到第二个 e 时，e 出现偶数次，此时 “ele” 符合条件，且状态为 0，那么需要用第二个 e 的索引值减去状态0 出现的位置，如果状态0 为空，那么第二个e 的状态0就会被当作第一次出现记录下来，导致结果错误，应为 2 - (-1) = 3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vowels = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">2</span>, <span class="string">'i'</span>: <span class="number">4</span>, <span class="string">'o'</span>: <span class="number">8</span>, <span class="string">'u'</span>: <span class="number">16</span>&#125;</span><br><span class="line">        d, n, r = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> vowels:</span><br><span class="line">                n ^= vowels[c]</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[n] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = max(r, i - d[n])</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h3 id="1372-Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="1372. Longest ZigZag Path in a Binary Tree"></a>1372. Longest ZigZag Path in a Binary Tree</h3><p>二叉树中的最长交错路径，使用 dfs 求解，dfs 返回值是[node.left 的最大长度，node.right 的最大长度，node 的最大长度]。<br>这里需要考虑当 root 为 None 时的返回值是多少，因为每递归一层，都需要在上一层将结果 +1 ，如果 root == None，那么 -1 + 1 = 0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestZigZag</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">            left, right = dfs(root.left), dfs(root.right)</span><br><span class="line">            <span class="keyword">return</span> [left[<span class="number">1</span>] + <span class="number">1</span>, right[<span class="number">0</span>] + <span class="number">1</span>, max(left[<span class="number">1</span>]+<span class="number">1</span>, right[<span class="number">0</span>]+<span class="number">1</span>, left[<span class="number">2</span>], right[<span class="number">2</span>])]</span><br><span class="line">        <span class="keyword">return</span> dfs(root)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>换一种方式比较好理解，传入两个参数：count 和当前所在的是 node 的 left 还是 right，如果上一层是 left，那么就在 node.right 将 count +1，否则将 count 置为1重新计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestZigZag</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, count, direction)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> count &gt; self.res:</span><br><span class="line">                    self.res = count</span><br><span class="line">                <span class="keyword">if</span> direction == <span class="string">'left'</span>:</span><br><span class="line">                    dfs(node.right, count+<span class="number">1</span>, <span class="string">'right'</span>)</span><br><span class="line">                    dfs(node.left, <span class="number">1</span>, <span class="string">'left'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dfs(node.left, count+<span class="number">1</span>, <span class="string">'left'</span>)</span><br><span class="line">                    dfs(node.right, <span class="number">1</span>, <span class="string">'right'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            dfs(root.left, <span class="number">1</span>, <span class="string">'left'</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            dfs(root.right, <span class="number">1</span>, <span class="string">'right'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1375-Bulb-Switcher-III"><a href="#1375-Bulb-Switcher-III" class="headerlink" title="1375. Bulb Switcher III"></a>1375. Bulb Switcher III</h3><p>属于那种题目很复杂，做起来很简单的类型，只需要判断当前最大值与当前索引是否相当即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTimesAllBlue</span><span class="params">(self, light)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type light: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        max_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(light):</span><br><span class="line">            max_idx = max(max_idx, b)</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> == max_idx:</span><br><span class="line">                <span class="keyword">print</span> b</span><br><span class="line">                res+= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1376-Time-Needed-to-Inform-All-Employees"><a href="#1376-Time-Needed-to-Inform-All-Employees" class="headerlink" title="1376. Time Needed to Inform All Employees"></a>1376. Time Needed to Inform All Employees</h3><p>使用 DFS 求解，先确定每个员工及它所负责通知的员工，再根据 headID 递归求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfMinutes</span><span class="params">(self, n, headID, manager, informTime)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type headID: int</span></span><br><span class="line"><span class="string">        :type manager: List[int]</span></span><br><span class="line"><span class="string">        :type informTime: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        children = [[] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i, m <span class="keyword">in</span> enumerate(manager):</span><br><span class="line">            <span class="keyword">if</span> m &gt;= <span class="number">0</span>: children[m].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> max([dfs(j) <span class="keyword">for</span> j <span class="keyword">in</span> children[i]] <span class="keyword">or</span> [<span class="number">0</span>]) + informTime[i]</span><br><span class="line">        <span class="keyword">return</span> dfs(headID)</span><br></pre></td></tr></table></figure><p>也可以自底向上求解，为避免重复计算，将每次计算结果记录下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfMinutes</span><span class="params">(self, n, headID, manager, informTime)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type headID: int</span></span><br><span class="line"><span class="string">        :type manager: List[int]</span></span><br><span class="line"><span class="string">        :type informTime: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> manager[i] != <span class="number">-1</span>:</span><br><span class="line">                informTime[i] += dfs(manager[i])</span><br><span class="line">                manager[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> informTime[i]</span><br><span class="line">        <span class="keyword">return</span> max(map(dfs, range(n)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1370-Increasing-Decreasing-String&quot;&gt;&lt;a href=&quot;#1370-Increasing-Decreasing-String&quot; class=&quot;headerlink&quot; title=&quot;1370. Increasing Decreasin
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SR-IOV 基本概念</title>
    <link href="https://zdyxry.github.io/2020/03/12/SR-IOV-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://zdyxry.github.io/2020/03/12/SR-IOV-基本概念/</id>
    <published>2020-03-12T15:04:27.000Z</published>
    <updated>2020-03-13T13:03:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周了解了 RDMA 的基础概念之后，发现在 KVM 平台无需其他配置就可使用，但是在 vSphere 场景下，需要面临一个取舍，其中的一个选择就是 SR-IOV ，今天来了解下 SR-IOV 。</p><h2 id="SR-IOV"><a href="#SR-IOV" class="headerlink" title="SR-IOV"></a>SR-IOV</h2><img src="/2020/03/12/SR-IOV-基本概念/sriov1.png" title="sriov1"><p>SR-IOV 全称 <code>Single Root I/O Virtualization</code>，是 Intel 在 2007年提出的一种基于硬件的虚拟化解决方案。</p><p>在虚拟化场景中，CPU 与内存是最先解决的，但是 I/O 设备一直没有很好的解决办法，Intel 有 VT-d（Virtualization Technology for Directed I/O）可以将物理服务器的 PCIe 设备直接提供给虚拟机使用，也就是我们常说的“直通”（passthrough），但是直通面临一个问题是 PCIe 设备只能给一个虚拟机使用，其他虚拟机就只能干瞪眼，这肯定是不行的，所以有了 SR-IOV，一个物理设备可以虚拟出多个虚拟设备给虚拟机使用。</p><p>SR-IOV 是一种规范，使得单根端口下的单个快速外围组件互连 (PCIe) 物理设备显示为管理程序或客户机操作系统的多个单独的物理设备，既有直通设备的性能优势，又可以支持多个虚拟机，一举两得。</p><img src="/2020/03/12/SR-IOV-基本概念/sriov2.png" title="sriov2"><p>SR-IOV 使用 physical functions (PF) 和 virtual functions (VF) 为 SR-IOV 设备管理全局功能。</p><ul><li>PF 包含SR-IOV 功能的完整PCIe设备，PF 作为普通的PCIe 设备被发现、管理和配置 。PF 通过分配VF 来配置和管理 SR-IOV 功能。禁用SR-IOV后，主机将在一个物理网卡上创建一个 PF。</li><li>VF 是轻量级 PCIe 功能（I/O 处理）的 PCIe 设备，每个 VF 都是通过 PF 来生成管理的，VF 的具体数量限制受限于 PCIe 设备自身配置及驱动程序的支持，启用S​​R-IOV后，主机将在一个物理NIC上创建单个PF和多个VF。 VF的数量取决于配置和驱动程序支持。</li></ul><blockquote><p>每个 SR-IOV 设备都可有一个 PF(Physical Functions)，并且每个 PF 最多可有64,000个与其关联的 VF(Virtual Function)。PF 可以通过寄存器创建 VF，这些寄存器设计有专用于此目的的属性。一旦在 PF 中启用了 SR-IOV，就可以通过 PF 的总线、设备和功能编号（路由 ID）访问各个 VF 的 PCI 配置空间。</p><p>每个 VF 都具有一个 PCI 内存空间，用于映射其寄存器集。VF设备驱动程序对寄存器集进行操作以启用其功能，并且显示为实际存在的PCI设备。创建 VF 后，可以直接将其指定给虚拟机或各个应用程序。此功能使得虚拟功能可以共享物理设备，并在没有CPU和虚拟机管理程序软件开销的情况下执行 I/O。</p></blockquote><h3 id="SR-IOV-with-RDMA"><a href="#SR-IOV-with-RDMA" class="headerlink" title="SR-IOV with RDMA"></a>SR-IOV with RDMA</h3><p>上面介绍了 SR-IOV 的基本概念，现在来说说什么时候会用到 SR-IOV，上周说我们产品中使用了 RDMA，那么在多种虚拟化平台下要想统一支持是比较困难的，KVM 是最轻松的，vSphere 就面临一个选择，SR-IOV 方式支持 vs vRDMA。</p><img src="/2020/03/12/SR-IOV-基本概念/sriov3.png" title="sriov3"><p>其中 SR-IOV 支持方式就如前面提到的概念一样，大概需要如下配置：</p><ul><li>在 BIOS 中启用网卡的 SR-IOV 功能</li><li>在 ESXi 安装 MFT vib 工具，用于管理和配置网卡 FW</li><li>在网卡 FW 中开启 SR-IOV，设置最大的 VF 数量</li><li>在 ESXi 网卡驱动中，开启 SRIOV，设置 VF 数量，需要重启 ESXi</li><li>创建对应的 vSwitch 并将 PF 作为上联网卡接入</li><li>创建虚拟机，添加 VF 作为 SR-IOV 网络适配器，并选择 PF 所在的 vSwitch 即可</li></ul><img src="/2020/03/12/SR-IOV-基本概念/sriov4.png" title="sriov4"><p>vRDMA 是 vSphere 提供的一种软件模拟 RDMA 的方式，但是他的性能受到很大影响，我们使用 RDMA 就是为了提高性能，所以这种就不会考虑了。<br>具体性能对比如下：</p><img src="/2020/03/12/SR-IOV-基本概念/sriov5.png" title="sriov5"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="SR-IOV-优点"><a href="#SR-IOV-优点" class="headerlink" title="SR-IOV 优点"></a>SR-IOV 优点</h3><ul><li>性能好</li><li>减少主机 CPU 消耗</li></ul><h3 id="SR-IOV-缺点"><a href="#SR-IOV-缺点" class="headerlink" title="SR-IOV 缺点"></a>SR-IOV 缺点</h3><ul><li>虚拟机使用 VF 后无法进行内存超分、快照、热迁移等高级功能</li><li>配置管理复杂</li></ul><p>不知道是不是接触的少，在日常中几乎没有遇到过使用 SR-IOV 的客户，只有少数客户会提出要有 SR-IOV 的需求，看到在 K8s 场景下有对应的 CNI 插件可以做到 SR-IOV 的管理，之后找时间看看是如何做到的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://octo.vmware.com/wp-content/uploads/2012/09/RDMAonvSphere.pdf" target="_blank" rel="noopener">https://octo.vmware.com/wp-content/uploads/2012/09/RDMAonvSphere.pdf</a></li><li><a href="https://docs.mellanox.com/pages/releaseview.action?pageId=15055422" target="_blank" rel="noopener">https://docs.mellanox.com/pages/releaseview.action?pageId=15055422</a></li><li><a href="https://en.wikipedia.org/wiki/Single-root_input/output_virtualization" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Single-root_input/output_virtualization</a></li><li><a href="https://github.com/intel/sriov-cni" target="_blank" rel="noopener">https://github.com/intel/sriov-cni</a></li><li><a href="https://github.com/hustcat/sriov-cni" target="_blank" rel="noopener">https://github.com/hustcat/sriov-cni</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上周了解了 RDMA 的基础概念之后，发现在 KVM 平台无需其他配置就可使用，但是在 vSphere 场景下，需要面临一个取舍，其中的一个
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第10周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/06/2020-%E7%AC%AC10%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/06/2020-第10周-LeetCode-记录/</id>
    <published>2020-03-06T13:10:06.000Z</published>
    <updated>2020-03-06T13:10:38.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number"><a href="#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number" class="headerlink" title="1365. How Many Numbers Are Smaller Than the Current Number"></a>1365. How Many Numbers Are Smaller Than the Current Number</h3><p>对数组升序排序，遍历排序后数组，判断是否与前一数字相同，若相同则该数字结果与前一结果相同，否则为当前索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums2 = sorted(nums)</span><br><span class="line">        mapping = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums2):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums2[i] == nums2[i<span class="number">-1</span>]:</span><br><span class="line">                mapping[nums2[i]] = mapping[nums2[i<span class="number">-1</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mapping[nums2[i]] = i</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res.append(mapping[num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1366-Rank-Teams-by-Votes"><a href="#1366-Rank-Teams-by-Votes" class="headerlink" title="1366. Rank Teams by Votes"></a>1366. Rank Teams by Votes</h3><p>考察排序，通过 dict 或者 list 统计所有字母的投票数值，然后进行排序，优先按照票数排序，如果票数相同，则按照字母序排序。</p><p>要熟练使用 sorted 和 sort.Slice 啊。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type votes: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(votes[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化哈希映射</span></span><br><span class="line">        ranking = collections.defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>] * n)</span><br><span class="line">        <span class="comment"># 遍历统计</span></span><br><span class="line">        <span class="keyword">for</span> vote <span class="keyword">in</span> votes:</span><br><span class="line">            <span class="keyword">for</span> i, vid <span class="keyword">in</span> enumerate(vote):</span><br><span class="line">                ranking[vid][i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 取出所有的键值对</span></span><br><span class="line">        result = list(ranking.items())</span><br><span class="line">        <span class="keyword">print</span> result</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        result.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], -ord(x[<span class="number">0</span>])), reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join([vid <span class="keyword">for</span> vid, rank <span class="keyword">in</span> result])</span><br></pre></td></tr></table></figure><h3 id="1367-Linked-List-in-Binary-Tree"><a href="#1367-Linked-List-in-Binary-Tree" class="headerlink" title="1367. Linked List in Binary Tree"></a>1367. Linked List in Binary Tree</h3><p>递归判断，比较当前 head 和 root、root.left、root.right，如果 head 为空，则表示已找到所有匹配的链表，返回 True，如果 root 为空或 root.val != head.val ，则返回 False，否则递归判断 head.next, root.left, root.right。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubPath</span><span class="params">(self, head, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(head, root) <span class="keyword">or</span> self.isSubPath(head, root.left) <span class="keyword">or</span> self.isSubPath(head, root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, head, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> root.val != head.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dfs(head.next, root.left) <span class="keyword">or</span> self.dfs(head.next, root.right)</span><br></pre></td></tr></table></figure><h3 id="1309-Decrypt-String-from-Alphabet-to-Integer-Mapping"><a href="#1309-Decrypt-String-from-Alphabet-to-Integer-Mapping" class="headerlink" title="1309. Decrypt String from Alphabet to Integer Mapping"></a>1309. Decrypt String from Alphabet to Integer Mapping</h3><p>简单粗暴的办法可以进行一个 map，先把所有的映射都记录好，然后逐个字符判断，该字符后的2位是否为 <code>#</code> ，来进行映射判断。比较取巧的办法是直接在原字符串上进行替换，不使用多余空间。</p><p>在进行字符串转换时，需要注意两位数是从 10 开始计算，而一位数是从 1 开始计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">27</span>):</span><br><span class="line">            s = s.replace( str(i) + <span class="string">'#'</span>,chr(ord(<span class="string">'j'</span>) - <span class="number">10</span> + i) )</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">            s = s.replace( str(i), chr(ord(<span class="string">'a'</span>) - <span class="number">1</span> + i ) )</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(st)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> st</span><br><span class="line">            <span class="keyword">return</span> chr(int(st) + <span class="number">96</span>)</span><br><span class="line">        </span><br><span class="line">        i, res = <span class="number">0</span>, <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">2</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">2</span>] == <span class="string">"#"</span>:</span><br><span class="line">                res += get(s[i : i + <span class="number">2</span>])</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += get(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1137-N-th-Tribonacci-Number"><a href="#1137-N-th-Tribonacci-Number" class="headerlink" title="1137. N-th Tribonacci Number"></a>1137. N-th Tribonacci Number</h3><p>泰波那契数，方法与斐波那契数一样，递归求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tibo</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> self.cache:</span><br><span class="line">                <span class="keyword">return</span> self.cache[n]</span><br><span class="line">            </span><br><span class="line">            self.cache[n] = tibo(n<span class="number">-1</span>) + tibo(n<span class="number">-2</span>) + tibo(n<span class="number">-3</span>)</span><br><span class="line">            <span class="keyword">return</span> self.cache[n]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tibo(n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number&quot;&gt;&lt;a href=&quot;#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number&quot; clas
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>systemd 常用操作及配置</title>
    <link href="https://zdyxry.github.io/2020/03/06/systemd-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>https://zdyxry.github.io/2020/03/06/systemd-常用操作及配置/</id>
    <published>2020-03-06T13:02:49.000Z</published>
    <updated>2020-03-06T23:42:56.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在大多数 Linux 发行版是由 systemd 来进行系统管理了， systemd 也是越来越复杂，但是常用的操作就那么多，今天来说说自己常用的操作及配置。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="daemon-reload"><a href="#daemon-reload" class="headerlink" title="daemon-reload"></a>daemon-reload</h3><p>在给系统新增服务的时候，通常要不断的改 test.service 配置文件，在改配置文件后，通常需要执行 <code>systemctl daemon-reload</code> 来重新加在 systemd 配置。</p><h3 id="no-page"><a href="#no-page" class="headerlink" title="no-page"></a>no-page</h3><p>通常使用 journalctl 查看服务日志，但是当日志超过当前行可显示最大字符数时，默认会将日志截断，此时可以使用 <code>journalctl -u &lt;service&gt; --no-page</code> 来让日志自动折行。</p><h3 id="disk-usage"><a href="#disk-usage" class="headerlink" title="disk-usage"></a>disk-usage</h3><p>systemd 日志配置文件在 <code>/etc/systemd/journald.conf</code> ，那么如果我想查看一个服务的日志占用空间，可以用 <code>journalctl -u &lt;servie&gt; --disk-usage</code> 命令查看。</p><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>Linux 下关机命令有很多， <code>init</code>,<code>shutdown</code>,<code>poweroff</code> ，但是如果你注意过会发现以下事实：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> ll `<span class="built_in">which</span> init`</span></span><br><span class="line">lrwxrwxrwx. 1 root root 22 8月  22 2019 /usr/sbin/init -&gt; ../lib/systemd/systemd</span><br><span class="line">root@localhost:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> ll `<span class="built_in">which</span> poweroff`</span></span><br><span class="line">lrwxrwxrwx. 1 root root 16 8月  22 2019 /usr/sbin/poweroff -&gt; ../bin/systemctl</span><br><span class="line">root@localhost:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> ll `<span class="built_in">which</span> shutdown`</span></span><br><span class="line">lrwxrwxrwx. 1 root root 16 8月  22 2019 /usr/sbin/shutdown -&gt; ../bin/systemctl</span><br></pre></td></tr></table></figure><p>是的，systemd 大法好，systemd 通过判断 <code>$0</code> 名称来执行对应命令，那我们就可以执行 <code>systemctl poweroff</code> 来进行关机。</p><h3 id="list-dependencies"><a href="#list-dependencies" class="headerlink" title="list-dependencies"></a>list-dependencies</h3><p>systemd 可以指定服务的依赖，在关键字 <code>After</code>,<code>Before</code>,<code>Requires</code> 来指定，通过 <code>systemctl list-dependencies &lt;service&gt;</code> 来显示服务的具体依赖路径。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Restart"><a href="#Restart" class="headerlink" title="Restart"></a>Restart</h3><p>大部分服务都是一个常驻进程，我们通常希望它能在 crash、kill、异常中断等情况下仍保持运行，所以我们可以在 <code>[Servie]</code> 中指定 <code>Restart=on-failure</code> 来完成目的。</p><h3 id="TimeoutStopSec"><a href="#TimeoutStopSec" class="headerlink" title="TimeoutStopSec"></a>TimeoutStopSec</h3><p>在通过 <code>systemctl stop</code> 进行服务停止时，如果在 <code>ExecStop</code> 中指定的操作耗时较长，我们可以通过添加 <code>TimeoutStopSec=10s</code> 来设置超时时间。</p><h3 id="RefuseManualStop"><a href="#RefuseManualStop" class="headerlink" title="RefuseManualStop"></a>RefuseManualStop</h3><p>如果有些服务我们只想让它处于启动状态，或者通过依赖自动启动，而不想受人为因素干扰，那么我们可以通过设置 <code>RefuseManualStop=true</code> 来保证服务无法被人工停止，比如 rdma.service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran 21:10:36 ~]$systemctl stop rdma</span><br><span class="line">Failed to stop rdma.service: Operation refused, unit rdma.service may be requested by dependency only (it is configured to refuse manual start/stop).</span><br><span class="line">See system logs and 'systemctl status rdma.service' for details.</span><br></pre></td></tr></table></figure><h3 id="PartOf"><a href="#PartOf" class="headerlink" title="PartOf"></a><code>PartOf</code></h3><p>与 Requires= 类似， 不同之处在于：仅作用于单元的停止或重启。 其含义是，当停止或重启这里列出的某个单元时， 也会同时停止或重启该单元自身。 注意，这个依赖是单向的， 该单元自身的停止或重启并不影响这里列出的单元。</p><p>如果 a.service 中包含了 PartOf=b.service ，那么这个依赖关系将在 b.service 的属性列表中显示为 ConsistsOf=a.service 。 也就是说，不能直接设置 ConsistsOf= 依赖。</p><h3 id><a href="#" class="headerlink" title="@"></a><code>@</code></h3><p>在 Linux 上配置过 openvpn 的同学应该都看到过一些 <a href="mailto:`openvpn@client.service" target="_blank" rel="noopener">`openvpn@client.service</a>` 这样的例子：</p><blockquote><p>若需在系统启动时自动启动 OpenVPN，对服务器端与客户端，都可以采用在对应机器上 启用 openvpn@<configuration>.service 的方式配置。例如，如果客户端配置文件是 /etc/openvpn/client.conf，则服务名称应为 <a href="mailto:openvpn@client.service" target="_blank" rel="noopener">openvpn@client.service</a>。或者，如果服务器端配置文件是 /etc/openvpn/server.conf，则服务名称应为 <a href="mailto:openvpn@server.service" target="_blank" rel="noopener">openvpn@server.service</a>。 </configuration></p></blockquote><p>我们来看下对应的 systemd 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yiran@t480:~/Downloads </span><br><span class="line"> $ cat /lib/systemd/system/openvpn@.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenVPN connection to %i</span><br><span class="line">PartOf=openvpn.service</span><br><span class="line">ReloadPropagatedFrom=openvpn.service</span><br><span class="line">Before=systemd-user-sessions.service</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Documentation=man:openvpn(8)</span><br><span class="line">Documentation=https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage</span><br><span class="line">Documentation=https://community.openvpn.net/openvpn/wiki/HOWTO</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">PrivateTmp=true</span><br><span class="line">WorkingDirectory=/etc/openvpn</span><br><span class="line">ExecStart=/usr/sbin/openvpn --daemon ovpn-%i --status /run/openvpn/%i.status 10 --cd /etc/openvpn --script-security 2 --config /etc/openvpn/%i.conf --writepid /run/openvpn/%i.pid</span><br><span class="line">PIDFile=/run/openvpn/%i.pid</span><br><span class="line">KillMode=process</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">CapabilityBoundingSet=CAP_IPC_LOCK CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW CAP_SETGID CAP_SETUID CAP_SYS_CHROOT CAP_DAC_OVERRIDE CAP_AUDIT_WRITE</span><br><span class="line">LimitNPROC=100</span><br><span class="line">DeviceAllow=/dev/null rw</span><br><span class="line">DeviceAllow=/dev/net/tun rw</span><br><span class="line">ProtectSystem=true</span><br><span class="line">ProtectHome=true</span><br><span class="line">RestartSec=5s</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>可以看到其实我们 <code>@</code> 后面的字段，对应的就是配置文件中的 <code>%i</code> ，这样可以让我们很方便的针对同一个应用的不同实例来创建对应的服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>systemd 大法好，博大精深。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wiki.archlinux.org/index.php/OpenVPN_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#systemd_%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/OpenVPN_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#systemd_%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE</a></li><li><a href="http://www.huzs.net/?p=2180" target="_blank" rel="noopener">http://www.huzs.net/?p=2180</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;现在大多数 Linux 发行版是由 systemd 来进行系统管理了， systemd 也是越来越复杂，但是常用的操作就那么多，今天来说说自
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>DMA &amp; RDMA 基本概念</title>
    <link href="https://zdyxry.github.io/2020/03/02/RDMA-%E6%A6%82%E5%BF%B5/"/>
    <id>https://zdyxry.github.io/2020/03/02/RDMA-概念/</id>
    <published>2020-03-02T11:56:16.000Z</published>
    <updated>2020-03-02T12:10:09.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司的存储系统要支持 RDMA 了，但是我连 RDMA 具体是啥还不清楚，今天花点时间来学习下相关知识。</p><p>在了解 RDMA 之前，需要先知道 DMA 是什么，所以会一点点说。</p><p>P.S. 本文部分内容截取自 《OSTEP》。</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><img src="/2020/03/02/RDMA-概念/rdma1.png" title="rdma1"><p>先来看一个典型的系统架构，其中，CPU 通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能 I/O 设备通过常规的I/O 总线（I/O bus）连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下面是外围总（peripheral bus），比如 SCSI、SATA 或者 USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。</p><p>为什么会用这样的分层架构？因为物理布局及造价成本。越快的总线长度越短，因此高性能的内存总线没有足够的空间来接太多设备。另外，在工程上高性能总线的造价非常高。所以，系统的设计采用了这种分层的方式，这样可以让要求高性能的设备（比如显卡）离 CPU 更近一些，低性能的设备离 CPU 远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。</p><h3 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h3><img src="/2020/03/02/RDMA-概念/rdma2.png" title="rdma2"><p>现在来看一个标准设备（不是真实存在的），通过它来帮助我们更好地理解设备交互的制。从图 中，可以看到一个包含两部分重要组件的设备。<br>第一部分是向系统其他部分展现的硬件接口（interface）。同软件一样，硬件也需要一些接口，让系统软件来控它的操作。因此，所有设备都有自己的特定接口以及典型交互的协议。<br>第二部分是它的内部结构（internal structure）。这部分包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口。非常简单的设备通常用一个或几个芯片来实现它们的功能。更复杂的设备会包含简单的 CPU、一些通用内存、设备相关的特定芯片，来完成它们的工作。例如，现代 RAID 控制器通常包含成百上千行固件（firmware，即硬件设备中的软件），以实现其功能。</p><h3 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h3><p>在图 36.2 中，一个（简化的）设备接口包含 3 个寄存器：一个状态（status）寄存器，可以读取并查看设备的当前状态；一个命令（command）寄存器，用于通知设备执行某个具体任务；一个数据（data）寄存器，将数据传给设备或从设备接收数据。通过读写这些寄存器，操作系统可以控制设备的行为。</p><p>我们现在来描述操作系统与该设备的典型交互，以便让设备为它做某事。协议如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">While (STATUS == BUSY)</span><br><span class="line">; // wait until device is not busy</span><br><span class="line">Write data to DATA register</span><br><span class="line">Write command to COMMAND register</span><br><span class="line">(Doing so starts the device and executes the command)</span><br><span class="line">While (STATUS == BUSY)</span><br><span class="line">; // wait until device is done with your request</span><br></pre></td></tr></table></figure><p>该协议包含 4 步：</p><ol><li>操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询（polling）设备（基本上，就是问它正在做什么）。</li><li>操作系统下发数据到数据寄存器。例如，你可以想象如果这是一个磁盘，需要多次写入操作，将一个磁盘块（比如 4KB）传递给设备。如果主 CPU 参与数据移动（就像这个示例协议一样），我们就称之为编程的 I/O（programmed I/O，PIO）。</li><li>操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。</li><li>操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令（有可能得到一个指示成功或失败的错误码）。</li></ol><p>这个简单的协议好处是足够简单并且有效。但是难免会有一些低效和不方便。我们注意到这个协议存在的第一个问题就是轮询过程比较低效，在等待设备执行完成命令时浪费大量 CPU 时间，如果此时操作系统可以切换执行下一个就绪进程，就可以大大提高 CPU 的利用率。</p><h3 id="利用中断减少-CPU-开销"><a href="#利用中断减少-CPU-开销" class="headerlink" title="利用中断减少 CPU 开销"></a>利用中断减少 CPU 开销</h3><p>多年前，工程师们发明了我们目前已经很常见的中断（interrupt）来减少 CPU 开销。有了中断后，CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发 CPU 跳转执行操作系统预先定义好的中断服务例程（Interrupt Service Routine，ISR），或更为简单的中断处理程序（interrupt handler）。中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且唤醒等待 I/O 的进程继续执行。因此，中断允许计算与 I/O 重叠（overlap），这是提高 CPU 利用率的关键。下面的时间线展示了这一点：</p><img src="/2020/03/02/RDMA-概念/rdma3.png" title="rdma3"><p>其中，进程 1 在 CPU 上运行一段时间（对应 CPU 那一行上重复的 1），然后发出一个读取数据的 I/O 请求给磁盘。如果没有中断，那么操作系统就会简单自旋，不断轮询设备状态，直到设备完成 I/O 操作（对应其中的 p）。当设备完成请求的操作后，进程 1 又可继续运行。</p><p>如果我们利用中断并允许重叠，操作系统就可以在等待磁盘操作时做其他事情：</p><img src="/2020/03/02/RDMA-概念/rdma4.png" title="rdma4"><p>在这个例子中，在磁盘处理进程 1 的请求时，操作系统在 CPU 上运行进程 2。磁盘处理完成后，触发一个中断，然后操作系统唤醒进程 1 继续运行。这样，在这段时间，无论CPU 还是磁盘都可以有效地利用。注意，使用中断并非总是最佳方案。假如有一个非常高性能的设备，它处理请求很快：通常在 CPU 第一次轮询时就可以返回结果。此时如果使用中断，反而会使系统变慢：切换到其他进程，处理中断，再切换回之前的进程代价不小。因此，如果设备非常快，那么最好的办法反而是轮询。如果设备比较慢，那么采用允许发生重叠的中断更好。如果设备的速度未知，或者时快时慢，可以考虑使用混合（hybrid）策略，先尝试轮询一小段时间，如果设备没有完成操作，此时再使用中断。这种两阶段（two-phased）的办法可以实现两种方法的好处。</p><p>另一个最好不要使用中断的场景是网络。网络端收到大量数据包，如果每一个包都发生一次中断，那么有可能导致操作系统发生活锁（livelock），即不断处理中断而无法处理用户层的请求。例如，假设一个 Web 服务器因为“点杠效应”而突然承受很重的负载。这种情况下，偶尔使用轮询的方式可以更好地控制系统的行为，并允许 Web 服务器先服务一些用户请求，再回去检查网卡设备是否有更多数据包到达。另一个基于中断的优化就是合并（coalescing）。设备在抛出中断之前往往会等待一小段时间，在此期间，其他请求可能很快完成，因此多次中断可以合并为一次中断抛出，从而降低处理中断的代价。当然，等待太长会增加请求的延迟，这是系统中常见的折中。</p><h3 id="利用-DMA-进行更高效的数据传送"><a href="#利用-DMA-进行更高效的数据传送" class="headerlink" title="利用 DMA 进行更高效的数据传送"></a>利用 DMA 进行更高效的数据传送</h3><p>标准协议还有一点需要我们注意。具体来说，如果使用编程的 I/O 将一大块数据传给设备，CPU 又会因为琐碎的任务而变得负载很重，浪费了时间和算力，本来更好是用于运行其他进程。下面的时间线展示了这个问题：</p><img src="/2020/03/02/RDMA-概念/rdma6.png" title="rdma6"><p>进程 1 在运行过程中需要向磁盘写一些数据，所以它开始进行 I/O 操作，将数据从内存拷贝到磁盘（其中标示 c 的过程）。拷贝结束后，磁盘上的 I/O 操作开始执行，此时 CPU 才可以处理其他请求。</p><p>解决方案就是使用 DMA（Direct Memory Access）。DMA 引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要 CPU 介入。DMA 工作过程如下。为了能够将数据传送给设备，操作系统会通过编程告诉 DMA 引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以<br>处理其他请求了。当 DMA 的任务完成后，DMA 控制器会抛出一个中断来告诉操作系统自己已经完成数据传输。修改后的时间线如下：</p><img src="/2020/03/02/RDMA-概念/rdma7.png" title="rdma7"><p>从时间线中可以看到，数据的拷贝工作都是由 DMA 控制器来完成的。因为 CPU 在此时是空闲的，所以操作系统可以让它做一些其他事情，比如此处调度进程 2 到 CPU 来运行。因此进程 2 在进程 1 再次运行之前可以使用更多的 CPU。</p><h2 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>远程直接内存访问（英语：remote direct memory access，RDMA）是一种绕过远程主机操作系统内核访问其内存中数据的技术，由于不经过操作系统，不仅节省了大量CPU资源，同样也提高了系统吞吐量、降低了系统的网络通信延迟，尤其适合在大规模并行计算机集群中有广泛应用。在基于NVMe over Fabric的数据中心中，RDMA可以配合高性能的NVMe SSD构建高性能、低延迟的存储网络。</p></blockquote><p>这类绕过操作系统内核的技术称为内核旁路（Kernel-Bypass）。Kernel-Bypass 框架/API 有：DPDK、ibverbs 。</p><img src="/2020/03/02/RDMA-概念/rdma8.png" title="rdma8"><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>远程直接内存访问<br>在某些场景下类似于 DMA<br>低延迟<br>毫秒级别，无内核调用时间<br>零拷贝<br>无需拷贝 I/O buffers<br>硬件处理信息传输，节省 CPU</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>贵。我能想到的只有贵。<br>来自开发了大半年的 wenquan 同学总结：<br>编程，调优麻烦<br>与性能相关的点很多<br>对网络环境要求高<br>…</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="InfiniBand"><a href="#InfiniBand" class="headerlink" title="InfiniBand"></a>InfiniBand</h4><p>InfiniBand 是指两种完全不同的东西。一个是 InfiniBand 网络的物理链接层协议，另一个是高级编程 API，名为 InfiniBand Verbs API。InfiniBand Verbs API 是一种远程直接内存访问（RDMA）技术的实施。<br>InfiniBand 需要全套的网络设备才可以支持，成本高，性能好。</p><h4 id="RoCE-amp-iWARP"><a href="#RoCE-amp-iWARP" class="headerlink" title="RoCE &amp; iWARP"></a>RoCE &amp; iWARP</h4><p>iWARP，以通过Internet协议网络进行有效的数据传输。由于iWARP 基于TCP 协议因此它对网络的要求不高，可以在各种环境中部署，成本低，性能也是最差的。<br>RoCE，基于融合以太网的RDMA（英语：RDMA over Converged Ethernet，缩写RoCE）是一个网络协议，允许在一个以太网网络上使用远程直接内存访问（RDMA）。RoCE有RoCE v1和RoCE v2两个版本。RoCE v1是一个以太网链路层协议，因此允许同一个以太网广播域中的任意两台主机间进行通信。RoCE v2是一个网络层协议，因而RoCE v2数据包可以被路由。虽然RoCE协议受益于融合以太网网络的特征，但该协议也可用于传统或非融合的以太网网络，成本中等，性能比 IB 略差。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/</a></li><li><a href="https://www.junmajinlong.com/os/io_dma_rdma/" target="_blank" rel="noopener">https://www.junmajinlong.com/os/io_dma_rdma/</a></li><li><a href="https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf" target="_blank" rel="noopener">https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE</a></li><li><a href="https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf" target="_blank" rel="noopener">https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf</a></li><li><a href="https://www.mellanox.com/pdf/whitepapers/IB_Intro_WP_190.pdf" target="_blank" rel="noopener">https://www.mellanox.com/pdf/whitepapers/IB_Intro_WP_190.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司的存储系统要支持 RDMA 了，但是我连 RDMA 具体是啥还不清楚，今天花点时间来学习下相关知识。&lt;/p&gt;
&lt;p&gt;在了解 RDMA
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第9周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/02/28/2020-%E7%AC%AC9%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/02/28/2020-第9周-LeetCode-记录/</id>
    <published>2020-02-28T11:35:45.000Z</published>
    <updated>2020-02-28T11:37:15.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1300-Sum-of-Mutated-Array-Closest-to-Target"><a href="#1300-Sum-of-Mutated-Array-Closest-to-Target" class="headerlink" title="1300. Sum of Mutated Array Closest to Target"></a>1300. Sum of Mutated Array Closest to Target</h3><p>对 arr 进行降序排序，将 arr 中的最小值乘以 arr 长度与 target比较，若比 target 小，则将其丢弃，并将其从 target 中减去。<br>若 arr 为空，则表示 arr 中最大值乘以 arr 长度仍比 target 小，则返回 arr 中的最大值。<br>若 arr 不为空，则表示 arr 中存在大于目标值的数值，取 target 除以此时 arr 长度（arr 中所有数值均大于目标值），最终值四舍五入得到目标值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBestValue</span><span class="params">(self, arr, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        arr.sort(reverse = <span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> arr <span class="keyword">and</span> target &gt;= arr[<span class="number">-1</span>]*len(arr):</span><br><span class="line">            temp = arr[<span class="number">-1</span>]</span><br><span class="line">            target -= arr.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        res = target/float(len(arr))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res % <span class="number">1</span> &gt; <span class="number">0.5</span>:</span><br><span class="line">            <span class="keyword">return</span> int(res)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><p>也可用二分方式做，取 [0, max(arr)] 中间值为 mid，对 arr 求和：若数值大于 mid则取 mid，求和结果与 target 比较。<br>记录最小差值和最小差值时 mid 值，若求和数值大于 target，则将上限置为 mid-1，否则将下限置为 mid+1，如果求和数值与 target 相等，则直接返回 mid。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBestValue</span><span class="params">(self, arr, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">0</span>, max(arr)</span><br><span class="line">        sub, ans = float(<span class="string">"inf"</span>), float(<span class="string">"inf"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            tmp = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">if</span> num &gt; mid:</span><br><span class="line">                    tmp += mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp += num</span><br><span class="line">            </span><br><span class="line">            cur_sub = abs(tmp - target)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> cur_sub &lt; sub:</span><br><span class="line">                sub = cur_sub</span><br><span class="line">                ans = mid</span><br><span class="line">            <span class="keyword">elif</span> cur_sub == sub:</span><br><span class="line">                ans = min(ans, mid)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> tmp &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> tmp &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> tmp == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1299-Replace-Elements-with-Greatest-Element-on-Right-Side"><a href="#1299-Replace-Elements-with-Greatest-Element-on-Right-Side" class="headerlink" title="1299. Replace Elements with Greatest Element on Right Side"></a>1299. Replace Elements with Greatest Element on Right Side</h3><p>按照题意暴力解法，时间接近5s。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceElements</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> i == len(arr)<span class="number">-1</span>:</span><br><span class="line">                arr[i] = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">return</span> arr</span><br><span class="line">            arr[i] = max(arr[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>正确姿势为从后向前比较，每次比较最大值与 arr[i] 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceElements</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        greatest = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; greatest:</span><br><span class="line">                arr[i] = greatest</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[i], greatest = greatest, arr[i]</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h3 id="1363-Largest-Multiple-of-Three"><a href="#1363-Largest-Multiple-of-Three" class="headerlink" title="1363. Largest Multiple of Three"></a>1363. Largest Multiple of Three</h3><p>这是一道数学题，当一个数字可以被 3 整除时，那么这个数字每一位相加之和也可被 3 整除。</p><p>倒序排序，计算所有数字之和，如果可以被 3 整除，那么直接返回；<br>如果余数为1，则从数组中尝试删除 1，4，7 其中一个；<br>如果余数为2，则从数组中尝试删除 2，5，8 其中一个；<br>若仍不满足条件，且余数为 2 ，则从数组中尝试删除 1，4，7 其中两个；<br>若仍不满足条件，且余数为 1 ，则从数组中尝试删除 2，5，8 其中两个；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestMultipleOfThree</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        total = sum(A)</span><br><span class="line">        count = collections.Counter(A)</span><br><span class="line">        A.sort(reverse=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> count[i]:</span><br><span class="line">                A.remove(i)</span><br><span class="line">                count[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> any(A): <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">            <span class="keyword">if</span> sum(A) % <span class="number">3</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">''</span>.join(map(str, A))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> count[<span class="number">1</span>] + count[<span class="number">4</span>] + count[<span class="number">7</span>]:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">1</span>) <span class="keyword">or</span> f(<span class="number">4</span>) <span class="keyword">or</span> f(<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> count[<span class="number">2</span>] + count[<span class="number">5</span>] + count[<span class="number">8</span>]:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">2</span>) <span class="keyword">or</span> f(<span class="number">5</span>) <span class="keyword">or</span> f(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">1</span>) <span class="keyword">or</span> f(<span class="number">1</span>) <span class="keyword">or</span> f(<span class="number">4</span>) <span class="keyword">or</span> f(<span class="number">4</span>) <span class="keyword">or</span> f(<span class="number">7</span>) <span class="keyword">or</span> f(<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">2</span>) <span class="keyword">or</span> f(<span class="number">2</span>) <span class="keyword">or</span> f(<span class="number">5</span>) <span class="keyword">or</span> f(<span class="number">5</span>) <span class="keyword">or</span> f(<span class="number">8</span>) <span class="keyword">or</span> f(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="1362-Closest-Divisors"><a href="#1362-Closest-Divisors" class="headerlink" title="1362. Closest Divisors"></a>1362. Closest Divisors</h3><p>求 num 的平方根，倒序排序后，依次遍历检测是否被 (num + 1) 或 (num + 2) 整除，若整除则为所求结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestDivisors</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, int((num + <span class="number">2</span>) ** <span class="number">0.5</span>) + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (num + <span class="number">1</span>) % i:</span><br><span class="line">                <span class="keyword">return</span> [i, (num + <span class="number">1</span>) // i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (num + <span class="number">2</span>) % i:</span><br><span class="line">                <span class="keyword">return</span> [i, (num + <span class="number">2</span>) // i]</span><br></pre></td></tr></table></figure><h3 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228. Summary Ranges"></a>228. Summary Ranges</h3><p>这道题我在实际应用中遇到过，具体问题可以看这篇记录 <a href="https://zdyxry.github.io/2019/04/11/%E8%AE%B0%E4%B8%80%E6%AC%A1-libcgroup-%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/">《记一次 libcgroup 配置失败》</a> 。</p><p>记录当前连续数字的 start 和 end，并遍历数组进行判断，如果 num = end + 1 ，那么更新 end 数值，如果不等于，那么将这段数字转换为字符串并添加到结果中，并重置 start &amp; end。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ranges = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> ranges</span><br><span class="line"></span><br><span class="line">        start, end = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(nums) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(nums) <span class="keyword">and</span> nums[i] == end + <span class="number">1</span>:</span><br><span class="line">                end = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                interval = str(start)</span><br><span class="line">                <span class="keyword">if</span> start != end:</span><br><span class="line">                    interval += <span class="string">"-&gt;"</span> + str(end)</span><br><span class="line">                ranges.append(interval)</span><br><span class="line">                <span class="keyword">if</span> i &lt; len(nums):</span><br><span class="line">                    start = end = nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ranges</span><br></pre></td></tr></table></figure><p>p.s. 贴一下自己用 shell 写的，写完就看不懂了。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function format_qemu_processors &#123;</span><br><span class="line">    # cgconfig.service could not be active when libcgroup &lt;= libcgroup-0.41-20.el7 and config field &gt;= 100 char</span><br><span class="line">    # use `-` format qemu_processors</span><br><span class="line">    # example:</span><br><span class="line">    # qemu_processors input (6,7,8,9,10),  output is "6-10"</span><br><span class="line">    # qemu_processors input (10,9,8,7,6),  output is "6-10"</span><br><span class="line">    # qemu_processors input (6,7,8,10,11), output is "6-8,10-11"</span><br><span class="line">    # qemu_processors input (1,3,5,7,9),   output is "1,3,5,7,9"</span><br><span class="line"></span><br><span class="line">    IFS=$'\n' sorted=($(sort -n &lt;&lt;&lt;"$&#123;qemu_processors[*]&#125;"))</span><br><span class="line">    unset IFS</span><br><span class="line"></span><br><span class="line">    QEMU_CPUS=""</span><br><span class="line">    TAG=""</span><br><span class="line">    for i in "$&#123;!sorted[@]&#125;";do</span><br><span class="line">        if [[ "$&#123;sorted[(i+1)]&#125;" == `expr $&#123;sorted[i]&#125; + 1` ]];then</span><br><span class="line">            if [[ $&#123;sorted[(i-1)]&#125; == $TAG ]];then</span><br><span class="line">                TAG=$&#123;sorted[i]&#125;</span><br><span class="line">                continue</span><br><span class="line">            fi</span><br><span class="line">            QEMU_CPUS=$QEMU_CPUS"$&#123;sorted[i]&#125;"</span><br><span class="line">            QEMU_CPUS=$QEMU_CPUS"-"</span><br><span class="line">            TAG="$&#123;sorted[i]&#125;"</span><br><span class="line">        else</span><br><span class="line">            QEMU_CPUS=$QEMU_CPUS"$&#123;sorted[i]&#125;"</span><br><span class="line">            if [[ $&#123;sorted[i]&#125;  != $&#123;sorted[-1]&#125; ]];then</span><br><span class="line">                QEMU_CPUS=$QEMU_CPUS","</span><br><span class="line">            fi</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    echo $&#123;QEMU_CPUS&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1300-Sum-of-Mutated-Array-Closest-to-Target&quot;&gt;&lt;a href=&quot;#1300-Sum-of-Mutated-Array-Closest-to-Target&quot; class=&quot;headerlink&quot; title=&quot;1300. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>zipstreamer 源码阅读</title>
    <link href="https://zdyxry.github.io/2020/02/21/zipstreamer-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2020/02/21/zipstreamer-源码阅读/</id>
    <published>2020-02-21T11:33:08.000Z</published>
    <updated>2020-02-21T14:07:52.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前的一篇博客<a href="https://zdyxry.github.io/2020/02/07/HTTP-Content-Length-%E5%AD%A6%E4%B9%A0/">《HTTP Content-Length 学习》</a> 中提到自己踩了一个坑，就是 <code>content-length</code> 与实际大小不匹配导致文件下载失败，在解决过程中用到了 zipstreamer ，今天来看看 zipstreamer 是如何工作的。</p><h2 id="zipfile"><a href="#zipfile" class="headerlink" title="zipfile"></a>zipfile</h2><p>Python 标准库中提供了 zipfile 用来对 Zip 文件进行操作，可以进行 Zip 的创建、写入、读取、解压等动作，但是 zipfile 只能对文件进行操作，没办法传入 stream，所以能做的操作有限。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        f = open(<span class="string">"file"</span> + str(i) + <span class="string">".txt"</span>, <span class="string">'w'</span>)</span><br><span class="line">        f.write(str(i))</span><br><span class="line">        f.close()</span><br><span class="line"> </span><br><span class="line">    f = zipfile.ZipFile(<span class="string">'filename.zip'</span>, <span class="string">'w'</span>, zipfile.ZIP_DEFLATED)</span><br><span class="line">    f.write(<span class="string">'file1.txt'</span>)</span><br><span class="line">    f.write(<span class="string">'file2.txt'</span>)</span><br><span class="line">    f.write(<span class="string">'file3.txt'</span>)</span><br><span class="line">    f.close()</span><br><span class="line"> </span><br><span class="line">    f = zipfile.ZipFile(<span class="string">'filename.zip'</span>)</span><br><span class="line">    f.extractall()</span><br><span class="line">    f.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h2 id="zipstreamer"><a href="#zipstreamer" class="headerlink" title="zipstreamer"></a>zipstreamer</h2><p>在提供文件下载接口时，有一个比较常见的需求是传过来一个 stream，然后我们要将 stream 作为 Zip 中的一个文件转发出去，实时下载，这时候就需要 zipstreamer 来实现了。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">z = ZipStream(files=[</span><br><span class="line">    ZipFile(<span class="string">'file.txt'</span>, <span class="number">4</span>, <span class="keyword">lambda</span>: StringIO(<span class="string">'test'</span>), <span class="keyword">None</span>, <span class="keyword">None</span>),</span><br><span class="line">    ZipFile(<span class="string">'emptydir/'</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>),</span><br><span class="line">    ZipFile(<span class="string">'dir/remote.txt'</span>, remote_file_size, get_remote_file, <span class="keyword">None</span>, <span class="keyword">None</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">size = z.size()</span><br><span class="line"></span><br><span class="line">res = Response(z.generate(), mimetype=<span class="string">'application/zip'</span>)</span><br><span class="line">res.headers[<span class="string">'Content-Length'</span>] = str(size)</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>在看代码之前，我们先看下 zip 文件的数据格式：</p><img src="/2020/02/21/zipstreamer-源码阅读/zip2.png" title="Zip Format"><img src="/2020/02/21/zipstreamer-源码阅读/zip.png" title="Zip Format"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/project/python-zipstreamer/zipstreamer</span><br><span class="line">master ✔ $ tree .</span><br><span class="line">.</span><br><span class="line">├── compat.py # py2 py3 兼容</span><br><span class="line">├── __init__.py # 主要逻辑</span><br><span class="line">└── __version__.py # 版本信息</span><br></pre></td></tr></table></figure><p>zipstreamer 的目录结构比较简单，所有逻辑都在 <code>__init__.py</code> 中，先来看看 <code>compat.py</code> 中做了什么，根据 Python 版本来决定 BytesIO 的引用，修改下默认的 str 定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#: Python 2.x?</span></span><br><span class="line">IS_PY2 = (_VER[<span class="number">0</span>] == <span class="number">2</span>)</span><br><span class="line"><span class="comment">#: Python 3.x?</span></span><br><span class="line">IS_PY3 = (_VER[<span class="number">0</span>] == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_PY2:</span><br><span class="line">    <span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO <span class="keyword">as</span> BytesIO</span><br><span class="line">    str = unicode</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> IS_PY3:</span><br><span class="line">    <span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">    str = str</span><br></pre></td></tr></table></figure><p>那么来看看 <code>__init__.py</code> 中都定义了哪些类，根据示例我们知道有 <code>ZipStream</code>，并且它肯定实现了 <code>generate</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipStream</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, files, comment=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_incr</span><span class="params">(self, buf)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_file</span><span class="params">(self, zip_file)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_dir_entry</span><span class="params">(self, entry)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_zip_file</span><span class="params">(self)</span>:</span></span><br></pre></td></tr></table></figure><p>先来看看构造函数中定义了什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, files, comment=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(comment, str):</span><br><span class="line">        <span class="keyword">raise</span> ZipFileBytesRequired(<span class="string">'ZIP comment should bytes'</span>)</span><br><span class="line">    <span class="comment"># 所有 ZipFile 的集合</span></span><br><span class="line">    self.files = files</span><br><span class="line">    self.comment = comment</span><br><span class="line">    <span class="comment"># 定义初始值及必要的 flag</span></span><br><span class="line">    self._dir = <span class="keyword">None</span></span><br><span class="line">    self._pos = <span class="keyword">None</span> <span class="comment"># 计算文件大小时用到</span></span><br><span class="line">    self._generating = <span class="keyword">False</span></span><br><span class="line">    self._calculate_size = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>最终传给 Response 的是 <code>z.generate()</code> ，所以先看看 <code>generate()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数中定义的 flag，因为是生成器，如果已经执行过那么后续执行都会异常，所以这里提前判断</span></span><br><span class="line">    <span class="keyword">if</span> self._generating:</span><br><span class="line">        <span class="keyword">raise</span> ZipFileInProgress(<span class="string">'ZipFile generator already in progress'</span>)</span><br><span class="line"></span><br><span class="line">    self._generating = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> self._generate_zip_file():</span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._generating = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>继续看 <code>self._generate_zip_file()</code> 这里是整个 zipstreamer 中最核心的逻辑，包含了 Zip 文件内容定义，数据格式定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_zip_file</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._dir = []</span><br><span class="line">    self._pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> zip_file <span class="keyword">in</span> self.files:</span><br><span class="line">        <span class="comment"># 生成文件数据</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> self._generate_file(zip_file):</span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line">    <span class="comment"># 这里可以判断 self._generate_file 会修改 self._pos</span></span><br><span class="line">    start = self._pos</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> self._dir:</span><br><span class="line">        <span class="comment"># 生成文件夹数据</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> self._generate_dir_entry(entry):</span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line">    <span class="comment"># 同样 self._generate_dir_entry 也会修改 self._pos</span></span><br><span class="line">    end = self._pos</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以猜测在 self._generate_dir_entry 会更新 self._dir</span></span><br><span class="line">    cent_dir_count = len(self._dir)</span><br><span class="line">    cent_dir_size = end - start</span><br><span class="line">    cent_dir_offset = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据条件判断最终 Zip 文件是否为 64 位</span></span><br><span class="line">    <span class="keyword">if</span> (cent_dir_count &gt;= UINT16_MAX <span class="keyword">or</span> cent_dir_size &gt;= UINT32_MAX <span class="keyword">or</span> cent_dir_offset &gt;= UINT32_MAX):</span><br><span class="line">        zip64_end_rec = struct.pack(</span><br><span class="line">            STRUCT_END_ARCHIVE64, STRING_END_ARCHIVE64, <span class="number">44</span>, ZIP_VERSION_45,</span><br><span class="line">            ZIP_VERSION_45, <span class="number">0</span>, <span class="number">0</span>, cent_dir_count, cent_dir_count,</span><br><span class="line">            cent_dir_size, cent_dir_offset)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self._incr(zip64_end_rec)</span><br><span class="line"></span><br><span class="line">        zip64_loc_rec = struct.pack(</span><br><span class="line">            STRUCT_END_ARCHIVE64_LOCATOR, STRING_END_ARCHIVE64_LOCATOR, <span class="number">0</span>,</span><br><span class="line">            end, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self._incr(zip64_loc_rec)</span><br><span class="line"></span><br><span class="line">        cent_dir_count = UINT16_MAX</span><br><span class="line">        cent_dir_size = UINT32_MAX</span><br><span class="line">        cent_dir_offset = UINT32_MAX</span><br><span class="line"></span><br><span class="line">    eocd_comment = <span class="string">b''</span> <span class="keyword">if</span> self.comment <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> self.comment</span><br><span class="line"></span><br><span class="line">    endrec = struct.pack(</span><br><span class="line">        STRUCT_END_ARCHIVE, STRING_END_ARCHIVE, <span class="number">0</span>, <span class="number">0</span>, cent_dir_count,</span><br><span class="line">        cent_dir_count, cent_dir_size, cent_dir_offset, len(eocd_comment))</span><br><span class="line">    <span class="comment"># 返回 Zip 格式要求的 central 部分</span></span><br><span class="line">    <span class="keyword">yield</span> self._incr(endrec)</span><br><span class="line">    <span class="keyword">yield</span> self._incr(eocd_comment)</span><br></pre></td></tr></table></figure><p><code>self._generate_file</code> 和 <code>self._generate_dir_entry</code> 都涉及到具体的 Zip 数据格式的定义，这里不详细展开了，需要注意的是在 <code>self._generate_file</code> 中的传输 chunk 大小的定义，一次返回的数据大小为 4096字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> file_obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        buf = file_obj.read(<span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> buf:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="文件大小计算"><a href="#文件大小计算" class="headerlink" title="文件大小计算"></a>文件大小计算</h3><p>在示例代码中我们使用 <code>z.size()</code> 来获取打包后的 Zip 文件大小，来看看这里是怎么获取的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._generating:</span><br><span class="line">        <span class="keyword">raise</span> ZipFileInProgress(</span><br><span class="line">            <span class="string">'ZipFile generator already in progress. You need to call'</span></span><br><span class="line">            <span class="string">' size() before generate()'</span>)</span><br><span class="line"></span><br><span class="line">    self._calculate_size = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行一次 generate() 方法</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> self.generate():</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._calculate_size = <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 最终返回 self._pos</span></span><br><span class="line">    <span class="keyword">return</span> self._pos</span><br></pre></td></tr></table></figure><p>在 zipstream 执行 yield 的时候，都是跟着 <code>self._incr</code> 的，这里保存这文件大小的计算逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_incr</span><span class="params">(self, buf)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> isinstance(buf, str)</span><br><span class="line"></span><br><span class="line">    self._pos += len(buf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf</span><br></pre></td></tr></table></figure><p>我们只需要保证我们返回的所有数据都用 <code>self._incr</code> 封装了，那么最终的 <code>self._pos</code> 就是文件的总大小。</p><h3 id="Zip-文件格式"><a href="#Zip-文件格式" class="headerlink" title="Zip 文件格式"></a>Zip 文件格式</h3><p>大概了解了 zipstream 是怎么做的，回过头来看看 Zip 的文件格式，根据 yield 顺序汇总一下，可以看到与我们在看代码之前看到的 Zip 文件格式图表是一致的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># files</span></span><br><span class="line"><span class="keyword">yield</span> self._incr(header)</span><br><span class="line"><span class="keyword">yield</span> self._incr(filename)</span><br><span class="line"><span class="keyword">yield</span> self._incr(extra)</span><br><span class="line"><span class="keyword">yield</span> self._incr(buf)</span><br><span class="line"><span class="keyword">yield</span> self._incr(data_descriptor)</span><br><span class="line"><span class="comment"># dirs</span></span><br><span class="line"><span class="keyword">yield</span> self._incr(central_dir)</span><br><span class="line"><span class="keyword">yield</span> self._incr(entry.filename)</span><br><span class="line"><span class="keyword">yield</span> self._incr(extra)</span><br><span class="line"><span class="keyword">yield</span> self._incr(entry.comment)</span><br><span class="line"><span class="comment"># zip structure</span></span><br><span class="line"><span class="keyword">yield</span> self._incr(zip64_end_rec)</span><br><span class="line"><span class="keyword">yield</span> self._incr(zip64_loc_rec)</span><br><span class="line"><span class="keyword">yield</span> self._incr(endrec)</span><br><span class="line"><span class="keyword">yield</span> self._incr(eocd_comment)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/koofr/python-zipstreamer" target="_blank" rel="noopener">https://github.com/koofr/python-zipstreamer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在之前的一篇博客&lt;a href=&quot;https://zdyxry.github.io/2020/02/07/HTTP-Content-Leng
      
    
    </summary>
    
    
      <category term="Python" scheme="https://zdyxry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>K8s drain 命令源码阅读</title>
    <link href="https://zdyxry.github.io/2020/02/15/K8s-drain-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2020/02/15/K8s-drain-源码阅读/</id>
    <published>2020-02-15T03:22:13.000Z</published>
    <updated>2020-02-15T07:17:20.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前写过一篇 <a href="https://zdyxry.github.io/2019/08/01/Kubernetes-%E5%AE%9E%E6%88%98-%E5%B9%B3%E6%BB%91%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/">《Kubernetes 实战-平滑移除节点》</a> 讲如何从 K8s 集群中移除节点的，今天来看看 <code>kubectl drain</code> 命令具体做了什么，怎么实现的。</p><h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h2><p><code>drain</code> 相关命令都属于 <code>kubectl</code> 的自命令，因此需要先看下 <code>kubectl</code> 的入口，K8s 使用 cobra 作为命令行构建组建（我自己使用 cobra 觉得不怎么好用，而且文档也不清晰。。），统一入口在 <code>cmd/kubectl/kubectl.go</code> ，实际的处理逻辑在 <code>pkg/kubectl/cmd/cmd.go</code> 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   ...</span><br><span class="line">groups := templates.CommandGroups&#123;</span><br><span class="line">&#123;</span><br><span class="line">Message: <span class="string">"Basic Commands (Beginner):"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Message: <span class="string">"Deploy Commands:"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Message: <span class="string">"Cluster Management Commands:"</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">certificates.NewCmdCertificate(f, ioStreams),</span><br><span class="line">clusterinfo.NewCmdClusterInfo(f, ioStreams),</span><br><span class="line">top.NewCmdTop(f, ioStreams),</span><br><span class="line">drain.NewCmdCordon(f, ioStreams),</span><br><span class="line">drain.NewCmdUncordon(f, ioStreams),</span><br><span class="line">drain.NewCmdDrain(f, ioStreams),</span><br><span class="line">taint.NewCmdTaint(f, ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">   groups.Add(cmds)</span><br></pre></td></tr></table></figure><p>可以看到在 <code>kubectl</code> 所有子命令的入口，我们今天要看的 <code>drain</code> 命令都属于集群管理命令，包含了：</p><ul><li>cordon</li><li>uncordon</li><li>drain</li></ul><h2 id="Cordon"><a href="#Cordon" class="headerlink" title="Cordon"></a>Cordon</h2><p>先来看看 <code>cordon</code> 命令，这条命令的用途是标记节点为不可调度状态，防止在进行节点维护时 K8s 仍调度资源到该节点上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCmdCordon</span><span class="params">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">o := NewDrainCmdOptions(f, ioStreams)</span><br><span class="line"></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:                   <span class="string">"cordon NODE"</span>,</span><br><span class="line">DisableFlagsInUseLine: <span class="literal">true</span>,</span><br><span class="line">Short:                 i18n.T(<span class="string">"Mark node as unschedulable"</span>),</span><br><span class="line">Long:                  cordonLong,</span><br><span class="line">Example:               cordonExample,</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">cmdutil.CheckErr(o.Complete(f, cmd, args))</span><br><span class="line">cmdutil.CheckErr(o.RunCordonOrUncordon(<span class="literal">true</span>))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Flags().StringVarP(&amp;o.drainer.Selector, <span class="string">"selector"</span>, <span class="string">"l"</span>, o.drainer.Selector, <span class="string">"Selector (label query) to filter on"</span>)</span><br><span class="line">cmdutil.AddDryRunFlag(cmd)</span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看 <code>Run</code> 中的内容，先忽略 <code>cmdutil.CheckErr</code> ，这里主要执行了两个方法：<code>o.Complete</code> 和 <code>o.RunCordonOrUncordon</code> 。这里就必须提一下 <code>kubectl</code> 的实现方式，<code>kubectl</code> 的根本目的是发送对应的 HTTP 请求到 APIServer，<code>kubectl</code> 通过 <code>Builder</code> 和 <code>Visitor</code> 来实现了一层封装，使每个子命令的实现方式统一、简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder provides convenience functions for taking arguments and parameters</span></span><br><span class="line"><span class="comment">// from the command line and converting them to a list of resources to iterate</span></span><br><span class="line"><span class="comment">// over using the Visitor interface.</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Visitor lets clients walk a list of resources.</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">Visit(VisitorFunc) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>o.Complete</code> 中构建了对应的 <code>builder</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 根据命令行参数构建 builder 实例</span></span><br><span class="line">builder := f.NewBuilder().</span><br><span class="line">WithScheme(scheme.Scheme, scheme.Scheme.PrioritizedVersionsAllGroups()...).</span><br><span class="line">NamespaceParam(o.Namespace).DefaultNamespace().</span><br><span class="line">ResourceNames(<span class="string">"nodes"</span>, args...).</span><br><span class="line">SingleResourceType().</span><br><span class="line">Flatten()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(o.drainer.Selector) &gt; <span class="number">0</span> &#123;</span><br><span class="line">builder = builder.LabelSelectorParam(o.drainer.Selector).</span><br><span class="line">ResourceTypes(<span class="string">"nodes"</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// builder.Do 返回带有 Visitor 的 Result 对象</span></span><br><span class="line">    r := builder.Do()</span><br></pre></td></tr></table></figure><p>来看看 <code>builder.Do()</code> 接下来是怎么做的来返回了 Result 类型资源：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Do</span><span class="params">()</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用 visitorResult 返回 Result 类型</span></span><br><span class="line">r := b.visitorResult()</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">visitorResult</span><span class="params">()</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 跳过其他步骤，直接看最简单的通过 Name 来获取 Result</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(b.names) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.visitByName()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">visitByName</span><span class="params">()</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明 Result 对象</span></span><br><span class="line">result := &amp;Result&#123;</span><br><span class="line">singleItemImplied:  <span class="built_in">len</span>(b.names) == <span class="number">1</span>,</span><br><span class="line">targetsSingleItems: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取 K8s client</span></span><br><span class="line">client, err := b.getClient(mapping.GroupVersionKind.GroupVersion())</span><br><span class="line">...</span><br><span class="line">visitors := []Visitor&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> b.names &#123;</span><br><span class="line">info := &amp;Info&#123;</span><br><span class="line">Client:    client,</span><br><span class="line">Mapping:   mapping,</span><br><span class="line">Namespace: selectorNamespace,</span><br><span class="line">Name:      name,</span><br><span class="line">Export:    b.export,</span><br><span class="line">&#125;</span><br><span class="line">visitors = <span class="built_in">append</span>(visitors, info)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// VisitorList 也实现了 Visit 接口，遍历执行 Visitor 的 Visit 方法</span></span><br><span class="line">result.visitor = VisitorList(visitors)</span><br><span class="line">result.sources = visitors</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了如何获取 Result 类型对象，我们再来看 <code>o.Complete</code> 如何处理的，传入一个 VisitorFunc，Result 的 visitor 都实现了 <code>Visit</code> 接口，<code>Visit</code> 接口的作用是接收 <code>VisitorFunc</code> 并执行。 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> r.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *resource.Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v DecoratedVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> v.decorators &#123;</span><br><span class="line"><span class="keyword">if</span> err := v.decorators[i](info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看 <code>o.RunCordonOrUncordon</code> 做了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DrainCmdOptions)</span> <span class="title">RunCordonOrUncordon</span><span class="params">(desired <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cordonOrUncordon := <span class="string">"cordon"</span></span><br><span class="line"><span class="keyword">if</span> !desired &#123;</span><br><span class="line">cordonOrUncordon = <span class="string">"un"</span> + cordonOrUncordon</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 通过 Visit 获取到的 nodeInfos 列表</span></span><br><span class="line"><span class="keyword">for</span> _, nodeInfo := <span class="keyword">range</span> o.nodeInfos &#123;</span><br><span class="line">        ...</span><br><span class="line">gvk := nodeInfo.ResourceMapping().GroupVersionKind</span><br><span class="line"><span class="keyword">if</span> gvk.Kind == <span class="string">"Node"</span> &#123;</span><br><span class="line">c, err := drain.NewCordonHelperFromRuntimeObject(nodeInfo.Object, scheme.Scheme, gvk)</span><br><span class="line"><span class="keyword">if</span> updateRequired := c.UpdateIfRequired(desired); !updateRequired &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> o.drainer.DryRunStrategy != cmdutil.DryRunClient &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// 修改对应节点的配置</span></span><br><span class="line">err, patchErr := c.PatchOrReplace(o.drainer.Client, o.drainer.DryRunStrategy == cmdutil.DryRunServer)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CordonHelper)</span> <span class="title">PatchOrReplace</span><span class="params">(clientset kubernetes.Interface, serverDryRun <span class="keyword">bool</span>)</span> <span class="params">(error, error)</span></span> &#123;</span><br><span class="line">client := clientset.CoreV1().Nodes()</span><br><span class="line">    oldData, err := json.Marshal(c.node)</span><br><span class="line">    <span class="comment">// 更新 node Spec 的 Unschedulable 字段</span></span><br><span class="line">c.node.Spec.Unschedulable = c.desired</span><br><span class="line">newData, err := json.Marshal(c.node)</span><br><span class="line">    <span class="comment">// merge 数据，通过 diff 然后获取</span></span><br><span class="line">patchBytes, patchErr := strategicpatch.CreateTwoWayMergePatch(oldData, newData, c.node)</span><br><span class="line"><span class="keyword">if</span> patchErr == <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">_, err = client.Patch(context.TODO(), c.node.Name, types.StrategicMergePatchType, patchBytes, patchOptions)</span><br><span class="line">&#125; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Drain"><a href="#Drain" class="headerlink" title="Drain"></a>Drain</h2><p>看完了 Cordon，再来看 Drain：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCmdDrain</span><span class="params">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">...</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">cmdutil.CheckErr(o.Complete(f, cmd, args))</span><br><span class="line">cmdutil.CheckErr(o.RunDrain())</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>直接看 <code>o.RunDrain</code>，我们会看到第一件事情就就是执行 <code>o.RunCordonOrUncordon</code> ，就是标记节点为不可调度，所以我之前写的那篇博客其实说法不正确，如果是想将节点下线，那么直接执行 <code>kubectl drain</code> 就好：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DrainCmdOptions)</span> <span class="title">RunDrain</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := o.RunCordonOrUncordon(<span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">drainedNodes := sets.NewString()</span><br><span class="line"><span class="keyword">var</span> fatal error</span><br><span class="line"><span class="keyword">for</span> _, info := <span class="keyword">range</span> o.nodeInfos &#123;</span><br><span class="line">        <span class="comment">// 驱逐 Pod</span></span><br><span class="line"><span class="keyword">if</span> err := o.deleteOrEvictPodsSimple(info); err == <span class="literal">nil</span> &#123;</span><br><span class="line">drainedNodes.Insert(info.Name)</span><br><span class="line">printObj(info.Object, o.Out)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果驱逐 Pod 失败，则显示对应的 Node 信息</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(remainingNodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Fprintf(o.ErrOut, <span class="string">"There are pending nodes to be drained:\n"</span>)</span><br><span class="line"><span class="keyword">for</span> _, nodeName := <span class="keyword">range</span> remainingNodes &#123;</span><br><span class="line">fmt.Fprintf(o.ErrOut, <span class="string">" %s\n"</span>, nodeName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>deleteOrEvictPodsSimple</code> 中，先通过 Node 名称获取对应的 Pod 信息，然后进行驱逐动作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DrainCmdOptions)</span> <span class="title">deleteOrEvictPodsSimple</span><span class="params">(nodeInfo *resource.Info)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">list, errs := o.drainer.GetPodsForDeletion(nodeInfo.Name)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> err := o.drainer.DeleteOrEvictPods(list.Pods()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>GetPodsForDeletion</code> 会进行一个过滤，包含以下几种场景的过滤，需要注意的是，这里的过滤场景是有严格的顺序的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Helper)</span> <span class="title">makeFilters</span><span class="params">()</span> []<span class="title">podFilter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []podFilter&#123;</span><br><span class="line">        <span class="comment">// 被标记删除的 Pod(DeletionTimestamp 不为0)</span></span><br><span class="line">        d.skipDeletedFilter,</span><br><span class="line">        <span class="comment">// 属于 DaemonSet 的 Pod</span></span><br><span class="line">        d.daemonSetFilter,</span><br><span class="line">        <span class="comment">// mirror pod 其实就是 static pod，</span></span><br><span class="line">        <span class="comment">// 是我们在 /etc/kubernetes/manifests/ 中定义的由 kubelet 负责生命周期管理的 Pod</span></span><br><span class="line">        <span class="comment">// 在 `Annotations` 中会包含 `kubernetes.io/config.mirror` </span></span><br><span class="line">        d.mirrorPodFilter,</span><br><span class="line">        <span class="comment">// 包含本地存储的 Pod，Pod 中的 Volume 字段不为空</span></span><br><span class="line">        d.localStorageFilter,</span><br><span class="line">        <span class="comment">// 不属于 replicate 的 pod，`Controlled By` 不为空的 pod</span></span><br><span class="line">d.unreplicatedFilter,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到过滤后的 Pod 列表后，就开始执行驱逐动作，每个 Pod 起一个 goroutine ，提交驱逐动作后会等待，直到 Pod 驱逐完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Helper)</span> <span class="title">evictPods</span><span class="params">(pods []corev1.Pod, policyGroupVersion <span class="keyword">string</span>, getPodFn <span class="keyword">func</span>(namespace, name <span class="keyword">string</span>)</span> <span class="params">(*corev1.Pod, error)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">returnCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line">ctx, cancel := context.WithTimeout(d.getContext(), globalTimeout)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(pod corev1.Pod, returnCh <span class="keyword">chan</span> error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// 驱逐超时</span></span><br><span class="line">returnCh &lt;- fmt.Errorf(<span class="string">"error when evicting pod %q: global timeout reached: %v"</span>, pod.Name, globalTimeout)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 驱逐 Pod 动作，最终执行 d.Client.PolicyV1beta1().Evictions(eviction.Namespace).Evict(eviction)</span></span><br><span class="line">err := d.EvictPod(pod, policyGroupVersion)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">params := waitForDeleteParams&#123;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待驱逐动作完成</span></span><br><span class="line">_, err := waitForDelete(params)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">returnCh &lt;- <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">returnCh &lt;- fmt.Errorf(<span class="string">"error when waiting for pod %q terminating: %v"</span>, pod.Name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(pod, returnCh)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>waitForDelete</code> 如果没有立即完成，会将 <code>ConditionFunc</code> 传入 <code>WaitFor</code> 循环检测，其中 <code>ConditionFunc</code> 的检测依据是 Pod 存在且 ObjectMeta UID发生了改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitFor</span><span class="params">(wait WaitFunc, fn ConditionFunc, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stopCh)</span><br><span class="line">c := wait(stopCh)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> _, open := &lt;-c:</span><br><span class="line">ok, err := runConditionWithCrashProtection(fn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !open &#123;</span><br><span class="line"><span class="keyword">return</span> ErrWaitTimeout</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span> ErrWaitTimeout</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>kubectl drain</code> 相关命令的实现还是很简单的，没有特别负责的逻辑，K8s 能够做到这种效果一个重要的原因是所有动作都是声明式的，声明之后等待执行完成就好，不需要主动的去做某些很脏的动作。在驱逐 Pod 的行为中，并不是所有的 Pod 都会被驱逐到其他节点，这里需要格外的注意，在节点下线前需要检查是否有单纯的 Pod 资源仍在节点上运行，是否有使用本地存储的 Pod等类似情况。</p><p>平时写代码很糙，见到这种多种设计模式组合的形式看了半天，找机会重新学习下设计模式。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://qiankunli.github.io/2018/12/23/kubernetes_source_kubectl.html" target="_blank" rel="noopener">https://qiankunli.github.io/2018/12/23/kubernetes_source_kubectl.html</a></li><li><a href="https://juejin.im/post/5a113e686fb9a0452936596c" target="_blank" rel="noopener">https://juejin.im/post/5a113e686fb9a0452936596c</a></li><li><a href="https://rootdeep.github.io/k8s-source-code-analysis/kubectl/construct-visitor.html" target="_blank" rel="noopener">https://rootdeep.github.io/k8s-source-code-analysis/kubectl/construct-visitor.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前写过一篇 &lt;a href=&quot;https://zdyxry.github.io/2019/08/01/Kubernetes-%E5%AE%
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Content-Length 学习</title>
    <link href="https://zdyxry.github.io/2020/02/07/HTTP-Content-Length-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zdyxry.github.io/2020/02/07/HTTP-Content-Length-学习/</id>
    <published>2020-02-07T14:54:14.000Z</published>
    <updated>2020-02-07T14:56:22.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前提供了一个用于下载文件的 API，使用到了 <code>Content-Length</code> 字段并踩了个坑： <code>Content-Length</code> 与实际的数据大小不一致。今天来学习下这个字段相关的知识。</p><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><blockquote><p>Content-Length 是一个实体消息首部，用来指明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目。</p></blockquote><p>当客户端向服务器发送一个请求时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端需要接收多少数据。除了使用 <code>Transfer-Encoding</code>，当<code>Content-Length</code> 存在是必须与实际传输的数据大小一致，如果前者大，则会导致请求一直等待直至超时；如果后者大，则会导致数据被截断，在最近版本的 Chrome 中，会直接提示 <code>net::ERR_CONTENT_LENGTH_MISMATCH</code> 报错导致加载失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">w.Header().Set(<span class="string">"Content-Length"</span>, <span class="string">"20"</span>)</span><br><span class="line"><span class="comment">//w.Header().Set("Content-Length", "12")</span></span><br><span class="line">w.WriteHeader(<span class="number">200</span>)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world\n"</span>))</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request URL: http://127.0.0.1:8080/</span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: 200 OK</span><br><span class="line">Remote Address: 127.0.0.1:8080</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line">Content-Length: 12</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Date: Fri, 07 Feb 2020 14:36:40 GMT</span><br><span class="line">X-DNS-Prefetch-Control: off</span><br></pre></td></tr></table></figure><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><img src="/2020/02/07/HTTP-Content-Length-学习/http.png" title="Transfer-Encoding"><blockquote><p>Transfer-Encoding 消息首部指明了将 entity 安全传递给用户所采用的编码形式。Transfer-Encoding 是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。一个多节点连接中的每一段都可以应用不同的Transfer-Encoding 值。</p></blockquote><p>如果在传输前不知道消息大小，那么就可以使用 <code>Transfer-Encoding</code> 。当设置了 <code>Transfer-Encoding</code> ， <code>Content-Length</code> 会被忽略，两者无法共存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"io"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world, the web server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        w.WriteHeader(<span class="number">200</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">                io.WriteString(w, <span class="string">"hello, world!\n"</span>)</span><br><span class="line">                w.(http.Flusher).Flush()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, HelloServer)</span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request URL: http://127.0.0.1:8080/</span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: 200 OK</span><br><span class="line">Remote Address: 127.0.0.1:8080</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Date: Fri, 07 Feb 2020 13:56:54 GMT</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-DNS-Prefetch-Control: off</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length</a></li><li><a href="https://blog.piaoruiqing.com/2019/09/08/do-you-know-content-length/#Content-Length-3" target="_blank" rel="noopener">https://blog.piaoruiqing.com/2019/09/08/do-you-know-content-length/#Content-Length-3</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前提供了一个用于下载文件的 API，使用到了 &lt;code&gt;Content-Length&lt;/code&gt; 字段并踩了个坑： &lt;code&gt;Con
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://zdyxry.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Server-Sent Events 简单使用</title>
    <link href="https://zdyxry.github.io/2020/02/03/Server-Sent-Events-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://zdyxry.github.io/2020/02/03/Server-Sent-Events-简单使用/</id>
    <published>2020-02-02T23:36:46.000Z</published>
    <updated>2020-02-02T23:37:14.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在刷 Twitter 的时候，发现 Twitter 会实时更新已加载页面的内容，以为是 Websocket，看了下请求发现是 Server-sent events，之前没有了解过这个，今天来学习一下。</p><h2 id="Server-sent-events"><a href="#Server-sent-events" class="headerlink" title="Server-sent events"></a>Server-sent events</h2><p>引用维基百科：</p><blockquote><p>Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via HTTP connection. The Server-Sent Events EventSource API is standardized as part of HTML5[1] by the W3C. </p></blockquote><p>SSE 通常与 Websocket 相比较：</p><ul><li>SSE 提供单向通信，Websocket 提供双向通信；</li><li>SSE 是通过 HTTP 协议实现的，Websocket 是单独的协议；</li><li>实现上来说 SSE 比较容易，Websocket 复杂一些；</li><li>对浏览器来说，IE/Edge 不支持 SSE，其它的都是支持的。</li><li>SSE 有最大连接数限制</li><li>WS 可以传输二进制数据和文本数据，而 SSE 只有文本数据</li></ul><p>SSE 使用场景：</p><ul><li>股票行情自动收录</li><li>社交网站自动更新（Twitter）</li><li>…</li></ul><p>Websocket 使用场景：</p><ul><li>VNC</li><li>协同编辑</li><li>…</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Golang 有 <a href="https://github.com/antage/eventsource" target="_blank" rel="noopener">eventsource</a> 可以直接使用，示例如下：</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"gopkg.in/antage/eventsource.v1"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        es := eventsource.New(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">defer</span> es.Close()</span><br><span class="line">        http.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"./public"</span>)))</span><br><span class="line">        http.Handle(<span class="string">"/events"</span>, es)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                        <span class="comment">// 每 2 秒发送一条消息，并打印对应客户端数量</span></span><br><span class="line">                        es.SendEventMessage(<span class="string">"hello"</span>, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">                        log.Printf(<span class="string">"Hello has been sent (consumers: %d)"</span>, es.ConsumersCount())</span><br><span class="line">                        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        log.Print(<span class="string">"Open URL http://localhost:8080/ in your browser."</span>)</span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      window.addEventListener("DOMContentLoaded", function () &#123;</span></span><br><span class="line"><span class="undefined">        var evsrc = new EventSource("/events");</span></span><br><span class="line"><span class="undefined">        evsrc.onmessage = function (ev) &#123;</span></span><br><span class="line"><span class="undefined">          document.getElementById("log")</span></span><br><span class="line"><span class="xml">            .insertAdjacentHTML("beforeend", "<span class="tag">&lt;<span class="name">li</span>&gt;</span>" + ev.data + "<span class="tag">&lt;/<span class="name">li</span>&gt;</span>");</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        evsrc.onerror = function (ev) &#123;</span></span><br><span class="line"><span class="undefined">          console.log("readyState = " + ev.currentTarget.readyState);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"log"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SSE 很适合 Twitter 这种场景，还特意观察了下微博，发现微博没有。。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource" target="_blank" rel="noopener">https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在刷 Twitter 的时候，发现 Twitter 会实时更新已加载页面的内容，以为是 Websocket，看了下请求发现是 Serve
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zdyxry.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>使用 Raft 实现 VIP 功能</title>
    <link href="https://zdyxry.github.io/2020/01/17/%E4%BD%BF%E7%94%A8-Raft-%E5%AE%9E%E7%8E%B0-VIP-%E5%8A%9F%E8%83%BD/"/>
    <id>https://zdyxry.github.io/2020/01/17/使用-Raft-实现-VIP-功能/</id>
    <published>2020-01-17T14:48:28.000Z</published>
    <updated>2020-01-17T14:49:46.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HAProxy 也存在单点故障，因此需要多个 HAProxy 来保证业务不中断，这时候我们需要另一个软件配合：Keepalived。通常我用 Keepalived 仅用来提供 VIP，保证当一个 Keepalived 故障，VIP 自动在其他 Keepalived 节点配置。</p><p>Keepalived 有一个问题是 virtual route ID 必须是同一网段内唯一的，当我们想要在一个网段内部署多个集群时，就需要人为的介入去分配 virtual route ID，不方便。这次来使用 Raft 自己实现 VIP 逻辑。</p><h2 id="hashicorp-raft"><a href="#hashicorp-raft" class="headerlink" title="hashicorp/raft"></a>hashicorp/raft</h2><p>Raft 有很多开源实现，其中 Hashicorp 实现的 <a href="https://github.com/hashicorp/raft" target="_blank" rel="noopener">Raft 库</a> 已经被 Consul 等软件使用，且接口友善，选择使用它来实现。在 Github 上有很多 Raft 的使用示例，比较简单且完整的是 <a href="https://github.com/otoolep/hraftd" target="_blank" rel="noopener">otoolep/hraftd</a>，我们来看看他是怎么使用的。</p><h3 id="otoolep-hraftd"><a href="#otoolep-hraftd" class="headerlink" title="otoolep/hraftd"></a>otoolep/hraftd</h3><h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><p>在 main.go 中主要做了 4 件事情：<code>store.New</code>, <code>store.Open</code>, <code>http.New</code>, <code>http.Start</code>，先来看看程序是如何启动的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置命令行参数</span></span><br><span class="line">flag.BoolVar(&amp;inmem, <span class="string">"inmem"</span>, <span class="literal">false</span>, <span class="string">"Use in-memory storage for Raft"</span>)</span><br><span class="line">...</span><br><span class="line">flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: %s [options] &lt;raft-data-path&gt; \n"</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">flag.PrintDefaults()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解析命令行参数</span></span><br><span class="line">flag.Parse()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建一个 Store 对象</span></span><br><span class="line">s := store.New(inmem)</span><br><span class="line">s.RaftDir = raftDir</span><br><span class="line">    s.RaftBind = raftAddr</span><br><span class="line">    <span class="comment">// 运行 Store </span></span><br><span class="line"><span class="keyword">if</span> err := s.Open(joinAddr == <span class="string">""</span>, nodeID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to open store: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 新建一个 http 对象并运行</span></span><br><span class="line">h := httpd.New(httpAddr, s)</span><br><span class="line"><span class="keyword">if</span> err := h.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to start HTTP service: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 joinAddr 参数不为空，则处理 join 请求</span></span><br><span class="line"><span class="keyword">if</span> joinAddr != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := join(joinAddr, raftAddr, nodeID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to join node at %s: %s"</span>, joinAddr, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"hraftd started successfully"</span>)</span><br><span class="line">    <span class="comment">// 监听系统信号，若接收到 os.Interrupt 则程序退出</span></span><br><span class="line">terminate := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(terminate, os.Interrupt)</span><br><span class="line">&lt;-terminate</span><br><span class="line">log.Println(<span class="string">"hraftd exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>看了 main.go 我们知道调用了 <code>http.Start</code>， 先不管 Store 是什么，先来看看 http 相关实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start starts the service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Service 实现了 ServeHTTP 方法</span></span><br><span class="line">http.Handle(<span class="string">"/"</span>, s)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := server.Serve(s.ln)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(r.URL.Path, <span class="string">"/key"</span>) &#123;</span><br><span class="line">s.handleKeyRequest(w, r)</span><br><span class="line">    <span class="comment">// 先忽略其他分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要处理请求的是 <code>s.handleKeyRequest</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">handleKeyRequest</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"GET"</span>:</span><br><span class="line">k := getKey()</span><br><span class="line"><span class="keyword">if</span> k == <span class="string">""</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">&#125;</span><br><span class="line">v, err := s.store.Get(k)</span><br><span class="line">...</span><br><span class="line">io.WriteString(w, <span class="keyword">string</span>(b))</span><br><span class="line"><span class="keyword">case</span> <span class="string">"POST"</span>:</span><br><span class="line"><span class="comment">// Read the value from the POST body.</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> err := s.store.Set(k, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在 <code>s.handleKeyRequest</code> 中根据请求方法，去调用 store 对应的方法，那么 store 实现了哪些接口呢？这也是在 http 模块中定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(key <span class="keyword">string</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">Set(key, value <span class="keyword">string</span>) error</span><br><span class="line">Delete(key <span class="keyword">string</span>) error</span><br><span class="line">Join(nodeID <span class="keyword">string</span>, addr <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 Join 看着比较奇怪，其他的都是一个 K/V 系统该有的接口，接下来就看看 Store 具体方法的实现。</p><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>这个模块的编写涉及到了 Raft 中的具体概念，建议先阅读 siddontang 写的 Raft 相关博客快速了解（链接在参考链接列出）。</p><p>以下以设置 Key 为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.raft.State() != raft.Leader &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"not leader"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装具体执行的动作</span></span><br><span class="line">c := &amp;command&#123;</span><br><span class="line">Op:    <span class="string">"set"</span>,</span><br><span class="line">Key:   key,</span><br><span class="line">Value: value,</span><br><span class="line">&#125;</span><br><span class="line">b, err := json.Marshal(c)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将 command 应用于 FSM</span></span><br><span class="line">f := s.raft.Apply(b, raftTimeout)</span><br><span class="line"><span class="keyword">return</span> f.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 FSM Apply 方法实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply applies a Raft log entry to the key-value store.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fsm)</span> <span class="title">Apply</span><span class="params">(l *raft.Log)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">var</span> c command</span><br><span class="line"><span class="comment">// 根据操作动作的不同，执行不同的方法，这里以设置 Key 为例</span></span><br><span class="line"><span class="keyword">switch</span> c.Op &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"set"</span>:</span><br><span class="line"><span class="keyword">return</span> f.applySet(c.Key, c.Value)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fsm)</span> <span class="title">applySet</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    f.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.mu.Unlock()</span><br><span class="line">    <span class="comment">// 设置 Map 中的 Key/Value</span></span><br><span class="line">f.m[key] = value</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h4><p>看了上面的具体动作实现，接下来看看 Raft 具体启动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">Open</span><span class="params">(enableSingle <span class="keyword">bool</span>, localID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置 Raft 配置</span></span><br><span class="line">config := raft.DefaultConfig()</span><br><span class="line">config.LocalID = raft.ServerID(localID)</span><br><span class="line">    <span class="comment">// 设置 Raft 通信</span></span><br><span class="line">addr, err := net.ResolveTCPAddr(<span class="string">"tcp"</span>, s.RaftBind)</span><br><span class="line">    ...</span><br><span class="line">transport, err := raft.NewTCPTransport(s.RaftBind, addr, <span class="number">3</span>, <span class="number">10</span>*time.Second, os.Stderr)</span><br><span class="line">    <span class="comment">// 设置 Raft 存储对象</span></span><br><span class="line">snapshots, err := raft.NewFileSnapshotStore(s.RaftDir, retainSnapshotCount, os.Stderr)</span><br><span class="line"><span class="keyword">var</span> logStore raft.LogStore</span><br><span class="line"><span class="keyword">var</span> stableStore raft.StableStore</span><br><span class="line"><span class="keyword">if</span> s.inmem &#123;</span><br><span class="line">logStore = raft.NewInmemStore()</span><br><span class="line">stableStore = raft.NewInmemStore()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">boltDB, err := raftboltdb.NewBoltStore(filepath.Join(s.RaftDir, <span class="string">"raft.db"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"new bolt store: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">logStore = boltDB</span><br><span class="line">stableStore = boltDB</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 创建 raft 示例，并使用该 raft 实例启动集群</span></span><br><span class="line">ra, err := raft.NewRaft(config, (*fsm)(s), logStore, stableStore, snapshots, transport)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"new raft: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s.raft = ra</span><br><span class="line"><span class="keyword">if</span> enableSingle &#123;</span><br><span class="line">...</span><br><span class="line">ra.BootstrapCluster(configuration)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 Raft 所需接口为 FSM 和 Snapshot，具体的实现方式根据需求来实现，一般与 hraftd 相仿，大概了解了 hashicorp/raft 的使用，那么我们来实现具体的 VIP 功能。</p><h2 id="VIP"><a href="#VIP" class="headerlink" title="VIP"></a>VIP</h2><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>既然是跟 IP 相关，那么肯定需要给对应网卡配置时间，在 Linux 中我们可以通过 <code>ip</code> 命令来设置，Golang 中使用 <a href="https://github.com/vishvananda/netlink" target="_blank" rel="noopener">vishvananda/netlink</a> 来实现。</p><p> <code>netlink.AddrAdd</code> 可以在指定的网络设备上添加 IP 地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nc *NetworkConfig)</span> <span class="title">addIP</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">res, err := nc.IsSet()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"ip check in AddIP failed"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := netlink.AddrAdd(nc.link, nc.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"could not add ip"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>netlink.AddrDel</code> 可以将 IP 从指定网络设备上删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nc *NetworkConfig)</span> <span class="title">delIP</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">res, err := nc.IsSet()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"ip check in DelIP failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !res &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := netlink.AddrDel(nc.link, nc.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"could not delete ip"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="raft-1"><a href="#raft-1" class="headerlink" title="raft"></a>raft</h3><p>实现了 IP 设置相关，我们不需要提供 HTTP 接口，直接编写 Raft 相关实现，跟 hraftd 实现不同，在 hraftd 中需要进行信息写入读取，而我们的 VIP 仅依赖于 Raft 选举 Leader，所以只需要编写好对应的方法，不需要做额外操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FSM <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fsm FSM)</span> <span class="title">Apply</span><span class="params">(log *raft.Log)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fsm FSM)</span> <span class="title">Restore</span><span class="params">(snap io.ReadCloser)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fsm FSM)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="params">(raft.FSMSnapshot, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Snapshot&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(snapshot Snapshot)</span> <span class="title">Persist</span><span class="params">(sink raft.SnapshotSink)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(snapshot Snapshot)</span> <span class="title">Release</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serve"><a href="#serve" class="headerlink" title="serve"></a>serve</h3><p>基础方法都已经实现了，那么接下来编写集群启动逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *VIPManager)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化 raft 配置、存储对象、通信</span></span><br><span class="line"><span class="keyword">for</span> id, ip := <span class="keyword">range</span> manager.peers &#123;</span><br><span class="line">configuration.Servers = <span class="built_in">append</span>(configuration.Servers, raft.Server&#123;ID: raft.ServerID(id), Address: raft.ServerAddress(ip)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Raft 集群，这里与 hraftd 不同，需要注意</span></span><br><span class="line"><span class="keyword">if</span> error := raft.BootstrapCluster(config, logStore, stableStore, snapshots, transport, configuration); error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 raft 实例</span></span><br><span class="line">raftServer, error := raft.NewRaft(config, manager.fsm, logStore, stableStore, snapshots, transport)</span><br><span class="line">    ...</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">isLeader := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 服务启动时先删除 VIP，防止集群中同时存在节点都配置了 VIP</span></span><br><span class="line">manager.deleteIP(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 当前节点是 Leader 节点，则设置 VIP</span></span><br><span class="line"><span class="keyword">case</span> leader := &lt;-raftServer.LeaderCh():</span><br><span class="line"><span class="keyword">if</span> leader &#123;</span><br><span class="line">isLeader = <span class="literal">true</span></span><br><span class="line">log.Info(<span class="string">"Leading"</span>)</span><br><span class="line">manager.addIP(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 定时检测，如果是 Leader，则检测 VIP 是否正确设置，如果没有就再次配置 VIP</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line"><span class="keyword">if</span> isLeader &#123;</span><br><span class="line">result, error := manager.networkConfigurator.IsSet()</span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">log.WithFields(log.Fields&#123;<span class="string">"error"</span>: error, <span class="string">"ip"</span>: manager.networkConfigurator.IP(), <span class="string">"interface"</span>: manager.networkConfigurator.Interface()&#125;).Error(<span class="string">"Could not check ip"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result == <span class="literal">false</span> &#123;</span><br><span class="line">log.Error(<span class="string">"Lost IP"</span>)</span><br><span class="line"></span><br><span class="line">manager.addIP(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里与 hraftd 的实现不同，hraftd 先实例 raft，然后使用该 raft 实例启动集群，这样做的好处是哪怕集群只有一个节点，就是第一个节点，那么集群也是可以正常工作的，坏处是集群启动顺序是固定的，必须要先启动第一个节点，然后其他节点通过 Join 请求添加到 Raft 集群中（我们忽略了 Join 的走读）。</p><p>重新想一下我们的需求：集群、高可用、故障。当这几个词放在一起，我们就知道 hraftd 的方法不适合我们，有以下原因：</p><ol><li>集群节点启动顺序要求</li><li>各个节点配置文件不同，有的需要 Join 参数</li></ol><p>所以我们是直接使用 <code>raft.BootstrapCluster</code> 来启动集群，虽然只有一个节点集群无法正常工作，但是这个是可以容忍的。</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在实现完上述功能后，我以为大功告成了，就开始自测，但是测试过程中发现了很诡异的现象，虽然我们通过 Raft 自身选举实现了 VIP 的故障自动漂移，但是实际测试中发现业务访问随着 VIP 的重建并没有立即恢复，，检查 ARP 记录发现集群中各个节点关于 VIP 的 ARP 记录各不相同，甚至是完全不同。</p><p>我们来重温下 ARP 协议内容：</p><blockquote><p>地址解析协议（英語：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。ARP最初在1982年的RFC 826（征求意见稿）[1]中提出并纳入互联网标准 STD 37. ARP 也可能指是在多数操作系统中管理其相关地址的一个进程。</p></blockquote><blockquote><p>在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p></blockquote><p>如果 VIP 与真实节点对应的 MAC 地址不同，就相当于 ARP 攻击了，所以我们的 Leader 节点设置完 VIP 后，还需要发送 ARP 请求广播，告诉广播域中的其他节点 VIP 正确的 MAC 地址。采用的方式是 gratuitous ARP（免费 ARP）。这里我们直接找一个开源的 ARP 实现来完成这个需求：</p><p><a href="https://github.com/google/seesaw" target="_blank" rel="noopener">google/seesaw</a> 是一个负载均衡器，里面实现了这个功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARPSendGratuitous sends a gratuitous ARP message via the specified interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ncc *SeesawNCC)</span> <span class="title">ARPSendGratuitous</span><span class="params">(arp *ncctypes.ARPGratuitous, out *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">iface, err := net.InterfaceByName(arp.IfaceName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get interface %q: %v"</span>, arp.IfaceName, err)</span><br><span class="line">&#125;</span><br><span class="line">log.V(<span class="number">2</span>).Infof(<span class="string">"Sending gratuitous ARP for %s (%s) via %s"</span>, arp.IP, iface.HardwareAddr, iface.Name)</span><br><span class="line">m, err := gratuitousARPReply(arp.IP, iface.HardwareAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sendARP(iface, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 hashicorp/raft 可以很简单方便的实现需要选举 Leader 的分布式应用，虽然我司的 Slogan 是 <code>Make IT Simple</code> ，但是愈发感觉 Hashicorp 才是这句话的忠实体现，他们的 Terraform、Vault、Consul、Nomad、Vagrant 等软件，都是让基础设施的适用与管理更简单方便的，还是很爽的。</p><p>本文的具体实现在 <a href="https://github.com/zdyxry/sparrow" target="_blank" rel="noopener">sparrow</a> 可以看到。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/138b4d267084" target="_blank" rel="noopener">https://www.jianshu.com/p/138b4d267084</a></li><li><a href="https://www.jianshu.com/p/2b60542640e2" target="_blank" rel="noopener">https://www.jianshu.com/p/2b60542640e2</a></li><li><a href="https://www.jianshu.com/p/1bbd7162727d" target="_blank" rel="noopener">https://www.jianshu.com/p/1bbd7162727d</a></li><li><a href="https://www.jianshu.com/p/99562bfec5c2" target="_blank" rel="noopener">https://www.jianshu.com/p/99562bfec5c2</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE</a></li><li><a href="https://github.com/darxkies/virtual-ip/blob/master/pkg/manager.go" target="_blank" rel="noopener">https://github.com/darxkies/virtual-ip/blob/master/pkg/manager.go</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HA
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPad T480 &amp; Ubuntu 19.10 连接多显示器方式</title>
    <link href="https://zdyxry.github.io/2020/01/12/ThinkPad-T480-Ubuntu-19-10-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://zdyxry.github.io/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/</id>
    <published>2020-01-12T12:26:35.000Z</published>
    <updated>2020-01-12T13:17:29.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时工作使用的电脑是 ThinkPad T480，之前一直安装的 Win10，连接多显示器很正常，没有问题，后来重装为了 Ubuntu，发现连接多显示器很诡异，在我的这套设备之上，如果想要正常使用，需要按照一个奇怪的顺序，记录一下。</p><h2 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h2><table><thead><tr><th>设备类型</th><th>设备</th><th>型号</th></tr></thead><tbody><tr><td>笔记本</td><td>ThinkPad</td><td>T480</td></tr><tr><td>拓展坞</td><td>联想/闪联 USB-C 集线器</td><td>C120</td></tr><tr><td>连接线</td><td>山泽 HDMI 数字高清线</td><td>SM-8855</td></tr><tr><td>连接线</td><td>VGA 高清视频线</td><td></td></tr><tr><td>显示器</td><td>DELL 24 寸</td><td>U2412Mb</td></tr><tr><td>显示器</td><td>DELL 24 寸</td><td>U2417H</td></tr></tbody></table><p>（不要问我为啥 Type-C 遍地走的现在，还在用 VGA，现在这套还是东拼西凑出来的。。。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/ubuntu.png" title="Ubuntu 19.10"><h2 id="设备接口"><a href="#设备接口" class="headerlink" title="设备接口"></a>设备接口</h2><p>T480 作为 ThinkPad 的 T 系列产品，接口还是很丰富的：</p><ul><li>2 x USB 3.1 Gen 1** (one Always On)</li><li>1 x USB 3.1 Gen 1** Type-C (Power Delivery, DisplayPort, Data transfer)</li><li><ul><li>x USB 3.1 Gen 2** Type-C / Intel Thunderbolt 3 (Power Delivery, DisplayPort, Data transfer)</li></ul></li><li>Headphone and microphone combo jack</li><li>4-in-1 SD card reader (SD, MMC, SDHC, SDXC)</li><li>HDMI</li><li>RJ45 Gigabit Ethernet</li><li>Optional Smart card reader</li></ul><p>ThinkPad T480 左视图：</p><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/t480-1.png" title="T480 左视图"><ul><li>1 x USB 3.1 Gen 1** Type-C (Power Delivery, DisplayPort, Data transfer)</li><li>1 x USB 3.1 Gen 2** Type-C / Intel Thunderbolt 3 (Power Delivery, DisplayPort, Data transfer)</li></ul><p>这里分别用 Type-C1 和 Type-C2 代指从左到右的两个接口。</p><p>ThinkPad T480 右视图：</p><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/t480-2.png" title="T480 右视图"><p>右侧有一个 HDMI 接口。</p><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/connection.png" title="连接图"><h2 id="连接顺序"><a href="#连接顺序" class="headerlink" title="连接顺序"></a>连接顺序</h2><ol><li>VGA 连接 U2412Mb</li><li>HDMI 连接 U2417H</li><li>VGA 连接 C120</li><li>电源连接 C120</li><li>C120 连接 Type-C2</li><li>电源断开 C120</li><li>电源连接 Type-C1</li><li>HDMI 连接 T480 HDMI</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个顺序在尝试过程中感觉跟 T480 供电正相关，但是没有找到直接问题，只能用这种连接顺序来保证这套东西正常工作了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;平时工作使用的电脑是 ThinkPad T480，之前一直安装的 Win10，连接多显示器很正常，没有问题，后来重装为了 Ubuntu，发现
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么 flannel.1 丢失后不会自动重建</title>
    <link href="https://zdyxry.github.io/2020/01/03/%E4%B8%BA%E4%BB%80%E4%B9%88-flannel-1-%E4%B8%A2%E5%A4%B1%E5%90%8E%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E9%87%8D%E5%BB%BA/"/>
    <id>https://zdyxry.github.io/2020/01/03/为什么-flannel-1-丢失后不会自动重建/</id>
    <published>2020-01-03T14:20:37.000Z</published>
    <updated>2020-01-04T03:34:50.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在用 K8s 的同学应该多少都使用过 Flannel 作为自己的网络插件，不讨论性能稳定性，在复杂的网络环境配置中 Flannel 的要求应该是最低的，所以我通常使用 Flannel 作为 让 K8s Ready 的最后一步。</p><p>在使用过程中，遇到过多次 flannel.1 这个 link 消失的情况，查看官方 Issue 中有人提到过： <a href="https://github.com/coreos/flannel/issues/869" target="_blank" rel="noopener">flannel.1 is deleted by <code>service network restart</code>, and never recreated again.</a> ，但是这个 Issue 从 2017年创建一直到现在都处于 Open 状态，看上去社区也不打算去解决，其实不只是重启网络，如果没有特殊指定的话，找到默认网关所在的网卡，直接 ifdown ，flannel.1 也会丢失，并且不会重建，那为什么会出现这个问题，今天来看一看。</p><h2 id="CNI-Flannel-Plugin"><a href="#CNI-Flannel-Plugin" class="headerlink" title="CNI Flannel Plugin"></a>CNI Flannel Plugin</h2><p>我们常说的 Flannel 分为两部分：<a href="https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel" target="_blank" rel="noopener">CNI Flannel Plugin</a> 及 Flannel。</p><p>CNI Flannel Plugin 是 Flannel CNI 插件的具体接口实现， CNI 要求实现的 <code>cmdAdd</code> <code>cmdDel</code> <code>cmdCheck</code> 都是在这里实现的，来看看具体的调用流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdAdd</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从标准输入加载配置</span></span><br><span class="line">n, err := loadFlannelNetConf(args.StdinData) </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 加载子网配置：/run/flannel/subnet.env</span></span><br><span class="line">fenv, err := loadFlannelSubnetEnv(n.SubnetFile) </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行添加动作</span></span><br><span class="line"><span class="keyword">return</span> doCmdAdd(args, n, fenv) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCmdAdd</span><span class="params">(args *skel.CmdArgs, n *NetConf, fenv *subnetEnv)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">n.Delegate[<span class="string">"name"</span>] = n.Name</span><br><span class="line"><span class="keyword">if</span> !hasKey(n.Delegate, <span class="string">"type"</span>) &#123;</span><br><span class="line">n.Delegate[<span class="string">"type"</span>] = <span class="string">"bridge"</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> n.CNIVersion != <span class="string">""</span> &#123;</span><br><span class="line">n.Delegate[<span class="string">"cniVersion"</span>] = n.CNIVersion</span><br><span class="line">&#125;</span><br><span class="line">n.Delegate[<span class="string">"ipam"</span>] = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"type"</span>:   <span class="string">"host-local"</span>,</span><br><span class="line"><span class="string">"subnet"</span>: fenv.sn.String(),</span><br><span class="line"><span class="string">"routes"</span>: []types.Route&#123;</span><br><span class="line">&#123;</span><br><span class="line">Dst: *fenv.nw,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 进行配置解析及填充后，执行委托类型插件进行配置，默认是 bridge，创建过程中会将配置保存到 /var/lib/cni/flannel ，删除时会用到</span></span><br><span class="line"><span class="keyword">return</span> delegateAdd(args.ContainerID, n.DataDir, n.Delegate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里已经跟 Flannel Plugin 无关了，是调用的其他插件完成的具体动作，再来看看删除动作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdDel</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">nc, err := loadFlannelNetConf(args.StdinData)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行删除动作</span></span><br><span class="line"><span class="keyword">return</span> doCmdDel(args, nc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCmdDel</span><span class="params">(args *skel.CmdArgs, n *NetConf)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从 /var/lib/cni/flannel 中根据 ContainerID 读取配置，并在读取后删除配置</span></span><br><span class="line">    netconfBytes, err := consumeScratchNetConf(args.ContainerID, n.DataDir) </span><br><span class="line">    ...</span><br><span class="line">nc := &amp;types.NetConf&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err = json.Unmarshal(netconfBytes, nc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to parse netconf: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 委托其他插件执行删除动作，默认 bridge</span></span><br><span class="line"><span class="keyword">return</span> invoke.DelegateDel(context.TODO(), nc.Type, netconfBytes, <span class="literal">nil</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们来捋一捋整个流程：</p><ol><li>kubelet 启动时查找可用 CNI 插件，并根据配置加载</li><li>kubelet 创建容器前，通过 CNI Interface 调用相应方法执行 cmdAdd/cmdDel 命令</li><li>CNI 根据配置信息调用对应的 Plugin 执行 cmdAdd/cmdDel</li></ol><h3 id="相应文件路径"><a href="#相应文件路径" class="headerlink" title="相应文件路径"></a>相应文件路径</h3><h4 id="var-lib-cni-flannel"><a href="#var-lib-cni-flannel" class="headerlink" title="/var/lib/cni/flannel"></a>/var/lib/cni/flannel</h4><p>每个 Pod 的具体网络配置，配置内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 09:29:48 cni]$pwd</span><br><span class="line">/var/lib/cni</span><br><span class="line">[root@install2 09:29:51 cni]$cat flannel/d3f1220d58a72ebe5a92f8febbe6dd45d3bff65dce0ff6960f732f202026c24c |jq</span><br><span class="line">&#123;</span><br><span class="line">  "cniVersion": "0.3.1",</span><br><span class="line">  "hairpinMode": true,</span><br><span class="line">  "ipMasq": false,</span><br><span class="line">  "ipam": &#123;</span><br><span class="line">    "routes": [</span><br><span class="line">      &#123;</span><br><span class="line">        "dst": "10.244.0.0/16"</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    "subnet": "10.244.1.0/24",</span><br><span class="line">    "type": "host-local"</span><br><span class="line">  &#125;,</span><br><span class="line">  "isDefaultGateway": true,</span><br><span class="line">  "isGateway": true,</span><br><span class="line">  "mtu": 1450,</span><br><span class="line">  "name": "cbr0",</span><br><span class="line">  "type": "bridge"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="var-lib-cni-networks"><a href="#var-lib-cni-networks" class="headerlink" title="/var/lib/cni/networks"></a>/var/lib/cni/networks</h4><p>IP 地址分配配置路径，默认 Flannel 使用的 ipam 是 host-local，bridge 是 cbr0 ，在这下面是已分配的 IP 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 09:31:48 cni]$pwd</span><br><span class="line">/var/lib/cni</span><br><span class="line">[root@install2 09:31:49 cni]$tree networks/</span><br><span class="line">networks/</span><br><span class="line">└── cbr0</span><br><span class="line">    ├── 10.244.1.160</span><br><span class="line">    ├── 10.244.1.161</span><br><span class="line">    ├── 10.244.1.162</span><br><span class="line">    ├── last_reserved_ip.0</span><br><span class="line">    └── lock</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br><span class="line">[root@install2 09:31:53 cni]$cat networks/cbr0/10.244.1.162</span><br><span class="line">d3f1220d58a72ebe5a92f8febbe6dd45d3bff65dce0ff6960f732f202026c24c</span><br><span class="line">[root@install2 09:32:07 cni]$cat networks/cbr0/last_reserved_ip.0</span><br><span class="line">10.244.1.162</span><br></pre></td></tr></table></figure><h4 id="etc-cni-net-d"><a href="#etc-cni-net-d" class="headerlink" title="/etc/cni/net.d"></a>/etc/cni/net.d</h4><p>CNI 插件配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 09:34:47 net.d]$pwd</span><br><span class="line">/etc/cni/net.d</span><br><span class="line">[root@install2 09:34:48 net.d]$cat 10-flannel.conflist</span><br><span class="line">&#123;</span><br><span class="line">  "name": "cbr0",</span><br><span class="line">  "cniVersion": "0.3.1",</span><br><span class="line">  "plugins": [</span><br><span class="line">    &#123;</span><br><span class="line">      "type": "flannel",</span><br><span class="line">      "delegate": &#123;</span><br><span class="line">        "hairpinMode": true,</span><br><span class="line">        "isDefaultGateway": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "type": "portmap",</span><br><span class="line">      "capabilities": &#123;</span><br><span class="line">        "portMappings": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概了解了 CNI Flannel Plugin ，说好的 <code>flannel.1</code> 呢？既然确定了 <code>flannel.1</code> 不是 CNI Plugin 里面实现的，那肯定就是 Flannel 自己的行为了，接下来看 <code>Flannel</code> 代码就可以了。</p><h2 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h2><p>提到 Flannel，就不得不拿出这张图：</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/go/src/github.com/coreos/flannel</span><br><span class="line">master ✗ $ tree . -L 1</span><br><span class="line">├── backend # 后端实现：vxlan,udp,hostgw</span><br><span class="line">├── main.go # 入口</span><br><span class="line">├── network # IPtables 相关配置</span><br><span class="line">├── pkg     # 辅助功能，如 IP，Namespace</span><br><span class="line">├── README.md</span><br><span class="line">├── subnet  # 子网管理，K8s 通信相关</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>我们先来回想一下 K8s 集群部署，我们通过 kubeadm 指定了 Pod CIDR 为 <code>10.244.0.0/16</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line"><span class="attr">  dnsDomain:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  podSubnet:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">  serviceSubnet:</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p>然后我们直接执行 <code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code> 等待 Node Ready 即可，这样做的前提是因为我们指定的 Pod 子网是 Flannel 默认子网，两者必须相同才可以配置正确。</p><h3 id="代码入口"><a href="#代码入口" class="headerlink" title="代码入口"></a>代码入口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">sm, err := newSubnetManager()</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 从 K8s 中获取配置信息，主要是子网信息</span></span><br><span class="line">config, err := getConfig(ctx, sm)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 创建 backend manager 并创建用来创建 backend 和注册网络</span></span><br><span class="line">bm := backend.NewManager(ctx, sm, extIface)</span><br><span class="line">be, err := bm.GetBackend(config.BackendType)</span><br><span class="line">  ...</span><br><span class="line">bn, err := be.RegisterNetwork(ctx, wg, config)</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 运行 backend </span></span><br><span class="line">log.Info(<span class="string">"Running backend."</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">bn.Run(ctx)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main.go 中获取配置的来源是 ConfigMap：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@install1</span> <span class="number">11</span><span class="string">:00:39</span> <span class="string">~]$kubectl</span> <span class="string">get</span> <span class="string">cm</span> <span class="string">kube-flannel-cfg</span> <span class="bullet">-n</span> <span class="string">kube-system</span> <span class="bullet">-o</span> <span class="string">yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">cni-conf.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "name": "cbr0",</span></span><br><span class="line"><span class="string">      "cniVersion": "0.3.1",</span></span><br><span class="line"><span class="string">      "plugins": [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "type": "flannel",</span></span><br><span class="line"><span class="string">          "delegate": &#123;</span></span><br><span class="line"><span class="string">            "hairpinMode": true,</span></span><br><span class="line"><span class="string">            "isDefaultGateway": true</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "type": "portmap",</span></span><br><span class="line"><span class="string">          "capabilities": &#123;</span></span><br><span class="line"><span class="string">            "portMappings": true</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  net-conf.json: |</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "Network": "10.244.0.0/16",</span></span><br><span class="line"><span class="string">      "Backend": &#123;</span></span><br><span class="line"><span class="string">        "Type": "vxlan"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="string">"2019-12-30T02:37:21Z"</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">flannel</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">node</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kube-flannel-cfg</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"235454"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/api/v1/namespaces/kube-system/configmaps/kube-flannel-cfg</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">fd9f67ee-ee1b-411d-8403-23ab05de56c8</span></span><br></pre></td></tr></table></figure><p>可以看到默认的 Backend 是 vxlan，我们接着看 backend 和 vxlan 相关处理，在 backend/ 路径下放着些统一的接口定义，vxlan 是接口的具体实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/go/src/github.com/coreos/flannel</span><br><span class="line">master ✗ $ tree backend -L 1</span><br><span class="line">backend</span><br><span class="line">├── common.go</span><br><span class="line">├── manager.go</span><br><span class="line">├── route_network.go</span><br><span class="line">├── route_network_test.go</span><br><span class="line">├── route_network_windows.go</span><br><span class="line">├── simple_network.go</span><br><span class="line">├── udp</span><br><span class="line">└── vxlan</span><br><span class="line">    ├── device.go</span><br><span class="line">    ├── device_windows.go</span><br><span class="line">    ├── vxlan.go</span><br><span class="line">    ├── vxlan_network.go</span><br><span class="line">    ├── vxlan_network_windows.go</span><br><span class="line">    └── vxlan_windows.go</span><br></pre></td></tr></table></figure><p>如 <code>RegisterNetwork</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Called when the backend should create or begin managing a new network</span></span><br><span class="line">RegisterNetwork(ctx context.Context, wg sync.WaitGroup, config *subnet.Config) (Network, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看 vxlan RegisterNetwork 做了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(be *VXLANBackend)</span> <span class="title">RegisterNetwork</span><span class="params">(ctx context.Context, wg sync.WaitGroup, config *subnet.Config)</span> <span class="params">(backend.Network, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 解析配置</span></span><br><span class="line">cfg := <span class="keyword">struct</span> &#123;</span><br><span class="line">VNI           <span class="keyword">int</span></span><br><span class="line">Port          <span class="keyword">int</span></span><br><span class="line">GBP           <span class="keyword">bool</span></span><br><span class="line">Learning      <span class="keyword">bool</span></span><br><span class="line">DirectRouting <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">VNI: defaultVNI,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vtep 配置信息</span></span><br><span class="line">devAttrs := vxlanDeviceAttrs&#123;</span><br><span class="line">vni:       <span class="keyword">uint32</span>(cfg.VNI),</span><br><span class="line">name:      fmt.Sprintf(<span class="string">"flannel.%v"</span>, cfg.VNI),</span><br><span class="line">vtepIndex: be.extIface.Iface.Index,</span><br><span class="line">vtepAddr:  be.extIface.IfaceAddr,</span><br><span class="line">vtepPort:  cfg.Port,</span><br><span class="line">gbp:       cfg.GBP,</span><br><span class="line">learning:  cfg.Learning,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 vtep</span></span><br><span class="line">dev, err := newVXLANDevice(&amp;devAttrs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">dev.directRouting = cfg.DirectRouting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newVXLANDevice</span><span class="params">(devAttrs *vxlanDeviceAttrs)</span> <span class="params">(*vxlanDevice, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// netlink 是 Golang 中操作网络相关的库，提供了创建 Vxlan 设备的接口</span></span><br><span class="line">link := &amp;netlink.Vxlan&#123;</span><br><span class="line">LinkAttrs: netlink.LinkAttrs&#123;</span><br><span class="line">Name: devAttrs.name,</span><br><span class="line">&#125;,</span><br><span class="line">VxlanId:      <span class="keyword">int</span>(devAttrs.vni),</span><br><span class="line">VtepDevIndex: devAttrs.vtepIndex,</span><br><span class="line">SrcAddr:      devAttrs.vtepAddr,</span><br><span class="line">Port:         devAttrs.vtepPort,</span><br><span class="line">Learning:     devAttrs.learning,</span><br><span class="line">GBP:          devAttrs.gbp,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link, err := ensureLink(link)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;vxlanDevice&#123;</span><br><span class="line">link: link,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ensureLink</span><span class="params">(vxlan *netlink.Vxlan)</span> <span class="params">(*netlink.Vxlan, error)</span></span> &#123;</span><br><span class="line">err := netlink.LinkAdd(vxlan)</span><br><span class="line"><span class="keyword">if</span> err == syscall.EEXIST &#123;</span><br><span class="line"><span class="comment">// it's ok if the device already exists as long as config is similar</span></span><br><span class="line">    log.V(<span class="number">1</span>).Infof(<span class="string">"VXLAN device already exists"</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 如果存在，则娇艳 原有设备是否兼容，如果不兼容则删除并重新创建设备</span></span><br><span class="line"><span class="keyword">if</span> err = netlink.LinkAdd(vxlan); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to create vxlan interface: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">return</span> vxlan, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们就知道了是 Flannel 在进行 backend 注册的时候创建的 <code>flannel.1</code> 设备，如果我们想要简单粗暴的去修改代码实现，我们可以在 <code>backend.Run()</code> 方法中加入 <code>ensureLink</code> 检测逻辑，保证当发现对应 vtep 设备消失时，重新创建。但是这种实现方式就比较侵入，而且破坏了 backend 通用逻辑，我理解正确的处理方式应该是通过 health 探针去检测，如果检测到 Pod 处于 unhealthy 状态，自动重建 Pod，会重新进行 <code>backend.RegisterNetwork</code> 逻辑，就不存在这个问题了。</p><p>来看下默认的 Flannel YAML 文件，发现其中并没有 health 探针配置，还是有点奇怪的，这么一个基础的服务，居然没有做任何的健康检查，听上去有些不合道理。</p><p>于是我又去 Github 上查找相关的 Issue，果然发现了很多人遇到这个问题，倒是最终都没有提出比较好的方案来解决，其中 Eduard Català 分别提交了 2 个 PR 用来增加 Health Check 机制，但是不知道因为什么最终都没有合并：</p><ul><li><a href="https://github.com/coreos/flannel/pull/917" target="_blank" rel="noopener">https://github.com/coreos/flannel/pull/917</a></li><li><a href="https://github.com/coreos/flannel/pull/920" target="_blank" rel="noopener">https://github.com/coreos/flannel/pull/920</a></li></ul><p>我们来看看他的对应实现，通过检测对应的设备是否存在，如果不存在则不健康：</p><p>backend/vxlan/vxlan.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(be *VXLANBackend)</span> <span class="title">CheckHealthz</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := net.InterfaceByName(be.extIface.Iface.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"Master interface %v disappeared. Waiting its return..."</span>, be.extIface.Iface.Name)</span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">_, err = net.InterfaceByName(be.extIface.Iface.Name)</span><br><span class="line">&#125;</span><br><span class="line">log.Errorf(<span class="string">"Master interface: %v reappeared"</span>, be.extIface.Iface.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = net.InterfaceByName(be.network.dev.link.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"Flannel interface: %v not found - Requiring flannel restart "</span>, be.network.dev.link.Name)</span><br><span class="line"><span class="keyword">return</span> backend.FlannelRestart</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flannel 社区活跃度不高，合并 PR 的速度更是慢的离谱，有很多存在很久的 Issue 也没有解决，感觉还是用着玩玩就好。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/containernetworking/plugins.git" target="_blank" rel="noopener">https://github.com/containernetworking/plugins.git</a></li><li><a href="https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/cni%20plugin/flannel%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.md" target="_blank" rel="noopener">https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/cni%20plugin/flannel%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.md</a></li><li><a href="https://cizixs.com/2016/07/16/flannel-source-code-insight/" target="_blank" rel="noopener">https://cizixs.com/2016/07/16/flannel-source-code-insight/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在用 K8s 的同学应该多少都使用过 Flannel 作为自己的网络插件，不讨论性能稳定性，在复杂的网络环境配置中 Flannel 的要求应
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
