<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2020-07-31T23:27:53.635Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 第31周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/01/2020-%E7%AC%AC31%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/01/2020-第31周-LeetCode-记录/</id>
    <published>2020-08-01T07:26:24.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1523-Count-Odd-Numbers-in-an-Interval-Range"><a href="#1523-Count-Odd-Numbers-in-an-Interval-Range" class="headerlink" title="1523. Count Odd Numbers in an Interval Range"></a>1523. Count Odd Numbers in an Interval Range</h3><p>数学题，数据范围是10^9，O(n) 会超时，统计 high 中有多少个奇数，减去 low-1 中的奇数个数，需要考虑边界条件：low/high 自身为奇数情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countOdds</span><span class="params">(self, low: int, high: int)</span> -&gt; int:</span></span><br><span class="line">        res = high // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> high % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> low - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            res -= (low - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (low - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1528-Shuffle-String"><a href="#1528-Shuffle-String" class="headerlink" title="1528. Shuffle String"></a>1528. Shuffle String</h3><p>按照指定顺序调整字符串，直接定义一个新的长度为 len(s)字符串，然后按照 indices 的索引顺序进行对应调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreString</span><span class="params">(self, s: str, indices: List[int])</span> -&gt; str:</span></span><br><span class="line">        _s = [<span class="string">'0'</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            _s[indices[idx]] = val</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(_s)</span><br></pre></td></tr></table></figure><h3 id="1524-Number-of-Sub-arrays-With-Odd-Sum"><a href="#1524-Number-of-Sub-arrays-With-Odd-Sum" class="headerlink" title="1524. Number of Sub-arrays With Odd Sum"></a>1524. Number of Sub-arrays With Odd Sum</h3><blockquote><p><a href="https://www.youtube.com/watch?v=vGTm8rjlDTQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=vGTm8rjlDTQ</a></p></blockquote><p>用两个变量分别记录奇数和偶数的个数，遍历数组，如果当前数字是奇数，那么 odd 等于偶数个数 +1，1为当前数字，even 等于奇数个数，因为奇数个数加上当前数字（奇数）为偶数；如果当前数字是偶数，那么 odd 等于 odd，偶数个数等于 even + 1，1为当前数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numOfSubarrays</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    odd, even := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">if</span> v % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            odd, even = even + <span class="number">1</span>, odd</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            odd, even = odd, even + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        res += odd</span><br><span class="line">        res %= mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1525-Number-of-Good-Ways-to-Split-a-String"><a href="#1525-Number-of-Good-Ways-to-Split-a-String" class="headerlink" title="1525. Number of Good Ways to Split a String"></a>1525. Number of Good Ways to Split a String</h3><p>使用 Counter 统计当前字符串中的字符出现的次数，left 表示切割索引左侧字符出现的次数，right 表示切割索引右侧字符出现的次数，遍历字符，如果 right[x] == 0，那么表示右侧已经没有字符 x，那么需要将对应的 key(x) 从 right 中删除，比较 left 中的 key 数量与 right 中是否相同，如果相同，则记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSplits</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = Counter()</span><br><span class="line">        right = Counter(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            left[s[i]] += <span class="number">1</span></span><br><span class="line">            right[s[i]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right[s[i]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> right[s[i]]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> len(left) == len(right):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1529-Bulb-Switcher-IV"><a href="#1529-Bulb-Switcher-IV" class="headerlink" title="1529. Bulb Switcher IV"></a>1529. Bulb Switcher IV</h3><p>统计需要翻转开关的次数，就是统计最终状态中 0，1 切换的次数，比如<code>001011101</code> ，0，1 切换分别在 <code>001</code> , <code>10</code>, <code>0111</code>, <code>1110</code>, <code>01</code> 这五个位置出现了切换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minFlips</span><span class="params">(target <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">target = <span class="string">"0"</span> + target</span><br><span class="line">flag := target[<span class="built_in">len</span>(target)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(target) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> target[i] != flag &#123;</span><br><span class="line">count++</span><br><span class="line">flag = target[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1523-Count-Odd-Numbers-in-an-Interval-Range&quot;&gt;&lt;a href=&quot;#1523-Count-Odd-Numbers-in-an-Interval-Range&quot; class=&quot;headerlink&quot; title=&quot;1523. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第30周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/26/2020-%E7%AC%AC30%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/26/2020-第30周-LeetCode-记录/</id>
    <published>2020-07-26T09:36:03.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1518-Water-Bottles"><a href="#1518-Water-Bottles" class="headerlink" title="1518. Water Bottles"></a>1518. Water Bottles</h3><p>小学数学题，用几个空瓶子可以换一瓶新的，问最后能喝到几瓶，在小学场景下可以先借再喝，在这道题没有这种场景，所以正常计算就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWaterBottles</span><span class="params">(self, numBottles: int, numExchange: int)</span> -&gt; int:</span></span><br><span class="line">        res = numBottles</span><br><span class="line">        <span class="keyword">while</span> numBottles &gt;= numExchange:</span><br><span class="line">            cnt = numBottles // numExchange</span><br><span class="line">            res += cnt</span><br><span class="line">            numBottles = numBottles - (cnt * numExchange)</span><br><span class="line">            numBottles += cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108. Defanging an IP Address"></a>1108. Defanging an IP Address</h3><p>将 IPv4 地址 “1.1.1.1” 转换为 “1[.]1[.]1[.]1” ，不知道这道题的意义在哪里。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">'.'</span>, <span class="string">'[.]'</span>)</span><br></pre></td></tr></table></figure><h3 id="1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><a href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label" class="headerlink" title="1519. Number of Nodes in the Sub-Tree With the Same Label"></a>1519. Number of Nodes in the Sub-Tree With the Same Label</h3><p>题目很绕，最好自己根据给的 edges 和 labels 构建出对应的树，了解是如何构建的，最终要求的 ans 中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数，记录所有节点的相邻节点，从 0 节点开始 dfs，如果节点已经访问过，则跳过对应节点，最终汇总 ans[i] 中的数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">        edge_map = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            edge_map[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            edge_map[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            visited.add(i)</span><br><span class="line">            <span class="comment"># 字符数字典</span></span><br><span class="line">            data = Counter(&#123;labels[i]: <span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> edge_map[i]:</span><br><span class="line">                <span class="keyword">if</span> nxt <span class="keyword">in</span> visited: <span class="keyword">continue</span> <span class="comment"># 去重</span></span><br><span class="line">                <span class="comment"># 整合子树的字符数</span></span><br><span class="line">                data += _dfs(nxt)</span><br><span class="line">            <span class="comment"># 设置当前节点的结果字符数</span></span><br><span class="line">            ans[i] = data[labels[i]]</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        ans = [<span class="number">1</span>] * n</span><br><span class="line">        _dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1189-Maximum-Number-of-Balloons"><a href="#1189-Maximum-Number-of-Balloons" class="headerlink" title="1189. Maximum Number of Balloons"></a>1189. Maximum Number of Balloons</h3><p>给一个字符串 text，使用 text 中的字母来拼凑尽可能多的单词 “balloon”，每个字母最多只能被使用一次。返回最多可以拼凑出多少个单词 “balloon”，分别统计每个字母出现的次数，然后判断满足ballon 所有字母出现次数最小的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfBalloons</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        d = collections.Counter(text)</span><br><span class="line">        <span class="keyword">return</span> min(d[<span class="string">'b'</span>], d[<span class="string">'a'</span>], d[<span class="string">'l'</span>] // <span class="number">2</span>, d[<span class="string">'o'</span>] // <span class="number">2</span>, d[<span class="string">'n'</span>])</span><br></pre></td></tr></table></figure><h3 id="1304-Find-N-Unique-Integers-Sum-up-to-Zero"><a href="#1304-Find-N-Unique-Integers-Sum-up-to-Zero" class="headerlink" title="1304. Find N Unique Integers Sum up to Zero"></a>1304. Find N Unique Integers Sum up to Zero</h3><p>给一个整数 n，返回任意一个由 n 个 各不相同的整数组成的数组，并且这 n 个数相加和为 0 ，题目很开放，如果n 为奇数，则补充一个数字 <code>0</code>，如果为 偶数，那么补充对应的 n/2 个数字的正负值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            res.append(i)</span><br><span class="line">            res.append(-i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1518-Water-Bottles&quot;&gt;&lt;a href=&quot;#1518-Water-Bottles&quot; class=&quot;headerlink&quot; title=&quot;1518. Water Bottles&quot;&gt;&lt;/a&gt;1518. Water Bottles&lt;/h3&gt;&lt;p&gt;小学数学
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第29周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/19/2020-第29周-LeetCode-记录/</id>
    <published>2020-07-19T11:19:38.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves"><a href="#1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves" class="headerlink" title="1509. Minimum Difference Between Largest and Smallest Value in Three Moves"></a>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</h3><p>要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> min(b - a <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(nums[:<span class="number">4</span>], nums[<span class="number">-4</span>:]))</span><br></pre></td></tr></table></figure><h3 id="1512-Number-of-Good-Pairs"><a href="#1512-Number-of-Good-Pairs" class="headerlink" title="1512. Number of Good Pairs"></a>1512. Number of Good Pairs</h3><p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 ，返回好数对的数目。<br>只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIdenticalPairs</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(k * (k - <span class="number">1</span>) / <span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> collections.Counter(A).values())</span><br></pre></td></tr></table></figure><h3 id="1513-Number-of-Substrings-With-Only-1s"><a href="#1513-Number-of-Substrings-With-Only-1s" class="headerlink" title="1513. Number of Substrings With Only 1s"></a>1513. Number of Substrings With Only 1s</h3><p>判断连续 1 的个数，每当遇到 1 时计数 +1， 遇到 0 时对现有计数进行求和公式，并加到最终结果中，重置计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += cnt * (cnt +<span class="number">1</span>) /<span class="number">2</span></span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            res += cnt * (cnt + <span class="number">1</span>)/ <span class="number">2</span></span><br><span class="line">        res %= <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><h3 id="1114-Print-in-Order"><a href="#1114-Print-in-Order" class="headerlink" title="1114. Print in Order"></a>1114. Print in Order</h3><p>将各个线程按照顺序执行，有很多实现方式，挑一种方式实现就可以了，这里直接使用 <code>threading.Event</code> 。</p><p><code>threading.Event</code> 定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b1 = threading.Event()</span><br><span class="line">        self.b2 = threading.Event()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.b1.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b1.wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.b2.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b2.wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure><h3 id="1209-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#1209-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="1209. Remove All Adjacent Duplicates in String II"></a>1209. Remove All Adjacent Duplicates in String II</h3><p>这题描述有点别扭，给一个字符串，如果字符串中包含 k 个相邻且相等的字母，那么就原地删除，然后继续检测是否满足条件，重复执行操作。使用栈来记录最终结果，遍历字符串，如果当前自负和栈顶相同，且长度等于 k，那么就出栈，最终将栈中记录拼接为字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">if</span> len(stack) == <span class="number">0</span> <span class="keyword">or</span> stack[<span class="number">-1</span>][<span class="number">0</span>] != i:</span><br><span class="line">                stack.append([i, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[<span class="number">-1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">        ret = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> stack:</span><br><span class="line">            ret += t[<span class="number">0</span>] * t[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves&quot;&gt;&lt;a href=&quot;#1509-Minimum-Difference-Between-Largest-and-Sma
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第28周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/11/2020-%E7%AC%AC28%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/11/2020-第28周-LeetCode-记录/</id>
    <published>2020-07-11T21:50:54.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1502-Can-Make-Arithmetic-Progression-From-Sequence"><a href="#1502-Can-Make-Arithmetic-Progression-From-Sequence" class="headerlink" title="1502. Can Make Arithmetic Progression From Sequence"></a>1502. Can Make Arithmetic Progression From Sequence</h3><p>判断是否可以组成等差数列，将数组排序后，比较两两数字差是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        arr.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        diff = arr[<span class="number">0</span>] - arr[<span class="number">1</span>]</span><br><span class="line">        pre = arr[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> pre - i != diff:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            pre = i</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank"><a href="#1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank" class="headerlink" title="1503. Last Moment Before All Ants Fall Out of a Plank"></a>1503. Last Moment Before All Ants Fall Out of a Plank</h3><p>标签是“脑筋急转弯”，蚂蚁只要在一个点碰到，那么就会调换方向，但是蚂蚁始终是蚂蚁，因此可以忽略掉这个条件，直接找到最大值就可以了。</p><p>再次怀疑自己智商。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastMoment</span><span class="params">(self, n: int, left: List[int], right: List[int])</span> -&gt; int:</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            time = max(time, max(left))</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            time = max(time, n - min(right))</span><br><span class="line">        <span class="keyword">return</span> time</span><br></pre></td></tr></table></figure><h3 id="939-Minimum-Area-Rectangle"><a href="#939-Minimum-Area-Rectangle" class="headerlink" title="939. Minimum Area Rectangle"></a>939. Minimum Area Rectangle</h3><p>一般会选择完整本周周赛题目，然后去做其他的题，但是 1504 做不出，就找了到也是矩形相关的补一补 - - 。</p><p>找出最小矩形面积，需要先找到组成矩形的四个点，遍历所有点，将其记录下来，并遍历已记录的点，此时拿到了两个点，直接暴力判断这两个点的对称点是否存在，如果存在，则计算面积并更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAreaRect</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        mem = set()</span><br><span class="line">        <span class="keyword">for</span> x1,y1 <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">for</span> x2,y2 <span class="keyword">in</span> mem:</span><br><span class="line">                <span class="keyword">if</span> (x2,y1) <span class="keyword">in</span> mem <span class="keyword">and</span> (x1,y2) <span class="keyword">in</span> mem:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> area:</span><br><span class="line">                        area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> abs(x2-x1)*abs(y2-y1) &lt; area:</span><br><span class="line">                            area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">            mem.add((x1,y1))</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure><h3 id="1160-Find-Words-That-Can-Be-Formed-by-Characters"><a href="#1160-Find-Words-That-Can-Be-Formed-by-Characters" class="headerlink" title="1160. Find Words That Can Be Formed by Characters"></a>1160. Find Words That Can Be Formed by Characters</h3><p>使用 Counter 统计词汇表中的字母，遍历单词，如果单词中的每个字母数量小于词汇表中的字母数量，那么满足条件，否则跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCharacters</span><span class="params">(self, words: List[str], chars: str)</span> -&gt; int:</span></span><br><span class="line">        chars_cnt = collections.Counter(chars)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_cnt = collections.Counter(word)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word_cnt:</span><br><span class="line">                <span class="keyword">if</span> chars_cnt[c] &lt; word_cnt[c]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += len(word)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a>1048. Longest String Chain</h3><p>先对所有单词进行排序，使用哈希表记录当前单词所能组成的最长字符串链的长度。当遍历到某个单词是，通过字符串切片，判断其所有可能的情况，如果记录中存在，那么与当前最大值进行比较更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        words.sort(key=len)</span><br><span class="line">        note=&#123;&#125;</span><br><span class="line">        maxChain=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> note:</span><br><span class="line">                note[word]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(word)):</span><br><span class="line">                newWord=word[:i]+word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> (newWord) <span class="keyword">in</span> note:</span><br><span class="line">                    note[word]=max(note[word],note[newWord]+<span class="number">1</span>)</span><br><span class="line">            maxChain=max(maxChain,note[word])</span><br><span class="line">        <span class="keyword">return</span> maxChain</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1502-Can-Make-Arithmetic-Progression-From-Sequence&quot;&gt;&lt;a href=&quot;#1502-Can-Make-Arithmetic-Progression-From-Sequence&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第27周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/04/2020-%E7%AC%AC27%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/04/2020-第27周-LeetCode-记录/</id>
    <published>2020-07-04T09:17:15.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1492-The-kth-Factor-of-n"><a href="#1492-The-kth-Factor-of-n" class="headerlink" title="1492. The kth Factor of n"></a>1492. The kth Factor of n</h3><p>计算 n 的第 k 个因子，i 从 1 开始递增，如果 i 可以被 n 整除，则 k–，当 k == 0 时， i为所求值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthFactor</span><span class="params">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1493-Longest-Subarray-of-1’s-After-Deleting-One-Element"><a href="#1493-Longest-Subarray-of-1’s-After-Deleting-One-Element" class="headerlink" title="1493. Longest Subarray of 1’s After Deleting One Element"></a>1493. Longest Subarray of 1’s After Deleting One Element</h3><p>用 cnt1 记录删除一个元素之后当前最长全为 1 的数组长度，用 cnt2 记录当前最长全为 1 的数组长度。</p><p>遍历数组，当 num == 1 时，则 cnt1++, cnt2++，当 num != 1 时，cnt1 = cnt2，并将 cnt2 置 0。每次更新 cnt1 时，比较最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        cnt1, cnt2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line">                maxlen = max(maxlen, cnt1)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt1 = cnt2</span><br><span class="line">                cnt2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 == len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure><h3 id="1496-Path-Crossing"><a href="#1496-Path-Crossing" class="headerlink" title="1496. Path Crossing"></a>1496. Path Crossing</h3><p>起始点为 (0,0)，然后遍历 path，当为南北时，分别对 y 进行 +1，-1， 当为东西时，分别对 x 进行 +1，-1，每次走过一个路径，就判断当前所在节点是否已经在记录中，如果在直接返回 True，否则将其添加到记录中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPathCrossing</span><span class="params">(self, path: str)</span> -&gt; bool:</span></span><br><span class="line">        x = y = <span class="number">0</span></span><br><span class="line">        set = &#123;(<span class="number">0</span>, <span class="number">0</span>)&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'N'</span>:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'S'</span>:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'E'</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">in</span> set:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            set.add((x, y))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1497-Check-If-Array-Pairs-Are-Divisible-by-k"><a href="#1497-Check-If-Array-Pairs-Are-Divisible-by-k" class="headerlink" title="1497. Check If Array Pairs Are Divisible by k"></a>1497. Check If Array Pairs Are Divisible by k</h3><p>使用哈希表，分别将所有 arr 中的数字对 k 取余，然后遍历余数，如果余数不为0，且 k - 余数 在哈希表中并且 两个key 数值相同，则这两个数字所组成的数字对之和是可以被 k 整除的。如果余数为0，那么判断余数为0 的个数是否为偶数，如果为偶数，那么返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canArrange</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        mod = collections.Counter(num % k <span class="keyword">for</span> num <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="keyword">for</span> t, occ <span class="keyword">in</span> mod.items():</span><br><span class="line">            <span class="keyword">if</span> t &gt; <span class="number">0</span> <span class="keyword">and</span> (k - t <span class="keyword">not</span> <span class="keyword">in</span> mod <span class="keyword">or</span> mod[k - t] != occ):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> mod[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition"><a href="#1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition" class="headerlink" title="1498. Number of Subsequences That Satisfy the Given Sum Condition"></a>1498. Number of Subsequences That Satisfy the Given Sum Condition</h3><p>因为是非空子序列，因此不要求连续，只要满足条件的任意组合即可。</p><p>对数组进行排序，然后使用双指针，如果 nums[l] + nums[r] &gt; target，此时不符合条件，那么将 r–，如果符合，那么在结果中 l 到 r 这个距离中所有的组合都是满足条件的，2 ^ (r-l)，l++，结果相加后取模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubseq</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] &gt; target:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += pow(<span class="number">2</span>, r - l, mod)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res % mod</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1492-The-kth-Factor-of-n&quot;&gt;&lt;a href=&quot;#1492-The-kth-Factor-of-n&quot; class=&quot;headerlink&quot; title=&quot;1492. The kth Factor of n&quot;&gt;&lt;/a&gt;1492. The kth
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第26周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/28/2020-%E7%AC%AC26%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/28/2020-第26周-LeetCode-记录/</id>
    <published>2020-06-28T21:57:10.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1486-XOR-Operation-in-an-Array"><a href="#1486-XOR-Operation-in-an-Array" class="headerlink" title="1486. XOR Operation in an Array"></a>1486. XOR Operation in an Array</h3><p>遍历进行异或操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorOperation</span><span class="params">(self, n: int, start: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans ^= start + <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1487-Making-File-Names-Unique"><a href="#1487-Making-File-Names-Unique" class="headerlink" title="1487. Making File Names Unique"></a>1487. Making File Names Unique</h3><p>一道实际环境中会遇到的场景，使用哈希表记录已有的文件名，如果该文件已经存在在哈希表中，那么循环判断文件名 + <code>()</code> 数字是否也在哈希表中，如果还在，那么数字 + 1，直到数字不在。然后将结果记录到返回列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFolderNames</span><span class="params">(self, names: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        nameMap = &#123;&#125; <span class="comment"># baseName : largest k suffix</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> nameMap:</span><br><span class="line">                <span class="comment"># find k</span></span><br><span class="line">                k = nameMap[n] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> ( n + <span class="string">"("</span> + str(k) + <span class="string">")"</span> ) <span class="keyword">in</span> nameMap:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                nameMap[n] = k</span><br><span class="line">                n = n + <span class="string">"("</span> + str(k) + <span class="string">")"</span> <span class="comment"># with suffix is now considered a base name</span></span><br><span class="line">                </span><br><span class="line">            nameMap[n] = <span class="number">0</span> <span class="comment"># first time seeing this base name</span></span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a>701. Insert into a Binary Search Tree</h3><p>在二叉树中插入节点，如果 val &gt; node.val，插入到右子树，如果 val &lt; node.val，插入到左子树，最终返回 root 节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="comment"># insert into the right subtree</span></span><br><span class="line">            <span class="keyword">if</span> val &gt; node.val:</span><br><span class="line">                <span class="comment"># insert right now</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    node.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> root</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.right</span><br><span class="line">            <span class="comment"># insert into the left subtree</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># insert right now</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                    node.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> root</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.left</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br></pre></td></tr></table></figure><h3 id="1488-Avoid-Flood-in-The-City"><a href="#1488-Avoid-Flood-in-The-City" class="headerlink" title="1488. Avoid Flood in The City"></a>1488. Avoid Flood in The City</h3><p>遇到不下雨的时候先不去判断应该将哪个湖水抽干，而是等到某个湖下雨两次，再去从不下雨的天气里在湖两次下雨之间抽取第一个来抽干这个湖，防止洪水泛滥，如果找不到，则发生洪水。</p><blockquote><p><a href="https://www.youtube.com/watch?v=8sxeQyumrYc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8sxeQyumrYc</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoidFlood</span><span class="params">(self, rains: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">1</span>] * len(rains)</span><br><span class="line">        left = []</span><br><span class="line">        record = dict()</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(rains):</span><br><span class="line">            <span class="keyword">if</span> val &gt; <span class="number">0</span>:</span><br><span class="line">                ans[i] = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">in</span> record:</span><br><span class="line">                    pos = bisect_left(left, record[val])</span><br><span class="line">                    <span class="keyword">if</span> pos &gt;= len(left):</span><br><span class="line">                        <span class="keyword">return</span> []</span><br><span class="line">                    ans[left.pop(pos)] = val</span><br><span class="line">                record[val] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a>1047. Remove All Adjacent Duplicates In String</h3><p>遍历字符串，使用列表作为栈记录结果，如果当前栈大于0 且当前字母与栈顶相同，则出栈，否则将其加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> len(res) &gt;= <span class="number">1</span> <span class="keyword">and</span> i == res[<span class="number">-1</span>]:</span><br><span class="line">                res.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1486-XOR-Operation-in-an-Array&quot;&gt;&lt;a href=&quot;#1486-XOR-Operation-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1486. XOR Operation in an Array&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第25周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/20/2020-%E7%AC%AC25%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/20/2020-第25周-LeetCode-记录/</id>
    <published>2020-06-20T06:53:40.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1476-Subrectangle-Queries"><a href="#1476-Subrectangle-Queries" class="headerlink" title="1476. Subrectangle Queries"></a>1476. Subrectangle Queries</h3><p>二维数组的更新与查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubrectangleQueries</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rectangle: List[List[int]])</span>:</span></span><br><span class="line">        self.rect = rectangle</span><br><span class="line">        self.rows, self.cols = len(self.rect), len(self.rect[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateSubrectangle</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int, newValue: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row1, row2 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col1, col2 + <span class="number">1</span>):</span><br><span class="line">                self.rect[i][j] = newValue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self, row: int, col: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.rect[row][col]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SubrectangleQueries object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = SubrectangleQueries(rectangle)</span></span><br><span class="line"><span class="comment"># obj.updateSubrectangle(row1,col1,row2,col2,newValue)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getValue(row,col)</span></span><br></pre></td></tr></table></figure><h3 id="1480-Running-Sum-of-1d-Array"><a href="#1480-Running-Sum-of-1d-Array" class="headerlink" title="1480. Running Sum of 1d Array"></a>1480. Running Sum of 1d Array</h3><p>统计动态和，始终用一个变量记录当前值，遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runningSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            sum += i</span><br><span class="line">            res.append(sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1481-Least-Number-of-Unique-Integers-after-K-Removals"><a href="#1481-Least-Number-of-Unique-Integers-after-K-Removals" class="headerlink" title="1481. Least Number of Unique Integers after K Removals"></a>1481. Least Number of Unique Integers after K Removals</h3><p>对 arr 中出现数字的次数进行统计，并按照升序进行排序，遍历排序后的结果，如果 sum + elem_v 小于等于 k，那么表示此时还可以继续删除数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        res = dict(Counter(arr))</span><br><span class="line">        res = sorted(res.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        len_elem = len(res)</span><br><span class="line">        <span class="keyword">for</span> (elem_k,elem_v) <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> sum + elem_v &lt;= k:</span><br><span class="line">                len_elem -=<span class="number">1</span></span><br><span class="line">                sum += elem_v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> len_elem</span><br></pre></td></tr></table></figure><h3 id="1482-Minimum-Number-of-Days-to-Make-m-Bouquets"><a href="#1482-Minimum-Number-of-Days-to-Make-m-Bouquets" class="headerlink" title="1482. Minimum Number of Days to Make m Bouquets"></a>1482. Minimum Number of Days to Make m Bouquets</h3><p>对所有天数进行排序，使用二分法判断是否满足，其中判断是否可以组成k 朵花需要注意判断是否连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDays</span><span class="params">(self, bloomDay: List[int], m: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(bloomDay)</span><br><span class="line">        <span class="keyword">if</span> n &lt; m * k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(day: int)</span>:</span></span><br><span class="line">            num = sums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> num &gt;= m:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> bloomDay[i] &lt;= day:</span><br><span class="line">                    sums += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sums = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> sums == k:</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">                    sums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= m</span><br><span class="line">        days = sorted(set(bloomDay))</span><br><span class="line">        l, r = <span class="number">0</span>, len(days)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> count(days[mid]):</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> days[l]</span><br></pre></td></tr></table></figure><h3 id="1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><a href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree" class="headerlink" title="1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"></a>1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</h3><p>题目描述不清楚，我理解是 dfs ，只是传入的是两个 Tree，判断符合条件后直接返回另一个 Tree Node。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTargetCopy</span><span class="params">(self, original: TreeNode, cloned: TreeNode, target: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(original, cloned, target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> original <span class="keyword">or</span> <span class="keyword">not</span> cloned:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> original == target:</span><br><span class="line">                <span class="keyword">return</span> cloned</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> traverse(original.left, cloned.left, target) <span class="keyword">or</span> \</span><br><span class="line">                traverse(original.right, cloned.right, target)</span><br><span class="line">        <span class="keyword">return</span> traverse(original, cloned, target)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1476-Subrectangle-Queries&quot;&gt;&lt;a href=&quot;#1476-Subrectangle-Queries&quot; class=&quot;headerlink&quot; title=&quot;1476. Subrectangle Queries&quot;&gt;&lt;/a&gt;1476. Subr
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>从北京转到上海生活两周感受</title>
    <link href="https://zdyxry.github.io/2020/06/13/%E4%BB%8E%E5%8C%97%E4%BA%AC%E8%BD%AC%E5%88%B0%E4%B8%8A%E6%B5%B7%E7%94%9F%E6%B4%BB%E4%B8%A4%E5%91%A8%E6%84%9F%E5%8F%97/"/>
    <id>https://zdyxry.github.io/2020/06/13/从北京转到上海生活两周感受/</id>
    <published>2020-06-13T22:09:05.000Z</published>
    <updated>2020-07-31T23:27:53.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾，换个城市感受一下，正好公司在上海也有办公室，就直接转过来了，到今天已经工作了两周，写一下感受，扯一扯。</p><h2 id="租房"><a href="#租房" class="headerlink" title="租房"></a>租房</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>因为在5月份的时候疫情消停了一段时间，我就开始了远程看房的计划，因为有深圳同事也要转到上海，就计划一起合租，那么目标就是两居室。我们通过 Notion 协作写清楚需求（是的，还有猫的需求），然后各自开始了远程找房。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># yiran 的需求</span><br><span class="line">- 步行 30min 可到达公司</span><br><span class="line">- 民水民点</span><br><span class="line">- 厨房可用</span><br><span class="line">- 周围有商超</span><br><span class="line">- 不临街</span><br><span class="line"></span><br><span class="line">## 同事的需求</span><br><span class="line">- 希望是有电梯的(骑车穿锁鞋很难下楼)</span><br><span class="line">- 避免石膏墙</span><br><span class="line">- 询问一下居住证的问题</span><br><span class="line"></span><br><span class="line">## 猫的需求</span><br><span class="line">- 最好是有防盗网的窗户</span><br><span class="line">- 阳光</span><br><span class="line">- 够大</span><br><span class="line"></span><br><span class="line"># 避免</span><br><span class="line">- 窗户有树</span><br></pre></td></tr></table></figure><h3 id="了解中介"><a href="#了解中介" class="headerlink" title="了解中介"></a>了解中介</h3><p>如果个人在上海本地，那么还有可能通过豆瓣等平台找到房东直接签约没有中介费，但是像我这种时间紧任务重的，就放弃了这种方式选择中介。上海租房与北京租房最主要的不同就是中介费，北京是租客需要支付一个月的租金，而上海是租客与房东共支付一个月的租金作为中介费，所以租客只需要支付50% 的租金即可，这点比北京友好很多，所以我们开始也是倾向于通过中介与房东签约的房子。</p><p>中介主要是链家，我爱我家的房源很少，且质量不高，贝壳上还有些其他的小中介，因为担心有其他隐患，最后还是选择的链家。</p><h3 id="看房"><a href="#看房" class="headerlink" title="看房"></a>看房</h3><p>主要看了两天的时间，第一天看了很多公司周围的板楼，后来才知道这类房子叫“老公房”，房子质量很差，且隔音很是问题，无法接受，于是第二天开始看一些距离公司地铁20min 可达的房子，在看的时候发现我忽略了一个比较重要的点，就是猫，同事养了两只猫，但是我看房子时忽略了房东不让养宠物的可能，直到我看了一个各方面都符合要求的房子后，想要与房东签约，才想到这点，房东果断拒绝了，后续也看了几个房子各方面都很好，但是不让养宠物而错过的，也是没有办法。</p><h3 id="自如"><a href="#自如" class="headerlink" title="自如"></a>自如</h3><p>在看了两天之后，发现房子质量比较好的房东，都不同意租客养宠物，换位思考可以理解，因为时间比较紧张，把目光选择了自如，自如的收费与北京相同，没有差别，照片都是真实的，但是我还是线下去看了房子，确保没有问题，期间发现了一些在自如网站上无法发现的问题：</p><ol><li>隔音，部分房子隔音很差</li><li>周围环境，发现部分房子周围存在基建施工情况，看形式不是几天可以完工的</li><li>老旧小区改造，在北京吃过亏，租的房子是老房子，恰逢政府进行小区改造，两个月没有卫生间的日子还是太难过了</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如果当地有朋友，还是通过朋友那里了解到租房坑是最直接的方式</li><li>要确认好自己的需求，尤其是宠物这种可能会一票否决的事项更是要第一时间提出，否则白白浪费一个小时看房</li><li>找中介看房基本上不会按照自己的计划来安排时间的，每个中介都会拉着你去看几个类似的房子，所以做时间规划的时候最好要留有余地</li><li>实在没有选择就找自如吧，至少是有基本保证，但是要注意上海这边属于南方，宽带很可能没有联通选项</li></ol><p>附一张 Notion 的看房列表：</p><img src="/2020/06/13/从北京转到上海生活两周感受/2.png" title="Notion"><h2 id="搬家"><a href="#搬家" class="headerlink" title="搬家"></a>搬家</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>因为我在去上海前没有租好房子，所以不能先把行李快递走，当时有两个计划，优先计划 2：</p><ol><li>先去上海租房，回北京快递行李，再去上海</li><li>出发前先打包好行李、去上海租房、找同事帮忙快递行李</li></ol><h3 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h3><p>在出发前我已经将自己的行李打包好了，在淘宝买了质量还可以的纸箱子，然后找了北京同事帮忙寄快递，选择的是德邦物流，之前也问过几个朋友，貌似是比较稳妥的方式了，当时物流费用是 448，我进行了保价，一共花费了 488，还是可以接受的，毕竟也是200kg+ 的行李。</p><p>但是事实证明别人的稳妥只有实际体验才知道，德邦在我的纸箱子外套了层编织袋，当我打开行李的时候，发现里面的纸箱子已经接近散架的状态，全靠编织袋才坚持到了上海，不知道其他人是不是也是这样，还好我没有什么贵重的大件物品，否则感觉要完。</p><p>同事搬家选择的顺丰，并且选择了带托盘的方式，行李在出发前是什么样子，到达时就是什么样子，全程行李没有离开托盘，所以行李也没有任何的破损，体验非常好，当然价格也很好，1k+ 的快递费。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果普通物品选择德邦还是可以的，但是我之后应该会选择顺丰。</p><h3 id="气候"><a href="#气候" class="headerlink" title="气候"></a>气候</h3><h3 id="梅雨期"><a href="#梅雨期" class="headerlink" title="梅雨期"></a>梅雨期</h3><p>在来上海前，好多朋友同事都说我作为东北人，会无法适应上海的气候，我觉得还是要感受一下才能知道是否真正适合，不试试是不知道的。</p><p>正好过来收拾的差不多就到了 6 月份，在上班的时候看到一个新闻： <code>气象局宣布，上海入梅了！上海昨天由此进入梅雨期，较常年提早9天。</code> ，这应该是整个夏天最闷最潮湿的时候了，我的感受是，北京我没有感觉到有多干燥，但是上海的潮湿是真的潮，洗完衣服晾干，我都怀疑我的感知能力，这衣服真的干了么？无论什么时间，走在室外都感觉随时会出汗，中午的时候甚至有一种水汽往脸上扑的感觉。因为我个人比较容易出汗，所以来到上海还是出汗，感受倒是没差，只是衣服不干比较愁人，也买了各种除湿袋，不知道是否真的有用，同时也在考虑除湿机。</p><h3 id="下雨"><a href="#下雨" class="headerlink" title="下雨"></a>下雨</h3><p>我自己的鞋子都是网或者布料的，所以如果下大雨鞋子肯定会湿，于是特意买了一双皮质的鞋子想着防雨，但是我低估了上海的大雨，鞋子很快就湿了，又因为是皮质的，所以干的还慢。问了同事才知道，这时候需要拖鞋，于是我在公司和家里都放了拖鞋，如果下大雨就还是穿拖鞋吧。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>目前来看，需要多准备几件衣服防止没有晾干，多准备几双鞋子防止鞋子湿了没有更换，同时备着拖鞋。</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="地下"><a href="#地下" class="headerlink" title="地下"></a>地下</h3><p>平时上班做地铁，之前在北京搭乘地铁我有一个不好的习惯：倚靠安全门，来上海的第一天就被说了两次。。现在好多了。</p><p>上海地铁有一点不好，就是没有屏幕实时展示当前地铁行进状态，虽然有小屏幕滚动，但是不够及时，在地铁上玩手机就需要留意广播重的信息，防止坐过站。</p><h3 id="地上"><a href="#地上" class="headerlink" title="地上"></a>地上</h3><p>公司到家的距离是 5 公里，体验了一下骑车回家，上海的自行车道感受很好，首先很宽，其次没有机动车抢占的情况，整体体验要比北京好很多。发现上海的交通管控也要比北京严格一些，经常能在路口看到交警在指挥交通，毕竟很少看到闯红绿灯的情况。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>目前在上海两周，还没有什么不适，感觉不错，目前还有待确定的：1. 没有暖气的冬天；2. 除湿机是否需要。之后如果有了感受再更新上来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 第24周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/13/2020-第24周-LeetCode-记录/</id>
    <published>2020-06-13T07:38:57.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1470-Shuffle-the-Array"><a href="#1470-Shuffle-the-Array" class="headerlink" title="1470. Shuffle the Array"></a>1470. Shuffle the Array</h3><p>重新排列数组，使用 zip 对两个切分后的数组进行聚合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self, nums: List[int], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(nums[<span class="number">0</span>:n],nums[n:]):</span><br><span class="line">            res+=[i,j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1471-The-k-Strongest-Values-in-an-Array"><a href="#1471-The-k-Strongest-Values-in-an-Array" class="headerlink" title="1471. The k Strongest Values in an Array"></a>1471. The k Strongest Values in an Array</h3><p>找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStrongest</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">        median = arr[(len(arr) - <span class="number">1</span>) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> len(arr) + i - j &lt;= k:</span><br><span class="line">            <span class="keyword">if</span> median - arr[i] &gt; arr[j] - median:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[:i] + arr[j + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h3 id="1472-Design-Browser-History"><a href="#1472-Design-Browser-History" class="headerlink" title="1472. Design Browser History"></a>1472. Design Browser History</h3><p>用两个变量记录 homepage 和当前位置，处理几个场景：  </p><ol><li>从当前页跳转访问 url 对应的页面，需要将当前位置之后的所有历史列表清空</li><li>在浏览历史中后退 steps 步，需要与 0 比较，如果小于 0，则将其置为 0</li><li>在浏览历史中前进 steps 步，需要与当前历史记录长度比较，如果超过长度，则取历史记录中最后一个</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, homepage: str)</span>:</span></span><br><span class="line">        self.hist = [homepage]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, url: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        self.hist[self.pos:] = []</span><br><span class="line">        self.hist.append(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos -= steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &lt; <span class="number">0</span>:</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos += steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.hist):</span><br><span class="line">            self.pos = len(self.hist) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br></pre></td></tr></table></figure><h3 id="754-Reach-a-Number"><a href="#754-Reach-a-Number" class="headerlink" title="754. Reach a Number"></a>754. Reach a Number</h3><blockquote><p><a href="https://www.bilibili.com/video/av31621072/" target="_blank" rel="noopener">https://www.bilibili.com/video/av31621072/</a></p></blockquote><blockquote><p><a href="https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/</a></p></blockquote><p>首先， 由于坐标轴是对称的，往左往右走的几率相等，因此可以只考虑右半轴。先递推一下可以知道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步数        能到达的位置</span><br><span class="line">1:          1</span><br><span class="line">2:          3, 1</span><br><span class="line">3:          6, 4, 2, 0</span><br><span class="line">4:          10, 8, 6, 4, 0</span><br><span class="line">5:          15, 13, 11, 9, 7, 5, 3, 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看出来，每一步能到达的最大位置是上一步最大位置加上步数，而每一步所能达到的位置之间间隔都为2。<br>记f(n)为第n步能到达的位置，那么有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(f(n)) = max(f(n-1)) + n</span><br><span class="line">f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]</span><br></pre></td></tr></table></figure><p>如果target可以在第n步达到，那么target一定小于等于max(f(n))且max(f(n))与taget同奇同偶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachNumber</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        target = abs(target)</span><br><span class="line">        p, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; target <span class="keyword">or</span> (p + target) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            p = p + i</span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree"></a>1038. Binary Search Tree to Greater Sum Tree</h3><p>与 538 题相同，使用 dfs 遍历，优先遍历右节点，然后root 节点，最后左节点，使用 currSum 记录比当前节点数值大的数字和，然后将自身与数字和想家，并更新数字和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        currSum = [<span class="number">0</span>]</span><br><span class="line">        self.recurse(root, currSum)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, root, currSum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.recurse(root.right, currSum)</span><br><span class="line">        root.val = root.val + currSum[<span class="number">0</span>]</span><br><span class="line">        currSum[<span class="number">0</span>] = root.val</span><br><span class="line">        self.recurse(root.left, currSum)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1470-Shuffle-the-Array&quot;&gt;&lt;a href=&quot;#1470-Shuffle-the-Array&quot; class=&quot;headerlink&quot; title=&quot;1470. Shuffle the Array&quot;&gt;&lt;/a&gt;1470. Shuffle the A
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第23周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/06/2020-%E7%AC%AC23%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/06/2020-第23周-LeetCode-记录/</id>
    <published>2020-06-06T13:25:41.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays"><a href="#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays" class="headerlink" title="1460. Make Two Arrays Equal by Reversing Sub-arrays"></a>1460. Make Two Arrays Equal by Reversing Sub-arrays</h3><p>比较两个列表是否可以通过翻转等价，统计列表中字母出现的次数判断，或者可以直接排序判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canBeEqual</span><span class="params">(self, target: List[int], arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        c = collections.Counter(target)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            c[a] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c[a] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1464-Maximum-Product-of-Two-Elements-in-an-Array"><a href="#1464-Maximum-Product-of-Two-Elements-in-an-Array" class="headerlink" title="1464. Maximum Product of Two Elements in an Array"></a>1464. Maximum Product of Two Elements in an Array</h3><p>找到数组中最大的两个数字，分别将其数值 -1 然后相乘返回。可以直接升序排序后取最后两个数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max:=<span class="number">0</span></span><br><span class="line">    secondMax:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        e:=nums[i]</span><br><span class="line">        <span class="keyword">if</span> e&gt;max&#123;</span><br><span class="line">            secondMax = max</span><br><span class="line">            max = e</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> e&gt;secondMax&#123;</span><br><span class="line">            secondMax = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (max<span class="number">-1</span>)*(secondMax<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K"><a href="#1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K" class="headerlink" title="1461. Check If a String Contains All Binary Codes of Size K"></a>1461. Check If a String Contains All Binary Codes of Size K</h3><p>s 字符串中只包含0或1，滑动窗口计算 s 所有长度为 k 的组合，使用 set 去重，与 K 个数字的二进制字符串数量相比较，是否相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAllCodes</span><span class="params">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        m = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)-k+<span class="number">1</span>):</span><br><span class="line">            m.add(s[i:i+k])</span><br><span class="line">        <span class="keyword">return</span> len(m) == (<span class="number">1</span> &lt;&lt; k)</span><br></pre></td></tr></table></figure><h3 id="1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts"><a href="#1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts" class="headerlink" title="1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"></a>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</h3><p>分别对两个数组进行排序切割，找到两个元素之间间隔最大的数值，然后将其相乘为最终所求面积大小，对 <code>1e9 +7</code> 取余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(h <span class="keyword">int</span>, w <span class="keyword">int</span>, horizontalCuts []<span class="keyword">int</span>, verticalCuts []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxH, maxV := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">pre := <span class="number">0</span></span><br><span class="line">sort.Ints(horizontalCuts)</span><br><span class="line">sort.Ints(verticalCuts)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(horizontalCuts); i++ &#123;</span><br><span class="line">maxH = max(maxH, horizontalCuts[i] - pre)</span><br><span class="line">pre = horizontalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxH = max(maxH, h - pre)</span><br><span class="line">pre = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(verticalCuts); i++ &#123;</span><br><span class="line">maxV = max(maxV, verticalCuts[i] - pre)</span><br><span class="line">pre = verticalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxV = max(maxV, w - pre)</span><br><span class="line"><span class="keyword">return</span> (maxH * maxV) % <span class="number">1000000007</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><p>遍历 connections ，统计每个节点之间相邻的节点，使用 dfs 从 0 开始计算，当相邻节点已经访问过了，直接跳过，如果没有访问过，且相邻节点到当前节点方向不对，那么就将结果 +1，并将其添加到访问过的集合中，继续dfs 相邻节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        edges = &#123; (a,b) <span class="keyword">for</span> a, b <span class="keyword">in</span> connections &#125; <span class="comment"># instantly check if a-&gt;b</span></span><br><span class="line">        neighbors = &#123; i:[] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;     <span class="comment"># adjacent cities</span></span><br><span class="line">        visit = set()                             <span class="comment"># visit each city once</span></span><br><span class="line">        changes = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            neighbors[a].append(b)</span><br><span class="line">            neighbors[b].append(a)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs from City 0, count outgoing edges</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> edges, neighbors, visit, changes</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors[city]:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">in</span> visit:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># neighbor can't reach city</span></span><br><span class="line">                <span class="keyword">if</span> (neighbor, city) <span class="keyword">not</span> <span class="keyword">in</span> edges:</span><br><span class="line">                    changes += <span class="number">1</span></span><br><span class="line">                visit.add(neighbor)</span><br><span class="line">                dfs(neighbor)</span><br><span class="line">        </span><br><span class="line">        visit.add(<span class="number">0</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> changes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot;&gt;&lt;a href=&quot;#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第22周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/01/2020-%E7%AC%AC22%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/01/2020-第22周-LeetCode-记录/</id>
    <published>2020-06-01T05:44:57.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence"><a href="#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence" class="headerlink" title="1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence"></a>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</h3><p>切分句子然后遍历判断是否为前缀，需要返回索引 + 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, sentence: str, searchWord: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> idx, w <span class="keyword">in</span> enumerate(sentence.split(<span class="string">' '</span>)):</span><br><span class="line">            <span class="keyword">if</span> w.startswith(searchWord):</span><br><span class="line">                <span class="keyword">return</span> idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length"><a href="#1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length" class="headerlink" title="1456. Maximum Number of Vowels in a Substring of Given Length"></a>1456. Maximum Number of Vowels in a Substring of Given Length</h3><p>滑动窗口，使用字典统计每个元音出现的次数，每次更新最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxVowels</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'e'</span>: <span class="number">0</span>, <span class="string">'i'</span>: <span class="number">0</span>, <span class="string">'o'</span>: <span class="number">0</span>, <span class="string">'u'</span>: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[:k]:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> d:</span><br><span class="line">                d[c] += <span class="number">1</span></span><br><span class="line">        res = sum(d.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i-k] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i-k]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i]] += <span class="number">1</span></span><br><span class="line">            res = max(res, sum(d.values()))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1200-Minimum-Absolute-Difference"><a href="#1200-Minimum-Absolute-Difference" class="headerlink" title="1200. Minimum Absolute Difference"></a>1200. Minimum Absolute Difference</h3><p>遍历列表，记录前一个数值，每次计算绝对差值，更新最小值，如果差值等于最小值，则将其加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span><span class="params">(self, arr: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        m = float(<span class="string">'inf'</span>)</span><br><span class="line">        out = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">            prev = arr[i - <span class="number">1</span>]</span><br><span class="line">            curr = abs(prev - arr[i])</span><br><span class="line">            <span class="keyword">if</span> curr &lt; m:</span><br><span class="line">                out = [[prev, arr[i]]]</span><br><span class="line">                m = curr</span><br><span class="line">            <span class="keyword">elif</span> curr == m: out.append([prev, arr[i]])</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree"><a href="#1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree" class="headerlink" title="1457. Pseudo-Palindromic Paths in a Binary Tree"></a>1457. Pseudo-Palindromic Paths in a Binary Tree</h3><p>DFS 遍历二叉树，使用 set 记录已有数值，如果该数值已经存在，则删掉，如果不存在，则加入set。判断回文字符的依据是set 中剩余字母长度是否小于等于1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        s = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            res = dfs(root.left) + dfs(root.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res += len(s)&lt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence&quot;&gt;&lt;a href=&quot;#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第21周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/22/2020-%E7%AC%AC21%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/22/2020-第21周-LeetCode-记录/</id>
    <published>2020-05-22T22:28:29.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1446-Consecutive-Characters"><a href="#1446-Consecutive-Characters" class="headerlink" title="1446. Consecutive Characters"></a>1446. Consecutive Characters</h3><p>判断最长连续相同字符的长度，记录下当前字母，然后比较与 flag 是否相同，如果相同则 +1，不相同则重置为 1。</p><p>也可以通过 itertools.groupby 来实现（新学习的。。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPower</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp = s[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i == tmp:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = i</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            max_cnt = max(max_cnt, cnt)</span><br><span class="line">        <span class="keyword">return</span> max_cnt</span><br></pre></td></tr></table></figure><h3 id="1447-Simplified-Fractions"><a href="#1447-Simplified-Fractions" class="headerlink" title="1447. Simplified Fractions"></a>1447. Simplified Fractions</h3><p>遍历分子与分母，求最大公约数，如果最大公约数为1，则将结果保存下来。分母从 2 开始计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifiedFractions</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> gcd(i, j) == <span class="number">1</span> &#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, fmt.Sprintf(<span class="string">"%d/%d"</span>, j, i))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x%y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1448-Count-Good-Nodes-in-Binary-Tree"><a href="#1448-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="1448. Count Good Nodes in Binary Tree"></a>1448. Count Good Nodes in Binary Tree</h3><p>遍历所有节点，记录 root 节点到当前节点经过的最大值，当前节点数值与最大值进行比较，如果符合条件，则结果 +1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, curmax)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> node.val &gt;= curmax:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            curmax = max(curmax, node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                dfs(node.left, curmax)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                dfs(node.right, curmax)</span><br><span class="line">            </span><br><span class="line">        dfs(root, -float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h3><p>遍历开始时间和结束时间，判断查询时间是否在两者之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busyStudent</span><span class="params">(self, startTime: List[int], endTime: List[int], queryTime: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(a&lt;=queryTime&lt;=b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(startTime,endTime))</span><br></pre></td></tr></table></figure><h3 id="896-Monotonic-Array"><a href="#896-Monotonic-Array" class="headerlink" title="896. Monotonic Array"></a>896. Monotonic Array</h3><p>遍历数组，记录前一个数字与当前数字的差值，判断是否单调递增或递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt_inc = <span class="number">0</span>; cnt_dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: prev = v; <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>   v &gt; prev: cnt_inc += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; prev: cnt_dec += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt_inc <span class="keyword">and</span> cnt_dec: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            prev = v</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1446-Consecutive-Characters&quot;&gt;&lt;a href=&quot;#1446-Consecutive-Characters&quot; class=&quot;headerlink&quot; title=&quot;1446. Consecutive Characters&quot;&gt;&lt;/a&gt;1446
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第20周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/16/2020-%E7%AC%AC20%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/16/2020-第20周-LeetCode-记录/</id>
    <published>2020-05-16T10:17:49.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1441-Build-an-Array-With-Stack-Operations"><a href="#1441-Build-an-Array-With-Stack-Operations" class="headerlink" title="1441. Build an Array With Stack Operations"></a>1441. Build an Array With Stack Operations</h3><p>遍历数组，比较当前值与目标值是否相同，如果相同，则在结果追加 <code>Push</code> ，如果不同，则追加 <code>Push</code>, <code>Pop</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildArray</span><span class="params">(self, target: List[int], n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        keep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(<span class="string">"Push"</span>)</span><br><span class="line">            keep += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> target:</span><br><span class="line">                res.append(<span class="string">"Pop"</span>)</span><br><span class="line">                keep -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> keep == len(target):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a>1442. Count Triplets That Can Form Two Arrays of Equal XOR</h3><p>求子数组中是否存在左侧部分异或值与右侧部分异或值相等的情况，a==b -&gt; a ^ b = 0，也就是是否存在子数组所有元素异或值为0 的情况，如果存在，那么子数组所有的元素都可以符合条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                temp = temp^arr[j]</span><br><span class="line">                <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                    count += j-i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers"><a href="#1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers" class="headerlink" title="1317. Convert Integer to the Sum of Two No-Zero Integers"></a>1317. Convert Integer to the Sum of Two No-Zero Integers</h3><p>从 1 开始遍历判断两个拆分数字是否包含 <code>0</code> ，判断对 10 取余是否为0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNoZeroIntegers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.check(i) <span class="keyword">and</span> self.check(n - i):</span><br><span class="line">                <span class="keyword">return</span> [i, n - i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree"></a>1443. Minimum Time to Collect All Apples in a Tree</h3><p>通过字典来保证每条路径只走一次，判断子节点是否有苹果，如果没有，则将子节点从字典中删除，最终字典中保存的是必须要经过的节点，要走 2 次，所以需要 * 2 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTime</span><span class="params">(self, n: int, edges: List[List[int]],</span></span></span><br><span class="line"><span class="function"><span class="params">                hasApple: List[bool])</span> -&gt; int:</span></span><br><span class="line">        maps = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            maps[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            selfOrChildHasApple = hasApple[i]</span><br><span class="line">            <span class="keyword">for</span> nex <span class="keyword">in</span> maps[i]:</span><br><span class="line">                selfOrChildHasApple |= dfs(nex)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> selfOrChildHasApple:</span><br><span class="line">                <span class="keyword">del</span> maps[i]</span><br><span class="line">            <span class="keyword">return</span> selfOrChildHasApple</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, <span class="number">2</span> * (len(maps) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="807-Max-Increase-to-Keep-City-Skyline"><a href="#807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="807. Max Increase to Keep City Skyline"></a>807. Max Increase to Keep City Skyline</h3><p>分别找出每行、每列的最大值，然后遍历判断当前值距离两个最大值中的最小值需要增加多少，累加计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        max_cols = [max(col) <span class="keyword">for</span> col <span class="keyword">in</span> zip(*grid)]</span><br><span class="line">        max_rows = [max(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid]</span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[i])):</span><br><span class="line">                inc += (min(max_cols[j], max_rows[i]) - grid[i][j])</span><br><span class="line">        <span class="keyword">return</span> inc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1441-Build-an-Array-With-Stack-Operations&quot;&gt;&lt;a href=&quot;#1441-Build-an-Array-With-Stack-Operations&quot; class=&quot;headerlink&quot; title=&quot;1441. Buil
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>PyInstaller 与 RPM 配合使用踩坑</title>
    <link href="https://zdyxry.github.io/2020/05/13/PyInstaller-%E4%B8%8E-RPM-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"/>
    <id>https://zdyxry.github.io/2020/05/13/PyInstaller-与-RPM-配合使用踩坑/</id>
    <published>2020-05-13T20:35:50.000Z</published>
    <updated>2020-07-31T23:27:53.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配置会有坑，然后搜索下来几乎没看到有人提到，可能用 pyinstaller 和用 rpm 的完全是两类人吧 - -。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先列一下官方默认例子的输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/demo</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls</span></span><br><span class="line">demo.py</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> pyinstaller demo.py</span></span><br><span class="line">63 INFO: PyInstaller: 3.6</span><br><span class="line">63 INFO: Python: 3.6.8</span><br><span class="line">65 INFO: Platform: Linux-3.10.0-862.el7.x86_64-x86_64-with-centos-7.5.1804-Core</span><br><span class="line">65 INFO: wrote /tmp/demo/demo.spec</span><br><span class="line">67 INFO: UPX is not available.</span><br><span class="line">70 INFO: Extending PYTHONPATH with paths</span><br><span class="line">['/tmp/demo', '/tmp/demo']</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>来看一下生成文件的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── demo</span><br><span class="line">├── demo.py</span><br><span class="line">├── demo.spec</span><br><span class="line">├── dist</span><br><span class="line">│   └── demo</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── binascii.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _bisect.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _blake2.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">|       ├── ...</span><br><span class="line">│       ├── _codecs_kr.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _codecs_tw.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _datetime.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── demo</span><br><span class="line">│       ├── libbz2.so.1</span><br><span class="line">│       ├── libcom_err.so.2</span><br><span class="line">│       ├── libcrypto.so.10</span><br><span class="line">│       ├── libexpat.so.1</span><br><span class="line">│       ├── libgssapi_krb5.so.2</span><br><span class="line">│       ├── libk5crypto.so.3</span><br><span class="line">│       ├── libkeyutils.so.1</span><br><span class="line">│       ├── libtinfo.so.5</span><br><span class="line">│       ├── libkrb5support.so.0</span><br><span class="line">│       ├── liblzma.so.5</span><br><span class="line">│       ├── libpcre.so.1</span><br><span class="line">│       ├── libpython3.6m.so.1.0</span><br><span class="line">│       ├── libreadline.so.6</span><br><span class="line">│       ├── libz.so.1</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── demo.cpython-36.pyc</span><br></pre></td></tr></table></figure><p>看上去也没啥问题，编写一个 rpm spec，然后使用 rpmbuild 直接就可以生成一个 RPM出来，在 RedHat 系列的 OS上可以直接安装使用，具体的步骤可以参考之前的博客：<a href="https://zdyxry.github.io/2018/07/28/RPM-%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/">《RPM 常用构建方式》</a>，目前来看一切都正常，但是坑来了。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在验证完基础的功能后，我想要将这个 RPM 放到 ISO 中发布，在验证过程中，发现这个 RPM 会破坏系统其他的依赖检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:00:20 tmp]$cat packaging.log |grep so |grep 'No such file'</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error ...</span><br><span class="line">09:19:50,495 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /usr/bin/trust: error while loading shared libraries: libfreebl3.so: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,500 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,501 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>简单的过滤了一下，有这些包直接受到了影响，还有很多未知的，简单的说就是系统的一些核心依赖库缺失，没有安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:02:48 tmp]$cat packaging.log |grep 'scriptlet failed'</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(readline-6.2-10.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(gawk-4.0.2-4.el7_3.1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(info-5.1-4.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(qemu-kvm-aurora-0.3.3-1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,495 INFO packaging: warning: %post(glib2-2.50.3-3.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,499 INFO packaging: warning: %post(ca-certificates-2017.2.14-71.el7.noarch) scriptlet failed, exit status 127</span><br></pre></td></tr></table></figure><p>最初在排查是否是 anaconda 在检查 rpm 相互之间的依赖时出了 bug，但是最近版本没什么变化，理论上不会，又去瞧了瞧 anaconda 的代码，发现跟 rpm 相关的太多，一时也没看出什么头绪。</p><p>再来看一下相关的库， <code>libz.so.1</code> , <code>libtinfo.so.5</code> 有没有点眼熟，都是在 pyinstaller 生成的文件中的，但是有一点很奇怪，命令路径都不是系统路径，为什么在检查依赖的时候还是会检查到新加入的 rpm 上，而不是真正提供这些库的 RPM？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>今天的主角登场：Automatic Dependencies。</p><p>Automatic Dependencies 是 RPM 的一个特性，官方文档中是这么描述的：</p><blockquote><p>When a package is built by RPM, if any file in the package’s %files list is a shared library, the library’s soname is automatically added to the list of capabilities the package provides. The soname is the name used to determine compatibility between different versions of a library.</p></blockquote><blockquote><p>Note that this is not a filename. In fact, no aspect of RPM’s dependency processing is based on filenames. Many people new to RPM often make the assumption that a failed dependency represents a missing file. This is not the case.</p></blockquote><blockquote><p>Remember that RPM’s dependency processing is based on knowing what capabilities are provided by a package and what capabilities a package requires. We’ve seen how RPM automatically determines what shared library resources a package provides. But does it automatically determine what shared libraries a package requires?</p></blockquote><blockquote><p>Yes! RPM does this by running ldd on every executable program in a package’s %files list. Since ldd provides a list of the shared libraries each program requires, both halves of the equation are complete — that is, the packages that make shared libraries available, and the packages that require those shared libraries, are tracked by RPM. RPM can then take that information into account when packages are installed, upgraded, or erased.</p></blockquote><p>嗯，找到问题了，解决的方式也很简单，直接关掉就好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoReqProv: no</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说 pyinstaller 用的人不少，rpm 用的人也不少，这俩默认配置配合使用是一定会出问题的，但是没有找到相关的问题，可能真的不是一类人吧。</p><p>用同事的话作为结束语： <code>automatic 开头的东西，一个字都不要信</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第19周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/08/2020-%E7%AC%AC19%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/08/2020-第19周-LeetCode-记录/</id>
    <published>2020-05-08T07:48:12.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1436-Destination-City"><a href="#1436-Destination-City" class="headerlink" title="1436. Destination City"></a>1436. Destination City</h3><p>使用 set() 来计算每个城市是否处于起始和终止，集合差为终点站。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destCity</span><span class="params">(self, paths: List[List[str]])</span> -&gt; str:</span></span><br><span class="line">        a = set()</span><br><span class="line">        b = set()</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">            x, y = path</span><br><span class="line">            a.add(x)</span><br><span class="line">            b.add(y)</span><br><span class="line"></span><br><span class="line">        b = b - a</span><br><span class="line">        <span class="keyword">assert</span> len(b) == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> b.pop()</span><br></pre></td></tr></table></figure><h3 id="1432-Max-Difference-You-Can-Get-From-Changing-an-Integer"><a href="#1432-Max-Difference-You-Can-Get-From-Changing-an-Integer" class="headerlink" title="1432. Max Difference You Can Get From Changing an Integer"></a>1432. Max Difference You Can Get From Changing an Integer</h3><p>分别求出给定数字可以转换的最大值和最小值，然后求差，最大值是将数字从前向后遍历，当数值不为9时，将其替换为 9；最小值要求首位不能为 0，则需要特殊判断，如果首位不为1，则将其替换为1，如果首位为1，则遍历后续数字，如果数字不为0，则替换为0，需要注意此时首位为1，如果数字为1然后替换为0会出现首位为0 情况，因此需要判断数字不为0且不为1，然后替换为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDiff</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        a = b = str(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> a:</span><br><span class="line">            <span class="keyword">if</span> digit != <span class="string">"9"</span>:</span><br><span class="line">                a = a.replace(digit, <span class="string">"9"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> b[<span class="number">0</span>] != <span class="string">"1"</span>:</span><br><span class="line">            b = b.replace(b[<span class="number">0</span>], <span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> digit <span class="keyword">in</span> b[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> digit <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"01"</span>:</span><br><span class="line">                    b = b.replace(digit, <span class="string">"0"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> int(a) - int(b)</span><br></pre></td></tr></table></figure><h3 id="1433-Check-If-a-String-Can-Break-Another-String"><a href="#1433-Check-If-a-String-Can-Break-Another-String" class="headerlink" title="1433. Check If a String Can Break Another String"></a>1433. Check If a String Can Break Another String</h3><p>检查两个字符串的字符序是否存在交叉情况，先对字符串进行排序，然后使用两个 flag 标记当前字符的大小，如果有大有小，那么直接返回 False，否则返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfCanBreak</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        s1= sorted(s1)</span><br><span class="line">        s2= sorted(s2)</span><br><span class="line">        res1, res2 = <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> zip(s1, s2):</span><br><span class="line">            com = ord(pair[<span class="number">0</span>]) - ord(pair[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> com &gt; <span class="number">0</span>:</span><br><span class="line">                res1 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> com &lt; <span class="number">0</span>:</span><br><span class="line">                res2 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> res1 <span class="keyword">and</span> res2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away"><a href="#1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away" class="headerlink" title="1437. Check If All 1’s Are at Least Length K Places Away"></a>1437. Check If All 1’s Are at Least Length K Places Away</h3><p>检查每个数字 1 之间的间隔是否大于 k，如果不大于则返回 False，遍历数字，如果数字不为 1，则将间隔 +1，直到下次遇1时判断并重置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kLengthApart</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        zero_num = <span class="number">1e5</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> zero_num &lt; k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                zero_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                zero_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</h3><p>滑动窗口，遍历数字，每次更新最大值与最小值，如果符合条件，则窗口增大，否则从左侧缩小窗口，缩小窗口后需要注意更新最大值与最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int], limit: int)</span> -&gt; int:</span></span><br><span class="line">        minimal, maximal = float(<span class="string">"inf"</span>), float(<span class="string">"-inf"</span>)</span><br><span class="line">        size, current_size_start_number = <span class="number">0</span>, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            maximal = max(maximal, nums[i])</span><br><span class="line">            minimal = min(minimal, nums[i])</span><br><span class="line">            <span class="keyword">if</span> abs(maximal - minimal) &lt;= limit:</span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_size_start_number = nums[i-size]</span><br><span class="line">                <span class="keyword">if</span> current_size_start_number == minimal:</span><br><span class="line">                    minimal = min(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> current_size_start_number == maximal:</span><br><span class="line">                    maximal = max(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1436-Destination-City&quot;&gt;&lt;a href=&quot;#1436-Destination-City&quot; class=&quot;headerlink&quot; title=&quot;1436. Destination City&quot;&gt;&lt;/a&gt;1436. Destination City
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第18周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/01/2020-%E7%AC%AC18%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/01/2020-第18周-LeetCode-记录/</id>
    <published>2020-05-01T06:43:57.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1422-Maximum-Score-After-Splitting-a-String"><a href="#1422-Maximum-Score-After-Splitting-a-String" class="headerlink" title="1422. Maximum Score After Splitting a String"></a>1422. Maximum Score After Splitting a String</h3><p>求出左侧 0 数量和右侧 1 数量之和最多的情况，遍历一次，每次更新最大值，注意要保证字符串始终被切分为 2 个子字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        right = s.count(<span class="string">'1'</span>)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        score = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[idx] == <span class="string">'1'</span>:</span><br><span class="line">                score = max(score, (left + right - <span class="number">1</span>))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                score = max(score, (left + <span class="number">1</span> + right))</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure><h3 id="1423-Maximum-Points-You-Can-Obtain-from-Cards"><a href="#1423-Maximum-Points-You-Can-Obtain-from-Cards" class="headerlink" title="1423. Maximum Points You Can Obtain from Cards"></a>1423. Maximum Points You Can Obtain from Cards</h3><p>先假设所有的数字都是从左侧获取的，然后依次遍历 k 个数值，每次遍历将左侧数字剔除，将右侧数字加入，比较最大值。</p><p>也可以转换问题为中间连续 len-k 长度数字和最小，然后所有数字之和减去最小值为所求结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxScore</span><span class="params">(cardPoints []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum + cardPoints[i]</span><br><span class="line">&#125;</span><br><span class="line">listLen := <span class="built_in">len</span>(cardPoints)</span><br><span class="line"><span class="keyword">if</span> k == listLen &#123;</span><br><span class="line"><span class="keyword">return</span> leftSum</span><br><span class="line">&#125;</span><br><span class="line">max := leftSum</span><br><span class="line"><span class="keyword">var</span> rightSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum - cardPoints[k-i<span class="number">-1</span>]</span><br><span class="line">rightSum = rightSum + cardPoints[listLen-i<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> leftSum+rightSum &gt; max &#123;</span><br><span class="line">max = leftSum + rightSum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a>1424. Diagonal Traverse II</h3><p>按照对角线方式打印出所有数字，考虑对角线部分数字为空的情况。在一个对角线上的数字，他们的横纵坐标之和都是相同的，使用一个二维数组存储，然后从上到下顺序打印出所有对角线的数值，需要注意每条对角线的数值输出应该是从下到上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="params">(ans []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    order := [<span class="number">1e5</span>][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(mat) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> mat[i] &#123;</span><br><span class="line">order[i+j] = <span class="built_in">append</span>(order[i+j], v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> order &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a>498. Diagonal Traverse</h3><p>可以用 #1424 相同的方式处理，获取所有对角线的数值，然后遍历，注意输出的顺序，也可以直接模拟，需要处理好边界。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, n*m)</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(res); i++ &#123;</span><br><span class="line">res[i] = matrix[x][y]</span><br><span class="line"><span class="keyword">if</span> (x+y)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> y == m<span class="number">-1</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y++</span><br><span class="line">x--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == n<span class="number">-1</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x++</span><br><span class="line">y--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h3><p>一个数字与全 1 进行异或，得到的数字为二进制取反。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findComplement</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">temp := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; temp &lt;= num; temp *= <span class="number">2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (temp - <span class="number">1</span>) ^ num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">5</span></span><br><span class="line">res := findComplement(num)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1422-Maximum-Score-After-Splitting-a-String&quot;&gt;&lt;a href=&quot;#1422-Maximum-Score-After-Splitting-a-String&quot; class=&quot;headerlink&quot; title=&quot;1422. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>在终端输入命令后系统做了什么</title>
    <link href="https://zdyxry.github.io/2020/04/25/%E5%9C%A8%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E5%90%8E%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://zdyxry.github.io/2020/04/25/在终端输入命令后系统做了什么/</id>
    <published>2020-04-25T15:18:03.000Z</published>
    <updated>2020-07-31T23:27:53.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>shell 是一个程序，也是一种编程语言，一个管理进程和运行程序的程序，在 Linux 中有很多 shell 可选，比如 bash、zsh、fish 等等，shell 主要有 3 个功能：</p><ol><li>运行程序</li><li>管理输入和输出</li><li>可编程</li></ol><p>运行程序很容易理解，在终端上输入的每个命令都是一个可执行程序，我们在 shell 中输入并执行程序；管理输入和输出，在 shell 中可以使用 <code>&lt;</code> <code>&gt;</code> <code>|</code> 符合控制输入、输出重定向，可以告诉 shell 将进程的输入和输出连接到一个文件或者其他的进程；编程，shell 是一种编程语言，可以进行变量赋值、循环、条件判断等操作。</p><h3 id="如何运行程序"><a href="#如何运行程序" class="headerlink" title="如何运行程序"></a>如何运行程序</h3><p>shell 永远在等待用户输入，输入完成按下回车键后，开始执行相应命令（程序），然后等待程序执行完成后打印相应输出，伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (! end_of_input)</span><br><span class="line">    get command</span><br><span class="line">    execute command</span><br><span class="line">    wait for command to finish</span><br></pre></td></tr></table></figure><p>在 shell 中因为需要执行其他的程序，需要用到 <code>execvp</code> ，<code>execvp</code> 会将指定的程序复制到调用它的进程，将指定的字符串组作为参数传递给程序，然后运行程序。这里存在一个问题， <code>execvp</code> 的执行过程是内核将程序加载到当前进程，替换当前进程的代码和数据，然后执行，那么原有进程的状态都被替换掉，在执行完程序就直接退出，不会再回到原程序等待下次输入。</p><p>为了保证我们在执行程序后回到 shell 中，需要每次创建新的进程来执行程序，调用 <code>fork</code> 指令，进程调用 fork 后，内核分配新的内存块和内核数据结构，复制原进程到新的进程，向运行进程添加新的进程，将控制返回给两个进程。通过 fork 返回值来判断当前进程是否为父进程或子进程。</p><p>shell 作为父进程通过调用 <code>fork</code> 创建子进程后，子进程通过 <code>execvp</code> 加载指定程序执行，父进程需要等待子进程退出，需要用到 <code>wait</code> ，在父进程 fork 出子进程后，父进程执行 <code>wait</code> 等待子进程执行，在调用时会传递一个整型变量地址，子进程执行完成后调用 <code>exit</code> 退出，内核将子进程的退出状态保存在这个变量中，用于父进程感知子进程退出状态。</p><h2 id="Golang-简易实现"><a href="#Golang-简易实现" class="headerlink" title="Golang 简易实现"></a>Golang 简易实现</h2><p>在 Golang 中可以调用 <code>os/exec</code> 来执行其他程序，然后在 main 中死循环不断的检测用户输入字符，同时也需要注意处理各种信号，比如 Ctrl-C 或者 Ctrl-D 之类的，下面是 Simon Jürgensmeyer 实现的一个简单的样例，可以了解一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"&gt; "</span>)</span><br><span class="line">        <span class="comment">// Read the keyboad input.</span></span><br><span class="line">        input, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle the execution of the input.</span></span><br><span class="line">        <span class="keyword">if</span> err = execInput(input); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrNoPath is returned when 'cd' was called without a second argument.</span></span><br><span class="line"><span class="keyword">var</span> ErrNoPath = errors.New(<span class="string">"path required"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execInput</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Remove the newline character.</span></span><br><span class="line">    input = strings.TrimSuffix(input, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split the input separate the command and the arguments.</span></span><br><span class="line">    args := strings.Split(input, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for built-in commands.</span></span><br><span class="line">    <span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"cd"</span>:</span><br><span class="line">        <span class="comment">// 'cd' to home with empty path not yet supported.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrNoPath</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change the directory and return the error.</span></span><br><span class="line">        <span class="keyword">return</span> os.Chdir(args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the command to execute.</span></span><br><span class="line">    cmd := exec.Command(args[<span class="number">0</span>], args[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the correct output device.</span></span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the command and return the error.</span></span><br><span class="line">    <span class="keyword">return</span> cmd.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/" target="_blank" rel="noopener">https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/</a></li><li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="noopener">https://book.douban.com/subject/1219329/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第17周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/24/2020-%E7%AC%AC17%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/24/2020-第17周-LeetCode-记录/</id>
    <published>2020-04-24T20:47:03.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1417-Reformat-The-String"><a href="#1417-Reformat-The-String" class="headerlink" title="1417. Reformat The String"></a>1417. Reformat The String</h3><p>重新格式化字符串，使得字母与数字交叉连接，先分别找出字母与数据，使用 zip_longest 来生成交叉后的元组，然后拼接得到目标字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reformat</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        a=re.findall(<span class="string">r'\d'</span>,s)</span><br><span class="line">        b=re.findall(<span class="string">r'[a-z]'</span>,s)</span><br><span class="line">        <span class="keyword">if</span> abs(len(a)-len(b))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        a,b=sorted([a,b],key=len)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(map(<span class="string">''</span>.join,itertools.zip_longest(b,a,fillvalue=<span class="string">''</span>)))</span><br></pre></td></tr></table></figure><h3 id="1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K"><a href="#1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K" class="headerlink" title="1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K"></a>1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K</h3><p>参考：<a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/tan-xin-jian-dan-zheng-ming-by-wyjoutstanding/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/tan-xin-jian-dan-zheng-ming-by-wyjoutstanding/</a></p><p>判定性：保证K一定能由斐波那契数组成，数据归纳法可证明</p><p>最小性：什么样的组合能最短？</p><ul><li>相邻合并：2个相邻的数可合并为二者的和，长度-1，因为f(n)=f(n-1)+f(n-2)。满足该条件的组合必定是间隔出现，但是又可能重现重复的值，这对于编程很不利。</li><li>重值转换：两个相同的值一定可以转换为两个不同的值，因为f(n)+f(n)=f(n)+f(n-1)+f(n-2)=f(n+1)+f(n-2)，一个比f(n)大，一个更小，这是等价转换，不会减小组合长度，但是会带来一个很好的性质，即单调递增性质。</li></ul><p>因此，重复使用以上两个操作后的组合数列，必定是一个无相邻值的递增数列，由于数列均为正数且和为K，因此值越大个数自然越小。</p><p>问：</p><blockquote><p>那会不会出现一种情况呢，就是如果减去最大的斐波那契数的话，剩下的数只能拆分成两个斐波那契数，而如果减去第二大的斐波那契数或者更小的斐波那契数的话，剩下的数刚好是斐波那契数？</p></blockquote><p>答：</p><p>可用反证法，假设总和为k，且f(m-1)&lt;k&lt;f(m)<br>那么对应你的第一种情况是k=f(m-1)+f(i)+f(j)，1&lt;=f(i),f(j)&lt;=f(m-2)；<br>对应你的第二种情况是k=f(m-2)+f(l)，其中,1&lt;=f(l)&lt;=f(m-3)。  </p><p>假设你说的情况成立，那么以上两个等式必定相等，即f(m-1)+f(i)+f(j)=f(m-2)+f(l)，<br>因为f(m-1) = f(m-2) + f(m-3), f(l)&lt;=f(m-3)，而f(i)和f(j)均不可能为0，因此等式不可能成立。<br>（左侧恒大于右侧，只有消去f(i)和f(j)才有可能取等）<br>当第二个等式的f(m-2)取更小值时更不可能成立。因此，推翻假设。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(self, k: int)</span> -&gt; int:</span></span><br><span class="line">        ls=self.fib(k)</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            <span class="keyword">if</span> k&gt;=ls[<span class="number">-1</span>]:</span><br><span class="line">                k-=ls[<span class="number">-1</span>]</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ls.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span> -&gt; int:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> b &lt;= N:</span><br><span class="line">            res.append(b)</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n"><a href="#1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n" class="headerlink" title="1415. The k-th Lexicographical String of All Happy Strings of Length n"></a>1415. The k-th Lexicographical String of All Happy Strings of Length n</h3><p>使用 dfs 求解，每次传入下一层时需要去除当前层最后一个字母；<br>不需要算出所有长度为 n 的值，在得到第 k 个时可以直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHappyString</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        self.res = <span class="string">""</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur, tmp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(cur) == self.n:</span><br><span class="line">                self.k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                    self.res = cur</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> self.res:</span><br><span class="line">                    <span class="keyword">return</span> self.res</span><br><span class="line">                new_tmp = [j <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] <span class="keyword">if</span> j != i]</span><br><span class="line">                dfs(cur+i, new_tmp)</span><br><span class="line">        dfs(<span class="string">""</span>, [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1419-Minimum-Number-of-Frogs-Croaking"><a href="#1419-Minimum-Number-of-Frogs-Croaking" class="headerlink" title="1419. Minimum Number of Frogs Croaking"></a>1419. Minimum Number of Frogs Croaking</h3><p>可以转换为求在 <code>croak</code> 周期内，出现多少个 <code>c</code>，需要考虑边界情况，<code>croak</code> 字母出现次数永远是按照顺序依次递减的，如果出现递增情况直接返回 -1；最终遍历结束后应该保证 <code>croak</code> 中的各个字母出现次数相同，且不存在出现 <code>croak</code> 一半的情况，比如 存在 <code>cro</code> ，如果存在则直接返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberOfFrogs</span><span class="params">(self, croakOfFrogs: str)</span> -&gt; int:</span></span><br><span class="line">        c, r, o, a, k, in_use, answer = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> croakOfFrogs:</span><br><span class="line">            <span class="keyword">if</span> d == <span class="string">'c'</span>:</span><br><span class="line">                c, in_use = c+<span class="number">1</span>, in_use+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'r'</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'o'</span>:</span><br><span class="line">                o += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'a'</span>:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k, in_use = k+<span class="number">1</span>, in_use<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            answer = max(answer, in_use)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> c &lt; r <span class="keyword">or</span> r &lt; o <span class="keyword">or</span> o &lt; a <span class="keyword">or</span> a &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> in_use == <span class="number">0</span> <span class="keyword">and</span> c == r <span class="keyword">and</span> r == o <span class="keyword">and</span> o == a <span class="keyword">and</span> a == k:</span><br><span class="line">            <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="926-Flip-String-to-Monotone-Increasing"><a href="#926-Flip-String-to-Monotone-Increasing" class="headerlink" title="926. Flip String to Monotone Increasing"></a>926. Flip String to Monotone Increasing</h3><p>动态规划，dp[i][0] 表示以 0 为结尾时，翻转的次数；dp[i][1] 表示以 1 为结尾是，翻转的次数；</p><p>当 i == 0 时，dp[i][0] = dp[i-1][0]，无需操作；<br>当 i == 0 时，dp[i][1] = min(dp[i-1][1], dp[i-1][0]) + 1，当 dp[i-1][1] 时，那么次数的 i = 0 ，需要翻转为 1，需 +1；当 dp[i-1][0] 时，此时要求以 1 为结尾需要翻转的次数，那么就需要将 i 翻转为 1，需 +1;  </p><p>当 i == 1 时，dp[i][0] = dp[i - 1][0] + 1 ，因为此时要求以 0 为结尾，需要将 i 翻转为 0，需 +1;<br>当 i == 1 时，dp[i][1] = min(dp[i - 1][1], dp[i - 1][0])，dp[i-1][1] 且当前 i == 1，所以无需操作；dp[i-1][0] 表示之前都是0且结尾是0，那么此时 i == 1 也符合递增情况无需操作。</p><p>简化后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, S: str)</span> -&gt; int:</span></span><br><span class="line">        N = len(S)</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i - <span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>]</span><br><span class="line">                dp[<span class="number">1</span>] = min(dp[<span class="number">1</span>], dp[<span class="number">0</span>]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">1</span>] = min(dp[<span class="number">1</span>], dp[<span class="number">0</span>])</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1417-Reformat-The-String&quot;&gt;&lt;a href=&quot;#1417-Reformat-The-String&quot; class=&quot;headerlink&quot; title=&quot;1417. Reformat The String&quot;&gt;&lt;/a&gt;1417. Reforma
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>文件系统基本概念及常用操作解释</title>
    <link href="https://zdyxry.github.io/2020/04/18/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%A7%A3%E9%87%8A/"/>
    <id>https://zdyxry.github.io/2020/04/18/文件系统基本概念及常用操作解释/</id>
    <published>2020-04-18T14:24:23.000Z</published>
    <updated>2020-07-31T23:27:53.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间一个朋友问我删除文件和格式化有什么区别，最近正好在读《Unix Linux 编程实践教程》这本书，其中第4章是来讲文件系统相关的，本文是对其中内容进行部分摘要来解释。</p><h2 id="Unix-文件系统的内部结构"><a href="#Unix-文件系统的内部结构" class="headerlink" title="Unix 文件系统的内部结构"></a>Unix 文件系统的内部结构</h2><p>从用户角度看，Unix 系统中的硬盘上的文件组成一棵目录树，每个目录能包含文件或其他目录，目录树的深度几乎没有限制，子目录下可以包含其他文件和子目录（套娃）。文件内容放置在对应的目录中，对应的目录内容放置在上层目录中。</p><p>文件系统是对硬盘设备的一种多层次的抽象，主要包含以下三层。</p><h3 id="第一层：从硬盘到分区"><a href="#第一层：从硬盘到分区" class="headerlink" title="第一层：从硬盘到分区"></a>第一层：从硬盘到分区</h3><p>一个硬盘能够存储大量的数据，硬盘可以被划分为多个区域，也就是硬盘分区，每个分区在系统中都可以看作是独立的硬盘。</p><h3 id="第二层：从磁盘到块序列"><a href="#第二层：从磁盘到块序列" class="headerlink" title="第二层：从磁盘到块序列"></a>第二层：从磁盘到块序列</h3><p>一个硬盘由许多磁性盘片组成，每个盘片的表面都被划分为很多同心圆，这些同心圆被成为磁道，每个磁道有进一步被划分为扇区，每个扇区可以存储一定字节数的数据，例如每个扇区有 512字节空间。扇区是磁盘上的基本存储单元，磁盘都包含大量的扇区。</p><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-1.jpg" title="fs-1"><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-2.jpg" title="fs-2"><p>为磁盘块编号是一种很重要的方法，给每个磁盘块分配连续的编号使得操作系统能够计算磁盘上的每个块，可以一个磁盘接一个磁盘的从上到下给所有的块编号，还可以一个磁道接一个磁道的从外向里给所有的块编号，一个将磁盘扇区编号的系统使得我们可以把磁盘视为一系列块的组合。</p><h3 id="第三层：从块序列到三个区域的划分"><a href="#第三层：从块序列到三个区域的划分" class="headerlink" title="第三层：从块序列到三个区域的划分"></a>第三层：从块序列到三个区域的划分</h3><p>文件系统可以用来存储文件内容、文件属性（文件所有者、日期等）和目录，这些不同类型的数据是如何存储在编号的磁盘块上的呢?</p><h2 id="文件系统区域划分"><a href="#文件系统区域划分" class="headerlink" title="文件系统区域划分"></a>文件系统区域划分</h2><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-3.png" title="fs-3"><p>一部分成为数据区，用来存放文件真正的内容。另一部分成为 i-node 表，用来存放文件属性。第三部分成为超级块（superblock），用来存放文件系统自身的信息。文件系统由这 3 部分组合而成，其中任一部分都是由很多有序磁盘块组成的。</p><h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>文件系统的第一个块被成为超级块。这个块中存放文件系统自身的结构信息，比如记录了每个区域的大小。超级块也存放未被使用的磁盘块信息，不同的文件系统的超级块信息不同，可以通过 <code>debugfs</code> 等类似命令查看。</p><h3 id="i-node-表"><a href="#i-node-表" class="headerlink" title="i-node 表"></a>i-node 表</h3><p>文件系统的下一个部分被成为 i-node 表，每个文件都有一些属性，如大小、文件所有者和最近修改时间等等，这些属性被记录在一个被成为 i-node 的结构中，所有的 i-node 都有相同的大小，并且 i-node 表是这些 i-node 结构组成的一个列表。文件系统中每个文件都有一个 i-node。</p><h3 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h3><p>文件系统的第 3 个部分是数据区。文件的真正内容保存在这个区域。磁盘上所有块的大小都是一样的。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。一个较大的文件很容易分布在上千个独立的磁盘块中。</p><h2 id="常见操作过程解释"><a href="#常见操作过程解释" class="headerlink" title="常见操作过程解释"></a>常见操作过程解释</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>当我们创建一个文件的时候，主要操作有以下 4个：</p><ul><li>存储属性<ul><li>文件属性的存储：内核先找到一个空的 i-node，把文件的信息记录到 i-node 中。</li></ul></li><li>存储数据<ul><li>文件内容的存储：内核从未被使用的数据块列表中找出足够的数据块，然后将数据从缓冲区复制到对应的数据块中。</li></ul></li><li>记录分配情况<ul><li>文件内容按照顺序存放在数据块中。内核在 i-node 的磁盘分布区记录了上述的块序列。磁盘分布区是一个磁盘块序号的列表。</li></ul></li><li>添加文件名到目录<ul><li>内核将文件 i-node 编号和对应的文件名添加到目录文件。文件名和 i-node 编号之间的对应关系将文件名和文件内容及文件属性进行了关联。</li></ul></li></ul><p>如果创建一个大文件该如何做？一个大文件需要多个磁盘块，在 i-node 中存放磁盘块分配列表，但是长度是固定的，也就是文件大小是有上限的，如何尽可能的支持更大的文件？</p><p>如果一个文件需要 14个数据块存储内容，但是 i-node 只包含一个含有 13 个项的分配列表，这是将分配列表中的前 10 个编号放到 i-node 中，将最后的 4个编号放到一个数据块中，然后在 i-node 的第 11 项中作为指向存放 4个数据块编号的数据块。最终这个文件一共使用了15个数据块，额外使用的数据块成为间接块。</p><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-4.png" title="fs-4"><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><ul><li>在目录中寻找文件名<ul><li>文件名存储在目录文件中，内核在目录文件中寻找包含文件名的记录，然后找到对应的 i-node 编号</li></ul></li><li>定位 i-node 编号并读取内容<ul><li>内核在文件系统的 i-node 区域找到对应的 i-node。定位 i-node 需要简单的计算，所有的 i-node 大小相同，每个磁盘块都包含相同数量的 i-node。内核会将 i-node 置为缓冲区，i-node 包含数据块编号的列表。</li></ul></li><li>访问存储文件内容的数据块<ul><li>通过 i-node 信息，内核已经知道文件真正的内容存放在哪些数据块上，以及它们的顺序，将字节从磁盘复制到内核缓冲区，然后到达用户空间。</li></ul></li></ul><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>目录是一种包含了文件名字列表的特殊文件，不同版本的 Unix 目录内部结构不同，但是抽象模型是一致的—一个包含 i-node 编号和文件名的列表。</p><p>当一个文件想要被多种方式共享且保证他们是一个文件，有多个有效的路径名，系统引入了链接机制：硬链接和软链接。其中硬链接与文件的 i-node 一致。一个文件内容自身的硬链接数刚创建时为1，之后通过其他方式创建了硬链接，那么引用计数对应增加。</p><p>“文件在目录中”从系统的角度看，是目录中有一个包含文件名和对应 i-node 编号的入口，“文件 x 在目录 a 中”意味着在目录 a 中有一个指向对应 i-node 的链接，这个链接所附加的文件名为 <code>x</code>。简单来说，目录包含的是文件的引用，每个引用被成为链接，文件的内容存储在数据块中，文件的属性被记录在 i-node 中，i-node编号和文件名存储在目录中。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除文件是从一个目录中删除一个对应文件的引用记录，减少对应的 i-node 的链接数，如果 i-node 的链接数减为0，则 i-node 和 i-node 对应的数据块被释放，这里的释放指的是删除 i-node 信息，这样我们就没办法通过 i-node 信息找到文件数据块信息的对应关系，但是文件真正的内容还是存在数据块中的，没有被删除，如果发现误删之后立即停止所有操作，是有可能通过一些方式来达到数据恢复的目的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="noopener">https://book.douban.com/subject/1219329/</a></li><li><a href="https://www.youtube.com/watch?v=Cj8-WNjaGuM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Cj8-WNjaGuM</a></li><li><a href="https://zhuanlan.zhihu.com/p/34883885" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34883885</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间一个朋友问我删除文件和格式化有什么区别，最近正好在读《Unix Linux 编程实践教程》这本书，其中第4章是来讲文件系统相关的，本
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第16周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/18/2020-%E7%AC%AC16%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/18/2020-第16周-LeetCode-记录/</id>
    <published>2020-04-18T05:34:09.000Z</published>
    <updated>2020-07-31T23:27:53.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1408-String-Matching-in-an-Array"><a href="#1408-String-Matching-in-an-Array" class="headerlink" title="1408. String Matching in an Array"></a>1408. String Matching in an Array</h3><p>先按照单词长度进行排序，然后遍历判断当前单词是否被其他单词包含，要注意最终结果应该是去重之后的。</p><p>Golang 中可以直接使用 <code>strings.Contains</code> 判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByLen []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(a[i]) &lt; <span class="built_in">len</span>(a[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringMatching</span><span class="params">(words []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">sort.Sort(ByLen(words))</span><br><span class="line">res := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(words); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(words[j], words[i]) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, words[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">skip := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> unique &#123;</span><br><span class="line"><span class="keyword">if</span> v == u &#123;</span><br><span class="line">skip = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !skip &#123;</span><br><span class="line">unique = <span class="built_in">append</span>(unique, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unique</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1409-Queries-on-a-Permutation-With-Key"><a href="#1409-Queries-on-a-Permutation-With-Key" class="headerlink" title="1409. Queries on a Permutation With Key"></a>1409. Queries on a Permutation With Key</h3><p>数据规模较小，可以直接使用数组暴力求解。</p><p>理想方法应该是使用 Fenwick Tree 来解答，具体的方法参考：</p><ul><li><a href="https://www.youtube.com/watch?v=WbafSgetDDk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=WbafSgetDDk</a></li><li><a href="https://www.youtube.com/watch?v=DwtijVbS3G0&amp;t=635s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=DwtijVbS3G0&amp;t=635s</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processQueries</span><span class="params">(queries []<span class="keyword">int</span>, m <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(queries))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">p[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> queries &#123;</span><br><span class="line"><span class="comment">//found value in p's index</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> p[i] == value &#123;</span><br><span class="line">res[index] = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//move p</span></span><br><span class="line">tmp := p[i]</span><br><span class="line"><span class="built_in">copy</span>(p[<span class="number">1</span>:i+<span class="number">1</span>], p[<span class="number">0</span>:i])</span><br><span class="line">p[<span class="number">0</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processQueries</span><span class="params">(self, queries: List[int], m: int)</span> -&gt; List[int]:</span></span><br><span class="line">        tree = [<span class="number">0</span>] * ((<span class="number">2</span>*m) + <span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(i,val)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;len(tree):</span><br><span class="line">                tree[i]+=val</span><br><span class="line">                i+=(i&amp;(-i))</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">prefixSum</span><span class="params">(i)</span>:</span></span><br><span class="line">            s=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                s+=tree[i]</span><br><span class="line">                i-=(i&amp;(-i))</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        hmap = collections.defaultdict(int)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            hmap[i] = i+m</span><br><span class="line">            update(i+m,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> queries:</span><br><span class="line">            res.append(prefixSum(hmap[i])<span class="number">-1</span>)</span><br><span class="line">            update(hmap[i],<span class="number">-1</span>)</span><br><span class="line">            update(m,<span class="number">1</span>)</span><br><span class="line">            hmap[i] = m</span><br><span class="line">            m-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1410-HTML-Entity-Parser"><a href="#1410-HTML-Entity-Parser" class="headerlink" title="1410. HTML Entity Parser"></a>1410. HTML Entity Parser</h3><p>字符串解析替换，遍历检查 <code>&amp;</code> 和 <code>;</code> 进行替换，也可以直接使用 <code>str.replace</code> 进行替换，如果使用 regex 会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">entityParser</span><span class="params">(self, text: str)</span> -&gt; str:</span></span><br><span class="line">        ent = &#123;<span class="string">'&amp;quot;'</span>: <span class="string">'"'</span>, <span class="string">'&amp;apos;'</span>:<span class="string">'\''</span> , <span class="string">'&amp;gt;'</span>:<span class="string">'&gt;'</span>, <span class="string">'&amp;lt;'</span>:<span class="string">'&lt;'</span>, <span class="string">'&amp;frasl;'</span>:<span class="string">'/'</span>, <span class="string">'&amp;amp;'</span>:<span class="string">'&amp;'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> ent.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> text:</span><br><span class="line">                text = text.replace(k, v)</span><br><span class="line">        <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure><h3 id="1138-Alphabet-Board-Path"><a href="#1138-Alphabet-Board-Path" class="headerlink" title="1138. Alphabet Board Path"></a>1138. Alphabet Board Path</h3><p>先准备字母表，需要注意的是最后一个字母 <code>z</code>，如果目标字母是 <code>z</code> ，那么只能先左再下，如果当前字母是 <code>z</code>，那么只能先上再右，需要考虑移动的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alphabetBoardPath</span><span class="params">(self, target: str)</span> -&gt; str:</span></span><br><span class="line">        m = &#123;c: [i // <span class="number">5</span>, i % <span class="number">5</span>] <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>)&#125;</span><br><span class="line">        x0, y0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> target:</span><br><span class="line">            x, y = m[c]</span><br><span class="line">            <span class="keyword">if</span> y &lt; y0: res.append(<span class="string">'L'</span> * (y0 - y))</span><br><span class="line">            <span class="keyword">if</span> x &lt; x0: res.append(<span class="string">'U'</span> * (x0 - x))</span><br><span class="line">            <span class="keyword">if</span> x &gt; x0: res.append(<span class="string">'D'</span> * (x - x0))</span><br><span class="line">            <span class="keyword">if</span> y &gt; y0: res.append(<span class="string">'R'</span> * (y - y0))</span><br><span class="line">            res.append(<span class="string">'!'</span>)</span><br><span class="line">            x0, y0 = x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="1302-Deepest-Leaves-Sum"><a href="#1302-Deepest-Leaves-Sum" class="headerlink" title="1302. Deepest Leaves Sum"></a>1302. Deepest Leaves Sum</h3><p>求最深层的叶子节点之和，需要维护 2个变量，一个是最深层次，一个是最深层次对应的和。遍历节点时与最深层次比较，进行求和运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepestLeavesSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        q = collections.deque([(root, <span class="number">0</span>)])</span><br><span class="line">        maxdep, total = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">            node, dep = q.pop()</span><br><span class="line">            <span class="keyword">if</span> dep &gt; maxdep:</span><br><span class="line">                maxdep, total = dep, node.val</span><br><span class="line">            <span class="keyword">elif</span> dep == maxdep:</span><br><span class="line">                total += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append((node.left, dep + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append((node.right, dep + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1408-String-Matching-in-an-Array&quot;&gt;&lt;a href=&quot;#1408-String-Matching-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1408. String Matching in an 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
