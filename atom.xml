<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2020-06-13T14:17:54.307Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从北京转到上海生活两周感受</title>
    <link href="https://zdyxry.github.io/2020/06/13/%E4%BB%8E%E5%8C%97%E4%BA%AC%E8%BD%AC%E5%88%B0%E4%B8%8A%E6%B5%B7%E7%94%9F%E6%B4%BB%E4%B8%A4%E5%91%A8%E6%84%9F%E5%8F%97/"/>
    <id>https://zdyxry.github.io/2020/06/13/从北京转到上海生活两周感受/</id>
    <published>2020-06-13T22:09:05.000Z</published>
    <updated>2020-06-13T14:17:54.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾，换个城市感受一下，正好公司在上海也有办公室，就直接转过来了，到今天已经工作了两周，写一下感受，扯一扯。</p><h2 id="租房"><a href="#租房" class="headerlink" title="租房"></a>租房</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>因为在5月份的时候疫情消停了一段时间，我就开始了远程看房的计划，因为有深圳同事也要转到上海，就计划一起合租，那么目标就是两居室。我们通过 Notion 协作写清楚需求（是的，还有猫的需求），然后各自开始了远程找房。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># yiran 的需求</span><br><span class="line">- 步行 30min 可到达公司</span><br><span class="line">- 民水民点</span><br><span class="line">- 厨房可用</span><br><span class="line">- 周围有商超</span><br><span class="line">- 不临街</span><br><span class="line"></span><br><span class="line">## 同事的需求</span><br><span class="line">- 希望是有电梯的(骑车穿锁鞋很难下楼)</span><br><span class="line">- 避免石膏墙</span><br><span class="line">- 询问一下居住证的问题</span><br><span class="line"></span><br><span class="line">## 猫的需求</span><br><span class="line">- 最好是有防盗网的窗户</span><br><span class="line">- 阳光</span><br><span class="line">- 够大</span><br><span class="line"></span><br><span class="line"># 避免</span><br><span class="line">- 窗户有树</span><br></pre></td></tr></table></figure><h3 id="了解中介"><a href="#了解中介" class="headerlink" title="了解中介"></a>了解中介</h3><p>如果个人在上海本地，那么还有可能通过豆瓣等平台找到房东直接签约没有中介费，但是像我这种时间紧任务重的，就放弃了这种方式选择中介。上海租房与北京租房最主要的不同就是中介费，北京是租客需要支付一个月的租金，而上海是租客与房东共支付一个月的租金作为中介费，所以租客只需要支付50% 的租金即可，这点比北京友好很多，所以我们开始也是倾向于通过中介与房东签约的房子。</p><p>中介主要是链家，我爱我家的房源很少，且质量不高，贝壳上还有些其他的小中介，因为担心有其他隐患，最后还是选择的链家。</p><h3 id="看房"><a href="#看房" class="headerlink" title="看房"></a>看房</h3><p>主要看了两天的时间，第一天看了很多公司周围的板楼，后来才知道这类房子叫“老公房”，房子质量很差，且隔音很是问题，无法接受，于是第二天开始看一些距离公司地铁20min 可达的房子，在看的时候发现我忽略了一个比较重要的点，就是猫，同事养了两只猫，但是我看房子时忽略了房东不让养宠物的可能，直到我看了一个各方面都符合要求的房子后，想要与房东签约，才想到这点，房东果断拒绝了，后续也看了几个房子各方面都很好，但是不让养宠物而错过的，也是没有办法。</p><h3 id="自如"><a href="#自如" class="headerlink" title="自如"></a>自如</h3><p>在看了两天之后，发现房子质量比较好的房东，都不同意租客养宠物，换位思考可以理解，因为时间比较紧张，把目光选择了自如，自如的收费与北京相同，没有差别，照片都是真实的，但是我还是线下去看了房子，确保没有问题，期间发现了一些在自如网站上无法发现的问题：</p><ol><li>隔音，部分房子隔音很差</li><li>周围环境，发现部分房子周围存在基建施工情况，看形式不是几天可以完工的</li><li>老旧小区改造，在北京吃过亏，租的房子是老房子，恰逢政府进行小区改造，两个月没有卫生间的日子还是太难过了</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如果当地有朋友，还是通过朋友那里了解到租房坑是最直接的方式</li><li>要确认好自己的需求，尤其是宠物这种可能会一票否决的事项更是要第一时间提出，否则白白浪费一个小时看房</li><li>找中介看房基本上不会按照自己的计划来安排时间的，每个中介都会拉着你去看几个类似的房子，所以做时间规划的时候最好要留有余地</li><li>实在没有选择就找自如吧，至少是有基本保证，但是要注意上海这边属于南方，宽带很可能没有联通选项</li></ol><p>附一张 Notion 的看房列表：</p><img src="/2020/06/13/从北京转到上海生活两周感受/2.png" title="Notion"><h2 id="搬家"><a href="#搬家" class="headerlink" title="搬家"></a>搬家</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>因为我在去上海前没有租好房子，所以不能先把行李快递走，当时有两个计划，优先计划 2：</p><ol><li>先去上海租房，回北京快递行李，再去上海</li><li>出发前先打包好行李、去上海租房、找同事帮忙快递行李</li></ol><h3 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h3><p>在出发前我已经将自己的行李打包好了，在淘宝买了质量还可以的纸箱子，然后找了北京同事帮忙寄快递，选择的是德邦物流，之前也问过几个朋友，貌似是比较稳妥的方式了，当时物流费用是 448，我进行了保价，一共花费了 488，还是可以接受的，毕竟也是200kg+ 的行李。</p><p>但是事实证明别人的稳妥只有实际体验才知道，德邦在我的纸箱子外套了层编织袋，当我打开行李的时候，发现里面的纸箱子已经接近散架的状态，全靠编织袋才坚持到了上海，不知道其他人是不是也是这样，还好我没有什么贵重的大件物品，否则感觉要完。</p><p>同事搬家选择的顺丰，并且选择了带托盘的方式，行李在出发前是什么样子，到达时就是什么样子，全程行李没有离开托盘，所以行李也没有任何的破损，体验非常好，当然价格也很好，1k+ 的快递费。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果普通物品选择德邦还是可以的，但是我之后应该会选择顺丰。</p><h3 id="气候"><a href="#气候" class="headerlink" title="气候"></a>气候</h3><h3 id="梅雨期"><a href="#梅雨期" class="headerlink" title="梅雨期"></a>梅雨期</h3><p>在来上海前，好多朋友同事都说我作为东北人，会无法适应上海的气候，我觉得还是要感受一下才能知道是否真正适合，不试试是不知道的。</p><p>正好过来收拾的差不多就到了 6 月份，在上班的时候看到一个新闻： <code>气象局宣布，上海入梅了！上海昨天由此进入梅雨期，较常年提早9天。</code> ，这应该是整个夏天最闷最潮湿的时候了，我的感受是，北京我没有感觉到有多干燥，但是上海的潮湿是真的潮，洗完衣服晾干，我都怀疑我的感知能力，这衣服真的干了么？无论什么时间，走在室外都感觉随时会出汗，中午的时候甚至有一种水汽往脸上扑的感觉。因为我个人比较容易出汗，所以来到上海还是出汗，感受倒是没差，只是衣服不干比较愁人，也买了各种除湿袋，不知道是否真的有用，同时也在考虑除湿机。</p><h3 id="下雨"><a href="#下雨" class="headerlink" title="下雨"></a>下雨</h3><p>我自己的鞋子都是网或者布料的，所以如果下大雨鞋子肯定会湿，于是特意买了一双皮质的鞋子想着防雨，但是我低估了上海的大雨，鞋子很快就湿了，又因为是皮质的，所以干的还慢。问了同事才知道，这时候需要拖鞋，于是我在公司和家里都放了拖鞋，如果下大雨就还是穿拖鞋吧。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>目前来看，需要多准备几件衣服防止没有晾干，多准备几双鞋子防止鞋子湿了没有更换，同时备着拖鞋。</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="地下"><a href="#地下" class="headerlink" title="地下"></a>地下</h3><p>平时上班做地铁，之前在北京搭乘地铁我有一个不好的习惯：倚靠安全门，来上海的第一天就被说了两次。。现在好多了。</p><p>上海地铁有一点不好，就是没有屏幕实时展示当前地铁行进状态，虽然有小屏幕滚动，但是不够及时，在地铁上玩手机就需要留意广播重的信息，防止坐过站。</p><h3 id="地上"><a href="#地上" class="headerlink" title="地上"></a>地上</h3><p>公司到家的距离是 5 公里，体验了一下骑车回家，上海的自行车道感受很好，首先很宽，其次没有机动车抢占的情况，整体体验要比北京好很多。发现上海的交通管控也要比北京严格一些，经常能在路口看到交警在指挥交通，毕竟很少看到闯红绿灯的情况。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>目前在上海两周，还没有什么不适，感觉不错，目前还有待确定的：1. 没有暖气的冬天；2. 除湿机是否需要。之后如果有了感受再更新上来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 第24周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/13/2020-第24周-LeetCode-记录/</id>
    <published>2020-06-13T07:38:57.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1470-Shuffle-the-Array"><a href="#1470-Shuffle-the-Array" class="headerlink" title="1470. Shuffle the Array"></a>1470. Shuffle the Array</h3><p>重新排列数组，使用 zip 对两个切分后的数组进行聚合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self, nums: List[int], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(nums[<span class="number">0</span>:n],nums[n:]):</span><br><span class="line">            res+=[i,j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1471-The-k-Strongest-Values-in-an-Array"><a href="#1471-The-k-Strongest-Values-in-an-Array" class="headerlink" title="1471. The k Strongest Values in an Array"></a>1471. The k Strongest Values in an Array</h3><p>找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStrongest</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">        median = arr[(len(arr) - <span class="number">1</span>) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> len(arr) + i - j &lt;= k:</span><br><span class="line">            <span class="keyword">if</span> median - arr[i] &gt; arr[j] - median:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[:i] + arr[j + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h3 id="1472-Design-Browser-History"><a href="#1472-Design-Browser-History" class="headerlink" title="1472. Design Browser History"></a>1472. Design Browser History</h3><p>用两个变量记录 homepage 和当前位置，处理几个场景：  </p><ol><li>从当前页跳转访问 url 对应的页面，需要将当前位置之后的所有历史列表清空</li><li>在浏览历史中后退 steps 步，需要与 0 比较，如果小于 0，则将其置为 0</li><li>在浏览历史中前进 steps 步，需要与当前历史记录长度比较，如果超过长度，则取历史记录中最后一个</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, homepage: str)</span>:</span></span><br><span class="line">        self.hist = [homepage]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, url: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        self.hist[self.pos:] = []</span><br><span class="line">        self.hist.append(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos -= steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &lt; <span class="number">0</span>:</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos += steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.hist):</span><br><span class="line">            self.pos = len(self.hist) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br></pre></td></tr></table></figure><h3 id="754-Reach-a-Number"><a href="#754-Reach-a-Number" class="headerlink" title="754. Reach a Number"></a>754. Reach a Number</h3><blockquote><p><a href="https://www.bilibili.com/video/av31621072/" target="_blank" rel="noopener">https://www.bilibili.com/video/av31621072/</a></p></blockquote><blockquote><p><a href="https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/</a></p></blockquote><p>首先， 由于坐标轴是对称的，往左往右走的几率相等，因此可以只考虑右半轴。先递推一下可以知道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步数        能到达的位置</span><br><span class="line">1:          1</span><br><span class="line">2:          3, 1</span><br><span class="line">3:          6, 4, 2, 0</span><br><span class="line">4:          10, 8, 6, 4, 0</span><br><span class="line">5:          15, 13, 11, 9, 7, 5, 3, 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看出来，每一步能到达的最大位置是上一步最大位置加上步数，而每一步所能达到的位置之间间隔都为2。<br>记f(n)为第n步能到达的位置，那么有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(f(n)) = max(f(n-1)) + n</span><br><span class="line">f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]</span><br></pre></td></tr></table></figure><p>如果target可以在第n步达到，那么target一定小于等于max(f(n))且max(f(n))与taget同奇同偶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachNumber</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        target = abs(target)</span><br><span class="line">        p, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; target <span class="keyword">or</span> (p + target) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            p = p + i</span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree"></a>1038. Binary Search Tree to Greater Sum Tree</h3><p>与 538 题相同，使用 dfs 遍历，优先遍历右节点，然后root 节点，最后左节点，使用 currSum 记录比当前节点数值大的数字和，然后将自身与数字和想家，并更新数字和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        currSum = [<span class="number">0</span>]</span><br><span class="line">        self.recurse(root, currSum)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, root, currSum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.recurse(root.right, currSum)</span><br><span class="line">        root.val = root.val + currSum[<span class="number">0</span>]</span><br><span class="line">        currSum[<span class="number">0</span>] = root.val</span><br><span class="line">        self.recurse(root.left, currSum)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1470-Shuffle-the-Array&quot;&gt;&lt;a href=&quot;#1470-Shuffle-the-Array&quot; class=&quot;headerlink&quot; title=&quot;1470. Shuffle the Array&quot;&gt;&lt;/a&gt;1470. Shuffle the A
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第23周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/06/2020-%E7%AC%AC23%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/06/2020-第23周-LeetCode-记录/</id>
    <published>2020-06-06T13:25:41.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays"><a href="#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays" class="headerlink" title="1460. Make Two Arrays Equal by Reversing Sub-arrays"></a>1460. Make Two Arrays Equal by Reversing Sub-arrays</h3><p>比较两个列表是否可以通过翻转等价，统计列表中字母出现的次数判断，或者可以直接排序判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canBeEqual</span><span class="params">(self, target: List[int], arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        c = collections.Counter(target)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            c[a] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c[a] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1464-Maximum-Product-of-Two-Elements-in-an-Array"><a href="#1464-Maximum-Product-of-Two-Elements-in-an-Array" class="headerlink" title="1464. Maximum Product of Two Elements in an Array"></a>1464. Maximum Product of Two Elements in an Array</h3><p>找到数组中最大的两个数字，分别将其数值 -1 然后相乘返回。可以直接升序排序后取最后两个数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max:=<span class="number">0</span></span><br><span class="line">    secondMax:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        e:=nums[i]</span><br><span class="line">        <span class="keyword">if</span> e&gt;max&#123;</span><br><span class="line">            secondMax = max</span><br><span class="line">            max = e</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> e&gt;secondMax&#123;</span><br><span class="line">            secondMax = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (max<span class="number">-1</span>)*(secondMax<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K"><a href="#1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K" class="headerlink" title="1461. Check If a String Contains All Binary Codes of Size K"></a>1461. Check If a String Contains All Binary Codes of Size K</h3><p>s 字符串中只包含0或1，滑动窗口计算 s 所有长度为 k 的组合，使用 set 去重，与 K 个数字的二进制字符串数量相比较，是否相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAllCodes</span><span class="params">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        m = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)-k+<span class="number">1</span>):</span><br><span class="line">            m.add(s[i:i+k])</span><br><span class="line">        <span class="keyword">return</span> len(m) == (<span class="number">1</span> &lt;&lt; k)</span><br></pre></td></tr></table></figure><h3 id="1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts"><a href="#1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts" class="headerlink" title="1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"></a>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</h3><p>分别对两个数组进行排序切割，找到两个元素之间间隔最大的数值，然后将其相乘为最终所求面积大小，对 <code>1e9 +7</code> 取余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(h <span class="keyword">int</span>, w <span class="keyword">int</span>, horizontalCuts []<span class="keyword">int</span>, verticalCuts []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxH, maxV := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">pre := <span class="number">0</span></span><br><span class="line">sort.Ints(horizontalCuts)</span><br><span class="line">sort.Ints(verticalCuts)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(horizontalCuts); i++ &#123;</span><br><span class="line">maxH = max(maxH, horizontalCuts[i] - pre)</span><br><span class="line">pre = horizontalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxH = max(maxH, h - pre)</span><br><span class="line">pre = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(verticalCuts); i++ &#123;</span><br><span class="line">maxV = max(maxV, verticalCuts[i] - pre)</span><br><span class="line">pre = verticalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxV = max(maxV, w - pre)</span><br><span class="line"><span class="keyword">return</span> (maxH * maxV) % <span class="number">1000000007</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><p>遍历 connections ，统计每个节点之间相邻的节点，使用 dfs 从 0 开始计算，当相邻节点已经访问过了，直接跳过，如果没有访问过，且相邻节点到当前节点方向不对，那么就将结果 +1，并将其添加到访问过的集合中，继续dfs 相邻节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        edges = &#123; (a,b) <span class="keyword">for</span> a, b <span class="keyword">in</span> connections &#125; <span class="comment"># instantly check if a-&gt;b</span></span><br><span class="line">        neighbors = &#123; i:[] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;     <span class="comment"># adjacent cities</span></span><br><span class="line">        visit = set()                             <span class="comment"># visit each city once</span></span><br><span class="line">        changes = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            neighbors[a].append(b)</span><br><span class="line">            neighbors[b].append(a)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs from City 0, count outgoing edges</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> edges, neighbors, visit, changes</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors[city]:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">in</span> visit:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># neighbor can't reach city</span></span><br><span class="line">                <span class="keyword">if</span> (neighbor, city) <span class="keyword">not</span> <span class="keyword">in</span> edges:</span><br><span class="line">                    changes += <span class="number">1</span></span><br><span class="line">                visit.add(neighbor)</span><br><span class="line">                dfs(neighbor)</span><br><span class="line">        </span><br><span class="line">        visit.add(<span class="number">0</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> changes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot;&gt;&lt;a href=&quot;#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第22周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/01/2020-%E7%AC%AC22%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/01/2020-第22周-LeetCode-记录/</id>
    <published>2020-06-01T05:44:57.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence"><a href="#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence" class="headerlink" title="1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence"></a>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</h3><p>切分句子然后遍历判断是否为前缀，需要返回索引 + 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, sentence: str, searchWord: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> idx, w <span class="keyword">in</span> enumerate(sentence.split(<span class="string">' '</span>)):</span><br><span class="line">            <span class="keyword">if</span> w.startswith(searchWord):</span><br><span class="line">                <span class="keyword">return</span> idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length"><a href="#1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length" class="headerlink" title="1456. Maximum Number of Vowels in a Substring of Given Length"></a>1456. Maximum Number of Vowels in a Substring of Given Length</h3><p>滑动窗口，使用字典统计每个元音出现的次数，每次更新最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxVowels</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'e'</span>: <span class="number">0</span>, <span class="string">'i'</span>: <span class="number">0</span>, <span class="string">'o'</span>: <span class="number">0</span>, <span class="string">'u'</span>: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[:k]:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> d:</span><br><span class="line">                d[c] += <span class="number">1</span></span><br><span class="line">        res = sum(d.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i-k] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i-k]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i]] += <span class="number">1</span></span><br><span class="line">            res = max(res, sum(d.values()))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1200-Minimum-Absolute-Difference"><a href="#1200-Minimum-Absolute-Difference" class="headerlink" title="1200. Minimum Absolute Difference"></a>1200. Minimum Absolute Difference</h3><p>遍历列表，记录前一个数值，每次计算绝对差值，更新最小值，如果差值等于最小值，则将其加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span><span class="params">(self, arr: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        m = float(<span class="string">'inf'</span>)</span><br><span class="line">        out = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">            prev = arr[i - <span class="number">1</span>]</span><br><span class="line">            curr = abs(prev - arr[i])</span><br><span class="line">            <span class="keyword">if</span> curr &lt; m:</span><br><span class="line">                out = [[prev, arr[i]]]</span><br><span class="line">                m = curr</span><br><span class="line">            <span class="keyword">elif</span> curr == m: out.append([prev, arr[i]])</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree"><a href="#1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree" class="headerlink" title="1457. Pseudo-Palindromic Paths in a Binary Tree"></a>1457. Pseudo-Palindromic Paths in a Binary Tree</h3><p>DFS 遍历二叉树，使用 set 记录已有数值，如果该数值已经存在，则删掉，如果不存在，则加入set。判断回文字符的依据是set 中剩余字母长度是否小于等于1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        s = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            res = dfs(root.left) + dfs(root.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res += len(s)&lt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence&quot;&gt;&lt;a href=&quot;#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第21周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/22/2020-%E7%AC%AC21%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/22/2020-第21周-LeetCode-记录/</id>
    <published>2020-05-22T22:28:29.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1446-Consecutive-Characters"><a href="#1446-Consecutive-Characters" class="headerlink" title="1446. Consecutive Characters"></a>1446. Consecutive Characters</h3><p>判断最长连续相同字符的长度，记录下当前字母，然后比较与 flag 是否相同，如果相同则 +1，不相同则重置为 1。</p><p>也可以通过 itertools.groupby 来实现（新学习的。。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPower</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp = s[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i == tmp:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = i</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            max_cnt = max(max_cnt, cnt)</span><br><span class="line">        <span class="keyword">return</span> max_cnt</span><br></pre></td></tr></table></figure><h3 id="1447-Simplified-Fractions"><a href="#1447-Simplified-Fractions" class="headerlink" title="1447. Simplified Fractions"></a>1447. Simplified Fractions</h3><p>遍历分子与分母，求最大公约数，如果最大公约数为1，则将结果保存下来。分母从 2 开始计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifiedFractions</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> gcd(i, j) == <span class="number">1</span> &#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, fmt.Sprintf(<span class="string">"%d/%d"</span>, j, i))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x%y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1448-Count-Good-Nodes-in-Binary-Tree"><a href="#1448-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="1448. Count Good Nodes in Binary Tree"></a>1448. Count Good Nodes in Binary Tree</h3><p>遍历所有节点，记录 root 节点到当前节点经过的最大值，当前节点数值与最大值进行比较，如果符合条件，则结果 +1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, curmax)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> node.val &gt;= curmax:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            curmax = max(curmax, node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                dfs(node.left, curmax)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                dfs(node.right, curmax)</span><br><span class="line">            </span><br><span class="line">        dfs(root, -float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h3><p>遍历开始时间和结束时间，判断查询时间是否在两者之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busyStudent</span><span class="params">(self, startTime: List[int], endTime: List[int], queryTime: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(a&lt;=queryTime&lt;=b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(startTime,endTime))</span><br></pre></td></tr></table></figure><h3 id="896-Monotonic-Array"><a href="#896-Monotonic-Array" class="headerlink" title="896. Monotonic Array"></a>896. Monotonic Array</h3><p>遍历数组，记录前一个数字与当前数字的差值，判断是否单调递增或递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt_inc = <span class="number">0</span>; cnt_dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: prev = v; <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>   v &gt; prev: cnt_inc += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; prev: cnt_dec += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt_inc <span class="keyword">and</span> cnt_dec: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            prev = v</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1446-Consecutive-Characters&quot;&gt;&lt;a href=&quot;#1446-Consecutive-Characters&quot; class=&quot;headerlink&quot; title=&quot;1446. Consecutive Characters&quot;&gt;&lt;/a&gt;1446
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第20周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/16/2020-%E7%AC%AC20%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/16/2020-第20周-LeetCode-记录/</id>
    <published>2020-05-16T10:17:49.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1441-Build-an-Array-With-Stack-Operations"><a href="#1441-Build-an-Array-With-Stack-Operations" class="headerlink" title="1441. Build an Array With Stack Operations"></a>1441. Build an Array With Stack Operations</h3><p>遍历数组，比较当前值与目标值是否相同，如果相同，则在结果追加 <code>Push</code> ，如果不同，则追加 <code>Push</code>, <code>Pop</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildArray</span><span class="params">(self, target: List[int], n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        keep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(<span class="string">"Push"</span>)</span><br><span class="line">            keep += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> target:</span><br><span class="line">                res.append(<span class="string">"Pop"</span>)</span><br><span class="line">                keep -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> keep == len(target):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a>1442. Count Triplets That Can Form Two Arrays of Equal XOR</h3><p>求子数组中是否存在左侧部分异或值与右侧部分异或值相等的情况，a==b -&gt; a ^ b = 0，也就是是否存在子数组所有元素异或值为0 的情况，如果存在，那么子数组所有的元素都可以符合条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                temp = temp^arr[j]</span><br><span class="line">                <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                    count += j-i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers"><a href="#1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers" class="headerlink" title="1317. Convert Integer to the Sum of Two No-Zero Integers"></a>1317. Convert Integer to the Sum of Two No-Zero Integers</h3><p>从 1 开始遍历判断两个拆分数字是否包含 <code>0</code> ，判断对 10 取余是否为0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNoZeroIntegers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.check(i) <span class="keyword">and</span> self.check(n - i):</span><br><span class="line">                <span class="keyword">return</span> [i, n - i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree"></a>1443. Minimum Time to Collect All Apples in a Tree</h3><p>通过字典来保证每条路径只走一次，判断子节点是否有苹果，如果没有，则将子节点从字典中删除，最终字典中保存的是必须要经过的节点，要走 2 次，所以需要 * 2 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTime</span><span class="params">(self, n: int, edges: List[List[int]],</span></span></span><br><span class="line"><span class="function"><span class="params">                hasApple: List[bool])</span> -&gt; int:</span></span><br><span class="line">        maps = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            maps[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            selfOrChildHasApple = hasApple[i]</span><br><span class="line">            <span class="keyword">for</span> nex <span class="keyword">in</span> maps[i]:</span><br><span class="line">                selfOrChildHasApple |= dfs(nex)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> selfOrChildHasApple:</span><br><span class="line">                <span class="keyword">del</span> maps[i]</span><br><span class="line">            <span class="keyword">return</span> selfOrChildHasApple</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, <span class="number">2</span> * (len(maps) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="807-Max-Increase-to-Keep-City-Skyline"><a href="#807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="807. Max Increase to Keep City Skyline"></a>807. Max Increase to Keep City Skyline</h3><p>分别找出每行、每列的最大值，然后遍历判断当前值距离两个最大值中的最小值需要增加多少，累加计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        max_cols = [max(col) <span class="keyword">for</span> col <span class="keyword">in</span> zip(*grid)]</span><br><span class="line">        max_rows = [max(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid]</span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[i])):</span><br><span class="line">                inc += (min(max_cols[j], max_rows[i]) - grid[i][j])</span><br><span class="line">        <span class="keyword">return</span> inc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1441-Build-an-Array-With-Stack-Operations&quot;&gt;&lt;a href=&quot;#1441-Build-an-Array-With-Stack-Operations&quot; class=&quot;headerlink&quot; title=&quot;1441. Buil
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>PyInstaller 与 RPM 配合使用踩坑</title>
    <link href="https://zdyxry.github.io/2020/05/13/PyInstaller-%E4%B8%8E-RPM-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"/>
    <id>https://zdyxry.github.io/2020/05/13/PyInstaller-与-RPM-配合使用踩坑/</id>
    <published>2020-05-13T20:35:50.000Z</published>
    <updated>2020-06-13T14:17:54.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配置会有坑，然后搜索下来几乎没看到有人提到，可能用 pyinstaller 和用 rpm 的完全是两类人吧 - -。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先列一下官方默认例子的输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/demo</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls</span></span><br><span class="line">demo.py</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> pyinstaller demo.py</span></span><br><span class="line">63 INFO: PyInstaller: 3.6</span><br><span class="line">63 INFO: Python: 3.6.8</span><br><span class="line">65 INFO: Platform: Linux-3.10.0-862.el7.x86_64-x86_64-with-centos-7.5.1804-Core</span><br><span class="line">65 INFO: wrote /tmp/demo/demo.spec</span><br><span class="line">67 INFO: UPX is not available.</span><br><span class="line">70 INFO: Extending PYTHONPATH with paths</span><br><span class="line">['/tmp/demo', '/tmp/demo']</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>来看一下生成文件的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── demo</span><br><span class="line">├── demo.py</span><br><span class="line">├── demo.spec</span><br><span class="line">├── dist</span><br><span class="line">│   └── demo</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── binascii.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _bisect.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _blake2.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">|       ├── ...</span><br><span class="line">│       ├── _codecs_kr.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _codecs_tw.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _datetime.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── demo</span><br><span class="line">│       ├── libbz2.so.1</span><br><span class="line">│       ├── libcom_err.so.2</span><br><span class="line">│       ├── libcrypto.so.10</span><br><span class="line">│       ├── libexpat.so.1</span><br><span class="line">│       ├── libgssapi_krb5.so.2</span><br><span class="line">│       ├── libk5crypto.so.3</span><br><span class="line">│       ├── libkeyutils.so.1</span><br><span class="line">│       ├── libtinfo.so.5</span><br><span class="line">│       ├── libkrb5support.so.0</span><br><span class="line">│       ├── liblzma.so.5</span><br><span class="line">│       ├── libpcre.so.1</span><br><span class="line">│       ├── libpython3.6m.so.1.0</span><br><span class="line">│       ├── libreadline.so.6</span><br><span class="line">│       ├── libz.so.1</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── demo.cpython-36.pyc</span><br></pre></td></tr></table></figure><p>看上去也没啥问题，编写一个 rpm spec，然后使用 rpmbuild 直接就可以生成一个 RPM出来，在 RedHat 系列的 OS上可以直接安装使用，具体的步骤可以参考之前的博客：<a href="https://zdyxry.github.io/2018/07/28/RPM-%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/">《RPM 常用构建方式》</a>，目前来看一切都正常，但是坑来了。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在验证完基础的功能后，我想要将这个 RPM 放到 ISO 中发布，在验证过程中，发现这个 RPM 会破坏系统其他的依赖检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:00:20 tmp]$cat packaging.log |grep so |grep 'No such file'</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error ...</span><br><span class="line">09:19:50,495 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /usr/bin/trust: error while loading shared libraries: libfreebl3.so: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,500 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,501 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>简单的过滤了一下，有这些包直接受到了影响，还有很多未知的，简单的说就是系统的一些核心依赖库缺失，没有安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:02:48 tmp]$cat packaging.log |grep 'scriptlet failed'</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(readline-6.2-10.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(gawk-4.0.2-4.el7_3.1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(info-5.1-4.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(qemu-kvm-aurora-0.3.3-1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,495 INFO packaging: warning: %post(glib2-2.50.3-3.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,499 INFO packaging: warning: %post(ca-certificates-2017.2.14-71.el7.noarch) scriptlet failed, exit status 127</span><br></pre></td></tr></table></figure><p>最初在排查是否是 anaconda 在检查 rpm 相互之间的依赖时出了 bug，但是最近版本没什么变化，理论上不会，又去瞧了瞧 anaconda 的代码，发现跟 rpm 相关的太多，一时也没看出什么头绪。</p><p>再来看一下相关的库， <code>libz.so.1</code> , <code>libtinfo.so.5</code> 有没有点眼熟，都是在 pyinstaller 生成的文件中的，但是有一点很奇怪，命令路径都不是系统路径，为什么在检查依赖的时候还是会检查到新加入的 rpm 上，而不是真正提供这些库的 RPM？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>今天的主角登场：Automatic Dependencies。</p><p>Automatic Dependencies 是 RPM 的一个特性，官方文档中是这么描述的：</p><blockquote><p>When a package is built by RPM, if any file in the package’s %files list is a shared library, the library’s soname is automatically added to the list of capabilities the package provides. The soname is the name used to determine compatibility between different versions of a library.</p></blockquote><blockquote><p>Note that this is not a filename. In fact, no aspect of RPM’s dependency processing is based on filenames. Many people new to RPM often make the assumption that a failed dependency represents a missing file. This is not the case.</p></blockquote><blockquote><p>Remember that RPM’s dependency processing is based on knowing what capabilities are provided by a package and what capabilities a package requires. We’ve seen how RPM automatically determines what shared library resources a package provides. But does it automatically determine what shared libraries a package requires?</p></blockquote><blockquote><p>Yes! RPM does this by running ldd on every executable program in a package’s %files list. Since ldd provides a list of the shared libraries each program requires, both halves of the equation are complete — that is, the packages that make shared libraries available, and the packages that require those shared libraries, are tracked by RPM. RPM can then take that information into account when packages are installed, upgraded, or erased.</p></blockquote><p>嗯，找到问题了，解决的方式也很简单，直接关掉就好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoReqProv: no</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说 pyinstaller 用的人不少，rpm 用的人也不少，这俩默认配置配合使用是一定会出问题的，但是没有找到相关的问题，可能真的不是一类人吧。</p><p>用同事的话作为结束语： <code>automatic 开头的东西，一个字都不要信</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第19周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/08/2020-%E7%AC%AC19%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/08/2020-第19周-LeetCode-记录/</id>
    <published>2020-05-08T07:48:12.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1436-Destination-City"><a href="#1436-Destination-City" class="headerlink" title="1436. Destination City"></a>1436. Destination City</h3><p>使用 set() 来计算每个城市是否处于起始和终止，集合差为终点站。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destCity</span><span class="params">(self, paths: List[List[str]])</span> -&gt; str:</span></span><br><span class="line">        a = set()</span><br><span class="line">        b = set()</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">            x, y = path</span><br><span class="line">            a.add(x)</span><br><span class="line">            b.add(y)</span><br><span class="line"></span><br><span class="line">        b = b - a</span><br><span class="line">        <span class="keyword">assert</span> len(b) == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> b.pop()</span><br></pre></td></tr></table></figure><h3 id="1432-Max-Difference-You-Can-Get-From-Changing-an-Integer"><a href="#1432-Max-Difference-You-Can-Get-From-Changing-an-Integer" class="headerlink" title="1432. Max Difference You Can Get From Changing an Integer"></a>1432. Max Difference You Can Get From Changing an Integer</h3><p>分别求出给定数字可以转换的最大值和最小值，然后求差，最大值是将数字从前向后遍历，当数值不为9时，将其替换为 9；最小值要求首位不能为 0，则需要特殊判断，如果首位不为1，则将其替换为1，如果首位为1，则遍历后续数字，如果数字不为0，则替换为0，需要注意此时首位为1，如果数字为1然后替换为0会出现首位为0 情况，因此需要判断数字不为0且不为1，然后替换为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDiff</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        a = b = str(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> a:</span><br><span class="line">            <span class="keyword">if</span> digit != <span class="string">"9"</span>:</span><br><span class="line">                a = a.replace(digit, <span class="string">"9"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> b[<span class="number">0</span>] != <span class="string">"1"</span>:</span><br><span class="line">            b = b.replace(b[<span class="number">0</span>], <span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> digit <span class="keyword">in</span> b[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> digit <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"01"</span>:</span><br><span class="line">                    b = b.replace(digit, <span class="string">"0"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> int(a) - int(b)</span><br></pre></td></tr></table></figure><h3 id="1433-Check-If-a-String-Can-Break-Another-String"><a href="#1433-Check-If-a-String-Can-Break-Another-String" class="headerlink" title="1433. Check If a String Can Break Another String"></a>1433. Check If a String Can Break Another String</h3><p>检查两个字符串的字符序是否存在交叉情况，先对字符串进行排序，然后使用两个 flag 标记当前字符的大小，如果有大有小，那么直接返回 False，否则返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfCanBreak</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        s1= sorted(s1)</span><br><span class="line">        s2= sorted(s2)</span><br><span class="line">        res1, res2 = <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> zip(s1, s2):</span><br><span class="line">            com = ord(pair[<span class="number">0</span>]) - ord(pair[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> com &gt; <span class="number">0</span>:</span><br><span class="line">                res1 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> com &lt; <span class="number">0</span>:</span><br><span class="line">                res2 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> res1 <span class="keyword">and</span> res2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away"><a href="#1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away" class="headerlink" title="1437. Check If All 1’s Are at Least Length K Places Away"></a>1437. Check If All 1’s Are at Least Length K Places Away</h3><p>检查每个数字 1 之间的间隔是否大于 k，如果不大于则返回 False，遍历数字，如果数字不为 1，则将间隔 +1，直到下次遇1时判断并重置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kLengthApart</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        zero_num = <span class="number">1e5</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> zero_num &lt; k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                zero_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                zero_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</h3><p>滑动窗口，遍历数字，每次更新最大值与最小值，如果符合条件，则窗口增大，否则从左侧缩小窗口，缩小窗口后需要注意更新最大值与最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int], limit: int)</span> -&gt; int:</span></span><br><span class="line">        minimal, maximal = float(<span class="string">"inf"</span>), float(<span class="string">"-inf"</span>)</span><br><span class="line">        size, current_size_start_number = <span class="number">0</span>, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            maximal = max(maximal, nums[i])</span><br><span class="line">            minimal = min(minimal, nums[i])</span><br><span class="line">            <span class="keyword">if</span> abs(maximal - minimal) &lt;= limit:</span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_size_start_number = nums[i-size]</span><br><span class="line">                <span class="keyword">if</span> current_size_start_number == minimal:</span><br><span class="line">                    minimal = min(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> current_size_start_number == maximal:</span><br><span class="line">                    maximal = max(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1436-Destination-City&quot;&gt;&lt;a href=&quot;#1436-Destination-City&quot; class=&quot;headerlink&quot; title=&quot;1436. Destination City&quot;&gt;&lt;/a&gt;1436. Destination City
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第18周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/01/2020-%E7%AC%AC18%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/01/2020-第18周-LeetCode-记录/</id>
    <published>2020-05-01T06:43:57.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1422-Maximum-Score-After-Splitting-a-String"><a href="#1422-Maximum-Score-After-Splitting-a-String" class="headerlink" title="1422. Maximum Score After Splitting a String"></a>1422. Maximum Score After Splitting a String</h3><p>求出左侧 0 数量和右侧 1 数量之和最多的情况，遍历一次，每次更新最大值，注意要保证字符串始终被切分为 2 个子字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        right = s.count(<span class="string">'1'</span>)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        score = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[idx] == <span class="string">'1'</span>:</span><br><span class="line">                score = max(score, (left + right - <span class="number">1</span>))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                score = max(score, (left + <span class="number">1</span> + right))</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure><h3 id="1423-Maximum-Points-You-Can-Obtain-from-Cards"><a href="#1423-Maximum-Points-You-Can-Obtain-from-Cards" class="headerlink" title="1423. Maximum Points You Can Obtain from Cards"></a>1423. Maximum Points You Can Obtain from Cards</h3><p>先假设所有的数字都是从左侧获取的，然后依次遍历 k 个数值，每次遍历将左侧数字剔除，将右侧数字加入，比较最大值。</p><p>也可以转换问题为中间连续 len-k 长度数字和最小，然后所有数字之和减去最小值为所求结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxScore</span><span class="params">(cardPoints []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum + cardPoints[i]</span><br><span class="line">&#125;</span><br><span class="line">listLen := <span class="built_in">len</span>(cardPoints)</span><br><span class="line"><span class="keyword">if</span> k == listLen &#123;</span><br><span class="line"><span class="keyword">return</span> leftSum</span><br><span class="line">&#125;</span><br><span class="line">max := leftSum</span><br><span class="line"><span class="keyword">var</span> rightSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum - cardPoints[k-i<span class="number">-1</span>]</span><br><span class="line">rightSum = rightSum + cardPoints[listLen-i<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> leftSum+rightSum &gt; max &#123;</span><br><span class="line">max = leftSum + rightSum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a>1424. Diagonal Traverse II</h3><p>按照对角线方式打印出所有数字，考虑对角线部分数字为空的情况。在一个对角线上的数字，他们的横纵坐标之和都是相同的，使用一个二维数组存储，然后从上到下顺序打印出所有对角线的数值，需要注意每条对角线的数值输出应该是从下到上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="params">(ans []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    order := [<span class="number">1e5</span>][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(mat) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> mat[i] &#123;</span><br><span class="line">order[i+j] = <span class="built_in">append</span>(order[i+j], v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> order &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a>498. Diagonal Traverse</h3><p>可以用 #1424 相同的方式处理，获取所有对角线的数值，然后遍历，注意输出的顺序，也可以直接模拟，需要处理好边界。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, n*m)</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(res); i++ &#123;</span><br><span class="line">res[i] = matrix[x][y]</span><br><span class="line"><span class="keyword">if</span> (x+y)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> y == m<span class="number">-1</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y++</span><br><span class="line">x--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == n<span class="number">-1</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x++</span><br><span class="line">y--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h3><p>一个数字与全 1 进行异或，得到的数字为二进制取反。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findComplement</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">temp := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; temp &lt;= num; temp *= <span class="number">2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (temp - <span class="number">1</span>) ^ num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">5</span></span><br><span class="line">res := findComplement(num)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1422-Maximum-Score-After-Splitting-a-String&quot;&gt;&lt;a href=&quot;#1422-Maximum-Score-After-Splitting-a-String&quot; class=&quot;headerlink&quot; title=&quot;1422. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>在终端输入命令后系统做了什么</title>
    <link href="https://zdyxry.github.io/2020/04/25/%E5%9C%A8%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E5%90%8E%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://zdyxry.github.io/2020/04/25/在终端输入命令后系统做了什么/</id>
    <published>2020-04-25T15:18:03.000Z</published>
    <updated>2020-06-13T14:17:54.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>shell 是一个程序，也是一种编程语言，一个管理进程和运行程序的程序，在 Linux 中有很多 shell 可选，比如 bash、zsh、fish 等等，shell 主要有 3 个功能：</p><ol><li>运行程序</li><li>管理输入和输出</li><li>可编程</li></ol><p>运行程序很容易理解，在终端上输入的每个命令都是一个可执行程序，我们在 shell 中输入并执行程序；管理输入和输出，在 shell 中可以使用 <code>&lt;</code> <code>&gt;</code> <code>|</code> 符合控制输入、输出重定向，可以告诉 shell 将进程的输入和输出连接到一个文件或者其他的进程；编程，shell 是一种编程语言，可以进行变量赋值、循环、条件判断等操作。</p><h3 id="如何运行程序"><a href="#如何运行程序" class="headerlink" title="如何运行程序"></a>如何运行程序</h3><p>shell 永远在等待用户输入，输入完成按下回车键后，开始执行相应命令（程序），然后等待程序执行完成后打印相应输出，伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (! end_of_input)</span><br><span class="line">    get command</span><br><span class="line">    execute command</span><br><span class="line">    wait for command to finish</span><br></pre></td></tr></table></figure><p>在 shell 中因为需要执行其他的程序，需要用到 <code>execvp</code> ，<code>execvp</code> 会将指定的程序复制到调用它的进程，将指定的字符串组作为参数传递给程序，然后运行程序。这里存在一个问题， <code>execvp</code> 的执行过程是内核将程序加载到当前进程，替换当前进程的代码和数据，然后执行，那么原有进程的状态都被替换掉，在执行完程序就直接退出，不会再回到原程序等待下次输入。</p><p>为了保证我们在执行程序后回到 shell 中，需要每次创建新的进程来执行程序，调用 <code>fork</code> 指令，进程调用 fork 后，内核分配新的内存块和内核数据结构，复制原进程到新的进程，向运行进程添加新的进程，将控制返回给两个进程。通过 fork 返回值来判断当前进程是否为父进程或子进程。</p><p>shell 作为父进程通过调用 <code>fork</code> 创建子进程后，子进程通过 <code>execvp</code> 加载指定程序执行，父进程需要等待子进程退出，需要用到 <code>wait</code> ，在父进程 fork 出子进程后，父进程执行 <code>wait</code> 等待子进程执行，在调用时会传递一个整型变量地址，子进程执行完成后调用 <code>exit</code> 退出，内核将子进程的退出状态保存在这个变量中，用于父进程感知子进程退出状态。</p><h2 id="Golang-简易实现"><a href="#Golang-简易实现" class="headerlink" title="Golang 简易实现"></a>Golang 简易实现</h2><p>在 Golang 中可以调用 <code>os/exec</code> 来执行其他程序，然后在 main 中死循环不断的检测用户输入字符，同时也需要注意处理各种信号，比如 Ctrl-C 或者 Ctrl-D 之类的，下面是 Simon Jürgensmeyer 实现的一个简单的样例，可以了解一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"&gt; "</span>)</span><br><span class="line">        <span class="comment">// Read the keyboad input.</span></span><br><span class="line">        input, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle the execution of the input.</span></span><br><span class="line">        <span class="keyword">if</span> err = execInput(input); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrNoPath is returned when 'cd' was called without a second argument.</span></span><br><span class="line"><span class="keyword">var</span> ErrNoPath = errors.New(<span class="string">"path required"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execInput</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Remove the newline character.</span></span><br><span class="line">    input = strings.TrimSuffix(input, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split the input separate the command and the arguments.</span></span><br><span class="line">    args := strings.Split(input, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for built-in commands.</span></span><br><span class="line">    <span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"cd"</span>:</span><br><span class="line">        <span class="comment">// 'cd' to home with empty path not yet supported.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrNoPath</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change the directory and return the error.</span></span><br><span class="line">        <span class="keyword">return</span> os.Chdir(args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the command to execute.</span></span><br><span class="line">    cmd := exec.Command(args[<span class="number">0</span>], args[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the correct output device.</span></span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the command and return the error.</span></span><br><span class="line">    <span class="keyword">return</span> cmd.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/" target="_blank" rel="noopener">https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/</a></li><li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="noopener">https://book.douban.com/subject/1219329/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第17周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/24/2020-%E7%AC%AC17%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/24/2020-第17周-LeetCode-记录/</id>
    <published>2020-04-24T20:47:03.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1417-Reformat-The-String"><a href="#1417-Reformat-The-String" class="headerlink" title="1417. Reformat The String"></a>1417. Reformat The String</h3><p>重新格式化字符串，使得字母与数字交叉连接，先分别找出字母与数据，使用 zip_longest 来生成交叉后的元组，然后拼接得到目标字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reformat</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        a=re.findall(<span class="string">r'\d'</span>,s)</span><br><span class="line">        b=re.findall(<span class="string">r'[a-z]'</span>,s)</span><br><span class="line">        <span class="keyword">if</span> abs(len(a)-len(b))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        a,b=sorted([a,b],key=len)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(map(<span class="string">''</span>.join,itertools.zip_longest(b,a,fillvalue=<span class="string">''</span>)))</span><br></pre></td></tr></table></figure><h3 id="1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K"><a href="#1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K" class="headerlink" title="1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K"></a>1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K</h3><p>参考：<a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/tan-xin-jian-dan-zheng-ming-by-wyjoutstanding/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/tan-xin-jian-dan-zheng-ming-by-wyjoutstanding/</a></p><p>判定性：保证K一定能由斐波那契数组成，数据归纳法可证明</p><p>最小性：什么样的组合能最短？</p><ul><li>相邻合并：2个相邻的数可合并为二者的和，长度-1，因为f(n)=f(n-1)+f(n-2)。满足该条件的组合必定是间隔出现，但是又可能重现重复的值，这对于编程很不利。</li><li>重值转换：两个相同的值一定可以转换为两个不同的值，因为f(n)+f(n)=f(n)+f(n-1)+f(n-2)=f(n+1)+f(n-2)，一个比f(n)大，一个更小，这是等价转换，不会减小组合长度，但是会带来一个很好的性质，即单调递增性质。</li></ul><p>因此，重复使用以上两个操作后的组合数列，必定是一个无相邻值的递增数列，由于数列均为正数且和为K，因此值越大个数自然越小。</p><p>问：</p><blockquote><p>那会不会出现一种情况呢，就是如果减去最大的斐波那契数的话，剩下的数只能拆分成两个斐波那契数，而如果减去第二大的斐波那契数或者更小的斐波那契数的话，剩下的数刚好是斐波那契数？</p></blockquote><p>答：</p><p>可用反证法，假设总和为k，且f(m-1)&lt;k&lt;f(m)<br>那么对应你的第一种情况是k=f(m-1)+f(i)+f(j)，1&lt;=f(i),f(j)&lt;=f(m-2)；<br>对应你的第二种情况是k=f(m-2)+f(l)，其中,1&lt;=f(l)&lt;=f(m-3)。  </p><p>假设你说的情况成立，那么以上两个等式必定相等，即f(m-1)+f(i)+f(j)=f(m-2)+f(l)，<br>因为f(m-1) = f(m-2) + f(m-3), f(l)&lt;=f(m-3)，而f(i)和f(j)均不可能为0，因此等式不可能成立。<br>（左侧恒大于右侧，只有消去f(i)和f(j)才有可能取等）<br>当第二个等式的f(m-2)取更小值时更不可能成立。因此，推翻假设。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(self, k: int)</span> -&gt; int:</span></span><br><span class="line">        ls=self.fib(k)</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            <span class="keyword">if</span> k&gt;=ls[<span class="number">-1</span>]:</span><br><span class="line">                k-=ls[<span class="number">-1</span>]</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ls.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span> -&gt; int:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> b &lt;= N:</span><br><span class="line">            res.append(b)</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n"><a href="#1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n" class="headerlink" title="1415. The k-th Lexicographical String of All Happy Strings of Length n"></a>1415. The k-th Lexicographical String of All Happy Strings of Length n</h3><p>使用 dfs 求解，每次传入下一层时需要去除当前层最后一个字母；<br>不需要算出所有长度为 n 的值，在得到第 k 个时可以直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHappyString</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        self.res = <span class="string">""</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur, tmp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(cur) == self.n:</span><br><span class="line">                self.k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                    self.res = cur</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> self.res:</span><br><span class="line">                    <span class="keyword">return</span> self.res</span><br><span class="line">                new_tmp = [j <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] <span class="keyword">if</span> j != i]</span><br><span class="line">                dfs(cur+i, new_tmp)</span><br><span class="line">        dfs(<span class="string">""</span>, [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1419-Minimum-Number-of-Frogs-Croaking"><a href="#1419-Minimum-Number-of-Frogs-Croaking" class="headerlink" title="1419. Minimum Number of Frogs Croaking"></a>1419. Minimum Number of Frogs Croaking</h3><p>可以转换为求在 <code>croak</code> 周期内，出现多少个 <code>c</code>，需要考虑边界情况，<code>croak</code> 字母出现次数永远是按照顺序依次递减的，如果出现递增情况直接返回 -1；最终遍历结束后应该保证 <code>croak</code> 中的各个字母出现次数相同，且不存在出现 <code>croak</code> 一半的情况，比如 存在 <code>cro</code> ，如果存在则直接返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberOfFrogs</span><span class="params">(self, croakOfFrogs: str)</span> -&gt; int:</span></span><br><span class="line">        c, r, o, a, k, in_use, answer = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> croakOfFrogs:</span><br><span class="line">            <span class="keyword">if</span> d == <span class="string">'c'</span>:</span><br><span class="line">                c, in_use = c+<span class="number">1</span>, in_use+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'r'</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'o'</span>:</span><br><span class="line">                o += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'a'</span>:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k, in_use = k+<span class="number">1</span>, in_use<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            answer = max(answer, in_use)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> c &lt; r <span class="keyword">or</span> r &lt; o <span class="keyword">or</span> o &lt; a <span class="keyword">or</span> a &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> in_use == <span class="number">0</span> <span class="keyword">and</span> c == r <span class="keyword">and</span> r == o <span class="keyword">and</span> o == a <span class="keyword">and</span> a == k:</span><br><span class="line">            <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="926-Flip-String-to-Monotone-Increasing"><a href="#926-Flip-String-to-Monotone-Increasing" class="headerlink" title="926. Flip String to Monotone Increasing"></a>926. Flip String to Monotone Increasing</h3><p>动态规划，dp[i][0] 表示以 0 为结尾时，翻转的次数；dp[i][1] 表示以 1 为结尾是，翻转的次数；</p><p>当 i == 0 时，dp[i][0] = dp[i-1][0]，无需操作；<br>当 i == 0 时，dp[i][1] = min(dp[i-1][1], dp[i-1][0]) + 1，当 dp[i-1][1] 时，那么次数的 i = 0 ，需要翻转为 1，需 +1；当 dp[i-1][0] 时，此时要求以 1 为结尾需要翻转的次数，那么就需要将 i 翻转为 1，需 +1;  </p><p>当 i == 1 时，dp[i][0] = dp[i - 1][0] + 1 ，因为此时要求以 0 为结尾，需要将 i 翻转为 0，需 +1;<br>当 i == 1 时，dp[i][1] = min(dp[i - 1][1], dp[i - 1][0])，dp[i-1][1] 且当前 i == 1，所以无需操作；dp[i-1][0] 表示之前都是0且结尾是0，那么此时 i == 1 也符合递增情况无需操作。</p><p>简化后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, S: str)</span> -&gt; int:</span></span><br><span class="line">        N = len(S)</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i - <span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>]</span><br><span class="line">                dp[<span class="number">1</span>] = min(dp[<span class="number">1</span>], dp[<span class="number">0</span>]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">1</span>] = min(dp[<span class="number">1</span>], dp[<span class="number">0</span>])</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1417-Reformat-The-String&quot;&gt;&lt;a href=&quot;#1417-Reformat-The-String&quot; class=&quot;headerlink&quot; title=&quot;1417. Reformat The String&quot;&gt;&lt;/a&gt;1417. Reforma
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>文件系统基本概念及常用操作解释</title>
    <link href="https://zdyxry.github.io/2020/04/18/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%A7%A3%E9%87%8A/"/>
    <id>https://zdyxry.github.io/2020/04/18/文件系统基本概念及常用操作解释/</id>
    <published>2020-04-18T14:24:23.000Z</published>
    <updated>2020-06-13T14:17:54.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间一个朋友问我删除文件和格式化有什么区别，最近正好在读《Unix Linux 编程实践教程》这本书，其中第4章是来讲文件系统相关的，本文是对其中内容进行部分摘要来解释。</p><h2 id="Unix-文件系统的内部结构"><a href="#Unix-文件系统的内部结构" class="headerlink" title="Unix 文件系统的内部结构"></a>Unix 文件系统的内部结构</h2><p>从用户角度看，Unix 系统中的硬盘上的文件组成一棵目录树，每个目录能包含文件或其他目录，目录树的深度几乎没有限制，子目录下可以包含其他文件和子目录（套娃）。文件内容放置在对应的目录中，对应的目录内容放置在上层目录中。</p><p>文件系统是对硬盘设备的一种多层次的抽象，主要包含以下三层。</p><h3 id="第一层：从硬盘到分区"><a href="#第一层：从硬盘到分区" class="headerlink" title="第一层：从硬盘到分区"></a>第一层：从硬盘到分区</h3><p>一个硬盘能够存储大量的数据，硬盘可以被划分为多个区域，也就是硬盘分区，每个分区在系统中都可以看作是独立的硬盘。</p><h3 id="第二层：从磁盘到块序列"><a href="#第二层：从磁盘到块序列" class="headerlink" title="第二层：从磁盘到块序列"></a>第二层：从磁盘到块序列</h3><p>一个硬盘由许多磁性盘片组成，每个盘片的表面都被划分为很多同心圆，这些同心圆被成为磁道，每个磁道有进一步被划分为扇区，每个扇区可以存储一定字节数的数据，例如每个扇区有 512字节空间。扇区是磁盘上的基本存储单元，磁盘都包含大量的扇区。</p><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-1.jpg" title="fs-1"><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-2.jpg" title="fs-2"><p>为磁盘块编号是一种很重要的方法，给每个磁盘块分配连续的编号使得操作系统能够计算磁盘上的每个块，可以一个磁盘接一个磁盘的从上到下给所有的块编号，还可以一个磁道接一个磁道的从外向里给所有的块编号，一个将磁盘扇区编号的系统使得我们可以把磁盘视为一系列块的组合。</p><h3 id="第三层：从块序列到三个区域的划分"><a href="#第三层：从块序列到三个区域的划分" class="headerlink" title="第三层：从块序列到三个区域的划分"></a>第三层：从块序列到三个区域的划分</h3><p>文件系统可以用来存储文件内容、文件属性（文件所有者、日期等）和目录，这些不同类型的数据是如何存储在编号的磁盘块上的呢?</p><h2 id="文件系统区域划分"><a href="#文件系统区域划分" class="headerlink" title="文件系统区域划分"></a>文件系统区域划分</h2><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-3.png" title="fs-3"><p>一部分成为数据区，用来存放文件真正的内容。另一部分成为 i-node 表，用来存放文件属性。第三部分成为超级块（superblock），用来存放文件系统自身的信息。文件系统由这 3 部分组合而成，其中任一部分都是由很多有序磁盘块组成的。</p><h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>文件系统的第一个块被成为超级块。这个块中存放文件系统自身的结构信息，比如记录了每个区域的大小。超级块也存放未被使用的磁盘块信息，不同的文件系统的超级块信息不同，可以通过 <code>debugfs</code> 等类似命令查看。</p><h3 id="i-node-表"><a href="#i-node-表" class="headerlink" title="i-node 表"></a>i-node 表</h3><p>文件系统的下一个部分被成为 i-node 表，每个文件都有一些属性，如大小、文件所有者和最近修改时间等等，这些属性被记录在一个被成为 i-node 的结构中，所有的 i-node 都有相同的大小，并且 i-node 表是这些 i-node 结构组成的一个列表。文件系统中每个文件都有一个 i-node。</p><h3 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h3><p>文件系统的第 3 个部分是数据区。文件的真正内容保存在这个区域。磁盘上所有块的大小都是一样的。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。一个较大的文件很容易分布在上千个独立的磁盘块中。</p><h2 id="常见操作过程解释"><a href="#常见操作过程解释" class="headerlink" title="常见操作过程解释"></a>常见操作过程解释</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>当我们创建一个文件的时候，主要操作有以下 4个：</p><ul><li>存储属性<ul><li>文件属性的存储：内核先找到一个空的 i-node，把文件的信息记录到 i-node 中。</li></ul></li><li>存储数据<ul><li>文件内容的存储：内核从未被使用的数据块列表中找出足够的数据块，然后将数据从缓冲区复制到对应的数据块中。</li></ul></li><li>记录分配情况<ul><li>文件内容按照顺序存放在数据块中。内核在 i-node 的磁盘分布区记录了上述的块序列。磁盘分布区是一个磁盘块序号的列表。</li></ul></li><li>添加文件名到目录<ul><li>内核将文件 i-node 编号和对应的文件名添加到目录文件。文件名和 i-node 编号之间的对应关系将文件名和文件内容及文件属性进行了关联。</li></ul></li></ul><p>如果创建一个大文件该如何做？一个大文件需要多个磁盘块，在 i-node 中存放磁盘块分配列表，但是长度是固定的，也就是文件大小是有上限的，如何尽可能的支持更大的文件？</p><p>如果一个文件需要 14个数据块存储内容，但是 i-node 只包含一个含有 13 个项的分配列表，这是将分配列表中的前 10 个编号放到 i-node 中，将最后的 4个编号放到一个数据块中，然后在 i-node 的第 11 项中作为指向存放 4个数据块编号的数据块。最终这个文件一共使用了15个数据块，额外使用的数据块成为间接块。</p><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-4.png" title="fs-4"><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><ul><li>在目录中寻找文件名<ul><li>文件名存储在目录文件中，内核在目录文件中寻找包含文件名的记录，然后找到对应的 i-node 编号</li></ul></li><li>定位 i-node 编号并读取内容<ul><li>内核在文件系统的 i-node 区域找到对应的 i-node。定位 i-node 需要简单的计算，所有的 i-node 大小相同，每个磁盘块都包含相同数量的 i-node。内核会将 i-node 置为缓冲区，i-node 包含数据块编号的列表。</li></ul></li><li>访问存储文件内容的数据块<ul><li>通过 i-node 信息，内核已经知道文件真正的内容存放在哪些数据块上，以及它们的顺序，将字节从磁盘复制到内核缓冲区，然后到达用户空间。</li></ul></li></ul><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>目录是一种包含了文件名字列表的特殊文件，不同版本的 Unix 目录内部结构不同，但是抽象模型是一致的—一个包含 i-node 编号和文件名的列表。</p><p>当一个文件想要被多种方式共享且保证他们是一个文件，有多个有效的路径名，系统引入了链接机制：硬链接和软链接。其中硬链接与文件的 i-node 一致。一个文件内容自身的硬链接数刚创建时为1，之后通过其他方式创建了硬链接，那么引用计数对应增加。</p><p>“文件在目录中”从系统的角度看，是目录中有一个包含文件名和对应 i-node 编号的入口，“文件 x 在目录 a 中”意味着在目录 a 中有一个指向对应 i-node 的链接，这个链接所附加的文件名为 <code>x</code>。简单来说，目录包含的是文件的引用，每个引用被成为链接，文件的内容存储在数据块中，文件的属性被记录在 i-node 中，i-node编号和文件名存储在目录中。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除文件是从一个目录中删除一个对应文件的引用记录，减少对应的 i-node 的链接数，如果 i-node 的链接数减为0，则 i-node 和 i-node 对应的数据块被释放，这里的释放指的是删除 i-node 信息，这样我们就没办法通过 i-node 信息找到文件数据块信息的对应关系，但是文件真正的内容还是存在数据块中的，没有被删除，如果发现误删之后立即停止所有操作，是有可能通过一些方式来达到数据恢复的目的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="noopener">https://book.douban.com/subject/1219329/</a></li><li><a href="https://www.youtube.com/watch?v=Cj8-WNjaGuM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Cj8-WNjaGuM</a></li><li><a href="https://zhuanlan.zhihu.com/p/34883885" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34883885</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间一个朋友问我删除文件和格式化有什么区别，最近正好在读《Unix Linux 编程实践教程》这本书，其中第4章是来讲文件系统相关的，本
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第16周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/18/2020-%E7%AC%AC16%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/18/2020-第16周-LeetCode-记录/</id>
    <published>2020-04-18T05:34:09.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1408-String-Matching-in-an-Array"><a href="#1408-String-Matching-in-an-Array" class="headerlink" title="1408. String Matching in an Array"></a>1408. String Matching in an Array</h3><p>先按照单词长度进行排序，然后遍历判断当前单词是否被其他单词包含，要注意最终结果应该是去重之后的。</p><p>Golang 中可以直接使用 <code>strings.Contains</code> 判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByLen []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(a[i]) &lt; <span class="built_in">len</span>(a[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringMatching</span><span class="params">(words []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">sort.Sort(ByLen(words))</span><br><span class="line">res := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(words); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(words[j], words[i]) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, words[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">skip := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> unique &#123;</span><br><span class="line"><span class="keyword">if</span> v == u &#123;</span><br><span class="line">skip = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !skip &#123;</span><br><span class="line">unique = <span class="built_in">append</span>(unique, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unique</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1409-Queries-on-a-Permutation-With-Key"><a href="#1409-Queries-on-a-Permutation-With-Key" class="headerlink" title="1409. Queries on a Permutation With Key"></a>1409. Queries on a Permutation With Key</h3><p>数据规模较小，可以直接使用数组暴力求解。</p><p>理想方法应该是使用 Fenwick Tree 来解答，具体的方法参考：</p><ul><li><a href="https://www.youtube.com/watch?v=WbafSgetDDk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=WbafSgetDDk</a></li><li><a href="https://www.youtube.com/watch?v=DwtijVbS3G0&amp;t=635s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=DwtijVbS3G0&amp;t=635s</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processQueries</span><span class="params">(queries []<span class="keyword">int</span>, m <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(queries))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">p[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> queries &#123;</span><br><span class="line"><span class="comment">//found value in p's index</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> p[i] == value &#123;</span><br><span class="line">res[index] = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//move p</span></span><br><span class="line">tmp := p[i]</span><br><span class="line"><span class="built_in">copy</span>(p[<span class="number">1</span>:i+<span class="number">1</span>], p[<span class="number">0</span>:i])</span><br><span class="line">p[<span class="number">0</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processQueries</span><span class="params">(self, queries: List[int], m: int)</span> -&gt; List[int]:</span></span><br><span class="line">        tree = [<span class="number">0</span>] * ((<span class="number">2</span>*m) + <span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(i,val)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;len(tree):</span><br><span class="line">                tree[i]+=val</span><br><span class="line">                i+=(i&amp;(-i))</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">prefixSum</span><span class="params">(i)</span>:</span></span><br><span class="line">            s=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                s+=tree[i]</span><br><span class="line">                i-=(i&amp;(-i))</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        hmap = collections.defaultdict(int)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            hmap[i] = i+m</span><br><span class="line">            update(i+m,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> queries:</span><br><span class="line">            res.append(prefixSum(hmap[i])<span class="number">-1</span>)</span><br><span class="line">            update(hmap[i],<span class="number">-1</span>)</span><br><span class="line">            update(m,<span class="number">1</span>)</span><br><span class="line">            hmap[i] = m</span><br><span class="line">            m-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1410-HTML-Entity-Parser"><a href="#1410-HTML-Entity-Parser" class="headerlink" title="1410. HTML Entity Parser"></a>1410. HTML Entity Parser</h3><p>字符串解析替换，遍历检查 <code>&amp;</code> 和 <code>;</code> 进行替换，也可以直接使用 <code>str.replace</code> 进行替换，如果使用 regex 会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">entityParser</span><span class="params">(self, text: str)</span> -&gt; str:</span></span><br><span class="line">        ent = &#123;<span class="string">'&amp;quot;'</span>: <span class="string">'"'</span>, <span class="string">'&amp;apos;'</span>:<span class="string">'\''</span> , <span class="string">'&amp;gt;'</span>:<span class="string">'&gt;'</span>, <span class="string">'&amp;lt;'</span>:<span class="string">'&lt;'</span>, <span class="string">'&amp;frasl;'</span>:<span class="string">'/'</span>, <span class="string">'&amp;amp;'</span>:<span class="string">'&amp;'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> ent.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> text:</span><br><span class="line">                text = text.replace(k, v)</span><br><span class="line">        <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure><h3 id="1138-Alphabet-Board-Path"><a href="#1138-Alphabet-Board-Path" class="headerlink" title="1138. Alphabet Board Path"></a>1138. Alphabet Board Path</h3><p>先准备字母表，需要注意的是最后一个字母 <code>z</code>，如果目标字母是 <code>z</code> ，那么只能先左再下，如果当前字母是 <code>z</code>，那么只能先上再右，需要考虑移动的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alphabetBoardPath</span><span class="params">(self, target: str)</span> -&gt; str:</span></span><br><span class="line">        m = &#123;c: [i // <span class="number">5</span>, i % <span class="number">5</span>] <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>)&#125;</span><br><span class="line">        x0, y0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> target:</span><br><span class="line">            x, y = m[c]</span><br><span class="line">            <span class="keyword">if</span> y &lt; y0: res.append(<span class="string">'L'</span> * (y0 - y))</span><br><span class="line">            <span class="keyword">if</span> x &lt; x0: res.append(<span class="string">'U'</span> * (x0 - x))</span><br><span class="line">            <span class="keyword">if</span> x &gt; x0: res.append(<span class="string">'D'</span> * (x - x0))</span><br><span class="line">            <span class="keyword">if</span> y &gt; y0: res.append(<span class="string">'R'</span> * (y - y0))</span><br><span class="line">            res.append(<span class="string">'!'</span>)</span><br><span class="line">            x0, y0 = x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="1302-Deepest-Leaves-Sum"><a href="#1302-Deepest-Leaves-Sum" class="headerlink" title="1302. Deepest Leaves Sum"></a>1302. Deepest Leaves Sum</h3><p>求最深层的叶子节点之和，需要维护 2个变量，一个是最深层次，一个是最深层次对应的和。遍历节点时与最深层次比较，进行求和运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepestLeavesSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        q = collections.deque([(root, <span class="number">0</span>)])</span><br><span class="line">        maxdep, total = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">            node, dep = q.pop()</span><br><span class="line">            <span class="keyword">if</span> dep &gt; maxdep:</span><br><span class="line">                maxdep, total = dep, node.val</span><br><span class="line">            <span class="keyword">elif</span> dep == maxdep:</span><br><span class="line">                total += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append((node.left, dep + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append((node.right, dep + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1408-String-Matching-in-an-Array&quot;&gt;&lt;a href=&quot;#1408-String-Matching-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1408. String Matching in an 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>runc nsenter 源码阅读</title>
    <link href="https://zdyxry.github.io/2020/04/12/runc-nsenter-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2020/04/12/runc-nsenter-源码阅读/</id>
    <published>2020-04-12T14:57:29.000Z</published>
    <updated>2020-06-13T14:17:54.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在阅读 runc 的实现，发现在 runc 中比较重要的一个逻辑是在设置 namespace 过程中的 nsenter 模块，其中逻辑有些绕，也发现了一段很长很有意思的注释，分享一下。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>什么是 nsenter，nsenter 是 runc 中的一个 package，它包含了一个特殊的构造函数，用来在 Go runtime 启动之前做一些事情，比如 setns()。nsenter 会引入 <code>C</code> 并使用 cgo 实现相关逻辑。在cgo中，如果在 <code>C</code> 的 import 后紧跟注释，则在编译程序包的 C 语言实现部分时，该注释将用作 header。因此，每次 import nsenter 时，nsexec()都会调用 C 函数。</p><p>在 runc 中只有 init.go import 了 nsenter。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>容器技术最关键的就是 namespace 和 cgroup，其中 namespace 是通过 setns() 函数来实现的，但是 setns() 有一个问题： <code>A multithreaded process may not change user namespace with setns().</code> 。而 go runtime 是多线程的，所以需要在 go runtime 启动前执行 setns() 设置好 namespace，然后再走 go 相关实现流程。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>在实际的 nsenter 实现中，存在 3 个进程，分别为 parent, child, grandchild。在注释中可以看到 nsenter 实现过程中的考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Okay, so this is quite annoying.</span><br><span class="line"> *</span><br><span class="line"> * In order for this unsharing code to be more extensible we need to split</span><br><span class="line"> * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case</span><br><span class="line"> * would be if we did clone(CLONE_NEWUSER) and the other namespaces</span><br><span class="line"> * separately, but because of SELinux issues we cannot really do that. But</span><br><span class="line"> * we cannot just dump the namespace flags into clone(...) because several</span><br><span class="line"> * usecases (such as rootless containers) require more granularity around</span><br><span class="line"> * the namespace setup. In addition, some older kernels had issues where</span><br><span class="line"> * CLONE_NEWUSER wasn&apos;t handled before other namespaces (but we cannot</span><br><span class="line"> * handle this while also dealing with SELinux so we choose SELinux support</span><br><span class="line"> * over broken kernel support).</span><br><span class="line"> *</span><br><span class="line"> * However, if we unshare(2) the user namespace *before* we clone(2), then</span><br><span class="line"> * all hell breaks loose.</span><br><span class="line"> *</span><br><span class="line"> * The parent no longer has permissions to do many things (unshare(2) drops</span><br><span class="line"> * all capabilities in your old namespace), and the container cannot be set</span><br><span class="line"> * up to have more than one &#123;uid,gid&#125; mapping. This is obviously less than</span><br><span class="line"> * ideal. In order to fix this, we have to first clone(2) and then unshare.</span><br><span class="line"> *</span><br><span class="line"> * Unfortunately, it&apos;s not as simple as that. We have to fork to enter the</span><br><span class="line"> * PID namespace (the PID namespace only applies to children). Since we&apos;ll</span><br><span class="line"> * have to double-fork, this clone_parent() call won&apos;t be able to get the</span><br><span class="line"> * PID of the _actual_ init process (without doing more synchronisation than</span><br><span class="line"> * I can deal with at the moment). So we&apos;ll just get the parent to send it</span><br><span class="line"> * for us, the only job of this process is to update</span><br><span class="line"> * /proc/pid/&#123;setgroups,uid_map,gid_map&#125;.</span><br><span class="line"> *</span><br><span class="line"> * And as a result of the above, we also need to setns(2) in the first child</span><br><span class="line"> * because if we join a PID namespace in the topmost parent then our child</span><br><span class="line"> * will be in that namespace (and it will not be able to give us a PID value</span><br><span class="line"> * that makes sense without resorting to sending things with cmsg).</span><br><span class="line"> *</span><br><span class="line"> * This also deals with an older issue caused by dumping cloneflags into</span><br><span class="line"> * clone(2): On old kernels, CLONE_PARENT didn&apos;t work with CLONE_NEWPID, so</span><br><span class="line"> * we have to unshare(2) before clone(2) in order to do this. This was fixed</span><br><span class="line"> * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was</span><br><span class="line"> * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we&apos;re</span><br><span class="line"> * aware, the last mainline kernel which had this bug was Linux 3.12.</span><br><span class="line"> * However, we cannot comment on which kernels the broken patch was</span><br><span class="line"> * backported to.</span><br><span class="line"> *</span><br><span class="line"> * -- Aleksa &quot;what has my life come to?&quot; Sarai</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>来看下 parent，child，grandchild 分别做了哪些事情：</p><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><p>parent 进程通过环境变量 <code>_LIBCONTAINER_INITPIPE</code> 获取相关配置信息，然后 clone 出 child 进程，当 child 进程 ready 之后设置 user map，从 child 进程中接受 grandchild 进程 pid，然后通过管道传递给外层的 runc 进程。parent 进程退出条件为 child 进程和 grandchild 都处于 ready 状态后，parent 进程退出。</p><p>之所以要 clone child 进程，是因为如果创建了 user namespace，那么 user map 只能由原有的 user namespace 设置，所以需要 clone child 进程，然后在 parent 进程中设置 user map。</p><h3 id="child"><a href="#child" class="headerlink" title="child"></a>child</h3><p>child 进程先执行 setns()，在一些老版本的kernel 中，<code>CLONE_PARENT</code> flag 与 <code>CLONE_NEWPID</code> 有冲突，所以使用 unshare 创建 user namespace， user namespace 需要先于其他 namespace 创建，创建 user namespace 并设置 user map，才有能力创建其他的 namespace。等待 parent 进程设置 user map 后，设置 child 当前进程的 uid 为 root(0) ，使用 unshare 创建其他 namespace，然后 clone grandchild 进程，并将 grandchild 进程 pid 传递给 parent，然后退出。</p><p>之所以要 clone grandchild 进程，是因为在 child 进程中设置 namespace 并不会在 child 进程中生效，所以需要 clone 出一个新的进程，继承 namespace 配置。</p><h3 id="grandchild"><a href="#grandchild" class="headerlink" title="grandchild"></a>grandchild</h3><p>grandchild 进程就是容器真正的进程，在确保 parent 和 child 进程都处于 ready 之后，设置 uid,gid，从管道中读取相应配置信息，然后 unshare 创建 cgroup namespace，然后将状态发送给 parent 后 返回。grandchild 进程返回后继续执行 go 代码流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>runc 作为 OCI 的标准实现，自身代码量并不大，但是逻辑比较扰，其中 namespace 更是博大精深，尤其是要考虑到一些老版本kernel 以及 rootless 场景下，复杂程度翻倍，有很多细节值得去思考。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/README.md" target="_blank" rel="noopener">https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/README.md</a></li><li><a href="https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c" target="_blank" rel="noopener">https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在阅读 runc 的实现，发现在 runc 中比较重要的一个逻辑是在设置 namespace 过程中的 nsenter 模块，其中逻辑有
      
    
    </summary>
    
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>2020 第15周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/10/2020-%E7%AC%AC15%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/10/2020-第15周-LeetCode-记录/</id>
    <published>2020-04-10T20:44:44.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1403-Minimum-Subsequence-in-Non-Increasing-Order"><a href="#1403-Minimum-Subsequence-in-Non-Increasing-Order" class="headerlink" title="1403. Minimum Subsequence in Non-Increasing Order"></a>1403. Minimum Subsequence in Non-Increasing Order</h3><p>对数组进行排序，然后依次取出当前最大值，比较当前取出数值和与剩余数值和，如果大于，则返回取出数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubsequence</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        N = len(nums)</span><br><span class="line">        total = sum(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            x = nums.pop()</span><br><span class="line"></span><br><span class="line">            t += x</span><br><span class="line">            ret.append(x)</span><br><span class="line">            <span class="keyword">if</span> t * <span class="number">2</span> &gt; total: <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h3 id="1400-Construct-K-Palindrome-Strings"><a href="#1400-Construct-K-Palindrome-Strings" class="headerlink" title="1400. Construct K Palindrome Strings"></a>1400. Construct K Palindrome Strings</h3><p>构造指定个数的回文字符串，检查出现次数为奇数的字母次数是否超过了k即可。可以直接用 Counter 计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        digit_count = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> len(s) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            odd = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> set(s):</span><br><span class="line">                digit_count[i] = s.count(i)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> digit_count.values():</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                    odd += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> odd &gt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1401-Circle-and-Rectangle-Overlapping"><a href="#1401-Circle-and-Rectangle-Overlapping" class="headerlink" title="1401. Circle and Rectangle Overlapping"></a>1401. Circle and Rectangle Overlapping</h3><p>依次考虑圆心与矩形的位置关系，是否在矩形的上下左右，求出矩形到圆心距离最小的点，然后根据两点间距离公式来与半径相比较。</p><p>zhihu 上有一个问题可以解答这道题：<a href="https://www.zhihu.com/question/24251545" target="_blank" rel="noopener">https://www.zhihu.com/question/24251545</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkOverlap</span><span class="params">(radius <span class="keyword">int</span>, x_center <span class="keyword">int</span>, y_center <span class="keyword">int</span>, x1 <span class="keyword">int</span>, y1 <span class="keyword">int</span>, x2 <span class="keyword">int</span>, y2 <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dx, dy <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">if</span> x1 &gt; x_center &#123;</span><br><span class="line">        dx = x1 - x_center  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> x_center &gt; x2 &#123;</span><br><span class="line">        dx = x_center - x2 </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        dx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> y1 &gt; y_center &#123;</span><br><span class="line">        dy = y1 - y_center  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> y_center &gt; y2 &#123;</span><br><span class="line">        dy = y_center - y2 </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        dy = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dx * dx + dy * dy &lt;= radius * radius</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One"><a href="#1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One" class="headerlink" title="1404. Number of Steps to Reduce a Number in Binary Representation to One"></a>1404. Number of Steps to Reduce a Number in Binary Representation to One</h3><p>这道题如果直接把二进制转换为十进制数，然后判断奇偶就很容易了，但是这不是它本身的目的，主要需要考虑位进位换算，其中分为 4 种情况：</p><p>无进位，当前位是1，则步骤 +2，进位为1<br>无进位，当前位是0，则步骤 +1，进位为0<br>有进位，当前位是1，则步骤 +1，进位为1<br>有进位，当前位是0，则步骤 +2，进位为1</p><p>其中步骤 +2 的情况为当前位是 1，需要 +1 和 /2 两个操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(A []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(A)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">A[i], A[<span class="built_in">len</span>(A)<span class="number">-1</span>-i] = A[<span class="built_in">len</span>(A)<span class="number">-1</span>-i], A[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSteps</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">reverse(bs)</span><br><span class="line">step, carry, last := <span class="number">0</span>, <span class="number">0</span>, bs[<span class="built_in">len</span>(bs)<span class="number">-1</span>]</span><br><span class="line">bs = bs[:<span class="built_in">len</span>(bs)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> bs &#123;</span><br><span class="line"><span class="keyword">if</span> carry == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">'1'</span> &#123;</span><br><span class="line">step += <span class="number">2</span></span><br><span class="line">carry = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">'0'</span> &#123;</span><br><span class="line">step += <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> last == <span class="string">'1'</span> &#123;</span><br><span class="line">step += carry</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1405-Longest-Happy-String"><a href="#1405-Longest-Happy-String" class="headerlink" title="1405. Longest Happy String"></a>1405. Longest Happy String</h3><p>对字母按照次数进行降序排序，然后依次遍历字母，判断最后2位是否与当前字母 * 2 相同，如果相同，则跳过，如果不相同，则将其添加到结果中，并将次数 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDiverseString</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class="line">        x = [[a, <span class="string">'a'</span>],[b, <span class="string">'b'</span>],[c,<span class="string">'c'</span>]]</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> sorted(x,reverse=<span class="keyword">True</span>):</span><br><span class="line">                <span class="keyword">if</span> num[<span class="number">0</span>] &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">if</span> len(res) &gt;= <span class="number">2</span> <span class="keyword">and</span> res[<span class="number">-2</span>:] == num[<span class="number">1</span>] * <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res += num[<span class="number">1</span>]</span><br><span class="line">                num[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1403-Minimum-Subsequence-in-Non-Increasing-Order&quot;&gt;&lt;a href=&quot;#1403-Minimum-Subsequence-in-Non-Increasing-Order&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>fsck 是如何工作的</title>
    <link href="https://zdyxry.github.io/2020/04/05/fsck-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://zdyxry.github.io/2020/04/05/fsck-是如何工作的/</id>
    <published>2020-04-05T09:08:33.000Z</published>
    <updated>2020-06-13T14:17:54.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在平时会遇到不少系统崩溃之后文件系统异常的情况，通常我们会通过 fsck 工具进行修复，今天来了解下 fsck 做了什么，是怎么做的。</p><h2 id="工作负载示例"><a href="#工作负载示例" class="headerlink" title="工作负载示例"></a>工作负载示例</h2><p>假设现在存在一种工作负载，将单个数据块附加到原有文件。通过打开文件，调用 <code>lseek()</code> 将文件偏移量移动到文件末尾，然后在关闭文件之前，向文件发出单个 4KB 写入来完成追加。</p><p>假定磁盘上使用标准的简单文件系统结构，包括一个 inode 位图（inode bitmap，只有 8 位，每个 inode 一个），一个数据位图（databitmap，也是 8 位，每个数据块一个），inode（总共 8 个，编号为 0 到 7，分布在 4 个块上），以及数据块（总共 8 个，编号为 0～7）。以下是该文件系统的示意图：</p><img src="/2020/04/05/fsck-是如何工作的/fsck-1.png" title="fsck-1"><p>查看图中的结构，可以看到分配了一个 inode（inode 号为 2），它在 inode 位图中标记，单个分配的数据块（数据块 4）也在数据中标记位图。inode 表示为 I [v1]，因为它是此 inode 的第一个版本。它将很快更新（由于上述工作负载）。再来看看这个简化的 inode。在 I[v1]中，可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">owner : remzi</span><br><span class="line">permissions : read-write</span><br><span class="line">size : 1</span><br><span class="line">pointer : 4</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br></pre></td></tr></table></figure><p>在这个简化的 inode 中，文件的大小为 1（它有一个块位于其中），第一个直接指针指向块 4（文件的第一个数据块，Da），并且所有其他 3 个直接指针都被设置为 null（表示它们未被使用）。当然，真正的 inode 有更多的字段。</p><p>向文件追加内容时，要向它添加一个新数据块，因此必须更新 3 个磁盘上的结构：inode（必须指向新块，并且由于追加而具有更大的大小），新数据块 Db 和新版本的数据位图（称之为 B[v2]）表示新数据块已被分配。<br>因此，在系统的内存中，有 3 个块必须写入磁盘。更新的 inode（inode 版本 2，或简称为 I [v2]）现在看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">owner : remzi</span><br><span class="line">permissions : read-write</span><br><span class="line">size : 2</span><br><span class="line">pointer : 4</span><br><span class="line">pointer : 5</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br></pre></td></tr></table></figure><p>更新的数据位图（B[v2]）现在看起来像这样：00001100。最后，有数据块（Db），它只是用户放入文件的内容。希望文件系统的最终磁盘映像如下所示:</p><img src="/2020/04/05/fsck-是如何工作的/fsck-2.png" title="fsck-2"><p>要实现这种转变，文件系统必须对磁盘执行 3 次单独写入，分别针对 inode（I[v2]），位图（B[v2]）和数据块（Db）。请注意，当用户发出 write()系统调用时，这些写操作通常不会立即发生。脏的 inode、位图和新数据先在内存（页面缓存，page cache，或缓冲区缓存，buffer cache）中存在一段时间。</p><p>然后，当文件系统最终决定将它们写入磁盘时（比如说 5s 或 30s），文件系统将向磁盘发出必要的写入请求。遗憾的是，可能会发生崩溃，从而干扰磁盘的这些更新。特别是，如果这些写入中的一个或两个完成后发生崩溃，而不是全部 3 个，则文件系统可能处于异常的状态。</p><h2 id="崩溃场景"><a href="#崩溃场景" class="headerlink" title="崩溃场景"></a>崩溃场景</h2><p>想象一下，只有一次写入成功。因此有以下 3 种可能的结果：</p><ul><li>只将数据块（Db）写入磁盘。在这种情况下，数据在磁盘上，但是没有指向它的 inode，也没有表示块已分配的位图。因此，就好像写入从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题。</li><li>只有更新的 inode（I[v2]）写入了磁盘。在这种情况下，inode 指向磁盘地址（5），其中 Db 即将写入，但 Db 尚未写入。因此，如果信任该指针，那将从磁盘读取垃圾数据（磁盘地址 5 的旧内容）。</li></ul><p>此外，遇到了一个新问题，将它称为文件系统不一致（file-system inconsistency）。磁盘上的位图显示数据块 5 尚未分配，但是 inode 说它已经分配了。文件系统数据结构中的这种不同意见，是文件系统的数据结构不一致。要使用文件系统，必须以某种方式解决这个问题。</p><ul><li>只有更新后的位图（B [v2]）写入了磁盘。在这种情况下，位图指示已分配块 5，但没有指向它的 inode。因此文件系统再次不一致。如果不解决，这种写入将导致空间泄露（space leak），因为文件系统永远不会使用块 5。</li></ul><p>在这个向磁盘写入 3 次的尝试中，还有 3 种崩溃场景。在这些情况下，两次写入成功，最后一次失败。</p><ul><li>inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）。在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图指示 5 正在使用，因此从文件系统的元数据的角度来看，一切看起来都很正常。但是有一个问题：5 中又是垃圾。</li><li>写入了 inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）。在这种情况下，inode 指向了磁盘上的正确数据，但同样在 inode 和位图（B1）的旧版本之间存在不一致。因此，在使用文件系统之前，又需要解决问题。</li><li>写入了位图（B[v2]）和数据块（Db），但没有写入 inode（I[v2]）。在这种情况下，inode 和数据位图之间再次存在不一致。但是，即使写入块并且位图指示其使用，也不知道它属于哪个文件，因为没有 inode 指向该块。</li></ul><p>从这些崩溃场景中可以看到由于崩溃而导致磁盘文件系统映像可能出现的许<br>多问题：在文件系统数据结构中可能存在不一致性。可能有空间泄露，可能将垃圾数据返回给用户，等等。</p><p>理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地<br>（atomically）移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是，做到这一点不容易，因为磁盘一次只提交一次写入，而这些更新之间可能会发生崩溃或断电。将这个一般问题称为崩溃一致性问题（crash-consistency problem，也可以称为一致性更新问题，consistent-update problem）。</p><h2 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h2><p>早期的文件系统采用了一种简单的方法来处理崩溃一致性。基本上，它们决定让不一致的事情发生，然后再修复它们（重启时）。这种偷懒方法的典型例子可以在一个工具中找到：fsck。fsck 是一个 UNIX 工具，用于查找这些不一致并修复它们。在不同的系统上，存在检查和修复磁盘分区的类似工具。请注意，这种方法无法解决所有问题。例如，考虑上面的情况，文件系统看起来是一致的，但是 inode 指向垃圾数据。唯一真正的目标，是确保文件系统元数据内部一致。</p><p>工具 fsck 在许多阶段运行，它在文件系统挂载并可用之前运行（fsck 假定在运行时没有其他文件系统活动正在进行）。一旦完成，磁盘上的文件系统应该是一致的，因此可以让用户访问。以下是 fsck 的基本总结：</p><ul><li>超级块：fsck 首先检查超级块是否合理，主要是进行健全性检查，例如确保文件系统大小大于分配的块数。通常，这些健全性检查的目的是找到一个可疑的（冲突的）超级块。在这种情况下，系统（或管理员）可以决定使用超级块的备用副本。</li><li>空闲块：接下来，fsck 扫描 inode、间接块、双重间接块等，以了解当前在文件系统中分配的块。它利用这些知识生成正确版本的分配位图。因此，如果位图和 inode之间存在任何不一致，则通过信任 inode 内的信息来解决它。对所有 inode 执行相同类型的检查，确保所有看起来像在用的 inode，都在 inode 位图中有标记。</li><li>inode 状态：检查每个 inode 是否存在损坏或其他问题。例如，fsck 确保每个分配的 inode 具有有效的类型字段（即常规文件、目录、符号链接等）。如果 inode 字段存在问题，不易修复，则 inode 被认为是可疑的，并被 fsck 清除，inode 位图相应地更新。</li><li>inode 链接：fsck 还会验证每个已分配的 inode 的链接数。你可能还记得，链接计数表示包含此特定文件的引用（即链接）的不同目录的数量。为了验证链接计数，fsck 从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数。如果新计算的计数与 inode 中找到的计数不匹配，则必须采取纠正措施，通常是修复 inode 中的计数。如果发现已分配的 inode 但没有目录引用它，则会将其移动到 lost + found 目录。</li><li>重复：fsck 还检查重复指针，即两个不同的 inode 引用同一个块的情况。如果一个 inode 明显不好，可能会被清除。或者，可以复制指向的块，从而根据需要为每个 inode 提供其自己的副本。</li><li>坏块：在扫描所有指针列表时，还会检查坏块指针。如果指针显然指向超出其有效范围的某个指针，则该指针被认为是“坏的”，例如，它的地址指向大于分区大小的块。在这种情况下，fsck 不能做任何太智能的事情。它只是从 inode 或间接块中删除（清除）该指针。</li><li>目录检查：fsck 不了解用户文件的内容。但是，目录包含由文件系统本身创建的特定格式的信息。因此，fsck 对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前面的条目，目录条目中引用的每个 inode 都已分配，并确保整个层次结构中没有目录的引用超过一次。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上所述，构建有效工作的 fsck 需要复杂的文件系统知识。确保这样的代码在所有情况下都能正常工作可能具有挑战性。然而，fsck（和类似的方法）有一个更大的、也许更根本的问题：它们太慢了。</p><p>对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。随着磁盘容量的增长和 RAID 的普及，fsck 的性能变得令人望而却步。在更高的层面上，fsck 的基本前提似乎有点不合理。考虑上面的示例，其中只有 3 个块写入磁盘。扫描整个磁盘，仅修复更新 3 个块期间出现的问题，这是非常昂贵的。</p><p>这种情况类似于将你的钥匙放在卧室的地板上，然后从地下室开始，搜遍每个房间，执行“搜索整个房子找钥匙”的恢复算法。它有效，但很浪费。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在平时会遇到不少系统崩溃之后文件系统异常的情况，通常我们会通过 fsck 工具进行修复，今天来了解下 fsck 做了什么，是怎么做的。&lt;/p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第14周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/03/2020-%E7%AC%AC14%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/03/2020-第14周-LeetCode-记录/</id>
    <published>2020-04-03T21:49:38.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1394-Find-Lucky-Integer-in-an-Array"><a href="#1394-Find-Lucky-Integer-in-an-Array" class="headerlink" title="1394. Find Lucky Integer in an Array"></a>1394. Find Lucky Integer in an Array</h3><p>找幸运数字，可以维护一个数组，然后统计出现过的次数，也可以直接使用 collections.Counter 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLucky</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">501</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            cnt[a] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> cnt[i] == i:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a>1395. Count Number of Teams</h3><p>遍历数组，假设当前数值是中间位置，因为要考虑到倒序排序，所以要找到左边比当前数值小的和比当前数值大的，找到右边比当前数值小的和比当前数值大的，然后进行排列组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTeams</span><span class="params">(self, rating)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rating: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(rating)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line">            l1,r1= <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            l2,r2 =<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &lt; rating[i]:</span><br><span class="line">                    l1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &gt; rating[i]:</span><br><span class="line">                    r1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r2 += <span class="number">1</span></span><br><span class="line">            ans += l1*r1 + l2*r2</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1396-Design-Underground-System"><a href="#1396-Design-Underground-System" class="headerlink" title="1396. Design Underground System"></a>1396. Design Underground System</h3><p>使用 dict ，在 checkin 的时候以 id 为key，记录地铁站和时间，在 checkout 的时候以 (checkin_station, checkout_station) 为 key，记录所用时间，需要注意多次的情况，记录次数，在 getAverageTime 的时候直接根据 (checkin_station, checkout_station) 从 dict 中读取所用时间总和和次数，进行除法计算每次结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = defaultdict(int)</span><br><span class="line">        self.time = defaultdict(int)</span><br><span class="line">        self.traveling = dict()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIn</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.traveling[id] = (stationName, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOut</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        (prev_station, prev_t) = self.traveling[id]</span><br><span class="line">        <span class="keyword">del</span> self.traveling[id]</span><br><span class="line">        key = (prev_station, stationName)</span><br><span class="line">        self.count[key] += <span class="number">1</span></span><br><span class="line">        self.time[key] += (t-prev_t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAverageTime</span><span class="params">(self, startStation: str, endStation: str)</span> -&gt; float:</span></span><br><span class="line">        key = (startStation, endStation)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.time[key] / self.count[key]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = UndergroundSystem()</span></span><br><span class="line"><span class="comment"># obj.checkIn(id,stationName,t)</span></span><br><span class="line"><span class="comment"># obj.checkOut(id,stationName,t)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getAverageTime(startStation,endStation)</span></span><br></pre></td></tr></table></figure><h3 id="1262-Greatest-Sum-Divisible-by-Three"><a href="#1262-Greatest-Sum-Divisible-by-Three" class="headerlink" title="1262. Greatest Sum Divisible by Three"></a>1262. Greatest Sum Divisible by Three</h3><p>可以用单纯的数学方式做，先统计所有数字的和，然后遍历数字，找出余数为 1 和余数为 2 的数值，当总和余数为 1 时，则减去余数为1 的最小的数字，当总和余数为 2 时，则减去余数为 2 的最小的数字。需要注意比较余数为 1 和余数为2 要进行大小相比，如果 两个余数为2的数值之和小于余数为1 的数值，那么此时应该减去的数字为前者。</p><p>也可以采用动态规划做，维护一个 dp，分别存储余数为 0，1，2 的最大数字和，遍历数字，更新相加后的余数最大和，最后返回余数为0 的最大和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            tmp_dp = dp[:]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">                c_sum = tmp_dp[i] + n</span><br><span class="line">                dp[c_sum % <span class="number">3</span>] = max(dp[c_sum % <span class="number">3</span>], c_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSumDivThree</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    one := <span class="number">10000</span></span><br><span class="line">    two := <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        res += nums[i]</span><br><span class="line">        <span class="keyword">if</span> nums[i] % <span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">            two = min(two, one + nums[i])</span><br><span class="line">            one = min(one, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] % <span class="number">3</span> == <span class="number">2</span> &#123;</span><br><span class="line">            one = min(one, two + nums[i])</span><br><span class="line">            two = min(two, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> res % <span class="number">3</span> == <span class="number">0</span> &#123; <span class="keyword">return</span> res &#125;</span><br><span class="line">    <span class="keyword">if</span> res % <span class="number">3</span> == <span class="number">1</span> &#123; <span class="keyword">return</span> res - one &#125;</span><br><span class="line">    <span class="keyword">return</span> res - two</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1232-Check-If-It-Is-a-Straight-Line"><a href="#1232-Check-If-It-Is-a-Straight-Line" class="headerlink" title="1232. Check If It Is a Straight Line"></a>1232. Check If It Is a Straight Line</h3><p>一道数学题，先用前两个点来计算出斜率，然后遍历之后的点，验证斜率是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkStraightLine</span><span class="params">(self, coordinates: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        same_slop = <span class="keyword">True</span></span><br><span class="line">        last_slop = <span class="keyword">None</span></span><br><span class="line">        intial_point = coordinates[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> coordinates[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                slop = (point[<span class="number">1</span>] - intial_point[<span class="number">1</span>])/(point[<span class="number">0</span>] - intial_point[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">except</span> ZeroDivisionError: </span><br><span class="line">                slop = float(inf)</span><br><span class="line">            <span class="keyword">if</span> last_slop== <span class="keyword">None</span>:last_slop = slop</span><br><span class="line">            <span class="keyword">elif</span> slop == last_slop:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                same_slop = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> same_slop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1394-Find-Lucky-Integer-in-an-Array&quot;&gt;&lt;a href=&quot;#1394-Find-Lucky-Integer-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1394. Find Lucky Integ
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第13周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/27/2020-%E7%AC%AC13%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/27/2020-第13周-LeetCode-记录/</id>
    <published>2020-03-27T22:27:32.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1387-Sort-Integers-by-The-Power-Value"><a href="#1387-Sort-Integers-by-The-Power-Value" class="headerlink" title="1387. Sort Integers by The Power Value"></a>1387. Sort Integers by The Power Value</h3><p>给定一个区间，让你求出这个区间内所有数字的权重，然后按照权重进行排序，权重计算方式为：</p><ul><li>如果 x 是偶数，那么 x = x / 2</li><li>如果 x 是奇数，那么 x = 3 * x + 1</li></ul><p>在计算过程中，肯定会有重复计算，所以使用 dict 记录已经计算过的数值权重。当计算完成后，对结果进行排序，优先使用权重排序，如果权重相同，则按照数值本身大小进行排序，取第 k 个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKth</span><span class="params">(self, lo, hi, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lo: int</span></span><br><span class="line"><span class="string">        :type hi: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> self.memo:</span><br><span class="line">                <span class="keyword">return</span> self.memo[n]</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">                ans=helper((n*<span class="number">3</span>+<span class="number">1</span>)/<span class="number">2</span>)+<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans=helper(n/<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">            self.memo[n]=ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        tmp=sorted([[helper(n),n] <span class="keyword">for</span> n <span class="keyword">in</span> range(lo,hi+<span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">return</span> tmp[k<span class="number">-1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1389-Create-Target-Array-in-the-Given-Order"><a href="#1389-Create-Target-Array-in-the-Given-Order" class="headerlink" title="1389. Create Target Array in the Given Order"></a>1389. Create Target Array in the Given Order</h3><p>考察 insert 动作，可以直接用 insert 函数来做；也可以通过对 list 进行切片实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTargetArray</span><span class="params">(self, nums, index)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type index: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> n, i <span class="keyword">in</span> zip(nums, index):</span><br><span class="line">            target.insert(i, n)</span><br><span class="line">            <span class="comment"># target = target[:i] + [n] + target[i:]</span></span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure><h3 id="1390-Four-Divisors"><a href="#1390-Four-Divisors" class="headerlink" title="1390. Four Divisors"></a>1390. Four Divisors</h3><p>数学题，如果一个数的因数恰好是 4个因数，那么返回这4个因数的和，直接暴力求解会超时。</p><p>如果整数 x 有因数 y，那么也必有因数 x/y，并且 y 和 x/y 中至少有一个不大于 sqrt(x)。这样我们只需要在 [1, sqrt(x)] 的区间内枚举可能为整数 x 的因数 y，并通过 x/y 得到整数 x 的其它因数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumFourDivisors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">                s = set()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1</span> + int(math.sqrt(n))):</span><br><span class="line">                    <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                        s.add(i)</span><br><span class="line">                        s.add(n / i)</span><br><span class="line">                    <span class="keyword">if</span> len(s) &gt; <span class="number">4</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                cache[n] = sum(s) <span class="keyword">if</span> len(s) == <span class="number">4</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> cache[n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(map(fn, nums))</span><br></pre></td></tr></table></figure><h3 id="1386-Cinema-Seat-Allocation"><a href="#1386-Cinema-Seat-Allocation" class="headerlink" title="1386. Cinema Seat Allocation"></a>1386. Cinema Seat Allocation</h3><p>使用位运算，先按照每行拆分，统计出已经被预约的位置，置为1，然后分别与可能安排的3种方式进行与运算，如果为0 ，则表示可以安排。最终将结果求和。需要注意如果一行内所有作为都未安排的情况，此时应该按照每行 2 种方式相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfFamilies</span><span class="params">(self, n, reservedSeats)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type reservedSeats: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        seats = collections.defaultdict(int) </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row, col <span class="keyword">in</span> reservedSeats:</span><br><span class="line">            seats[row] = seats[row] | (<span class="number">1</span> &lt;&lt; (col<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> bin(seats[<span class="number">3</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> reserved <span class="keyword">in</span> seats.values():</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0111100000'</span>, <span class="number">2</span>)) == <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0000011110'</span>, <span class="number">2</span>)) == <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0001111000'</span>, <span class="number">2</span>)) == <span class="number">0</span> <span class="keyword">and</span> curr == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            res += curr    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">2</span> * (n - len(seats))</span><br></pre></td></tr></table></figure><h3 id="1329-Sort-the-Matrix-Diagonally"><a href="#1329-Sort-the-Matrix-Diagonally" class="headerlink" title="1329. Sort the Matrix Diagonally"></a>1329. Sort the Matrix Diagonally</h3><p>考察排序和数组，需要先找到对角线的数字集，可以使用（每行的索引 - 每列的索引）来表示，因为对角线上的数字该值是相同的，找到后对起进行排序，然后再次遍历填入排序后的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diagonalSort</span><span class="params">(self, mat)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type mat: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        diag = defaultdict(list)</span><br><span class="line">        N,M = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                diag[i-j].append(mat[i][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> diag.keys():</span><br><span class="line">            diag[k].sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                mat[i][j] = diag[i-j].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1387-Sort-Integers-by-The-Power-Value&quot;&gt;&lt;a href=&quot;#1387-Sort-Integers-by-The-Power-Value&quot; class=&quot;headerlink&quot; title=&quot;1387. Sort Integer
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 《Pingmesh: A Large-Scale System for Data Center Network Latency Measurement and Analysis》</title>
    <link href="https://zdyxry.github.io/2020/03/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E3%80%8APingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis%E3%80%8B/"/>
    <id>https://zdyxry.github.io/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/</id>
    <published>2020-03-26T20:24:09.000Z</published>
    <updated>2020-06-13T14:17:54.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们内部产品中，一直有关于网络性能数据监控需求，我们之前是直接使用 <code>ping</code> 命令收集结果，每台服务器去 ping (N-1) 台，也就是 N^2 的复杂度，稳定性和性能都存在一些问题，最近打算对这部分进行重写，在重新调研期间看到了 Pingmesh 这篇论文，Pingmesh 是微软用来监控数据中心网络情况而开发的软件，通过阅读这篇论文来学习下他们是怎么做的。</p><p>数据中心自身是极为复杂的，其中网络涉及到的设备很多就显得更为复杂，一个大型数据中心都有成百上千的节点、网卡、交换机、路由器以及无数的网线、光纤。在这些硬件设备基础上构建了很多软件，比如搜索引擎、分布式文件系统、分布式存储等等。在这些系统运行过程中，面临一些问题：如何判断一个故障是网络故障？如何定义和追踪网络的 SLA？出了故障如何去排查？</p><p>基于这几点问题，微软设计开发了 Pingmesh，用来记录和分析数据中心的网络情况。在微软内部 Pingmesh 每天会记录 24TB 数据，进行 2k 亿次 ping 探测，通过这些数据，微软可以很好的进行网络故障判定和及时的修复。</p><h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>常见的数据中心网络拓扑：</p><img src="/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/pingmesh-1.png" title="pingmesh-1"><p>网络延时计算方式：server A 发送消息到 server B 接受消息的时间。最终使用 RTT 时间，RTT 一个好处是绝对时间，与时钟不相关。</p><p>在大多数情况下，大家不会去关心延时具体是什么导致的，都是直接归结于网络原因，让网络团队去排查，实际上是浪费了很多人力成本。延时变高有很多原因：CPU 繁忙、服务自身 Bug、网络原因等等。往往丢包会伴随着延时升高，因为丢包意味着会发生重传，所以丢包也是需要观察的重点。</p><p>因为 Pingmesh 运行在微软内部，所以依托于微软自己的基础架构，有自动化管理系统 Autopilot，有大数据系统 Cosmos，也有类似于 SQL 的脚本语言 SCOPE。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>根据上面的需求，Pingmesh 先评估了现有的开源工具，不符合的原因有很多，大多数工具都是以命令行形式呈现，一般是出现故障了去使用工具排查，而且工具提供的数据也不全面，有可能正在运行工具问题已经解决了。当然这并不是说已有的工具没有用，只能说不适合 Pingmesh。</p><p>Pingmesh 是松耦合设计，每个组件都是可以独立运行的，分为 3 个组件。在设计的时候需要考虑几点：</p><ul><li>因为要运行在所有的 server 上，所以不能占用太多的计算资源或网络资源</li><li>需要是灵活配置的且高可用的的</li><li>记录的数据需要进行合理的汇总分析</li></ul><p>Pingmesh 架构设计：</p><img src="/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/pingmesh-2.png" title="pingmesh-2"><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller 主要负责生成 pinglist 文件，这个文件是 XML 格式的，pinglist 的生成是很重要的，需要根据实际的数据中心网络拓扑进行及时更新。</p><p>在生成 pinglist 时， Controller 为了避免开销，分为3 个级别：</p><ol><li>在机架内部，让所有的 server 互相 ping，每个 server ping （N-1） 个 server</li><li>在机架之间，则每个机架选几个 server ping 其他机架的 server，保证 server 所属的 ToR 不同</li><li>在数据中心之间，则选择不同的数据中心的几个不同机架的 server 来ping </li></ol><p>Controller 在生成 pinglist 文件后，通过 HTTP 提供出去，Agent 会定期获取 pinglist 来更新 agent 自己的配置，也就是我们说的“拉”模式。Controller 需要保证高可用，因此需要在 VIP 后面配置多个实例，每个实例的算法一致，pinglist 文件内容也一致，保证可用性。</p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>微软数据中心的每个 server 都会运行 Agent，用来真正做 ping 动作的服务。为了保证获取结果与真实的服务一致，Pingmesh 没有采用 ICMP ping，而是采用的 TCP/HTTP ping。所以每个 Agent 即是 Server 也是 Client。每个 ping 动作都开启一个新的连接，主要为了减少 Pingmesh 造成的 TCP 并发。</p><p>Agent 要保证自己是可靠的，不会造成一些严重的后果，其次要保证自己使用的资源要足够的少，毕竟要运行在每个 server 上。两个server ping 的周期最小是 10s，Packet 大小最大 64kb。针对灵活配置的需求，Agent 会定期去 Controller 上拉取 pinglist，如果 3 次拉取不到，那么就会删除本地已有 pinglist，停止 ping 动作。</p><p>在进行 ping 动作后，会将结果保存在内存中，当保存结果超过一定阈值或者到达了超时时间，就将结果上传到 Cosmos 中用于分析，如果上传失败，会有重试，超过重试次数则将数据丢弃，保证 Agent 的内存使用。</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>拿到了数据就要进行分析，Pingmesh 会以 10min，1hour，1天的粒度进行统计汇总，数据的实时性最快也就是 10min ，Pingmesh 还借助内部的基础设施能够拿到 5min 级别的数据结果，算是一种“实时”监控吧。</p><h2 id="网络状况"><a href="#网络状况" class="headerlink" title="网络状况"></a>网络状况</h2><p>根据论文中提到的，不同负载的数据中心的数据是有很大差异的，在 P99.9 时延时大概在 10-20ms，在 P99.99 延时大概在100+ms 。关于丢包率的计算，因为没有用 ICMP ping 的方式，所以这里是一种新的计算方式，（一次失败 + 二次失败）次数/（成功次数）= 丢包率。这里是每次 ping 的 timeout 是 3s，windows 重传机制等待时间是 3s，下一次 ping 的 timeout 时间是 3s，加一起也就是 9s。所以这里跟 Agent 最小探测周期 10s 是有关联的。二次失败的时间就是 （2 * RTT）+ RTO 时间。</p><p>Pingmesh 的判断依据有两个，如果超过就报警：</p><ul><li>延时超过 5ms</li><li>丢包率超过 10^(-3) </li></ul><p>在论文中还提到了其他的网络故障场景，交换机的静默丢包。有可能是 A 可以连通 B，但是不能连通 C。还有可能是 A 的 i 端口可以连通 B 的 j 端口，但是 A 的 m 端口不能连通 B 的 j 端口，这些都属于交换机的静默丢包的范畴。Pingmesh 通过统计这种数据，然后给交换机进行打分，当超过一定阈值时就会通过 Autopilot 来自动重启交换机，恢复交换机的能力。</p><h2 id="经验学习"><a href="#经验学习" class="headerlink" title="经验学习"></a>经验学习</h2><ol><li>找到可信数据，只有数据来源可信，那么分析才是有效的</li><li>让服务作为 daemon 运行，保证持续的收集数据</li><li>松耦合设计，每个组件都可以独立工作</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我们自己的系统是有 Prometheus 这样的监控系统的，但是当遇到交换机级别的间歇性故障时，Prometheus 也是故障的状态，所以也就不会收集 exporter 汇报的数据，也就更没办法产生告警了。所以如果遇到那种长时间持续的故障反而是好事，至少我们有一个足够的状态去排查哪里出了问题，否则真的是间歇性故障仅仅依靠 ping, traceroute, iperf, netstat 之类的工具去排查是没什么效果的，只有我们知道过去一段时间的网络情况，才能去排查。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p139.pdf" target="_blank" rel="noopener">https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p139.pdf</a></li><li><a href="http://ninjadq.com/2017/04/01/linux-rto" target="_blank" rel="noopener">http://ninjadq.com/2017/04/01/linux-rto</a></li><li><a href="https://yi-ran.github.io/2019/03/27/Pingmesh-SIGCOMM-2015/" target="_blank" rel="noopener">https://yi-ran.github.io/2019/03/27/Pingmesh-SIGCOMM-2015/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在我们内部产品中，一直有关于网络性能数据监控需求，我们之前是直接使用 &lt;code&gt;ping&lt;/code&gt; 命令收集结果，每台服务器去 pin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 第12周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/20/2020-%E7%AC%AC12%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/20/2020-第12周-LeetCode-记录/</id>
    <published>2020-03-20T20:08:24.000Z</published>
    <updated>2020-06-13T14:17:54.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1380-Lucky-Numbers-in-a-Matrix"><a href="#1380-Lucky-Numbers-in-a-Matrix" class="headerlink" title="1380. Lucky Numbers in a Matrix"></a>1380. Lucky Numbers in a Matrix</h3><p>给一个二维数组，分别求每行最小值，每列最大值，然后找到幸运数字。（遇到二维数组善用 zip 来解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span> <span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mins = &#123;min(rows) <span class="keyword">for</span> rows <span class="keyword">in</span> matrix&#125;</span><br><span class="line">        maxes = &#123;max(columns) <span class="keyword">for</span> columns <span class="keyword">in</span> zip(*matrix)&#125;</span><br><span class="line">        <span class="keyword">return</span> list(mins &amp; maxes)</span><br></pre></td></tr></table></figure><h3 id="1381-Design-a-Stack-With-Increment-Operation"><a href="#1381-Design-a-Stack-With-Increment-Operation" class="headerlink" title="1381. Design a Stack With Increment Operation"></a>1381. Design a Stack With Increment Operation</h3><p>相比与 stack 多了一个 inc 操作，一般想法是每次遇到 inc 操作，那么我们遍历一次，将对应值进行加操作就可以了，但是这个操作是 O(n) 的，我们可以使用一个辅助 list ，保存 inc 的数值，当 pop 的时候，进行相加处理。</p><p>以示例展示处理过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class="line">[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack, inc</span><br><span class="line">[1], [0]</span><br><span class="line">[1,2], [0]</span><br><span class="line">[1], [0]</span><br><span class="line">[1,2], [0,0]</span><br><span class="line">[1,2,3], [0,0,0]</span><br><span class="line">[1,2,3], [0,0, 100]</span><br><span class="line">[1,2,3], [0, 100, 100]</span><br><span class="line">[1,2], [0,200]</span><br><span class="line">[1], [200]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxSize)</span>:</span></span><br><span class="line">        self.n = maxSize</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.inc = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.inc) &lt; self.n:</span><br><span class="line">            self.stack.append(x)</span><br><span class="line">            self.inc.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.inc: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(self.inc) &gt; <span class="number">1</span>:</span><br><span class="line">            self.inc[<span class="number">-2</span>] += self.inc[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop() + self.inc.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, k, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.inc:</span><br><span class="line">            self.inc[min(k, len(self.inc)) - <span class="number">1</span>] += val</span><br></pre></td></tr></table></figure><h3 id="1382-Balance-a-Binary-Search-Tree"><a href="#1382-Balance-a-Binary-Search-Tree" class="headerlink" title="1382. Balance a Binary Search Tree"></a>1382. Balance a Binary Search Tree</h3><p>给一个二叉搜索树，使其变为平衡二叉搜索树，只需要一次性操作，不需要时刻考虑每次插入后的变化，根据二叉搜索树特性将其进行中序遍历，得到的结果是升序排序的，然后通过升序排序的结果构建平衡二叉搜索树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balanceBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="string">"""inorder depth-first traverse bst"""</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">            dfs(node.left)</span><br><span class="line">            value.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        </span><br><span class="line">        value = [] <span class="comment">#collect values</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(x)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            k = len(x)//<span class="number">2</span></span><br><span class="line">            ans = TreeNode(x[k])</span><br><span class="line">            ans.left = tree(x[:k])</span><br><span class="line">            ans.right = tree(x[k+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tree(value)</span><br></pre></td></tr></table></figure><h3 id="901-Online-Stock-Span"><a href="#901-Online-Stock-Span" class="headerlink" title="901. Online Stock Span"></a>901. Online Stock Span</h3><p>维护一个单调栈，遍历 prices：如果 price 比前一天要大，那么将前一天移除，并将前一天的权重与当天相加；如果 price 比前一天要小，那么直接追加当天 price，并将其权重置为 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, price)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type price: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        weight = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>] &lt;= price:</span><br><span class="line">            weight += self.stack.pop()[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">print</span> price, self.stack</span><br><span class="line">        self.stack.append((price, weight))</span><br><span class="line">        <span class="keyword">print</span> self.stack</span><br><span class="line">        <span class="keyword">return</span> weight</span><br></pre></td></tr></table></figure><h3 id="897-Increasing-Order-Search-Tree"><a href="#897-Increasing-Order-Search-Tree" class="headerlink" title="897. Increasing Order Search Tree"></a>897. Increasing Order Search Tree</h3><p>考察中序遍历，使用 dfs 直接求解，然后重新构造二叉搜索树。<br>也可以直接改动原有树结构，同样是中序遍历，当我们遍历到一个节点时，把它的左孩子设为空，并将其本身作为上一个遍历到的节点的右孩子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                inorder(node.left)</span><br><span class="line">                node.left = <span class="keyword">None</span></span><br><span class="line">                self.cur.right = node</span><br><span class="line">                self.cur = node</span><br><span class="line">                inorder(node.right)</span><br><span class="line"></span><br><span class="line">        ans = self.cur = TreeNode(<span class="keyword">None</span>)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> ans.right</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            dfs(node.left)</span><br><span class="line">            values.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        values = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        tmp = TreeNode(<span class="number">0</span>)</span><br><span class="line">        root = tmp</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> values:</span><br><span class="line">            tmp.right = TreeNode(node)</span><br><span class="line">            tmp = tmp.right</span><br><span class="line">        <span class="keyword">return</span> root.right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1380-Lucky-Numbers-in-a-Matrix&quot;&gt;&lt;a href=&quot;#1380-Lucky-Numbers-in-a-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1380. Lucky Numbers in a Matrix&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
