<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2020-05-22T14:29:41.540Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 第21周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/22/2020-%E7%AC%AC21%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/22/2020-第21周-LeetCode-记录/</id>
    <published>2020-05-22T22:28:29.000Z</published>
    <updated>2020-05-22T14:29:41.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1446-Consecutive-Characters"><a href="#1446-Consecutive-Characters" class="headerlink" title="1446. Consecutive Characters"></a>1446. Consecutive Characters</h3><p>判断最长连续相同字符的长度，记录下当前字母，然后比较与 flag 是否相同，如果相同则 +1，不相同则重置为 1。</p><p>也可以通过 itertools.groupby 来实现（新学习的。。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPower</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp = s[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i == tmp:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = i</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            max_cnt = max(max_cnt, cnt)</span><br><span class="line">        <span class="keyword">return</span> max_cnt</span><br></pre></td></tr></table></figure><h3 id="1447-Simplified-Fractions"><a href="#1447-Simplified-Fractions" class="headerlink" title="1447. Simplified Fractions"></a>1447. Simplified Fractions</h3><p>遍历分子与分母，求最大公约数，如果最大公约数为1，则将结果保存下来。分母从 2 开始计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifiedFractions</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> gcd(i, j) == <span class="number">1</span> &#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, fmt.Sprintf(<span class="string">"%d/%d"</span>, j, i))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x%y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1448-Count-Good-Nodes-in-Binary-Tree"><a href="#1448-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="1448. Count Good Nodes in Binary Tree"></a>1448. Count Good Nodes in Binary Tree</h3><p>遍历所有节点，记录 root 节点到当前节点经过的最大值，当前节点数值与最大值进行比较，如果符合条件，则结果 +1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, curmax)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> node.val &gt;= curmax:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            curmax = max(curmax, node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                dfs(node.left, curmax)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                dfs(node.right, curmax)</span><br><span class="line">            </span><br><span class="line">        dfs(root, -float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h3><p>遍历开始时间和结束时间，判断查询时间是否在两者之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busyStudent</span><span class="params">(self, startTime: List[int], endTime: List[int], queryTime: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(a&lt;=queryTime&lt;=b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(startTime,endTime))</span><br></pre></td></tr></table></figure><h3 id="896-Monotonic-Array"><a href="#896-Monotonic-Array" class="headerlink" title="896. Monotonic Array"></a>896. Monotonic Array</h3><p>遍历数组，记录前一个数字与当前数字的差值，判断是否单调递增或递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt_inc = <span class="number">0</span>; cnt_dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: prev = v; <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>   v &gt; prev: cnt_inc += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; prev: cnt_dec += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt_inc <span class="keyword">and</span> cnt_dec: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            prev = v</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1446-Consecutive-Characters&quot;&gt;&lt;a href=&quot;#1446-Consecutive-Characters&quot; class=&quot;headerlink&quot; title=&quot;1446. Consecutive Characters&quot;&gt;&lt;/a&gt;1446
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第20周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/16/2020-%E7%AC%AC20%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/16/2020-第20周-LeetCode-记录/</id>
    <published>2020-05-16T10:17:49.000Z</published>
    <updated>2020-05-22T14:29:41.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1441-Build-an-Array-With-Stack-Operations"><a href="#1441-Build-an-Array-With-Stack-Operations" class="headerlink" title="1441. Build an Array With Stack Operations"></a>1441. Build an Array With Stack Operations</h3><p>遍历数组，比较当前值与目标值是否相同，如果相同，则在结果追加 <code>Push</code> ，如果不同，则追加 <code>Push</code>, <code>Pop</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildArray</span><span class="params">(self, target: List[int], n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        keep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(<span class="string">"Push"</span>)</span><br><span class="line">            keep += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> target:</span><br><span class="line">                res.append(<span class="string">"Pop"</span>)</span><br><span class="line">                keep -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> keep == len(target):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a>1442. Count Triplets That Can Form Two Arrays of Equal XOR</h3><p>求子数组中是否存在左侧部分异或值与右侧部分异或值相等的情况，a==b -&gt; a ^ b = 0，也就是是否存在子数组所有元素异或值为0 的情况，如果存在，那么子数组所有的元素都可以符合条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                temp = temp^arr[j]</span><br><span class="line">                <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                    count += j-i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers"><a href="#1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers" class="headerlink" title="1317. Convert Integer to the Sum of Two No-Zero Integers"></a>1317. Convert Integer to the Sum of Two No-Zero Integers</h3><p>从 1 开始遍历判断两个拆分数字是否包含 <code>0</code> ，判断对 10 取余是否为0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNoZeroIntegers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.check(i) <span class="keyword">and</span> self.check(n - i):</span><br><span class="line">                <span class="keyword">return</span> [i, n - i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree"></a>1443. Minimum Time to Collect All Apples in a Tree</h3><p>通过字典来保证每条路径只走一次，判断子节点是否有苹果，如果没有，则将子节点从字典中删除，最终字典中保存的是必须要经过的节点，要走 2 次，所以需要 * 2 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTime</span><span class="params">(self, n: int, edges: List[List[int]],</span></span></span><br><span class="line"><span class="function"><span class="params">                hasApple: List[bool])</span> -&gt; int:</span></span><br><span class="line">        maps = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            maps[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            selfOrChildHasApple = hasApple[i]</span><br><span class="line">            <span class="keyword">for</span> nex <span class="keyword">in</span> maps[i]:</span><br><span class="line">                selfOrChildHasApple |= dfs(nex)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> selfOrChildHasApple:</span><br><span class="line">                <span class="keyword">del</span> maps[i]</span><br><span class="line">            <span class="keyword">return</span> selfOrChildHasApple</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, <span class="number">2</span> * (len(maps) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="807-Max-Increase-to-Keep-City-Skyline"><a href="#807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="807. Max Increase to Keep City Skyline"></a>807. Max Increase to Keep City Skyline</h3><p>分别找出每行、每列的最大值，然后遍历判断当前值距离两个最大值中的最小值需要增加多少，累加计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        max_cols = [max(col) <span class="keyword">for</span> col <span class="keyword">in</span> zip(*grid)]</span><br><span class="line">        max_rows = [max(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid]</span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[i])):</span><br><span class="line">                inc += (min(max_cols[j], max_rows[i]) - grid[i][j])</span><br><span class="line">        <span class="keyword">return</span> inc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1441-Build-an-Array-With-Stack-Operations&quot;&gt;&lt;a href=&quot;#1441-Build-an-Array-With-Stack-Operations&quot; class=&quot;headerlink&quot; title=&quot;1441. Buil
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>PyInstaller 与 RPM 配合使用踩坑</title>
    <link href="https://zdyxry.github.io/2020/05/13/PyInstaller-%E4%B8%8E-RPM-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"/>
    <id>https://zdyxry.github.io/2020/05/13/PyInstaller-与-RPM-配合使用踩坑/</id>
    <published>2020-05-13T20:35:50.000Z</published>
    <updated>2020-05-22T14:29:41.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配置会有坑，然后搜索下来几乎没看到有人提到，可能用 pyinstaller 和用 rpm 的完全是两类人吧 - -。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先列一下官方默认例子的输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/demo</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls</span></span><br><span class="line">demo.py</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> pyinstaller demo.py</span></span><br><span class="line">63 INFO: PyInstaller: 3.6</span><br><span class="line">63 INFO: Python: 3.6.8</span><br><span class="line">65 INFO: Platform: Linux-3.10.0-862.el7.x86_64-x86_64-with-centos-7.5.1804-Core</span><br><span class="line">65 INFO: wrote /tmp/demo/demo.spec</span><br><span class="line">67 INFO: UPX is not available.</span><br><span class="line">70 INFO: Extending PYTHONPATH with paths</span><br><span class="line">['/tmp/demo', '/tmp/demo']</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>来看一下生成文件的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── demo</span><br><span class="line">├── demo.py</span><br><span class="line">├── demo.spec</span><br><span class="line">├── dist</span><br><span class="line">│   └── demo</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── binascii.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _bisect.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _blake2.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">|       ├── ...</span><br><span class="line">│       ├── _codecs_kr.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _codecs_tw.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _datetime.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── demo</span><br><span class="line">│       ├── libbz2.so.1</span><br><span class="line">│       ├── libcom_err.so.2</span><br><span class="line">│       ├── libcrypto.so.10</span><br><span class="line">│       ├── libexpat.so.1</span><br><span class="line">│       ├── libgssapi_krb5.so.2</span><br><span class="line">│       ├── libk5crypto.so.3</span><br><span class="line">│       ├── libkeyutils.so.1</span><br><span class="line">│       ├── libtinfo.so.5</span><br><span class="line">│       ├── libkrb5support.so.0</span><br><span class="line">│       ├── liblzma.so.5</span><br><span class="line">│       ├── libpcre.so.1</span><br><span class="line">│       ├── libpython3.6m.so.1.0</span><br><span class="line">│       ├── libreadline.so.6</span><br><span class="line">│       ├── libz.so.1</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── demo.cpython-36.pyc</span><br></pre></td></tr></table></figure><p>看上去也没啥问题，编写一个 rpm spec，然后使用 rpmbuild 直接就可以生成一个 RPM出来，在 RedHat 系列的 OS上可以直接安装使用，具体的步骤可以参考之前的博客：<a href="https://zdyxry.github.io/2018/07/28/RPM-%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/">《RPM 常用构建方式》</a>，目前来看一切都正常，但是坑来了。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在验证完基础的功能后，我想要将这个 RPM 放到 ISO 中发布，在验证过程中，发现这个 RPM 会破坏系统其他的依赖检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:00:20 tmp]$cat packaging.log |grep so |grep 'No such file'</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error ...</span><br><span class="line">09:19:50,495 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /usr/bin/trust: error while loading shared libraries: libfreebl3.so: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,500 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,501 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>简单的过滤了一下，有这些包直接受到了影响，还有很多未知的，简单的说就是系统的一些核心依赖库缺失，没有安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:02:48 tmp]$cat packaging.log |grep 'scriptlet failed'</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(readline-6.2-10.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(gawk-4.0.2-4.el7_3.1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(info-5.1-4.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(qemu-kvm-aurora-0.3.3-1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,495 INFO packaging: warning: %post(glib2-2.50.3-3.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,499 INFO packaging: warning: %post(ca-certificates-2017.2.14-71.el7.noarch) scriptlet failed, exit status 127</span><br></pre></td></tr></table></figure><p>最初在排查是否是 anaconda 在检查 rpm 相互之间的依赖时出了 bug，但是最近版本没什么变化，理论上不会，又去瞧了瞧 anaconda 的代码，发现跟 rpm 相关的太多，一时也没看出什么头绪。</p><p>再来看一下相关的库， <code>libz.so.1</code> , <code>libtinfo.so.5</code> 有没有点眼熟，都是在 pyinstaller 生成的文件中的，但是有一点很奇怪，命令路径都不是系统路径，为什么在检查依赖的时候还是会检查到新加入的 rpm 上，而不是真正提供这些库的 RPM？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>今天的主角登场：Automatic Dependencies。</p><p>Automatic Dependencies 是 RPM 的一个特性，官方文档中是这么描述的：</p><blockquote><p>When a package is built by RPM, if any file in the package’s %files list is a shared library, the library’s soname is automatically added to the list of capabilities the package provides. The soname is the name used to determine compatibility between different versions of a library.</p></blockquote><blockquote><p>Note that this is not a filename. In fact, no aspect of RPM’s dependency processing is based on filenames. Many people new to RPM often make the assumption that a failed dependency represents a missing file. This is not the case.</p></blockquote><blockquote><p>Remember that RPM’s dependency processing is based on knowing what capabilities are provided by a package and what capabilities a package requires. We’ve seen how RPM automatically determines what shared library resources a package provides. But does it automatically determine what shared libraries a package requires?</p></blockquote><blockquote><p>Yes! RPM does this by running ldd on every executable program in a package’s %files list. Since ldd provides a list of the shared libraries each program requires, both halves of the equation are complete — that is, the packages that make shared libraries available, and the packages that require those shared libraries, are tracked by RPM. RPM can then take that information into account when packages are installed, upgraded, or erased.</p></blockquote><p>嗯，找到问题了，解决的方式也很简单，直接关掉就好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoReqProv: no</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说 pyinstaller 用的人不少，rpm 用的人也不少，这俩默认配置配合使用是一定会出问题的，但是没有找到相关的问题，可能真的不是一类人吧。</p><p>用同事的话作为结束语： <code>automatic 开头的东西，一个字都不要信</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第19周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/08/2020-%E7%AC%AC19%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/08/2020-第19周-LeetCode-记录/</id>
    <published>2020-05-08T07:48:12.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1436-Destination-City"><a href="#1436-Destination-City" class="headerlink" title="1436. Destination City"></a>1436. Destination City</h3><p>使用 set() 来计算每个城市是否处于起始和终止，集合差为终点站。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destCity</span><span class="params">(self, paths: List[List[str]])</span> -&gt; str:</span></span><br><span class="line">        a = set()</span><br><span class="line">        b = set()</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">            x, y = path</span><br><span class="line">            a.add(x)</span><br><span class="line">            b.add(y)</span><br><span class="line"></span><br><span class="line">        b = b - a</span><br><span class="line">        <span class="keyword">assert</span> len(b) == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> b.pop()</span><br></pre></td></tr></table></figure><h3 id="1432-Max-Difference-You-Can-Get-From-Changing-an-Integer"><a href="#1432-Max-Difference-You-Can-Get-From-Changing-an-Integer" class="headerlink" title="1432. Max Difference You Can Get From Changing an Integer"></a>1432. Max Difference You Can Get From Changing an Integer</h3><p>分别求出给定数字可以转换的最大值和最小值，然后求差，最大值是将数字从前向后遍历，当数值不为9时，将其替换为 9；最小值要求首位不能为 0，则需要特殊判断，如果首位不为1，则将其替换为1，如果首位为1，则遍历后续数字，如果数字不为0，则替换为0，需要注意此时首位为1，如果数字为1然后替换为0会出现首位为0 情况，因此需要判断数字不为0且不为1，然后替换为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDiff</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        a = b = str(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> a:</span><br><span class="line">            <span class="keyword">if</span> digit != <span class="string">"9"</span>:</span><br><span class="line">                a = a.replace(digit, <span class="string">"9"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> b[<span class="number">0</span>] != <span class="string">"1"</span>:</span><br><span class="line">            b = b.replace(b[<span class="number">0</span>], <span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> digit <span class="keyword">in</span> b[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> digit <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"01"</span>:</span><br><span class="line">                    b = b.replace(digit, <span class="string">"0"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> int(a) - int(b)</span><br></pre></td></tr></table></figure><h3 id="1433-Check-If-a-String-Can-Break-Another-String"><a href="#1433-Check-If-a-String-Can-Break-Another-String" class="headerlink" title="1433. Check If a String Can Break Another String"></a>1433. Check If a String Can Break Another String</h3><p>检查两个字符串的字符序是否存在交叉情况，先对字符串进行排序，然后使用两个 flag 标记当前字符的大小，如果有大有小，那么直接返回 False，否则返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfCanBreak</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        s1= sorted(s1)</span><br><span class="line">        s2= sorted(s2)</span><br><span class="line">        res1, res2 = <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> zip(s1, s2):</span><br><span class="line">            com = ord(pair[<span class="number">0</span>]) - ord(pair[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> com &gt; <span class="number">0</span>:</span><br><span class="line">                res1 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> com &lt; <span class="number">0</span>:</span><br><span class="line">                res2 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> res1 <span class="keyword">and</span> res2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away"><a href="#1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away" class="headerlink" title="1437. Check If All 1’s Are at Least Length K Places Away"></a>1437. Check If All 1’s Are at Least Length K Places Away</h3><p>检查每个数字 1 之间的间隔是否大于 k，如果不大于则返回 False，遍历数字，如果数字不为 1，则将间隔 +1，直到下次遇1时判断并重置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kLengthApart</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        zero_num = <span class="number">1e5</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> zero_num &lt; k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                zero_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                zero_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</h3><p>滑动窗口，遍历数字，每次更新最大值与最小值，如果符合条件，则窗口增大，否则从左侧缩小窗口，缩小窗口后需要注意更新最大值与最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int], limit: int)</span> -&gt; int:</span></span><br><span class="line">        minimal, maximal = float(<span class="string">"inf"</span>), float(<span class="string">"-inf"</span>)</span><br><span class="line">        size, current_size_start_number = <span class="number">0</span>, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            maximal = max(maximal, nums[i])</span><br><span class="line">            minimal = min(minimal, nums[i])</span><br><span class="line">            <span class="keyword">if</span> abs(maximal - minimal) &lt;= limit:</span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_size_start_number = nums[i-size]</span><br><span class="line">                <span class="keyword">if</span> current_size_start_number == minimal:</span><br><span class="line">                    minimal = min(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> current_size_start_number == maximal:</span><br><span class="line">                    maximal = max(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1436-Destination-City&quot;&gt;&lt;a href=&quot;#1436-Destination-City&quot; class=&quot;headerlink&quot; title=&quot;1436. Destination City&quot;&gt;&lt;/a&gt;1436. Destination City
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第18周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/01/2020-%E7%AC%AC18%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/01/2020-第18周-LeetCode-记录/</id>
    <published>2020-05-01T06:43:57.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1422-Maximum-Score-After-Splitting-a-String"><a href="#1422-Maximum-Score-After-Splitting-a-String" class="headerlink" title="1422. Maximum Score After Splitting a String"></a>1422. Maximum Score After Splitting a String</h3><p>求出左侧 0 数量和右侧 1 数量之和最多的情况，遍历一次，每次更新最大值，注意要保证字符串始终被切分为 2 个子字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        right = s.count(<span class="string">'1'</span>)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        score = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[idx] == <span class="string">'1'</span>:</span><br><span class="line">                score = max(score, (left + right - <span class="number">1</span>))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                score = max(score, (left + <span class="number">1</span> + right))</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure><h3 id="1423-Maximum-Points-You-Can-Obtain-from-Cards"><a href="#1423-Maximum-Points-You-Can-Obtain-from-Cards" class="headerlink" title="1423. Maximum Points You Can Obtain from Cards"></a>1423. Maximum Points You Can Obtain from Cards</h3><p>先假设所有的数字都是从左侧获取的，然后依次遍历 k 个数值，每次遍历将左侧数字剔除，将右侧数字加入，比较最大值。</p><p>也可以转换问题为中间连续 len-k 长度数字和最小，然后所有数字之和减去最小值为所求结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxScore</span><span class="params">(cardPoints []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum + cardPoints[i]</span><br><span class="line">&#125;</span><br><span class="line">listLen := <span class="built_in">len</span>(cardPoints)</span><br><span class="line"><span class="keyword">if</span> k == listLen &#123;</span><br><span class="line"><span class="keyword">return</span> leftSum</span><br><span class="line">&#125;</span><br><span class="line">max := leftSum</span><br><span class="line"><span class="keyword">var</span> rightSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum - cardPoints[k-i<span class="number">-1</span>]</span><br><span class="line">rightSum = rightSum + cardPoints[listLen-i<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> leftSum+rightSum &gt; max &#123;</span><br><span class="line">max = leftSum + rightSum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a>1424. Diagonal Traverse II</h3><p>按照对角线方式打印出所有数字，考虑对角线部分数字为空的情况。在一个对角线上的数字，他们的横纵坐标之和都是相同的，使用一个二维数组存储，然后从上到下顺序打印出所有对角线的数值，需要注意每条对角线的数值输出应该是从下到上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="params">(ans []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    order := [<span class="number">1e5</span>][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(mat) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> mat[i] &#123;</span><br><span class="line">order[i+j] = <span class="built_in">append</span>(order[i+j], v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> order &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a>498. Diagonal Traverse</h3><p>可以用 #1424 相同的方式处理，获取所有对角线的数值，然后遍历，注意输出的顺序，也可以直接模拟，需要处理好边界。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, n*m)</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(res); i++ &#123;</span><br><span class="line">res[i] = matrix[x][y]</span><br><span class="line"><span class="keyword">if</span> (x+y)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> y == m<span class="number">-1</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y++</span><br><span class="line">x--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == n<span class="number">-1</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x++</span><br><span class="line">y--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h3><p>一个数字与全 1 进行异或，得到的数字为二进制取反。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findComplement</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">temp := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; temp &lt;= num; temp *= <span class="number">2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (temp - <span class="number">1</span>) ^ num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">5</span></span><br><span class="line">res := findComplement(num)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1422-Maximum-Score-After-Splitting-a-String&quot;&gt;&lt;a href=&quot;#1422-Maximum-Score-After-Splitting-a-String&quot; class=&quot;headerlink&quot; title=&quot;1422. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>在终端输入命令后系统做了什么</title>
    <link href="https://zdyxry.github.io/2020/04/25/%E5%9C%A8%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E5%90%8E%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://zdyxry.github.io/2020/04/25/在终端输入命令后系统做了什么/</id>
    <published>2020-04-25T15:18:03.000Z</published>
    <updated>2020-05-22T14:29:41.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>shell 是一个程序，也是一种编程语言，一个管理进程和运行程序的程序，在 Linux 中有很多 shell 可选，比如 bash、zsh、fish 等等，shell 主要有 3 个功能：</p><ol><li>运行程序</li><li>管理输入和输出</li><li>可编程</li></ol><p>运行程序很容易理解，在终端上输入的每个命令都是一个可执行程序，我们在 shell 中输入并执行程序；管理输入和输出，在 shell 中可以使用 <code>&lt;</code> <code>&gt;</code> <code>|</code> 符合控制输入、输出重定向，可以告诉 shell 将进程的输入和输出连接到一个文件或者其他的进程；编程，shell 是一种编程语言，可以进行变量赋值、循环、条件判断等操作。</p><h3 id="如何运行程序"><a href="#如何运行程序" class="headerlink" title="如何运行程序"></a>如何运行程序</h3><p>shell 永远在等待用户输入，输入完成按下回车键后，开始执行相应命令（程序），然后等待程序执行完成后打印相应输出，伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (! end_of_input)</span><br><span class="line">    get command</span><br><span class="line">    execute command</span><br><span class="line">    wait for command to finish</span><br></pre></td></tr></table></figure><p>在 shell 中因为需要执行其他的程序，需要用到 <code>execvp</code> ，<code>execvp</code> 会将指定的程序复制到调用它的进程，将指定的字符串组作为参数传递给程序，然后运行程序。这里存在一个问题， <code>execvp</code> 的执行过程是内核将程序加载到当前进程，替换当前进程的代码和数据，然后执行，那么原有进程的状态都被替换掉，在执行完程序就直接退出，不会再回到原程序等待下次输入。</p><p>为了保证我们在执行程序后回到 shell 中，需要每次创建新的进程来执行程序，调用 <code>fork</code> 指令，进程调用 fork 后，内核分配新的内存块和内核数据结构，复制原进程到新的进程，向运行进程添加新的进程，将控制返回给两个进程。通过 fork 返回值来判断当前进程是否为父进程或子进程。</p><p>shell 作为父进程通过调用 <code>fork</code> 创建子进程后，子进程通过 <code>execvp</code> 加载指定程序执行，父进程需要等待子进程退出，需要用到 <code>wait</code> ，在父进程 fork 出子进程后，父进程执行 <code>wait</code> 等待子进程执行，在调用时会传递一个整型变量地址，子进程执行完成后调用 <code>exit</code> 退出，内核将子进程的退出状态保存在这个变量中，用于父进程感知子进程退出状态。</p><h2 id="Golang-简易实现"><a href="#Golang-简易实现" class="headerlink" title="Golang 简易实现"></a>Golang 简易实现</h2><p>在 Golang 中可以调用 <code>os/exec</code> 来执行其他程序，然后在 main 中死循环不断的检测用户输入字符，同时也需要注意处理各种信号，比如 Ctrl-C 或者 Ctrl-D 之类的，下面是 Simon Jürgensmeyer 实现的一个简单的样例，可以了解一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"&gt; "</span>)</span><br><span class="line">        <span class="comment">// Read the keyboad input.</span></span><br><span class="line">        input, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle the execution of the input.</span></span><br><span class="line">        <span class="keyword">if</span> err = execInput(input); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrNoPath is returned when 'cd' was called without a second argument.</span></span><br><span class="line"><span class="keyword">var</span> ErrNoPath = errors.New(<span class="string">"path required"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execInput</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Remove the newline character.</span></span><br><span class="line">    input = strings.TrimSuffix(input, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split the input separate the command and the arguments.</span></span><br><span class="line">    args := strings.Split(input, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for built-in commands.</span></span><br><span class="line">    <span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"cd"</span>:</span><br><span class="line">        <span class="comment">// 'cd' to home with empty path not yet supported.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrNoPath</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change the directory and return the error.</span></span><br><span class="line">        <span class="keyword">return</span> os.Chdir(args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the command to execute.</span></span><br><span class="line">    cmd := exec.Command(args[<span class="number">0</span>], args[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the correct output device.</span></span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the command and return the error.</span></span><br><span class="line">    <span class="keyword">return</span> cmd.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/" target="_blank" rel="noopener">https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/</a></li><li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="noopener">https://book.douban.com/subject/1219329/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第17周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/24/2020-%E7%AC%AC17%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/24/2020-第17周-LeetCode-记录/</id>
    <published>2020-04-24T20:47:03.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1417-Reformat-The-String"><a href="#1417-Reformat-The-String" class="headerlink" title="1417. Reformat The String"></a>1417. Reformat The String</h3><p>重新格式化字符串，使得字母与数字交叉连接，先分别找出字母与数据，使用 zip_longest 来生成交叉后的元组，然后拼接得到目标字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reformat</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        a=re.findall(<span class="string">r'\d'</span>,s)</span><br><span class="line">        b=re.findall(<span class="string">r'[a-z]'</span>,s)</span><br><span class="line">        <span class="keyword">if</span> abs(len(a)-len(b))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        a,b=sorted([a,b],key=len)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(map(<span class="string">''</span>.join,itertools.zip_longest(b,a,fillvalue=<span class="string">''</span>)))</span><br></pre></td></tr></table></figure><h3 id="1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K"><a href="#1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K" class="headerlink" title="1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K"></a>1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K</h3><p>参考：<a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/tan-xin-jian-dan-zheng-ming-by-wyjoutstanding/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/tan-xin-jian-dan-zheng-ming-by-wyjoutstanding/</a></p><p>判定性：保证K一定能由斐波那契数组成，数据归纳法可证明</p><p>最小性：什么样的组合能最短？</p><ul><li>相邻合并：2个相邻的数可合并为二者的和，长度-1，因为f(n)=f(n-1)+f(n-2)。满足该条件的组合必定是间隔出现，但是又可能重现重复的值，这对于编程很不利。</li><li>重值转换：两个相同的值一定可以转换为两个不同的值，因为f(n)+f(n)=f(n)+f(n-1)+f(n-2)=f(n+1)+f(n-2)，一个比f(n)大，一个更小，这是等价转换，不会减小组合长度，但是会带来一个很好的性质，即单调递增性质。</li></ul><p>因此，重复使用以上两个操作后的组合数列，必定是一个无相邻值的递增数列，由于数列均为正数且和为K，因此值越大个数自然越小。</p><p>问：</p><blockquote><p>那会不会出现一种情况呢，就是如果减去最大的斐波那契数的话，剩下的数只能拆分成两个斐波那契数，而如果减去第二大的斐波那契数或者更小的斐波那契数的话，剩下的数刚好是斐波那契数？</p></blockquote><p>答：</p><p>可用反证法，假设总和为k，且f(m-1)&lt;k&lt;f(m)<br>那么对应你的第一种情况是k=f(m-1)+f(i)+f(j)，1&lt;=f(i),f(j)&lt;=f(m-2)；<br>对应你的第二种情况是k=f(m-2)+f(l)，其中,1&lt;=f(l)&lt;=f(m-3)。  </p><p>假设你说的情况成立，那么以上两个等式必定相等，即f(m-1)+f(i)+f(j)=f(m-2)+f(l)，<br>因为f(m-1) = f(m-2) + f(m-3), f(l)&lt;=f(m-3)，而f(i)和f(j)均不可能为0，因此等式不可能成立。<br>（左侧恒大于右侧，只有消去f(i)和f(j)才有可能取等）<br>当第二个等式的f(m-2)取更小值时更不可能成立。因此，推翻假设。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(self, k: int)</span> -&gt; int:</span></span><br><span class="line">        ls=self.fib(k)</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            <span class="keyword">if</span> k&gt;=ls[<span class="number">-1</span>]:</span><br><span class="line">                k-=ls[<span class="number">-1</span>]</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ls.pop()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span> -&gt; int:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> b &lt;= N:</span><br><span class="line">            res.append(b)</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n"><a href="#1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n" class="headerlink" title="1415. The k-th Lexicographical String of All Happy Strings of Length n"></a>1415. The k-th Lexicographical String of All Happy Strings of Length n</h3><p>使用 dfs 求解，每次传入下一层时需要去除当前层最后一个字母；<br>不需要算出所有长度为 n 的值，在得到第 k 个时可以直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHappyString</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        self.res = <span class="string">""</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur, tmp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(cur) == self.n:</span><br><span class="line">                self.k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                    self.res = cur</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">if</span> self.res:</span><br><span class="line">                    <span class="keyword">return</span> self.res</span><br><span class="line">                new_tmp = [j <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] <span class="keyword">if</span> j != i]</span><br><span class="line">                dfs(cur+i, new_tmp)</span><br><span class="line">        dfs(<span class="string">""</span>, [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1419-Minimum-Number-of-Frogs-Croaking"><a href="#1419-Minimum-Number-of-Frogs-Croaking" class="headerlink" title="1419. Minimum Number of Frogs Croaking"></a>1419. Minimum Number of Frogs Croaking</h3><p>可以转换为求在 <code>croak</code> 周期内，出现多少个 <code>c</code>，需要考虑边界情况，<code>croak</code> 字母出现次数永远是按照顺序依次递减的，如果出现递增情况直接返回 -1；最终遍历结束后应该保证 <code>croak</code> 中的各个字母出现次数相同，且不存在出现 <code>croak</code> 一半的情况，比如 存在 <code>cro</code> ，如果存在则直接返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberOfFrogs</span><span class="params">(self, croakOfFrogs: str)</span> -&gt; int:</span></span><br><span class="line">        c, r, o, a, k, in_use, answer = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> croakOfFrogs:</span><br><span class="line">            <span class="keyword">if</span> d == <span class="string">'c'</span>:</span><br><span class="line">                c, in_use = c+<span class="number">1</span>, in_use+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'r'</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'o'</span>:</span><br><span class="line">                o += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> d == <span class="string">'a'</span>:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k, in_use = k+<span class="number">1</span>, in_use<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            answer = max(answer, in_use)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> c &lt; r <span class="keyword">or</span> r &lt; o <span class="keyword">or</span> o &lt; a <span class="keyword">or</span> a &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> in_use == <span class="number">0</span> <span class="keyword">and</span> c == r <span class="keyword">and</span> r == o <span class="keyword">and</span> o == a <span class="keyword">and</span> a == k:</span><br><span class="line">            <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="926-Flip-String-to-Monotone-Increasing"><a href="#926-Flip-String-to-Monotone-Increasing" class="headerlink" title="926. Flip String to Monotone Increasing"></a>926. Flip String to Monotone Increasing</h3><p>动态规划，dp[i][0] 表示以 0 为结尾时，翻转的次数；dp[i][1] 表示以 1 为结尾是，翻转的次数；</p><p>当 i == 0 时，dp[i][0] = dp[i-1][0]，无需操作；<br>当 i == 0 时，dp[i][1] = min(dp[i-1][1], dp[i-1][0]) + 1，当 dp[i-1][1] 时，那么次数的 i = 0 ，需要翻转为 1，需 +1；当 dp[i-1][0] 时，此时要求以 1 为结尾需要翻转的次数，那么就需要将 i 翻转为 1，需 +1;  </p><p>当 i == 1 时，dp[i][0] = dp[i - 1][0] + 1 ，因为此时要求以 0 为结尾，需要将 i 翻转为 0，需 +1;<br>当 i == 1 时，dp[i][1] = min(dp[i - 1][1], dp[i - 1][0])，dp[i-1][1] 且当前 i == 1，所以无需操作；dp[i-1][0] 表示之前都是0且结尾是0，那么此时 i == 1 也符合递增情况无需操作。</p><p>简化后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, S: str)</span> -&gt; int:</span></span><br><span class="line">        N = len(S)</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i - <span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>]</span><br><span class="line">                dp[<span class="number">1</span>] = min(dp[<span class="number">1</span>], dp[<span class="number">0</span>]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">1</span>] = min(dp[<span class="number">1</span>], dp[<span class="number">0</span>])</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1417-Reformat-The-String&quot;&gt;&lt;a href=&quot;#1417-Reformat-The-String&quot; class=&quot;headerlink&quot; title=&quot;1417. Reformat The String&quot;&gt;&lt;/a&gt;1417. Reforma
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>文件系统基本概念及常用操作解释</title>
    <link href="https://zdyxry.github.io/2020/04/18/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%A7%A3%E9%87%8A/"/>
    <id>https://zdyxry.github.io/2020/04/18/文件系统基本概念及常用操作解释/</id>
    <published>2020-04-18T14:24:23.000Z</published>
    <updated>2020-05-22T14:29:41.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间一个朋友问我删除文件和格式化有什么区别，最近正好在读《Unix Linux 编程实践教程》这本书，其中第4章是来讲文件系统相关的，本文是对其中内容进行部分摘要来解释。</p><h2 id="Unix-文件系统的内部结构"><a href="#Unix-文件系统的内部结构" class="headerlink" title="Unix 文件系统的内部结构"></a>Unix 文件系统的内部结构</h2><p>从用户角度看，Unix 系统中的硬盘上的文件组成一棵目录树，每个目录能包含文件或其他目录，目录树的深度几乎没有限制，子目录下可以包含其他文件和子目录（套娃）。文件内容放置在对应的目录中，对应的目录内容放置在上层目录中。</p><p>文件系统是对硬盘设备的一种多层次的抽象，主要包含以下三层。</p><h3 id="第一层：从硬盘到分区"><a href="#第一层：从硬盘到分区" class="headerlink" title="第一层：从硬盘到分区"></a>第一层：从硬盘到分区</h3><p>一个硬盘能够存储大量的数据，硬盘可以被划分为多个区域，也就是硬盘分区，每个分区在系统中都可以看作是独立的硬盘。</p><h3 id="第二层：从磁盘到块序列"><a href="#第二层：从磁盘到块序列" class="headerlink" title="第二层：从磁盘到块序列"></a>第二层：从磁盘到块序列</h3><p>一个硬盘由许多磁性盘片组成，每个盘片的表面都被划分为很多同心圆，这些同心圆被成为磁道，每个磁道有进一步被划分为扇区，每个扇区可以存储一定字节数的数据，例如每个扇区有 512字节空间。扇区是磁盘上的基本存储单元，磁盘都包含大量的扇区。</p><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-1.jpg" title="fs-1"><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-2.jpg" title="fs-2"><p>为磁盘块编号是一种很重要的方法，给每个磁盘块分配连续的编号使得操作系统能够计算磁盘上的每个块，可以一个磁盘接一个磁盘的从上到下给所有的块编号，还可以一个磁道接一个磁道的从外向里给所有的块编号，一个将磁盘扇区编号的系统使得我们可以把磁盘视为一系列块的组合。</p><h3 id="第三层：从块序列到三个区域的划分"><a href="#第三层：从块序列到三个区域的划分" class="headerlink" title="第三层：从块序列到三个区域的划分"></a>第三层：从块序列到三个区域的划分</h3><p>文件系统可以用来存储文件内容、文件属性（文件所有者、日期等）和目录，这些不同类型的数据是如何存储在编号的磁盘块上的呢?</p><h2 id="文件系统区域划分"><a href="#文件系统区域划分" class="headerlink" title="文件系统区域划分"></a>文件系统区域划分</h2><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-3.png" title="fs-3"><p>一部分成为数据区，用来存放文件真正的内容。另一部分成为 i-node 表，用来存放文件属性。第三部分成为超级块（superblock），用来存放文件系统自身的信息。文件系统由这 3 部分组合而成，其中任一部分都是由很多有序磁盘块组成的。</p><h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>文件系统的第一个块被成为超级块。这个块中存放文件系统自身的结构信息，比如记录了每个区域的大小。超级块也存放未被使用的磁盘块信息，不同的文件系统的超级块信息不同，可以通过 <code>debugfs</code> 等类似命令查看。</p><h3 id="i-node-表"><a href="#i-node-表" class="headerlink" title="i-node 表"></a>i-node 表</h3><p>文件系统的下一个部分被成为 i-node 表，每个文件都有一些属性，如大小、文件所有者和最近修改时间等等，这些属性被记录在一个被成为 i-node 的结构中，所有的 i-node 都有相同的大小，并且 i-node 表是这些 i-node 结构组成的一个列表。文件系统中每个文件都有一个 i-node。</p><h3 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h3><p>文件系统的第 3 个部分是数据区。文件的真正内容保存在这个区域。磁盘上所有块的大小都是一样的。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。一个较大的文件很容易分布在上千个独立的磁盘块中。</p><h2 id="常见操作过程解释"><a href="#常见操作过程解释" class="headerlink" title="常见操作过程解释"></a>常见操作过程解释</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>当我们创建一个文件的时候，主要操作有以下 4个：</p><ul><li>存储属性<ul><li>文件属性的存储：内核先找到一个空的 i-node，把文件的信息记录到 i-node 中。</li></ul></li><li>存储数据<ul><li>文件内容的存储：内核从未被使用的数据块列表中找出足够的数据块，然后将数据从缓冲区复制到对应的数据块中。</li></ul></li><li>记录分配情况<ul><li>文件内容按照顺序存放在数据块中。内核在 i-node 的磁盘分布区记录了上述的块序列。磁盘分布区是一个磁盘块序号的列表。</li></ul></li><li>添加文件名到目录<ul><li>内核将文件 i-node 编号和对应的文件名添加到目录文件。文件名和 i-node 编号之间的对应关系将文件名和文件内容及文件属性进行了关联。</li></ul></li></ul><p>如果创建一个大文件该如何做？一个大文件需要多个磁盘块，在 i-node 中存放磁盘块分配列表，但是长度是固定的，也就是文件大小是有上限的，如何尽可能的支持更大的文件？</p><p>如果一个文件需要 14个数据块存储内容，但是 i-node 只包含一个含有 13 个项的分配列表，这是将分配列表中的前 10 个编号放到 i-node 中，将最后的 4个编号放到一个数据块中，然后在 i-node 的第 11 项中作为指向存放 4个数据块编号的数据块。最终这个文件一共使用了15个数据块，额外使用的数据块成为间接块。</p><img src="/2020/04/18/文件系统基本概念及常用操作解释/fs-4.png" title="fs-4"><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><ul><li>在目录中寻找文件名<ul><li>文件名存储在目录文件中，内核在目录文件中寻找包含文件名的记录，然后找到对应的 i-node 编号</li></ul></li><li>定位 i-node 编号并读取内容<ul><li>内核在文件系统的 i-node 区域找到对应的 i-node。定位 i-node 需要简单的计算，所有的 i-node 大小相同，每个磁盘块都包含相同数量的 i-node。内核会将 i-node 置为缓冲区，i-node 包含数据块编号的列表。</li></ul></li><li>访问存储文件内容的数据块<ul><li>通过 i-node 信息，内核已经知道文件真正的内容存放在哪些数据块上，以及它们的顺序，将字节从磁盘复制到内核缓冲区，然后到达用户空间。</li></ul></li></ul><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>目录是一种包含了文件名字列表的特殊文件，不同版本的 Unix 目录内部结构不同，但是抽象模型是一致的—一个包含 i-node 编号和文件名的列表。</p><p>当一个文件想要被多种方式共享且保证他们是一个文件，有多个有效的路径名，系统引入了链接机制：硬链接和软链接。其中硬链接与文件的 i-node 一致。一个文件内容自身的硬链接数刚创建时为1，之后通过其他方式创建了硬链接，那么引用计数对应增加。</p><p>“文件在目录中”从系统的角度看，是目录中有一个包含文件名和对应 i-node 编号的入口，“文件 x 在目录 a 中”意味着在目录 a 中有一个指向对应 i-node 的链接，这个链接所附加的文件名为 <code>x</code>。简单来说，目录包含的是文件的引用，每个引用被成为链接，文件的内容存储在数据块中，文件的属性被记录在 i-node 中，i-node编号和文件名存储在目录中。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除文件是从一个目录中删除一个对应文件的引用记录，减少对应的 i-node 的链接数，如果 i-node 的链接数减为0，则 i-node 和 i-node 对应的数据块被释放，这里的释放指的是删除 i-node 信息，这样我们就没办法通过 i-node 信息找到文件数据块信息的对应关系，但是文件真正的内容还是存在数据块中的，没有被删除，如果发现误删之后立即停止所有操作，是有可能通过一些方式来达到数据恢复的目的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="noopener">https://book.douban.com/subject/1219329/</a></li><li><a href="https://www.youtube.com/watch?v=Cj8-WNjaGuM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Cj8-WNjaGuM</a></li><li><a href="https://zhuanlan.zhihu.com/p/34883885" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34883885</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间一个朋友问我删除文件和格式化有什么区别，最近正好在读《Unix Linux 编程实践教程》这本书，其中第4章是来讲文件系统相关的，本
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第16周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/18/2020-%E7%AC%AC16%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/18/2020-第16周-LeetCode-记录/</id>
    <published>2020-04-18T05:34:09.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1408-String-Matching-in-an-Array"><a href="#1408-String-Matching-in-an-Array" class="headerlink" title="1408. String Matching in an Array"></a>1408. String Matching in an Array</h3><p>先按照单词长度进行排序，然后遍历判断当前单词是否被其他单词包含，要注意最终结果应该是去重之后的。</p><p>Golang 中可以直接使用 <code>strings.Contains</code> 判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByLen []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(a[i]) &lt; <span class="built_in">len</span>(a[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByLen)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringMatching</span><span class="params">(words []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">sort.Sort(ByLen(words))</span><br><span class="line">res := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(words); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(words[j], words[i]) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, words[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">skip := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> unique &#123;</span><br><span class="line"><span class="keyword">if</span> v == u &#123;</span><br><span class="line">skip = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !skip &#123;</span><br><span class="line">unique = <span class="built_in">append</span>(unique, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unique</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1409-Queries-on-a-Permutation-With-Key"><a href="#1409-Queries-on-a-Permutation-With-Key" class="headerlink" title="1409. Queries on a Permutation With Key"></a>1409. Queries on a Permutation With Key</h3><p>数据规模较小，可以直接使用数组暴力求解。</p><p>理想方法应该是使用 Fenwick Tree 来解答，具体的方法参考：</p><ul><li><a href="https://www.youtube.com/watch?v=WbafSgetDDk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=WbafSgetDDk</a></li><li><a href="https://www.youtube.com/watch?v=DwtijVbS3G0&amp;t=635s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=DwtijVbS3G0&amp;t=635s</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processQueries</span><span class="params">(queries []<span class="keyword">int</span>, m <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(queries))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">p[i] = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> queries &#123;</span><br><span class="line"><span class="comment">//found value in p's index</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> p[i] == value &#123;</span><br><span class="line">res[index] = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//move p</span></span><br><span class="line">tmp := p[i]</span><br><span class="line"><span class="built_in">copy</span>(p[<span class="number">1</span>:i+<span class="number">1</span>], p[<span class="number">0</span>:i])</span><br><span class="line">p[<span class="number">0</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processQueries</span><span class="params">(self, queries: List[int], m: int)</span> -&gt; List[int]:</span></span><br><span class="line">        tree = [<span class="number">0</span>] * ((<span class="number">2</span>*m) + <span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(i,val)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;len(tree):</span><br><span class="line">                tree[i]+=val</span><br><span class="line">                i+=(i&amp;(-i))</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">prefixSum</span><span class="params">(i)</span>:</span></span><br><span class="line">            s=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                s+=tree[i]</span><br><span class="line">                i-=(i&amp;(-i))</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        hmap = collections.defaultdict(int)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            hmap[i] = i+m</span><br><span class="line">            update(i+m,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> queries:</span><br><span class="line">            res.append(prefixSum(hmap[i])<span class="number">-1</span>)</span><br><span class="line">            update(hmap[i],<span class="number">-1</span>)</span><br><span class="line">            update(m,<span class="number">1</span>)</span><br><span class="line">            hmap[i] = m</span><br><span class="line">            m-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1410-HTML-Entity-Parser"><a href="#1410-HTML-Entity-Parser" class="headerlink" title="1410. HTML Entity Parser"></a>1410. HTML Entity Parser</h3><p>字符串解析替换，遍历检查 <code>&amp;</code> 和 <code>;</code> 进行替换，也可以直接使用 <code>str.replace</code> 进行替换，如果使用 regex 会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">entityParser</span><span class="params">(self, text: str)</span> -&gt; str:</span></span><br><span class="line">        ent = &#123;<span class="string">'&amp;quot;'</span>: <span class="string">'"'</span>, <span class="string">'&amp;apos;'</span>:<span class="string">'\''</span> , <span class="string">'&amp;gt;'</span>:<span class="string">'&gt;'</span>, <span class="string">'&amp;lt;'</span>:<span class="string">'&lt;'</span>, <span class="string">'&amp;frasl;'</span>:<span class="string">'/'</span>, <span class="string">'&amp;amp;'</span>:<span class="string">'&amp;'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> ent.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> text:</span><br><span class="line">                text = text.replace(k, v)</span><br><span class="line">        <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure><h3 id="1138-Alphabet-Board-Path"><a href="#1138-Alphabet-Board-Path" class="headerlink" title="1138. Alphabet Board Path"></a>1138. Alphabet Board Path</h3><p>先准备字母表，需要注意的是最后一个字母 <code>z</code>，如果目标字母是 <code>z</code> ，那么只能先左再下，如果当前字母是 <code>z</code>，那么只能先上再右，需要考虑移动的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alphabetBoardPath</span><span class="params">(self, target: str)</span> -&gt; str:</span></span><br><span class="line">        m = &#123;c: [i // <span class="number">5</span>, i % <span class="number">5</span>] <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>)&#125;</span><br><span class="line">        x0, y0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> target:</span><br><span class="line">            x, y = m[c]</span><br><span class="line">            <span class="keyword">if</span> y &lt; y0: res.append(<span class="string">'L'</span> * (y0 - y))</span><br><span class="line">            <span class="keyword">if</span> x &lt; x0: res.append(<span class="string">'U'</span> * (x0 - x))</span><br><span class="line">            <span class="keyword">if</span> x &gt; x0: res.append(<span class="string">'D'</span> * (x - x0))</span><br><span class="line">            <span class="keyword">if</span> y &gt; y0: res.append(<span class="string">'R'</span> * (y - y0))</span><br><span class="line">            res.append(<span class="string">'!'</span>)</span><br><span class="line">            x0, y0 = x, y</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="1302-Deepest-Leaves-Sum"><a href="#1302-Deepest-Leaves-Sum" class="headerlink" title="1302. Deepest Leaves Sum"></a>1302. Deepest Leaves Sum</h3><p>求最深层的叶子节点之和，需要维护 2个变量，一个是最深层次，一个是最深层次对应的和。遍历节点时与最深层次比较，进行求和运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepestLeavesSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        q = collections.deque([(root, <span class="number">0</span>)])</span><br><span class="line">        maxdep, total = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">            node, dep = q.pop()</span><br><span class="line">            <span class="keyword">if</span> dep &gt; maxdep:</span><br><span class="line">                maxdep, total = dep, node.val</span><br><span class="line">            <span class="keyword">elif</span> dep == maxdep:</span><br><span class="line">                total += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append((node.left, dep + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append((node.right, dep + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1408-String-Matching-in-an-Array&quot;&gt;&lt;a href=&quot;#1408-String-Matching-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1408. String Matching in an 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>runc nsenter 源码阅读</title>
    <link href="https://zdyxry.github.io/2020/04/12/runc-nsenter-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2020/04/12/runc-nsenter-源码阅读/</id>
    <published>2020-04-12T14:57:29.000Z</published>
    <updated>2020-05-22T14:29:41.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在阅读 runc 的实现，发现在 runc 中比较重要的一个逻辑是在设置 namespace 过程中的 nsenter 模块，其中逻辑有些绕，也发现了一段很长很有意思的注释，分享一下。</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>什么是 nsenter，nsenter 是 runc 中的一个 package，它包含了一个特殊的构造函数，用来在 Go runtime 启动之前做一些事情，比如 setns()。nsenter 会引入 <code>C</code> 并使用 cgo 实现相关逻辑。在cgo中，如果在 <code>C</code> 的 import 后紧跟注释，则在编译程序包的 C 语言实现部分时，该注释将用作 header。因此，每次 import nsenter 时，nsexec()都会调用 C 函数。</p><p>在 runc 中只有 init.go import 了 nsenter。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>容器技术最关键的就是 namespace 和 cgroup，其中 namespace 是通过 setns() 函数来实现的，但是 setns() 有一个问题： <code>A multithreaded process may not change user namespace with setns().</code> 。而 go runtime 是多线程的，所以需要在 go runtime 启动前执行 setns() 设置好 namespace，然后再走 go 相关实现流程。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>在实际的 nsenter 实现中，存在 3 个进程，分别为 parent, child, grandchild。在注释中可以看到 nsenter 实现过程中的考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Okay, so this is quite annoying.</span><br><span class="line"> *</span><br><span class="line"> * In order for this unsharing code to be more extensible we need to split</span><br><span class="line"> * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case</span><br><span class="line"> * would be if we did clone(CLONE_NEWUSER) and the other namespaces</span><br><span class="line"> * separately, but because of SELinux issues we cannot really do that. But</span><br><span class="line"> * we cannot just dump the namespace flags into clone(...) because several</span><br><span class="line"> * usecases (such as rootless containers) require more granularity around</span><br><span class="line"> * the namespace setup. In addition, some older kernels had issues where</span><br><span class="line"> * CLONE_NEWUSER wasn&apos;t handled before other namespaces (but we cannot</span><br><span class="line"> * handle this while also dealing with SELinux so we choose SELinux support</span><br><span class="line"> * over broken kernel support).</span><br><span class="line"> *</span><br><span class="line"> * However, if we unshare(2) the user namespace *before* we clone(2), then</span><br><span class="line"> * all hell breaks loose.</span><br><span class="line"> *</span><br><span class="line"> * The parent no longer has permissions to do many things (unshare(2) drops</span><br><span class="line"> * all capabilities in your old namespace), and the container cannot be set</span><br><span class="line"> * up to have more than one &#123;uid,gid&#125; mapping. This is obviously less than</span><br><span class="line"> * ideal. In order to fix this, we have to first clone(2) and then unshare.</span><br><span class="line"> *</span><br><span class="line"> * Unfortunately, it&apos;s not as simple as that. We have to fork to enter the</span><br><span class="line"> * PID namespace (the PID namespace only applies to children). Since we&apos;ll</span><br><span class="line"> * have to double-fork, this clone_parent() call won&apos;t be able to get the</span><br><span class="line"> * PID of the _actual_ init process (without doing more synchronisation than</span><br><span class="line"> * I can deal with at the moment). So we&apos;ll just get the parent to send it</span><br><span class="line"> * for us, the only job of this process is to update</span><br><span class="line"> * /proc/pid/&#123;setgroups,uid_map,gid_map&#125;.</span><br><span class="line"> *</span><br><span class="line"> * And as a result of the above, we also need to setns(2) in the first child</span><br><span class="line"> * because if we join a PID namespace in the topmost parent then our child</span><br><span class="line"> * will be in that namespace (and it will not be able to give us a PID value</span><br><span class="line"> * that makes sense without resorting to sending things with cmsg).</span><br><span class="line"> *</span><br><span class="line"> * This also deals with an older issue caused by dumping cloneflags into</span><br><span class="line"> * clone(2): On old kernels, CLONE_PARENT didn&apos;t work with CLONE_NEWPID, so</span><br><span class="line"> * we have to unshare(2) before clone(2) in order to do this. This was fixed</span><br><span class="line"> * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was</span><br><span class="line"> * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we&apos;re</span><br><span class="line"> * aware, the last mainline kernel which had this bug was Linux 3.12.</span><br><span class="line"> * However, we cannot comment on which kernels the broken patch was</span><br><span class="line"> * backported to.</span><br><span class="line"> *</span><br><span class="line"> * -- Aleksa &quot;what has my life come to?&quot; Sarai</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>来看下 parent，child，grandchild 分别做了哪些事情：</p><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><p>parent 进程通过环境变量 <code>_LIBCONTAINER_INITPIPE</code> 获取相关配置信息，然后 clone 出 child 进程，当 child 进程 ready 之后设置 user map，从 child 进程中接受 grandchild 进程 pid，然后通过管道传递给外层的 runc 进程。parent 进程退出条件为 child 进程和 grandchild 都处于 ready 状态后，parent 进程退出。</p><p>之所以要 clone child 进程，是因为如果创建了 user namespace，那么 user map 只能由原有的 user namespace 设置，所以需要 clone child 进程，然后在 parent 进程中设置 user map。</p><h3 id="child"><a href="#child" class="headerlink" title="child"></a>child</h3><p>child 进程先执行 setns()，在一些老版本的kernel 中，<code>CLONE_PARENT</code> flag 与 <code>CLONE_NEWPID</code> 有冲突，所以使用 unshare 创建 user namespace， user namespace 需要先于其他 namespace 创建，创建 user namespace 并设置 user map，才有能力创建其他的 namespace。等待 parent 进程设置 user map 后，设置 child 当前进程的 uid 为 root(0) ，使用 unshare 创建其他 namespace，然后 clone grandchild 进程，并将 grandchild 进程 pid 传递给 parent，然后退出。</p><p>之所以要 clone grandchild 进程，是因为在 child 进程中设置 namespace 并不会在 child 进程中生效，所以需要 clone 出一个新的进程，继承 namespace 配置。</p><h3 id="grandchild"><a href="#grandchild" class="headerlink" title="grandchild"></a>grandchild</h3><p>grandchild 进程就是容器真正的进程，在确保 parent 和 child 进程都处于 ready 之后，设置 uid,gid，从管道中读取相应配置信息，然后 unshare 创建 cgroup namespace，然后将状态发送给 parent 后 返回。grandchild 进程返回后继续执行 go 代码流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>runc 作为 OCI 的标准实现，自身代码量并不大，但是逻辑比较扰，其中 namespace 更是博大精深，尤其是要考虑到一些老版本kernel 以及 rootless 场景下，复杂程度翻倍，有很多细节值得去思考。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/README.md" target="_blank" rel="noopener">https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/README.md</a></li><li><a href="https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c" target="_blank" rel="noopener">https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/nsexec.c</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在阅读 runc 的实现，发现在 runc 中比较重要的一个逻辑是在设置 namespace 过程中的 nsenter 模块，其中逻辑有
      
    
    </summary>
    
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>2020 第15周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/10/2020-%E7%AC%AC15%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/10/2020-第15周-LeetCode-记录/</id>
    <published>2020-04-10T20:44:44.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1403-Minimum-Subsequence-in-Non-Increasing-Order"><a href="#1403-Minimum-Subsequence-in-Non-Increasing-Order" class="headerlink" title="1403. Minimum Subsequence in Non-Increasing Order"></a>1403. Minimum Subsequence in Non-Increasing Order</h3><p>对数组进行排序，然后依次取出当前最大值，比较当前取出数值和与剩余数值和，如果大于，则返回取出数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubsequence</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        N = len(nums)</span><br><span class="line">        total = sum(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            x = nums.pop()</span><br><span class="line"></span><br><span class="line">            t += x</span><br><span class="line">            ret.append(x)</span><br><span class="line">            <span class="keyword">if</span> t * <span class="number">2</span> &gt; total: <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h3 id="1400-Construct-K-Palindrome-Strings"><a href="#1400-Construct-K-Palindrome-Strings" class="headerlink" title="1400. Construct K Palindrome Strings"></a>1400. Construct K Palindrome Strings</h3><p>构造指定个数的回文字符串，检查出现次数为奇数的字母次数是否超过了k即可。可以直接用 Counter 计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        digit_count = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> len(s) == k:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            odd = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> set(s):</span><br><span class="line">                digit_count[i] = s.count(i)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> digit_count.values():</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                    odd += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> odd &gt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1401-Circle-and-Rectangle-Overlapping"><a href="#1401-Circle-and-Rectangle-Overlapping" class="headerlink" title="1401. Circle and Rectangle Overlapping"></a>1401. Circle and Rectangle Overlapping</h3><p>依次考虑圆心与矩形的位置关系，是否在矩形的上下左右，求出矩形到圆心距离最小的点，然后根据两点间距离公式来与半径相比较。</p><p>zhihu 上有一个问题可以解答这道题：<a href="https://www.zhihu.com/question/24251545" target="_blank" rel="noopener">https://www.zhihu.com/question/24251545</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkOverlap</span><span class="params">(radius <span class="keyword">int</span>, x_center <span class="keyword">int</span>, y_center <span class="keyword">int</span>, x1 <span class="keyword">int</span>, y1 <span class="keyword">int</span>, x2 <span class="keyword">int</span>, y2 <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dx, dy <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">if</span> x1 &gt; x_center &#123;</span><br><span class="line">        dx = x1 - x_center  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> x_center &gt; x2 &#123;</span><br><span class="line">        dx = x_center - x2 </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        dx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> y1 &gt; y_center &#123;</span><br><span class="line">        dy = y1 - y_center  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> y_center &gt; y2 &#123;</span><br><span class="line">        dy = y_center - y2 </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        dy = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dx * dx + dy * dy &lt;= radius * radius</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One"><a href="#1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One" class="headerlink" title="1404. Number of Steps to Reduce a Number in Binary Representation to One"></a>1404. Number of Steps to Reduce a Number in Binary Representation to One</h3><p>这道题如果直接把二进制转换为十进制数，然后判断奇偶就很容易了，但是这不是它本身的目的，主要需要考虑位进位换算，其中分为 4 种情况：</p><p>无进位，当前位是1，则步骤 +2，进位为1<br>无进位，当前位是0，则步骤 +1，进位为0<br>有进位，当前位是1，则步骤 +1，进位为1<br>有进位，当前位是0，则步骤 +2，进位为1</p><p>其中步骤 +2 的情况为当前位是 1，需要 +1 和 /2 两个操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(A []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(A)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">A[i], A[<span class="built_in">len</span>(A)<span class="number">-1</span>-i] = A[<span class="built_in">len</span>(A)<span class="number">-1</span>-i], A[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSteps</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">reverse(bs)</span><br><span class="line">step, carry, last := <span class="number">0</span>, <span class="number">0</span>, bs[<span class="built_in">len</span>(bs)<span class="number">-1</span>]</span><br><span class="line">bs = bs[:<span class="built_in">len</span>(bs)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> bs &#123;</span><br><span class="line"><span class="keyword">if</span> carry == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">'1'</span> &#123;</span><br><span class="line">step += <span class="number">2</span></span><br><span class="line">carry = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v == <span class="string">'0'</span> &#123;</span><br><span class="line">step += <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">step += <span class="number">1</span></span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> last == <span class="string">'1'</span> &#123;</span><br><span class="line">step += carry</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1405-Longest-Happy-String"><a href="#1405-Longest-Happy-String" class="headerlink" title="1405. Longest Happy String"></a>1405. Longest Happy String</h3><p>对字母按照次数进行降序排序，然后依次遍历字母，判断最后2位是否与当前字母 * 2 相同，如果相同，则跳过，如果不相同，则将其添加到结果中，并将次数 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDiverseString</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; str:</span></span><br><span class="line">        x = [[a, <span class="string">'a'</span>],[b, <span class="string">'b'</span>],[c,<span class="string">'c'</span>]]</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> sorted(x,reverse=<span class="keyword">True</span>):</span><br><span class="line">                <span class="keyword">if</span> num[<span class="number">0</span>] &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">if</span> len(res) &gt;= <span class="number">2</span> <span class="keyword">and</span> res[<span class="number">-2</span>:] == num[<span class="number">1</span>] * <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res += num[<span class="number">1</span>]</span><br><span class="line">                num[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1403-Minimum-Subsequence-in-Non-Increasing-Order&quot;&gt;&lt;a href=&quot;#1403-Minimum-Subsequence-in-Non-Increasing-Order&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>fsck 是如何工作的</title>
    <link href="https://zdyxry.github.io/2020/04/05/fsck-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://zdyxry.github.io/2020/04/05/fsck-是如何工作的/</id>
    <published>2020-04-05T09:08:33.000Z</published>
    <updated>2020-05-22T14:29:41.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在平时会遇到不少系统崩溃之后文件系统异常的情况，通常我们会通过 fsck 工具进行修复，今天来了解下 fsck 做了什么，是怎么做的。</p><h2 id="工作负载示例"><a href="#工作负载示例" class="headerlink" title="工作负载示例"></a>工作负载示例</h2><p>假设现在存在一种工作负载，将单个数据块附加到原有文件。通过打开文件，调用 <code>lseek()</code> 将文件偏移量移动到文件末尾，然后在关闭文件之前，向文件发出单个 4KB 写入来完成追加。</p><p>假定磁盘上使用标准的简单文件系统结构，包括一个 inode 位图（inode bitmap，只有 8 位，每个 inode 一个），一个数据位图（databitmap，也是 8 位，每个数据块一个），inode（总共 8 个，编号为 0 到 7，分布在 4 个块上），以及数据块（总共 8 个，编号为 0～7）。以下是该文件系统的示意图：</p><img src="/2020/04/05/fsck-是如何工作的/fsck-1.png" title="fsck-1"><p>查看图中的结构，可以看到分配了一个 inode（inode 号为 2），它在 inode 位图中标记，单个分配的数据块（数据块 4）也在数据中标记位图。inode 表示为 I [v1]，因为它是此 inode 的第一个版本。它将很快更新（由于上述工作负载）。再来看看这个简化的 inode。在 I[v1]中，可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">owner : remzi</span><br><span class="line">permissions : read-write</span><br><span class="line">size : 1</span><br><span class="line">pointer : 4</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br></pre></td></tr></table></figure><p>在这个简化的 inode 中，文件的大小为 1（它有一个块位于其中），第一个直接指针指向块 4（文件的第一个数据块，Da），并且所有其他 3 个直接指针都被设置为 null（表示它们未被使用）。当然，真正的 inode 有更多的字段。</p><p>向文件追加内容时，要向它添加一个新数据块，因此必须更新 3 个磁盘上的结构：inode（必须指向新块，并且由于追加而具有更大的大小），新数据块 Db 和新版本的数据位图（称之为 B[v2]）表示新数据块已被分配。<br>因此，在系统的内存中，有 3 个块必须写入磁盘。更新的 inode（inode 版本 2，或简称为 I [v2]）现在看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">owner : remzi</span><br><span class="line">permissions : read-write</span><br><span class="line">size : 2</span><br><span class="line">pointer : 4</span><br><span class="line">pointer : 5</span><br><span class="line">pointer : null</span><br><span class="line">pointer : null</span><br></pre></td></tr></table></figure><p>更新的数据位图（B[v2]）现在看起来像这样：00001100。最后，有数据块（Db），它只是用户放入文件的内容。希望文件系统的最终磁盘映像如下所示:</p><img src="/2020/04/05/fsck-是如何工作的/fsck-2.png" title="fsck-2"><p>要实现这种转变，文件系统必须对磁盘执行 3 次单独写入，分别针对 inode（I[v2]），位图（B[v2]）和数据块（Db）。请注意，当用户发出 write()系统调用时，这些写操作通常不会立即发生。脏的 inode、位图和新数据先在内存（页面缓存，page cache，或缓冲区缓存，buffer cache）中存在一段时间。</p><p>然后，当文件系统最终决定将它们写入磁盘时（比如说 5s 或 30s），文件系统将向磁盘发出必要的写入请求。遗憾的是，可能会发生崩溃，从而干扰磁盘的这些更新。特别是，如果这些写入中的一个或两个完成后发生崩溃，而不是全部 3 个，则文件系统可能处于异常的状态。</p><h2 id="崩溃场景"><a href="#崩溃场景" class="headerlink" title="崩溃场景"></a>崩溃场景</h2><p>想象一下，只有一次写入成功。因此有以下 3 种可能的结果：</p><ul><li>只将数据块（Db）写入磁盘。在这种情况下，数据在磁盘上，但是没有指向它的 inode，也没有表示块已分配的位图。因此，就好像写入从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题。</li><li>只有更新的 inode（I[v2]）写入了磁盘。在这种情况下，inode 指向磁盘地址（5），其中 Db 即将写入，但 Db 尚未写入。因此，如果信任该指针，那将从磁盘读取垃圾数据（磁盘地址 5 的旧内容）。</li></ul><p>此外，遇到了一个新问题，将它称为文件系统不一致（file-system inconsistency）。磁盘上的位图显示数据块 5 尚未分配，但是 inode 说它已经分配了。文件系统数据结构中的这种不同意见，是文件系统的数据结构不一致。要使用文件系统，必须以某种方式解决这个问题。</p><ul><li>只有更新后的位图（B [v2]）写入了磁盘。在这种情况下，位图指示已分配块 5，但没有指向它的 inode。因此文件系统再次不一致。如果不解决，这种写入将导致空间泄露（space leak），因为文件系统永远不会使用块 5。</li></ul><p>在这个向磁盘写入 3 次的尝试中，还有 3 种崩溃场景。在这些情况下，两次写入成功，最后一次失败。</p><ul><li>inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）。在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图指示 5 正在使用，因此从文件系统的元数据的角度来看，一切看起来都很正常。但是有一个问题：5 中又是垃圾。</li><li>写入了 inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）。在这种情况下，inode 指向了磁盘上的正确数据，但同样在 inode 和位图（B1）的旧版本之间存在不一致。因此，在使用文件系统之前，又需要解决问题。</li><li>写入了位图（B[v2]）和数据块（Db），但没有写入 inode（I[v2]）。在这种情况下，inode 和数据位图之间再次存在不一致。但是，即使写入块并且位图指示其使用，也不知道它属于哪个文件，因为没有 inode 指向该块。</li></ul><p>从这些崩溃场景中可以看到由于崩溃而导致磁盘文件系统映像可能出现的许<br>多问题：在文件系统数据结构中可能存在不一致性。可能有空间泄露，可能将垃圾数据返回给用户，等等。</p><p>理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地<br>（atomically）移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是，做到这一点不容易，因为磁盘一次只提交一次写入，而这些更新之间可能会发生崩溃或断电。将这个一般问题称为崩溃一致性问题（crash-consistency problem，也可以称为一致性更新问题，consistent-update problem）。</p><h2 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h2><p>早期的文件系统采用了一种简单的方法来处理崩溃一致性。基本上，它们决定让不一致的事情发生，然后再修复它们（重启时）。这种偷懒方法的典型例子可以在一个工具中找到：fsck。fsck 是一个 UNIX 工具，用于查找这些不一致并修复它们。在不同的系统上，存在检查和修复磁盘分区的类似工具。请注意，这种方法无法解决所有问题。例如，考虑上面的情况，文件系统看起来是一致的，但是 inode 指向垃圾数据。唯一真正的目标，是确保文件系统元数据内部一致。</p><p>工具 fsck 在许多阶段运行，它在文件系统挂载并可用之前运行（fsck 假定在运行时没有其他文件系统活动正在进行）。一旦完成，磁盘上的文件系统应该是一致的，因此可以让用户访问。以下是 fsck 的基本总结：</p><ul><li>超级块：fsck 首先检查超级块是否合理，主要是进行健全性检查，例如确保文件系统大小大于分配的块数。通常，这些健全性检查的目的是找到一个可疑的（冲突的）超级块。在这种情况下，系统（或管理员）可以决定使用超级块的备用副本。</li><li>空闲块：接下来，fsck 扫描 inode、间接块、双重间接块等，以了解当前在文件系统中分配的块。它利用这些知识生成正确版本的分配位图。因此，如果位图和 inode之间存在任何不一致，则通过信任 inode 内的信息来解决它。对所有 inode 执行相同类型的检查，确保所有看起来像在用的 inode，都在 inode 位图中有标记。</li><li>inode 状态：检查每个 inode 是否存在损坏或其他问题。例如，fsck 确保每个分配的 inode 具有有效的类型字段（即常规文件、目录、符号链接等）。如果 inode 字段存在问题，不易修复，则 inode 被认为是可疑的，并被 fsck 清除，inode 位图相应地更新。</li><li>inode 链接：fsck 还会验证每个已分配的 inode 的链接数。你可能还记得，链接计数表示包含此特定文件的引用（即链接）的不同目录的数量。为了验证链接计数，fsck 从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数。如果新计算的计数与 inode 中找到的计数不匹配，则必须采取纠正措施，通常是修复 inode 中的计数。如果发现已分配的 inode 但没有目录引用它，则会将其移动到 lost + found 目录。</li><li>重复：fsck 还检查重复指针，即两个不同的 inode 引用同一个块的情况。如果一个 inode 明显不好，可能会被清除。或者，可以复制指向的块，从而根据需要为每个 inode 提供其自己的副本。</li><li>坏块：在扫描所有指针列表时，还会检查坏块指针。如果指针显然指向超出其有效范围的某个指针，则该指针被认为是“坏的”，例如，它的地址指向大于分区大小的块。在这种情况下，fsck 不能做任何太智能的事情。它只是从 inode 或间接块中删除（清除）该指针。</li><li>目录检查：fsck 不了解用户文件的内容。但是，目录包含由文件系统本身创建的特定格式的信息。因此，fsck 对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前面的条目，目录条目中引用的每个 inode 都已分配，并确保整个层次结构中没有目录的引用超过一次。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上所述，构建有效工作的 fsck 需要复杂的文件系统知识。确保这样的代码在所有情况下都能正常工作可能具有挑战性。然而，fsck（和类似的方法）有一个更大的、也许更根本的问题：它们太慢了。</p><p>对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。随着磁盘容量的增长和 RAID 的普及，fsck 的性能变得令人望而却步。在更高的层面上，fsck 的基本前提似乎有点不合理。考虑上面的示例，其中只有 3 个块写入磁盘。扫描整个磁盘，仅修复更新 3 个块期间出现的问题，这是非常昂贵的。</p><p>这种情况类似于将你的钥匙放在卧室的地板上，然后从地下室开始，搜遍每个房间，执行“搜索整个房子找钥匙”的恢复算法。它有效，但很浪费。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在平时会遇到不少系统崩溃之后文件系统异常的情况，通常我们会通过 fsck 工具进行修复，今天来了解下 fsck 做了什么，是怎么做的。&lt;/p
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第14周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/04/03/2020-%E7%AC%AC14%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/04/03/2020-第14周-LeetCode-记录/</id>
    <published>2020-04-03T21:49:38.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1394-Find-Lucky-Integer-in-an-Array"><a href="#1394-Find-Lucky-Integer-in-an-Array" class="headerlink" title="1394. Find Lucky Integer in an Array"></a>1394. Find Lucky Integer in an Array</h3><p>找幸运数字，可以维护一个数组，然后统计出现过的次数，也可以直接使用 collections.Counter 实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLucky</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">501</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            cnt[a] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> cnt[i] == i:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a>1395. Count Number of Teams</h3><p>遍历数组，假设当前数值是中间位置，因为要考虑到倒序排序，所以要找到左边比当前数值小的和比当前数值大的，找到右边比当前数值小的和比当前数值大的，然后进行排列组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTeams</span><span class="params">(self, rating)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rating: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(rating)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line">            l1,r1= <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            l2,r2 =<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &lt; rating[i]:</span><br><span class="line">                    l1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> rating[j] &gt; rating[i]:</span><br><span class="line">                    r1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r2 += <span class="number">1</span></span><br><span class="line">            ans += l1*r1 + l2*r2</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1396-Design-Underground-System"><a href="#1396-Design-Underground-System" class="headerlink" title="1396. Design Underground System"></a>1396. Design Underground System</h3><p>使用 dict ，在 checkin 的时候以 id 为key，记录地铁站和时间，在 checkout 的时候以 (checkin_station, checkout_station) 为 key，记录所用时间，需要注意多次的情况，记录次数，在 getAverageTime 的时候直接根据 (checkin_station, checkout_station) 从 dict 中读取所用时间总和和次数，进行除法计算每次结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = defaultdict(int)</span><br><span class="line">        self.time = defaultdict(int)</span><br><span class="line">        self.traveling = dict()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIn</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.traveling[id] = (stationName, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOut</span><span class="params">(self, id: int, stationName: str, t: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        (prev_station, prev_t) = self.traveling[id]</span><br><span class="line">        <span class="keyword">del</span> self.traveling[id]</span><br><span class="line">        key = (prev_station, stationName)</span><br><span class="line">        self.count[key] += <span class="number">1</span></span><br><span class="line">        self.time[key] += (t-prev_t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAverageTime</span><span class="params">(self, startStation: str, endStation: str)</span> -&gt; float:</span></span><br><span class="line">        key = (startStation, endStation)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.time[key] / self.count[key]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = UndergroundSystem()</span></span><br><span class="line"><span class="comment"># obj.checkIn(id,stationName,t)</span></span><br><span class="line"><span class="comment"># obj.checkOut(id,stationName,t)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getAverageTime(startStation,endStation)</span></span><br></pre></td></tr></table></figure><h3 id="1262-Greatest-Sum-Divisible-by-Three"><a href="#1262-Greatest-Sum-Divisible-by-Three" class="headerlink" title="1262. Greatest Sum Divisible by Three"></a>1262. Greatest Sum Divisible by Three</h3><p>可以用单纯的数学方式做，先统计所有数字的和，然后遍历数字，找出余数为 1 和余数为 2 的数值，当总和余数为 1 时，则减去余数为1 的最小的数字，当总和余数为 2 时，则减去余数为 2 的最小的数字。需要注意比较余数为 1 和余数为2 要进行大小相比，如果 两个余数为2的数值之和小于余数为1 的数值，那么此时应该减去的数字为前者。</p><p>也可以采用动态规划做，维护一个 dp，分别存储余数为 0，1，2 的最大数字和，遍历数字，更新相加后的余数最大和，最后返回余数为0 的最大和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            tmp_dp = dp[:]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">                c_sum = tmp_dp[i] + n</span><br><span class="line">                dp[c_sum % <span class="number">3</span>] = max(dp[c_sum % <span class="number">3</span>], c_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSumDivThree</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    one := <span class="number">10000</span></span><br><span class="line">    two := <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        res += nums[i]</span><br><span class="line">        <span class="keyword">if</span> nums[i] % <span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">            two = min(two, one + nums[i])</span><br><span class="line">            one = min(one, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] % <span class="number">3</span> == <span class="number">2</span> &#123;</span><br><span class="line">            one = min(one, two + nums[i])</span><br><span class="line">            two = min(two, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> res % <span class="number">3</span> == <span class="number">0</span> &#123; <span class="keyword">return</span> res &#125;</span><br><span class="line">    <span class="keyword">if</span> res % <span class="number">3</span> == <span class="number">1</span> &#123; <span class="keyword">return</span> res - one &#125;</span><br><span class="line">    <span class="keyword">return</span> res - two</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1232-Check-If-It-Is-a-Straight-Line"><a href="#1232-Check-If-It-Is-a-Straight-Line" class="headerlink" title="1232. Check If It Is a Straight Line"></a>1232. Check If It Is a Straight Line</h3><p>一道数学题，先用前两个点来计算出斜率，然后遍历之后的点，验证斜率是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkStraightLine</span><span class="params">(self, coordinates: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        same_slop = <span class="keyword">True</span></span><br><span class="line">        last_slop = <span class="keyword">None</span></span><br><span class="line">        intial_point = coordinates[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> coordinates[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                slop = (point[<span class="number">1</span>] - intial_point[<span class="number">1</span>])/(point[<span class="number">0</span>] - intial_point[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">except</span> ZeroDivisionError: </span><br><span class="line">                slop = float(inf)</span><br><span class="line">            <span class="keyword">if</span> last_slop== <span class="keyword">None</span>:last_slop = slop</span><br><span class="line">            <span class="keyword">elif</span> slop == last_slop:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                same_slop = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> same_slop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1394-Find-Lucky-Integer-in-an-Array&quot;&gt;&lt;a href=&quot;#1394-Find-Lucky-Integer-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1394. Find Lucky Integ
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第13周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/27/2020-%E7%AC%AC13%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/27/2020-第13周-LeetCode-记录/</id>
    <published>2020-03-27T22:27:32.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1387-Sort-Integers-by-The-Power-Value"><a href="#1387-Sort-Integers-by-The-Power-Value" class="headerlink" title="1387. Sort Integers by The Power Value"></a>1387. Sort Integers by The Power Value</h3><p>给定一个区间，让你求出这个区间内所有数字的权重，然后按照权重进行排序，权重计算方式为：</p><ul><li>如果 x 是偶数，那么 x = x / 2</li><li>如果 x 是奇数，那么 x = 3 * x + 1</li></ul><p>在计算过程中，肯定会有重复计算，所以使用 dict 记录已经计算过的数值权重。当计算完成后，对结果进行排序，优先使用权重排序，如果权重相同，则按照数值本身大小进行排序，取第 k 个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKth</span><span class="params">(self, lo, hi, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lo: int</span></span><br><span class="line"><span class="string">        :type hi: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> self.memo:</span><br><span class="line">                <span class="keyword">return</span> self.memo[n]</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">                ans=helper((n*<span class="number">3</span>+<span class="number">1</span>)/<span class="number">2</span>)+<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans=helper(n/<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">            self.memo[n]=ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        tmp=sorted([[helper(n),n] <span class="keyword">for</span> n <span class="keyword">in</span> range(lo,hi+<span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">return</span> tmp[k<span class="number">-1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1389-Create-Target-Array-in-the-Given-Order"><a href="#1389-Create-Target-Array-in-the-Given-Order" class="headerlink" title="1389. Create Target Array in the Given Order"></a>1389. Create Target Array in the Given Order</h3><p>考察 insert 动作，可以直接用 insert 函数来做；也可以通过对 list 进行切片实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTargetArray</span><span class="params">(self, nums, index)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type index: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> n, i <span class="keyword">in</span> zip(nums, index):</span><br><span class="line">            target.insert(i, n)</span><br><span class="line">            <span class="comment"># target = target[:i] + [n] + target[i:]</span></span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure><h3 id="1390-Four-Divisors"><a href="#1390-Four-Divisors" class="headerlink" title="1390. Four Divisors"></a>1390. Four Divisors</h3><p>数学题，如果一个数的因数恰好是 4个因数，那么返回这4个因数的和，直接暴力求解会超时。</p><p>如果整数 x 有因数 y，那么也必有因数 x/y，并且 y 和 x/y 中至少有一个不大于 sqrt(x)。这样我们只需要在 [1, sqrt(x)] 的区间内枚举可能为整数 x 的因数 y，并通过 x/y 得到整数 x 的其它因数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumFourDivisors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">                s = set()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1</span> + int(math.sqrt(n))):</span><br><span class="line">                    <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                        s.add(i)</span><br><span class="line">                        s.add(n / i)</span><br><span class="line">                    <span class="keyword">if</span> len(s) &gt; <span class="number">4</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                cache[n] = sum(s) <span class="keyword">if</span> len(s) == <span class="number">4</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> cache[n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(map(fn, nums))</span><br></pre></td></tr></table></figure><h3 id="1386-Cinema-Seat-Allocation"><a href="#1386-Cinema-Seat-Allocation" class="headerlink" title="1386. Cinema Seat Allocation"></a>1386. Cinema Seat Allocation</h3><p>使用位运算，先按照每行拆分，统计出已经被预约的位置，置为1，然后分别与可能安排的3种方式进行与运算，如果为0 ，则表示可以安排。最终将结果求和。需要注意如果一行内所有作为都未安排的情况，此时应该按照每行 2 种方式相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfFamilies</span><span class="params">(self, n, reservedSeats)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type reservedSeats: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        seats = collections.defaultdict(int) </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row, col <span class="keyword">in</span> reservedSeats:</span><br><span class="line">            seats[row] = seats[row] | (<span class="number">1</span> &lt;&lt; (col<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> bin(seats[<span class="number">3</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> reserved <span class="keyword">in</span> seats.values():</span><br><span class="line">            curr = <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0111100000'</span>, <span class="number">2</span>)) == <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0000011110'</span>, <span class="number">2</span>)) == <span class="number">0</span></span><br><span class="line">            curr += (reserved &amp; int(<span class="string">'0001111000'</span>, <span class="number">2</span>)) == <span class="number">0</span> <span class="keyword">and</span> curr == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            res += curr    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">2</span> * (n - len(seats))</span><br></pre></td></tr></table></figure><h3 id="1329-Sort-the-Matrix-Diagonally"><a href="#1329-Sort-the-Matrix-Diagonally" class="headerlink" title="1329. Sort the Matrix Diagonally"></a>1329. Sort the Matrix Diagonally</h3><p>考察排序和数组，需要先找到对角线的数字集，可以使用（每行的索引 - 每列的索引）来表示，因为对角线上的数字该值是相同的，找到后对起进行排序，然后再次遍历填入排序后的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diagonalSort</span><span class="params">(self, mat)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type mat: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        diag = defaultdict(list)</span><br><span class="line">        N,M = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                diag[i-j].append(mat[i][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> diag.keys():</span><br><span class="line">            diag[k].sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                mat[i][j] = diag[i-j].pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1387-Sort-Integers-by-The-Power-Value&quot;&gt;&lt;a href=&quot;#1387-Sort-Integers-by-The-Power-Value&quot; class=&quot;headerlink&quot; title=&quot;1387. Sort Integer
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 《Pingmesh: A Large-Scale System for Data Center Network Latency Measurement and Analysis》</title>
    <link href="https://zdyxry.github.io/2020/03/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E3%80%8APingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis%E3%80%8B/"/>
    <id>https://zdyxry.github.io/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/</id>
    <published>2020-03-26T20:24:09.000Z</published>
    <updated>2020-05-22T14:29:41.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们内部产品中，一直有关于网络性能数据监控需求，我们之前是直接使用 <code>ping</code> 命令收集结果，每台服务器去 ping (N-1) 台，也就是 N^2 的复杂度，稳定性和性能都存在一些问题，最近打算对这部分进行重写，在重新调研期间看到了 Pingmesh 这篇论文，Pingmesh 是微软用来监控数据中心网络情况而开发的软件，通过阅读这篇论文来学习下他们是怎么做的。</p><p>数据中心自身是极为复杂的，其中网络涉及到的设备很多就显得更为复杂，一个大型数据中心都有成百上千的节点、网卡、交换机、路由器以及无数的网线、光纤。在这些硬件设备基础上构建了很多软件，比如搜索引擎、分布式文件系统、分布式存储等等。在这些系统运行过程中，面临一些问题：如何判断一个故障是网络故障？如何定义和追踪网络的 SLA？出了故障如何去排查？</p><p>基于这几点问题，微软设计开发了 Pingmesh，用来记录和分析数据中心的网络情况。在微软内部 Pingmesh 每天会记录 24TB 数据，进行 2k 亿次 ping 探测，通过这些数据，微软可以很好的进行网络故障判定和及时的修复。</p><h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>常见的数据中心网络拓扑：</p><img src="/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/pingmesh-1.png" title="pingmesh-1"><p>网络延时计算方式：server A 发送消息到 server B 接受消息的时间。最终使用 RTT 时间，RTT 一个好处是绝对时间，与时钟不相关。</p><p>在大多数情况下，大家不会去关心延时具体是什么导致的，都是直接归结于网络原因，让网络团队去排查，实际上是浪费了很多人力成本。延时变高有很多原因：CPU 繁忙、服务自身 Bug、网络原因等等。往往丢包会伴随着延时升高，因为丢包意味着会发生重传，所以丢包也是需要观察的重点。</p><p>因为 Pingmesh 运行在微软内部，所以依托于微软自己的基础架构，有自动化管理系统 Autopilot，有大数据系统 Cosmos，也有类似于 SQL 的脚本语言 SCOPE。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>根据上面的需求，Pingmesh 先评估了现有的开源工具，不符合的原因有很多，大多数工具都是以命令行形式呈现，一般是出现故障了去使用工具排查，而且工具提供的数据也不全面，有可能正在运行工具问题已经解决了。当然这并不是说已有的工具没有用，只能说不适合 Pingmesh。</p><p>Pingmesh 是松耦合设计，每个组件都是可以独立运行的，分为 3 个组件。在设计的时候需要考虑几点：</p><ul><li>因为要运行在所有的 server 上，所以不能占用太多的计算资源或网络资源</li><li>需要是灵活配置的且高可用的的</li><li>记录的数据需要进行合理的汇总分析</li></ul><p>Pingmesh 架构设计：</p><img src="/2020/03/26/论文阅读-《Pingmesh-A-Large-Scale-System-for-Data-Center-Network-Latency-Measurement-and-Analysis》/pingmesh-2.png" title="pingmesh-2"><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller 主要负责生成 pinglist 文件，这个文件是 XML 格式的，pinglist 的生成是很重要的，需要根据实际的数据中心网络拓扑进行及时更新。</p><p>在生成 pinglist 时， Controller 为了避免开销，分为3 个级别：</p><ol><li>在机架内部，让所有的 server 互相 ping，每个 server ping （N-1） 个 server</li><li>在机架之间，则每个机架选几个 server ping 其他机架的 server，保证 server 所属的 ToR 不同</li><li>在数据中心之间，则选择不同的数据中心的几个不同机架的 server 来ping </li></ol><p>Controller 在生成 pinglist 文件后，通过 HTTP 提供出去，Agent 会定期获取 pinglist 来更新 agent 自己的配置，也就是我们说的“拉”模式。Controller 需要保证高可用，因此需要在 VIP 后面配置多个实例，每个实例的算法一致，pinglist 文件内容也一致，保证可用性。</p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>微软数据中心的每个 server 都会运行 Agent，用来真正做 ping 动作的服务。为了保证获取结果与真实的服务一致，Pingmesh 没有采用 ICMP ping，而是采用的 TCP/HTTP ping。所以每个 Agent 即是 Server 也是 Client。每个 ping 动作都开启一个新的连接，主要为了减少 Pingmesh 造成的 TCP 并发。</p><p>Agent 要保证自己是可靠的，不会造成一些严重的后果，其次要保证自己使用的资源要足够的少，毕竟要运行在每个 server 上。两个server ping 的周期最小是 10s，Packet 大小最大 64kb。针对灵活配置的需求，Agent 会定期去 Controller 上拉取 pinglist，如果 3 次拉取不到，那么就会删除本地已有 pinglist，停止 ping 动作。</p><p>在进行 ping 动作后，会将结果保存在内存中，当保存结果超过一定阈值或者到达了超时时间，就将结果上传到 Cosmos 中用于分析，如果上传失败，会有重试，超过重试次数则将数据丢弃，保证 Agent 的内存使用。</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>拿到了数据就要进行分析，Pingmesh 会以 10min，1hour，1天的粒度进行统计汇总，数据的实时性最快也就是 10min ，Pingmesh 还借助内部的基础设施能够拿到 5min 级别的数据结果，算是一种“实时”监控吧。</p><h2 id="网络状况"><a href="#网络状况" class="headerlink" title="网络状况"></a>网络状况</h2><p>根据论文中提到的，不同负载的数据中心的数据是有很大差异的，在 P99.9 时延时大概在 10-20ms，在 P99.99 延时大概在100+ms 。关于丢包率的计算，因为没有用 ICMP ping 的方式，所以这里是一种新的计算方式，（一次失败 + 二次失败）次数/（成功次数）= 丢包率。这里是每次 ping 的 timeout 是 3s，windows 重传机制等待时间是 3s，下一次 ping 的 timeout 时间是 3s，加一起也就是 9s。所以这里跟 Agent 最小探测周期 10s 是有关联的。二次失败的时间就是 （2 * RTT）+ RTO 时间。</p><p>Pingmesh 的判断依据有两个，如果超过就报警：</p><ul><li>延时超过 5ms</li><li>丢包率超过 10^(-3) </li></ul><p>在论文中还提到了其他的网络故障场景，交换机的静默丢包。有可能是 A 可以连通 B，但是不能连通 C。还有可能是 A 的 i 端口可以连通 B 的 j 端口，但是 A 的 m 端口不能连通 B 的 j 端口，这些都属于交换机的静默丢包的范畴。Pingmesh 通过统计这种数据，然后给交换机进行打分，当超过一定阈值时就会通过 Autopilot 来自动重启交换机，恢复交换机的能力。</p><h2 id="经验学习"><a href="#经验学习" class="headerlink" title="经验学习"></a>经验学习</h2><ol><li>找到可信数据，只有数据来源可信，那么分析才是有效的</li><li>让服务作为 daemon 运行，保证持续的收集数据</li><li>松耦合设计，每个组件都可以独立工作</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我们自己的系统是有 Prometheus 这样的监控系统的，但是当遇到交换机级别的间歇性故障时，Prometheus 也是故障的状态，所以也就不会收集 exporter 汇报的数据，也就更没办法产生告警了。所以如果遇到那种长时间持续的故障反而是好事，至少我们有一个足够的状态去排查哪里出了问题，否则真的是间歇性故障仅仅依靠 ping, traceroute, iperf, netstat 之类的工具去排查是没什么效果的，只有我们知道过去一段时间的网络情况，才能去排查。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p139.pdf" target="_blank" rel="noopener">https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p139.pdf</a></li><li><a href="http://ninjadq.com/2017/04/01/linux-rto" target="_blank" rel="noopener">http://ninjadq.com/2017/04/01/linux-rto</a></li><li><a href="https://yi-ran.github.io/2019/03/27/Pingmesh-SIGCOMM-2015/" target="_blank" rel="noopener">https://yi-ran.github.io/2019/03/27/Pingmesh-SIGCOMM-2015/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在我们内部产品中，一直有关于网络性能数据监控需求，我们之前是直接使用 &lt;code&gt;ping&lt;/code&gt; 命令收集结果，每台服务器去 pin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 第12周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/20/2020-%E7%AC%AC12%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/20/2020-第12周-LeetCode-记录/</id>
    <published>2020-03-20T20:08:24.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1380-Lucky-Numbers-in-a-Matrix"><a href="#1380-Lucky-Numbers-in-a-Matrix" class="headerlink" title="1380. Lucky Numbers in a Matrix"></a>1380. Lucky Numbers in a Matrix</h3><p>给一个二维数组，分别求每行最小值，每列最大值，然后找到幸运数字。（遇到二维数组善用 zip 来解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">luckyNumbers</span> <span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mins = &#123;min(rows) <span class="keyword">for</span> rows <span class="keyword">in</span> matrix&#125;</span><br><span class="line">        maxes = &#123;max(columns) <span class="keyword">for</span> columns <span class="keyword">in</span> zip(*matrix)&#125;</span><br><span class="line">        <span class="keyword">return</span> list(mins &amp; maxes)</span><br></pre></td></tr></table></figure><h3 id="1381-Design-a-Stack-With-Increment-Operation"><a href="#1381-Design-a-Stack-With-Increment-Operation" class="headerlink" title="1381. Design a Stack With Increment Operation"></a>1381. Design a Stack With Increment Operation</h3><p>相比与 stack 多了一个 inc 操作，一般想法是每次遇到 inc 操作，那么我们遍历一次，将对应值进行加操作就可以了，但是这个操作是 O(n) 的，我们可以使用一个辅助 list ，保存 inc 的数值，当 pop 的时候，进行相加处理。</p><p>以示例展示处理过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]</span><br><span class="line">[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack, inc</span><br><span class="line">[1], [0]</span><br><span class="line">[1,2], [0]</span><br><span class="line">[1], [0]</span><br><span class="line">[1,2], [0,0]</span><br><span class="line">[1,2,3], [0,0,0]</span><br><span class="line">[1,2,3], [0,0, 100]</span><br><span class="line">[1,2,3], [0, 100, 100]</span><br><span class="line">[1,2], [0,200]</span><br><span class="line">[1], [200]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxSize)</span>:</span></span><br><span class="line">        self.n = maxSize</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.inc = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.inc) &lt; self.n:</span><br><span class="line">            self.stack.append(x)</span><br><span class="line">            self.inc.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.inc: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(self.inc) &gt; <span class="number">1</span>:</span><br><span class="line">            self.inc[<span class="number">-2</span>] += self.inc[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop() + self.inc.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, k, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.inc:</span><br><span class="line">            self.inc[min(k, len(self.inc)) - <span class="number">1</span>] += val</span><br></pre></td></tr></table></figure><h3 id="1382-Balance-a-Binary-Search-Tree"><a href="#1382-Balance-a-Binary-Search-Tree" class="headerlink" title="1382. Balance a Binary Search Tree"></a>1382. Balance a Binary Search Tree</h3><p>给一个二叉搜索树，使其变为平衡二叉搜索树，只需要一次性操作，不需要时刻考虑每次插入后的变化，根据二叉搜索树特性将其进行中序遍历，得到的结果是升序排序的，然后通过升序排序的结果构建平衡二叉搜索树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balanceBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="string">"""inorder depth-first traverse bst"""</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">            dfs(node.left)</span><br><span class="line">            value.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        </span><br><span class="line">        value = [] <span class="comment">#collect values</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(x)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            k = len(x)//<span class="number">2</span></span><br><span class="line">            ans = TreeNode(x[k])</span><br><span class="line">            ans.left = tree(x[:k])</span><br><span class="line">            ans.right = tree(x[k+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tree(value)</span><br></pre></td></tr></table></figure><h3 id="901-Online-Stock-Span"><a href="#901-Online-Stock-Span" class="headerlink" title="901. Online Stock Span"></a>901. Online Stock Span</h3><p>维护一个单调栈，遍历 prices：如果 price 比前一天要大，那么将前一天移除，并将前一天的权重与当天相加；如果 price 比前一天要小，那么直接追加当天 price，并将其权重置为 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, price)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type price: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        weight = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>] &lt;= price:</span><br><span class="line">            weight += self.stack.pop()[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">print</span> price, self.stack</span><br><span class="line">        self.stack.append((price, weight))</span><br><span class="line">        <span class="keyword">print</span> self.stack</span><br><span class="line">        <span class="keyword">return</span> weight</span><br></pre></td></tr></table></figure><h3 id="897-Increasing-Order-Search-Tree"><a href="#897-Increasing-Order-Search-Tree" class="headerlink" title="897. Increasing Order Search Tree"></a>897. Increasing Order Search Tree</h3><p>考察中序遍历，使用 dfs 直接求解，然后重新构造二叉搜索树。<br>也可以直接改动原有树结构，同样是中序遍历，当我们遍历到一个节点时，把它的左孩子设为空，并将其本身作为上一个遍历到的节点的右孩子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                inorder(node.left)</span><br><span class="line">                node.left = <span class="keyword">None</span></span><br><span class="line">                self.cur.right = node</span><br><span class="line">                self.cur = node</span><br><span class="line">                inorder(node.right)</span><br><span class="line"></span><br><span class="line">        ans = self.cur = TreeNode(<span class="keyword">None</span>)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> ans.right</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            dfs(node.left)</span><br><span class="line">            values.append(node.val)</span><br><span class="line">            dfs(node.right)</span><br><span class="line">        values = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        tmp = TreeNode(<span class="number">0</span>)</span><br><span class="line">        root = tmp</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> values:</span><br><span class="line">            tmp.right = TreeNode(node)</span><br><span class="line">            tmp = tmp.right</span><br><span class="line">        <span class="keyword">return</span> root.right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1380-Lucky-Numbers-in-a-Matrix&quot;&gt;&lt;a href=&quot;#1380-Lucky-Numbers-in-a-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1380. Lucky Numbers in a Matrix&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>理解网卡混杂模式</title>
    <link href="https://zdyxry.github.io/2020/03/18/%E7%90%86%E8%A7%A3%E7%BD%91%E5%8D%A1%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zdyxry.github.io/2020/03/18/理解网卡混杂模式/</id>
    <published>2020-03-18T19:49:04.000Z</published>
    <updated>2020-05-22T14:29:41.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我自己会在虚拟机验证一些网络配置，比如在虚拟机内部创建 OVS Bridge 之类的操作。当 Hypervisor 是 vSphere ESXi 时，通常需要在 ESXi 的虚拟交换机上开启混杂模式，今天来说一说网络的混杂模式。</p><h2 id="网卡工作模式"><a href="#网卡工作模式" class="headerlink" title="网卡工作模式"></a>网卡工作模式</h2><p>网卡有以下几种<a href="https://www.nowcoder.com/questionTerminal/242b0842bff9497988bda2676476dea3?toCommentId=9762" target="_blank" rel="noopener">工作模式</a>，通常网卡会配置广播和多播模式：</p><ol><li>广播模式（Broad Cast Model）:它的物理地址地址是 0Xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧。它将会接收所有目的地址为广播地址的数据包，一般所有的网卡都会设置为这个模式</li><li>多播传送（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员。当数据包的目的地址为多播地址，而且网卡地址是属于那个多播地址所代表的多播组时，网卡将接纳此数据包，即使一个网卡并不是一个多播组的成员，程序也可以将网卡设置为多播模式而接收那些多播的数据包。</li><li>直接模式（Direct Model）:工作在直接模式下的网卡只接收目地址是自己 Mac 地址的帧。只有当数据包的目的地址为网卡自己的地址时，网卡才接收它。</li><li>混杂模式（Promiscuous Model）:工作在混杂模式下的网卡接收所有的流过网卡的帧，抓包程序就是在这种模式下运行的。网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，网卡将接受同一网络内所有所发送的数据包，这样就可以到达对于网络信息监视捕获的目的。它将接收所有经过的数据包，这个特性是编写网络监听程序的关键。</li></ol><h2 id="混杂模式"><a href="#混杂模式" class="headerlink" title="混杂模式"></a>混杂模式</h2><img src="/2020/03/18/理解网卡混杂模式/nic1.png" title="nic1"><p>混杂模式（promiscuous mode）是计算机网络中的术语。是指一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。</p><blockquote><p>一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。网卡的混杂模式一般在网络管理员分析网络数据作为网络故障诊断手段时用到，同时这个模式也被网络黑客利用来作为网络数据窃听的入口。在Linux操作系统中设置网卡混杂模式时需要管理员权限。在Windows操作系统和Linux操作系统中都有使用混杂模式的抓包工具，比如著名的开源软件Wireshark。</p></blockquote><h3 id="查看网卡是否开启混杂模式"><a href="#查看网卡是否开启混杂模式" class="headerlink" title="查看网卡是否开启混杂模式"></a>查看网卡是否开启混杂模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 21:06:51 ~]$ifconfig ens192</span><br><span class="line">ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.17.88  netmask 255.255.240.0  broadcast 192.168.31.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe99:4eb2  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:99:4e:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 163692  bytes 10031607 (9.5 MiB)</span><br><span class="line">        RX errors 0  dropped 110  overruns 0  frame 0</span><br><span class="line">        TX packets 1751  bytes 175974 (171.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@node1 21:06:53 ~]$ifconfig ens192 promisc</span><br><span class="line">[root@node1 21:06:57 ~]$ifconfig ens192</span><br><span class="line">ens192: flags=4419&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.17.88  netmask 255.255.240.0  broadcast 192.168.31.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe99:4eb2  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:99:4e:b2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 171193  bytes 10482754 (9.9 MiB)</span><br><span class="line">        RX errors 0  dropped 110  overruns 0  frame 0</span><br><span class="line">        TX packets 1776  bytes 179091 (174.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>如果在虚拟化场景下，就像我在开头提到的，往往需要在 vSwitch 上开启混杂模式用于开发测试。但是大部分开启混杂模式都是为了抓包。如果二层是使用的集线器，那么只要网卡打开了混杂模式，就可以接受到其他主机发送的数据包，如果二层使用的是交换机，那么往往需要在交换机上配置镜像模式才可以抓到包，这里是需要注意的。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>关于 tcpdump 抓包和混杂模式的关系，这里引用wuyangchun博客的两个流程图来说明。</p><img src="/2020/03/18/理解网卡混杂模式/nic2.png" title="nic2"><p>混杂模式是为了让数据包能够完成步骤 1，进入到 OS 中，tcpdump 真正抓到的包是在下图中的第 15 步。</p><img src="/2020/03/18/理解网卡混杂模式/nic3.png" title="nic3"><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F</a></li><li><a href="https://segmentfault.com/a/1190000008836467" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008836467</a></li><li><a href="https://www.nowcoder.com/questionTerminal/242b0842bff9497988bda2676476dea3?toCommentId=9762" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/242b0842bff9497988bda2676476dea3?toCommentId=9762</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我自己会在虚拟机验证一些网络配置，比如在虚拟机内部创建 OVS Bridge 之类的操作。当 Hypervisor 是 vSphere ES
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第11周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/13/2020-%E7%AC%AC11%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/13/2020-第11周-LeetCode-记录/</id>
    <published>2020-03-13T21:09:45.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1370-Increasing-Decreasing-String"><a href="#1370-Increasing-Decreasing-String" class="headerlink" title="1370. Increasing Decreasing String"></a>1370. Increasing Decreasing String</h3><p>题目描述很复杂，但其实就是排序和字典，先顺序遍历再反向遍历。（熟练使用 Counter）</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        set_s = set()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">set_s.add(c)</span><br><span class="line">        characters = sorted(set_s)</span><br><span class="line"></span><br><span class="line">        d = collections.Counter(s)</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> sum(d.values()) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> characters:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> s <span class="keyword">and</span> d[c] &gt; <span class="number">0</span>:</span><br><span class="line">                    res += c</span><br><span class="line">                    d[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> characters[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> s <span class="keyword">and</span> d[c] &gt; <span class="number">0</span>:</span><br><span class="line">                    res += c</span><br><span class="line">                    d[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">sMap[<span class="keyword">string</span>(c)]++</span><br><span class="line">&#125;</span><br><span class="line">chars := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c, _ := <span class="keyword">range</span> sMap &#123;</span><br><span class="line">chars = <span class="built_in">append</span>(chars, <span class="keyword">string</span>(c))</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(chars)</span><br><span class="line">res := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(sMap) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> chars &#123;</span><br><span class="line"><span class="keyword">if</span> sMap[chars[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">res += <span class="keyword">string</span>(chars[i])</span><br><span class="line">sMap[chars[i]]--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(sMap, chars[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> chars &#123;</span><br><span class="line"><span class="keyword">if</span> sMap[chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">res += <span class="keyword">string</span>(chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>])</span><br><span class="line">sMap[chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>]]--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(sMap, chars[<span class="built_in">len</span>(chars)-i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts"><a href="#1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts" class="headerlink" title="1371. Find the Longest Substring Containing Vowels in Even Counts"></a>1371. Find the Longest Substring Containing Vowels in Even Counts</h3><p>采用状态压缩的方式，将每个元音字母出现次数的奇偶作为一种状态，1 表示为奇数次，0表示偶数次，那么一共有 2^5=32 种状态。遍历所有的字符，如果当前字符是元音字母，那么就进行异或操作，并记录此时状态。如果子串[0，i]与字串[0,j]状态相同，那么字串[i+1,j]的状态一定是0，因此可以记录每个状态第一次出现的位置，此后再出现该状态时相减即可。</p><p>来源：<a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/</a></p><p>需要将状态 0 出现的位置设置为 -1，比如 “ele” ，当循环到第一个 e 时，e 出现奇数次，当循环到第二个 e 时，e 出现偶数次，此时 “ele” 符合条件，且状态为 0，那么需要用第二个 e 的索引值减去状态0 出现的位置，如果状态0 为空，那么第二个e 的状态0就会被当作第一次出现记录下来，导致结果错误，应为 2 - (-1) = 3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vowels = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">2</span>, <span class="string">'i'</span>: <span class="number">4</span>, <span class="string">'o'</span>: <span class="number">8</span>, <span class="string">'u'</span>: <span class="number">16</span>&#125;</span><br><span class="line">        d, n, r = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> vowels:</span><br><span class="line">                n ^= vowels[c]</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[n] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = max(r, i - d[n])</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h3 id="1372-Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="1372. Longest ZigZag Path in a Binary Tree"></a>1372. Longest ZigZag Path in a Binary Tree</h3><p>二叉树中的最长交错路径，使用 dfs 求解，dfs 返回值是[node.left 的最大长度，node.right 的最大长度，node 的最大长度]。<br>这里需要考虑当 root 为 None 时的返回值是多少，因为每递归一层，都需要在上一层将结果 +1 ，如果 root == None，那么 -1 + 1 = 0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestZigZag</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">            left, right = dfs(root.left), dfs(root.right)</span><br><span class="line">            <span class="keyword">return</span> [left[<span class="number">1</span>] + <span class="number">1</span>, right[<span class="number">0</span>] + <span class="number">1</span>, max(left[<span class="number">1</span>]+<span class="number">1</span>, right[<span class="number">0</span>]+<span class="number">1</span>, left[<span class="number">2</span>], right[<span class="number">2</span>])]</span><br><span class="line">        <span class="keyword">return</span> dfs(root)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>换一种方式比较好理解，传入两个参数：count 和当前所在的是 node 的 left 还是 right，如果上一层是 left，那么就在 node.right 将 count +1，否则将 count 置为1重新计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestZigZag</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, count, direction)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> count &gt; self.res:</span><br><span class="line">                    self.res = count</span><br><span class="line">                <span class="keyword">if</span> direction == <span class="string">'left'</span>:</span><br><span class="line">                    dfs(node.right, count+<span class="number">1</span>, <span class="string">'right'</span>)</span><br><span class="line">                    dfs(node.left, <span class="number">1</span>, <span class="string">'left'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dfs(node.left, count+<span class="number">1</span>, <span class="string">'left'</span>)</span><br><span class="line">                    dfs(node.right, <span class="number">1</span>, <span class="string">'right'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            dfs(root.left, <span class="number">1</span>, <span class="string">'left'</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            dfs(root.right, <span class="number">1</span>, <span class="string">'right'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1375-Bulb-Switcher-III"><a href="#1375-Bulb-Switcher-III" class="headerlink" title="1375. Bulb Switcher III"></a>1375. Bulb Switcher III</h3><p>属于那种题目很复杂，做起来很简单的类型，只需要判断当前最大值与当前索引是否相当即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTimesAllBlue</span><span class="params">(self, light)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type light: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        max_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(light):</span><br><span class="line">            max_idx = max(max_idx, b)</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> == max_idx:</span><br><span class="line">                <span class="keyword">print</span> b</span><br><span class="line">                res+= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1376-Time-Needed-to-Inform-All-Employees"><a href="#1376-Time-Needed-to-Inform-All-Employees" class="headerlink" title="1376. Time Needed to Inform All Employees"></a>1376. Time Needed to Inform All Employees</h3><p>使用 DFS 求解，先确定每个员工及它所负责通知的员工，再根据 headID 递归求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfMinutes</span><span class="params">(self, n, headID, manager, informTime)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type headID: int</span></span><br><span class="line"><span class="string">        :type manager: List[int]</span></span><br><span class="line"><span class="string">        :type informTime: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        children = [[] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i, m <span class="keyword">in</span> enumerate(manager):</span><br><span class="line">            <span class="keyword">if</span> m &gt;= <span class="number">0</span>: children[m].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> max([dfs(j) <span class="keyword">for</span> j <span class="keyword">in</span> children[i]] <span class="keyword">or</span> [<span class="number">0</span>]) + informTime[i]</span><br><span class="line">        <span class="keyword">return</span> dfs(headID)</span><br></pre></td></tr></table></figure><p>也可以自底向上求解，为避免重复计算，将每次计算结果记录下来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfMinutes</span><span class="params">(self, n, headID, manager, informTime)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type headID: int</span></span><br><span class="line"><span class="string">        :type manager: List[int]</span></span><br><span class="line"><span class="string">        :type informTime: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> manager[i] != <span class="number">-1</span>:</span><br><span class="line">                informTime[i] += dfs(manager[i])</span><br><span class="line">                manager[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> informTime[i]</span><br><span class="line">        <span class="keyword">return</span> max(map(dfs, range(n)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1370-Increasing-Decreasing-String&quot;&gt;&lt;a href=&quot;#1370-Increasing-Decreasing-String&quot; class=&quot;headerlink&quot; title=&quot;1370. Increasing Decreasin
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SR-IOV 基本概念</title>
    <link href="https://zdyxry.github.io/2020/03/12/SR-IOV-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://zdyxry.github.io/2020/03/12/SR-IOV-基本概念/</id>
    <published>2020-03-12T23:04:27.000Z</published>
    <updated>2020-05-22T14:29:41.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周了解了 RDMA 的基础概念之后，发现在 KVM 平台无需其他配置就可使用，但是在 vSphere 场景下，需要面临一个取舍，其中的一个选择就是 SR-IOV ，今天来了解下 SR-IOV 。</p><h2 id="SR-IOV"><a href="#SR-IOV" class="headerlink" title="SR-IOV"></a>SR-IOV</h2><img src="/2020/03/12/SR-IOV-基本概念/sriov1.png" title="sriov1"><p>SR-IOV 全称 <code>Single Root I/O Virtualization</code>，是 Intel 在 2007年提出的一种基于硬件的虚拟化解决方案。</p><p>在虚拟化场景中，CPU 与内存是最先解决的，但是 I/O 设备一直没有很好的解决办法，Intel 有 VT-d（Virtualization Technology for Directed I/O）可以将物理服务器的 PCIe 设备直接提供给虚拟机使用，也就是我们常说的“直通”（passthrough），但是直通面临一个问题是 PCIe 设备只能给一个虚拟机使用，其他虚拟机就只能干瞪眼，这肯定是不行的，所以有了 SR-IOV，一个物理设备可以虚拟出多个虚拟设备给虚拟机使用。</p><p>SR-IOV 是一种规范，使得单根端口下的单个快速外围组件互连 (PCIe) 物理设备显示为管理程序或客户机操作系统的多个单独的物理设备，既有直通设备的性能优势，又可以支持多个虚拟机，一举两得。</p><img src="/2020/03/12/SR-IOV-基本概念/sriov2.png" title="sriov2"><p>SR-IOV 使用 physical functions (PF) 和 virtual functions (VF) 为 SR-IOV 设备管理全局功能。</p><ul><li>PF 包含SR-IOV 功能的完整PCIe设备，PF 作为普通的PCIe 设备被发现、管理和配置 。PF 通过分配VF 来配置和管理 SR-IOV 功能。禁用SR-IOV后，主机将在一个物理网卡上创建一个 PF。</li><li>VF 是轻量级 PCIe 功能（I/O 处理）的 PCIe 设备，每个 VF 都是通过 PF 来生成管理的，VF 的具体数量限制受限于 PCIe 设备自身配置及驱动程序的支持，启用S​​R-IOV后，主机将在一个物理NIC上创建单个PF和多个VF。 VF的数量取决于配置和驱动程序支持。</li></ul><blockquote><p>每个 SR-IOV 设备都可有一个 PF(Physical Functions)，并且每个 PF 最多可有64,000个与其关联的 VF(Virtual Function)。PF 可以通过寄存器创建 VF，这些寄存器设计有专用于此目的的属性。一旦在 PF 中启用了 SR-IOV，就可以通过 PF 的总线、设备和功能编号（路由 ID）访问各个 VF 的 PCI 配置空间。</p><p>每个 VF 都具有一个 PCI 内存空间，用于映射其寄存器集。VF设备驱动程序对寄存器集进行操作以启用其功能，并且显示为实际存在的PCI设备。创建 VF 后，可以直接将其指定给虚拟机或各个应用程序。此功能使得虚拟功能可以共享物理设备，并在没有CPU和虚拟机管理程序软件开销的情况下执行 I/O。</p></blockquote><h3 id="SR-IOV-with-RDMA"><a href="#SR-IOV-with-RDMA" class="headerlink" title="SR-IOV with RDMA"></a>SR-IOV with RDMA</h3><p>上面介绍了 SR-IOV 的基本概念，现在来说说什么时候会用到 SR-IOV，上周说我们产品中使用了 RDMA，那么在多种虚拟化平台下要想统一支持是比较困难的，KVM 是最轻松的，vSphere 就面临一个选择，SR-IOV 方式支持 vs vRDMA。</p><img src="/2020/03/12/SR-IOV-基本概念/sriov3.png" title="sriov3"><p>其中 SR-IOV 支持方式就如前面提到的概念一样，大概需要如下配置：</p><ul><li>在 BIOS 中启用网卡的 SR-IOV 功能</li><li>在 ESXi 安装 MFT vib 工具，用于管理和配置网卡 FW</li><li>在网卡 FW 中开启 SR-IOV，设置最大的 VF 数量</li><li>在 ESXi 网卡驱动中，开启 SRIOV，设置 VF 数量，需要重启 ESXi</li><li>创建对应的 vSwitch 并将 PF 作为上联网卡接入</li><li>创建虚拟机，添加 VF 作为 SR-IOV 网络适配器，并选择 PF 所在的 vSwitch 即可</li></ul><img src="/2020/03/12/SR-IOV-基本概念/sriov4.png" title="sriov4"><p>vRDMA 是 vSphere 提供的一种软件模拟 RDMA 的方式，但是他的性能受到很大影响，我们使用 RDMA 就是为了提高性能，所以这种就不会考虑了。<br>具体性能对比如下：</p><img src="/2020/03/12/SR-IOV-基本概念/sriov5.png" title="sriov5"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="SR-IOV-优点"><a href="#SR-IOV-优点" class="headerlink" title="SR-IOV 优点"></a>SR-IOV 优点</h3><ul><li>性能好</li><li>减少主机 CPU 消耗</li></ul><h3 id="SR-IOV-缺点"><a href="#SR-IOV-缺点" class="headerlink" title="SR-IOV 缺点"></a>SR-IOV 缺点</h3><ul><li>虚拟机使用 VF 后无法进行内存超分、快照、热迁移等高级功能</li><li>配置管理复杂</li></ul><p>不知道是不是接触的少，在日常中几乎没有遇到过使用 SR-IOV 的客户，只有少数客户会提出要有 SR-IOV 的需求，看到在 K8s 场景下有对应的 CNI 插件可以做到 SR-IOV 的管理，之后找时间看看是如何做到的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://octo.vmware.com/wp-content/uploads/2012/09/RDMAonvSphere.pdf" target="_blank" rel="noopener">https://octo.vmware.com/wp-content/uploads/2012/09/RDMAonvSphere.pdf</a></li><li><a href="https://docs.mellanox.com/pages/releaseview.action?pageId=15055422" target="_blank" rel="noopener">https://docs.mellanox.com/pages/releaseview.action?pageId=15055422</a></li><li><a href="https://en.wikipedia.org/wiki/Single-root_input/output_virtualization" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Single-root_input/output_virtualization</a></li><li><a href="https://github.com/intel/sriov-cni" target="_blank" rel="noopener">https://github.com/intel/sriov-cni</a></li><li><a href="https://github.com/hustcat/sriov-cni" target="_blank" rel="noopener">https://github.com/hustcat/sriov-cni</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上周了解了 RDMA 的基础概念之后，发现在 KVM 平台无需其他配置就可使用，但是在 vSphere 场景下，需要面临一个取舍，其中的一个
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第10周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/06/2020-%E7%AC%AC10%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/06/2020-第10周-LeetCode-记录/</id>
    <published>2020-03-06T21:10:06.000Z</published>
    <updated>2020-05-22T14:29:41.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number"><a href="#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number" class="headerlink" title="1365. How Many Numbers Are Smaller Than the Current Number"></a>1365. How Many Numbers Are Smaller Than the Current Number</h3><p>对数组升序排序，遍历排序后数组，判断是否与前一数字相同，若相同则该数字结果与前一结果相同，否则为当前索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums2 = sorted(nums)</span><br><span class="line">        mapping = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums2):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums2[i] == nums2[i<span class="number">-1</span>]:</span><br><span class="line">                mapping[nums2[i]] = mapping[nums2[i<span class="number">-1</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mapping[nums2[i]] = i</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res.append(mapping[num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1366-Rank-Teams-by-Votes"><a href="#1366-Rank-Teams-by-Votes" class="headerlink" title="1366. Rank Teams by Votes"></a>1366. Rank Teams by Votes</h3><p>考察排序，通过 dict 或者 list 统计所有字母的投票数值，然后进行排序，优先按照票数排序，如果票数相同，则按照字母序排序。</p><p>要熟练使用 sorted 和 sort.Slice 啊。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type votes: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(votes[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化哈希映射</span></span><br><span class="line">        ranking = collections.defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>] * n)</span><br><span class="line">        <span class="comment"># 遍历统计</span></span><br><span class="line">        <span class="keyword">for</span> vote <span class="keyword">in</span> votes:</span><br><span class="line">            <span class="keyword">for</span> i, vid <span class="keyword">in</span> enumerate(vote):</span><br><span class="line">                ranking[vid][i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 取出所有的键值对</span></span><br><span class="line">        result = list(ranking.items())</span><br><span class="line">        <span class="keyword">print</span> result</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        result.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], -ord(x[<span class="number">0</span>])), reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join([vid <span class="keyword">for</span> vid, rank <span class="keyword">in</span> result])</span><br></pre></td></tr></table></figure><h3 id="1367-Linked-List-in-Binary-Tree"><a href="#1367-Linked-List-in-Binary-Tree" class="headerlink" title="1367. Linked List in Binary Tree"></a>1367. Linked List in Binary Tree</h3><p>递归判断，比较当前 head 和 root、root.left、root.right，如果 head 为空，则表示已找到所有匹配的链表，返回 True，如果 root 为空或 root.val != head.val ，则返回 False，否则递归判断 head.next, root.left, root.right。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubPath</span><span class="params">(self, head, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(head, root) <span class="keyword">or</span> self.isSubPath(head, root.left) <span class="keyword">or</span> self.isSubPath(head, root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, head, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> root.val != head.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dfs(head.next, root.left) <span class="keyword">or</span> self.dfs(head.next, root.right)</span><br></pre></td></tr></table></figure><h3 id="1309-Decrypt-String-from-Alphabet-to-Integer-Mapping"><a href="#1309-Decrypt-String-from-Alphabet-to-Integer-Mapping" class="headerlink" title="1309. Decrypt String from Alphabet to Integer Mapping"></a>1309. Decrypt String from Alphabet to Integer Mapping</h3><p>简单粗暴的办法可以进行一个 map，先把所有的映射都记录好，然后逐个字符判断，该字符后的2位是否为 <code>#</code> ，来进行映射判断。比较取巧的办法是直接在原字符串上进行替换，不使用多余空间。</p><p>在进行字符串转换时，需要注意两位数是从 10 开始计算，而一位数是从 1 开始计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">27</span>):</span><br><span class="line">            s = s.replace( str(i) + <span class="string">'#'</span>,chr(ord(<span class="string">'j'</span>) - <span class="number">10</span> + i) )</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">            s = s.replace( str(i), chr(ord(<span class="string">'a'</span>) - <span class="number">1</span> + i ) )</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(st)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> st</span><br><span class="line">            <span class="keyword">return</span> chr(int(st) + <span class="number">96</span>)</span><br><span class="line">        </span><br><span class="line">        i, res = <span class="number">0</span>, <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">2</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">2</span>] == <span class="string">"#"</span>:</span><br><span class="line">                res += get(s[i : i + <span class="number">2</span>])</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += get(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1137-N-th-Tribonacci-Number"><a href="#1137-N-th-Tribonacci-Number" class="headerlink" title="1137. N-th Tribonacci Number"></a>1137. N-th Tribonacci Number</h3><p>泰波那契数，方法与斐波那契数一样，递归求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tibo</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> self.cache:</span><br><span class="line">                <span class="keyword">return</span> self.cache[n]</span><br><span class="line">            </span><br><span class="line">            self.cache[n] = tibo(n<span class="number">-1</span>) + tibo(n<span class="number">-2</span>) + tibo(n<span class="number">-3</span>)</span><br><span class="line">            <span class="keyword">return</span> self.cache[n]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tibo(n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number&quot;&gt;&lt;a href=&quot;#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number&quot; clas
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
