<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2020-08-16T02:29:02.044Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 第33周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/16/2020-第33周-LeetCode-记录/</id>
    <published>2020-08-16T10:27:06.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1544-Make-The-String-Great"><a href="#1544-Make-The-String-Great" class="headerlink" title="1544. Make The String Great"></a>1544. Make The String Great</h3><p>使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeGood</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> ((ord(stack[<span class="number">-1</span>])<span class="number">-32</span>) == ord(i) <span class="keyword">or</span> (ord(stack[<span class="number">-1</span>])+<span class="number">32</span>) == ord(i)):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure><h3 id="1545-Find-Kth-Bit-in-Nth-Binary-String"><a href="#1545-Find-Kth-Bit-in-Nth-Binary-String" class="headerlink" title="1545. Find Kth Bit in Nth Binary String"></a>1545. Find Kth Bit in Nth Binary String</h3><p>找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        l = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">        mid = (l &gt;&gt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == mid:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">elif</span> k &lt; mid:</span><br><span class="line">            <span class="keyword">return</span> self.findKthBit(n - <span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = l + <span class="number">1</span> -k</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span> <span class="keyword">if</span> self.findKthBit(n - <span class="number">1</span>, k) == <span class="string">'0'</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        s = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + <span class="string">'1'</span> + self.reverse(s[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> s[n][k<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                res.append(<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target"><a href="#1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target" class="headerlink" title="1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target"></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</h3><p>这是一道告诉你方法就会立刻做出来的题目，前缀和，因为要求不重叠，因此在遍历过的结果中找到 target，那么就需要将 set 重置，cur_sum 清零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNonOverlapping</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += num</span><br><span class="line">            <span class="keyword">if</span> cur_sum - target <span class="keyword">in</span> s:</span><br><span class="line">                s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">                cur_sum = <span class="number">0</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(cur_sum)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1541-Minimum-Insertions-to-Balance-a-Parentheses-String"><a href="#1541-Minimum-Insertions-to-Balance-a-Parentheses-String" class="headerlink" title="1541. Minimum Insertions to Balance a Parentheses String"></a>1541. Minimum Insertions to Balance a Parentheses String</h3><p>看完题目第一想法是用栈来做，但是写了半天发现题目理解错了，这题跟 #1544 不同的是，它不会因为栈中某个时刻符合平衡括号的条件就全部出栈，比如 <code>&quot;(()))(()))()())))&quot;</code> 这个用例，如果自己计算理解了这个用例这道题也就做出来了。</p><p>使用栈记录当前遍历字符为 <code>(</code> 的情况，如果为 <code>(</code> 那么直接入栈，如果为 <code>)</code> ，那么此时有两种情况：</p><ul><li>如果栈不存在，意味着左边缺少 <code>(</code> ，那么就至少需要补充一个 <code>(</code> ，此时判断当前字符的右侧是否为 <code>)</code> ，如果是，那么只需要添加一个 <code>(</code> ，如果不是 <code>)</code> ，那么就需要添加一个 <code>(</code> 和一个 <code>)</code>；</li><li>如果栈存在，意味着左侧存在 <code>(</code> ，此时判断当前字符右侧是否为 <code>)</code> ，如果是，那么将左侧字符出栈，此时已经满足了平衡括号情况，无须添加，如果不是 <code>)</code> ，那么需要添加一个 <code>)</code> 满足平衡。</li></ul><p>最终判断 stack 是否还存在，如果存在，则每个 <code>(</code> 需要添加两个 <code>)</code> 满足条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># use stack</span></span><br><span class="line">        stack = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># when facing empty stack</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">if</span> i+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        count += <span class="number">1</span>  <span class="comment"># add one "("</span></span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">2</span>   <span class="comment"># add one "("  and one ")"</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># check two positions</span></span><br><span class="line">                    <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">1</span>   <span class="comment"># add one ")"</span></span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        rest = len(stack)*<span class="number">2</span>  <span class="comment"># still have "(" on the stack. one "(" pairs with two ")"</span></span><br><span class="line">        <span class="keyword">return</span> count + rest</span><br></pre></td></tr></table></figure><h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h3><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/solution/da-lao-de-dai-ma-kan-ming-bai-hou-ji-ge-bi-ji-yong/" target="_blank" rel="noopener">leetcode-cn</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:                            </span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy=ListNode(float(-inf))             <span class="comment">#首项负无穷保证插的数据不在最前头</span></span><br><span class="line">        dummy.next=head                         <span class="comment">#用于返回答案</span></span><br><span class="line">        pre=head                                    </span><br><span class="line">        nxt=head.next</span><br><span class="line">        <span class="keyword">while</span> nxt:                              <span class="comment">#最后一项为None结束循环</span></span><br><span class="line">            <span class="keyword">if</span> nxt.val&gt;pre.val:                 <span class="comment">#从头开始，如果后一项大于前一项不改变节点</span></span><br><span class="line">               pre=nxt                          <span class="comment">#这两行移动指针（往后挪一格）</span></span><br><span class="line">               nxt=nxt.next</span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment">#如果后项小需要把后项nxt的节点插到正确位置</span></span><br><span class="line">                pre.next=nxt.next               <span class="comment">#把nxt指向的节点拿出来</span></span><br><span class="line">                cp1=dummy                       <span class="comment">#这两个指针负责从头开始比较nxt的位置</span></span><br><span class="line">                cp2=dummy.next                  <span class="comment">#使用dummy的原因见11行注释</span></span><br><span class="line">                <span class="keyword">while</span> nxt.val&gt;cp2.val:          <span class="comment">#因为前面是排好序的循环结束nxt正好在cp1和cp2中间</span></span><br><span class="line">                    cp1=cp2                     <span class="comment">#</span></span><br><span class="line">                    cp2=cp2.next                <span class="comment">#</span></span><br><span class="line">                nxt.next=cp2                    <span class="comment">#这两行负责插</span></span><br><span class="line">                cp1.next=nxt                    <span class="comment">#把nxt指向的节点查到cp1和cp2中间</span></span><br><span class="line">                nxt=pre.next                    <span class="comment">#指针从哪来回哪去 准备下一个循环</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1544-Make-The-String-Great&quot;&gt;&lt;a href=&quot;#1544-Make-The-String-Great&quot; class=&quot;headerlink&quot; title=&quot;1544. Make The String Great&quot;&gt;&lt;/a&gt;1544. M
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第32周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/08/2020-%E7%AC%AC32%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/08/2020-第32周-LeetCode-记录/</id>
    <published>2020-08-08T16:17:20.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1534-Count-Good-Triplets"><a href="#1534-Count-Good-Triplets" class="headerlink" title="1534. Count Good Triplets"></a>1534. Count Good Triplets</h3><p>数据规模很小，暴力循环解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countGoodTriplets</span><span class="params">(self, arr: List[int], a: int, b: int, c: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(arr)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, len(arr)):</span><br><span class="line">                    <span class="keyword">if</span> abs(arr[i] - arr[j]) &lt;= a <span class="keyword">and</span> abs(arr[j] - arr[k]) &lt;= b <span class="keyword">and</span> abs(arr[i] - arr[k]) &lt;= c:</span><br><span class="line">                        ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1535-Find-the-Winner-of-an-Array-Game"><a href="#1535-Find-the-Winner-of-an-Array-Game" class="headerlink" title="1535. Find the Winner of an Array Game"></a>1535. Find the Winner of an Array Game</h3><p>每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。</p><p>假设第一个数字为所求数字，从下一个数字开始遍历，如果当前数字比所求数字大，那么更新所求数字为当前数字并重置胜利变量为1，否则 += 1，如果胜利次数等于 k，那么直接返回当前最大的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWinner</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        a,n=arr[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i&gt;a:</span><br><span class="line">                a,n=i,<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> n==k:</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h3 id="1536-Minimum-Swaps-to-Arrange-a-Binary-Grid"><a href="#1536-Minimum-Swaps-to-Arrange-a-Binary-Grid" class="headerlink" title="1536. Minimum Swaps to Arrange a Binary Grid"></a>1536. Minimum Swaps to Arrange a Binary Grid</h3><p>最终需要将二维数组变为 grid[i] 的 grid[i][i+1:] 均为0，遍历 grid，找到满足当前 grid[i][i+1:] 需求，如果找到了，那么就需要一次次的交换，因为每次只能交换相邻两行，所以交换的次数等于 j -i 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwaps</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        need = <span class="number">0</span></span><br><span class="line">        l = len(grid)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, l):</span><br><span class="line">                <span class="keyword">if</span> sum(grid[j][i+<span class="number">1</span>:]) == <span class="number">0</span>:</span><br><span class="line">                    need += j-i</span><br><span class="line">                    grid[i:j+<span class="number">1</span>] = grid[j:j+<span class="number">1</span>]+grid[i:j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> need</span><br></pre></td></tr></table></figure><h3 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h3><p>每 k 组链表进行反转，使用递归做比较清晰易懂，<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/" target="_blank" rel="noopener">官方题解</a>感觉需要自己实际画画方便理解。</p><p>这道题的基础就是反转链表，通常的反转链表的操作是定义一个 pre，然后遍历整个链表，进行链表连接的断开以及反转，这里需要判断每 k 次，如果不足 k，那么直接返回当前的 head ，如果大于 k，那么就开始反转 k 个链表，注意需要记录反转前的 head，因为进行 k 次反转后，head 就是当前链表的尾端，然后递归反转后续链表，并赋值 head.next 保证链表的连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr: <span class="keyword">return</span> head</span><br><span class="line">            curr = curr.next</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reverse the group (basic way to reverse linked list)</span></span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nxt = curr.next</span><br><span class="line">            curr.next = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = nxt</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># After reverse, we know that `head` is the tail of the group.</span></span><br><span class="line"><span class="comment"># And `curr` is the next pointer in original linked list order</span></span><br><span class="line">        head.next = self.reverseKGroup(curr, k)</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h3 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h3><p>合并 k 个链表，题目没有要求原地合并，直接遍历记录所有链表的数值，然后进行排序，最后再重新定义链表连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists <span class="keyword">or</span> len(lists) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        all_vals = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l:</span><br><span class="line">                all_vals.append(l.val)</span><br><span class="line">                l = l.next</span><br><span class="line">        all_vals.sort()</span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> all_vals:</span><br><span class="line">            temp_node = ListNode(i)</span><br><span class="line">            cur.next = temp_node</span><br><span class="line">            cur = temp_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1534-Count-Good-Triplets&quot;&gt;&lt;a href=&quot;#1534-Count-Good-Triplets&quot; class=&quot;headerlink&quot; title=&quot;1534. Count Good Triplets&quot;&gt;&lt;/a&gt;1534. Count G
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>通过 grub 修复系统无法正确引导问题</title>
    <link href="https://zdyxry.github.io/2020/08/02/%E9%80%9A%E8%BF%87-grub-%E4%BF%AE%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%BC%95%E5%AF%BC%E9%97%AE%E9%A2%98/"/>
    <id>https://zdyxry.github.io/2020/08/02/通过-grub-修复系统无法正确引导问题/</id>
    <published>2020-08-02T09:10:39.000Z</published>
    <updated>2020-08-16T02:29:02.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在将一个节点的 kernel 从 4.18 版本降级到 4.14 后，发现系统无法启动，直接进入到了 GRUB 提示符界面，记录下修复过程。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>因为 kernel 4.18 版本和 4.14 的 打包方式发生了比较大的变化，4.18 版本多出了 kernel-core 和 kernel-modules 两个 rpm：</p><blockquote><p>4.14</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@sh-workstation Packages]# ls |grep ^kernel</span><br><span class="line">kernel-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-headers-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-tools-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-tools-libs-4.14.0-115.el7a.0.1.aarch64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>4.18</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-core-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-modules-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-tools-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-tools-libs-4.18.0-147.8.1.el7.aarch64.rpm</span><br></pre></td></tr></table></figure><p>在没有官方 yum repo 的情况下，降级就比较麻烦，我直接尝试 <code>rpm -Uvh kernel-4.14*.rpm</code> ，然后将 4.18 的 kernel-core 和 kernel-modules 卸载掉，然后重启后，发现系统直接进入到了 GRUB 提示符界面，无法正常启动，只能寻求修复办法。</p><h2 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h2><p>当时系统启动后，显示的是 <code>grub&gt;</code> 提示符，说明此时已经加载了 grub 程序，但是没有找到 grub.cfg 配置文件中的指定kernel 和 initramfs。</p><p>此时有两种修复思路：一种是在现有环境基础上，手动指定 grub 参数，先启动进入系统，然后再修复 grub 配置；一种是关机，在服务器上挂载一个 LiveCD OS，进入到 LiveCD 中，chroot 进行修复。</p><p>因为当时没有 LiveCD，所以选择第一种方式修复。</p><p>此时排查思路如下：</p><ol><li>需要找到 <code>/boot/</code> 分区所在磁盘，可以通过 <code>ls</code> 命令显示此时所有的磁盘分区情况，可以通过 <code>ls (hd0,msdos1)/</code> 方式查看磁盘分区下的文件，如果是 <code>/boot/</code> 分区，会看到 vmlinuz 和 initramfs 文件</li><li>根据 <code>/boot</code> 分区文件系统类型，执行 <code>insmod</code> 命令加载对应的 module，比如 <code>insmod xfs</code></li><li>找到 <code>/boot/</code> 分区所在磁盘后，设置 <code>root</code> 变量，<code>root</code> 变量是指定的我们当前交互的根分区，指定我们找到的磁盘分区，<code>set root=(hd0,msdos1)</code> </li><li>加载 linux kernel，并指定系统根分区 <code>root</code>，这个 <code>root</code> 变量并不是我们在上一步所指定的，而是作为加载 kernel 的参数传递的，如果使用 lvm 配置，那么默认是 <code>/dev/mapper/centos-root</code> ，最终命令如 <code>linux /vmlinuz-4.14.0-115.el7a.0.1.aarch64 root=/dev/mapper/centos-root</code> </li><li>加载 initramfs，如 <code>initrd initramfs-4.14.0-115.el7a.0.1.aarch64.img</code> </li><li>此时所有引导的必要参数已经设置完成，输入 <code>boot</code> 命令即可正确引导</li><li>系统引导后，检查 grub.cfg 配置，执行 <code>grub2-mkconfig -o</code> 重新生成 grub 配置。</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>在 kernel 升级的动作中，grub 会被自动更新，但是如果通过非常规方式进行 kernel 降级，就需要注意 grub 配置了，修复 grub 不是什么好的体验，慎重。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.gnu.org/software/grub/manual/grub/grub.html" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/grub/grub.html</a></li><li><a href="https://help.ubuntu.com/community/Grub2/Troubleshooting" target="_blank" rel="noopener">https://help.ubuntu.com/community/Grub2/Troubleshooting</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在将一个节点的 kernel 从 4.18 版本降级到 4.14 后，发现系统无法启动，直接进入到了 GRUB 提示符界面，记录下修复过
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第31周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/01/2020-%E7%AC%AC31%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/01/2020-第31周-LeetCode-记录/</id>
    <published>2020-08-01T07:26:24.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1523-Count-Odd-Numbers-in-an-Interval-Range"><a href="#1523-Count-Odd-Numbers-in-an-Interval-Range" class="headerlink" title="1523. Count Odd Numbers in an Interval Range"></a>1523. Count Odd Numbers in an Interval Range</h3><p>数学题，数据范围是10^9，O(n) 会超时，统计 high 中有多少个奇数，减去 low-1 中的奇数个数，需要考虑边界条件：low/high 自身为奇数情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countOdds</span><span class="params">(self, low: int, high: int)</span> -&gt; int:</span></span><br><span class="line">        res = high // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> high % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> low - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            res -= (low - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (low - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1528-Shuffle-String"><a href="#1528-Shuffle-String" class="headerlink" title="1528. Shuffle String"></a>1528. Shuffle String</h3><p>按照指定顺序调整字符串，直接定义一个新的长度为 len(s)字符串，然后按照 indices 的索引顺序进行对应调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreString</span><span class="params">(self, s: str, indices: List[int])</span> -&gt; str:</span></span><br><span class="line">        _s = [<span class="string">'0'</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            _s[indices[idx]] = val</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(_s)</span><br></pre></td></tr></table></figure><h3 id="1524-Number-of-Sub-arrays-With-Odd-Sum"><a href="#1524-Number-of-Sub-arrays-With-Odd-Sum" class="headerlink" title="1524. Number of Sub-arrays With Odd Sum"></a>1524. Number of Sub-arrays With Odd Sum</h3><blockquote><p><a href="https://www.youtube.com/watch?v=vGTm8rjlDTQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=vGTm8rjlDTQ</a></p></blockquote><p>用两个变量分别记录奇数和偶数的个数，遍历数组，如果当前数字是奇数，那么 odd 等于偶数个数 +1，1为当前数字，even 等于奇数个数，因为奇数个数加上当前数字（奇数）为偶数；如果当前数字是偶数，那么 odd 等于 odd，偶数个数等于 even + 1，1为当前数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numOfSubarrays</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    odd, even := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">if</span> v % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            odd, even = even + <span class="number">1</span>, odd</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            odd, even = odd, even + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        res += odd</span><br><span class="line">        res %= mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1525-Number-of-Good-Ways-to-Split-a-String"><a href="#1525-Number-of-Good-Ways-to-Split-a-String" class="headerlink" title="1525. Number of Good Ways to Split a String"></a>1525. Number of Good Ways to Split a String</h3><p>使用 Counter 统计当前字符串中的字符出现的次数，left 表示切割索引左侧字符出现的次数，right 表示切割索引右侧字符出现的次数，遍历字符，如果 right[x] == 0，那么表示右侧已经没有字符 x，那么需要将对应的 key(x) 从 right 中删除，比较 left 中的 key 数量与 right 中是否相同，如果相同，则记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSplits</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = Counter()</span><br><span class="line">        right = Counter(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            left[s[i]] += <span class="number">1</span></span><br><span class="line">            right[s[i]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right[s[i]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> right[s[i]]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> len(left) == len(right):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1529-Bulb-Switcher-IV"><a href="#1529-Bulb-Switcher-IV" class="headerlink" title="1529. Bulb Switcher IV"></a>1529. Bulb Switcher IV</h3><p>统计需要翻转开关的次数，就是统计最终状态中 0，1 切换的次数，比如<code>001011101</code> ，0，1 切换分别在 <code>001</code> , <code>10</code>, <code>0111</code>, <code>1110</code>, <code>01</code> 这五个位置出现了切换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minFlips</span><span class="params">(target <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">target = <span class="string">"0"</span> + target</span><br><span class="line">flag := target[<span class="built_in">len</span>(target)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(target) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> target[i] != flag &#123;</span><br><span class="line">count++</span><br><span class="line">flag = target[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1523-Count-Odd-Numbers-in-an-Interval-Range&quot;&gt;&lt;a href=&quot;#1523-Count-Odd-Numbers-in-an-Interval-Range&quot; class=&quot;headerlink&quot; title=&quot;1523. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第30周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/26/2020-%E7%AC%AC30%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/26/2020-第30周-LeetCode-记录/</id>
    <published>2020-07-26T09:36:03.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1518-Water-Bottles"><a href="#1518-Water-Bottles" class="headerlink" title="1518. Water Bottles"></a>1518. Water Bottles</h3><p>小学数学题，用几个空瓶子可以换一瓶新的，问最后能喝到几瓶，在小学场景下可以先借再喝，在这道题没有这种场景，所以正常计算就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWaterBottles</span><span class="params">(self, numBottles: int, numExchange: int)</span> -&gt; int:</span></span><br><span class="line">        res = numBottles</span><br><span class="line">        <span class="keyword">while</span> numBottles &gt;= numExchange:</span><br><span class="line">            cnt = numBottles // numExchange</span><br><span class="line">            res += cnt</span><br><span class="line">            numBottles = numBottles - (cnt * numExchange)</span><br><span class="line">            numBottles += cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108. Defanging an IP Address"></a>1108. Defanging an IP Address</h3><p>将 IPv4 地址 “1.1.1.1” 转换为 “1[.]1[.]1[.]1” ，不知道这道题的意义在哪里。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">'.'</span>, <span class="string">'[.]'</span>)</span><br></pre></td></tr></table></figure><h3 id="1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><a href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label" class="headerlink" title="1519. Number of Nodes in the Sub-Tree With the Same Label"></a>1519. Number of Nodes in the Sub-Tree With the Same Label</h3><p>题目很绕，最好自己根据给的 edges 和 labels 构建出对应的树，了解是如何构建的，最终要求的 ans 中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数，记录所有节点的相邻节点，从 0 节点开始 dfs，如果节点已经访问过，则跳过对应节点，最终汇总 ans[i] 中的数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">        edge_map = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            edge_map[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            edge_map[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            visited.add(i)</span><br><span class="line">            <span class="comment"># 字符数字典</span></span><br><span class="line">            data = Counter(&#123;labels[i]: <span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> edge_map[i]:</span><br><span class="line">                <span class="keyword">if</span> nxt <span class="keyword">in</span> visited: <span class="keyword">continue</span> <span class="comment"># 去重</span></span><br><span class="line">                <span class="comment"># 整合子树的字符数</span></span><br><span class="line">                data += _dfs(nxt)</span><br><span class="line">            <span class="comment"># 设置当前节点的结果字符数</span></span><br><span class="line">            ans[i] = data[labels[i]]</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        ans = [<span class="number">1</span>] * n</span><br><span class="line">        _dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1189-Maximum-Number-of-Balloons"><a href="#1189-Maximum-Number-of-Balloons" class="headerlink" title="1189. Maximum Number of Balloons"></a>1189. Maximum Number of Balloons</h3><p>给一个字符串 text，使用 text 中的字母来拼凑尽可能多的单词 “balloon”，每个字母最多只能被使用一次。返回最多可以拼凑出多少个单词 “balloon”，分别统计每个字母出现的次数，然后判断满足ballon 所有字母出现次数最小的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfBalloons</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        d = collections.Counter(text)</span><br><span class="line">        <span class="keyword">return</span> min(d[<span class="string">'b'</span>], d[<span class="string">'a'</span>], d[<span class="string">'l'</span>] // <span class="number">2</span>, d[<span class="string">'o'</span>] // <span class="number">2</span>, d[<span class="string">'n'</span>])</span><br></pre></td></tr></table></figure><h3 id="1304-Find-N-Unique-Integers-Sum-up-to-Zero"><a href="#1304-Find-N-Unique-Integers-Sum-up-to-Zero" class="headerlink" title="1304. Find N Unique Integers Sum up to Zero"></a>1304. Find N Unique Integers Sum up to Zero</h3><p>给一个整数 n，返回任意一个由 n 个 各不相同的整数组成的数组，并且这 n 个数相加和为 0 ，题目很开放，如果n 为奇数，则补充一个数字 <code>0</code>，如果为 偶数，那么补充对应的 n/2 个数字的正负值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            res.append(i)</span><br><span class="line">            res.append(-i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1518-Water-Bottles&quot;&gt;&lt;a href=&quot;#1518-Water-Bottles&quot; class=&quot;headerlink&quot; title=&quot;1518. Water Bottles&quot;&gt;&lt;/a&gt;1518. Water Bottles&lt;/h3&gt;&lt;p&gt;小学数学
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第29周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/19/2020-第29周-LeetCode-记录/</id>
    <published>2020-07-19T11:19:38.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves"><a href="#1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves" class="headerlink" title="1509. Minimum Difference Between Largest and Smallest Value in Three Moves"></a>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</h3><p>要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> min(b - a <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(nums[:<span class="number">4</span>], nums[<span class="number">-4</span>:]))</span><br></pre></td></tr></table></figure><h3 id="1512-Number-of-Good-Pairs"><a href="#1512-Number-of-Good-Pairs" class="headerlink" title="1512. Number of Good Pairs"></a>1512. Number of Good Pairs</h3><p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 ，返回好数对的数目。<br>只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIdenticalPairs</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(k * (k - <span class="number">1</span>) / <span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> collections.Counter(A).values())</span><br></pre></td></tr></table></figure><h3 id="1513-Number-of-Substrings-With-Only-1s"><a href="#1513-Number-of-Substrings-With-Only-1s" class="headerlink" title="1513. Number of Substrings With Only 1s"></a>1513. Number of Substrings With Only 1s</h3><p>判断连续 1 的个数，每当遇到 1 时计数 +1， 遇到 0 时对现有计数进行求和公式，并加到最终结果中，重置计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += cnt * (cnt +<span class="number">1</span>) /<span class="number">2</span></span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            res += cnt * (cnt + <span class="number">1</span>)/ <span class="number">2</span></span><br><span class="line">        res %= <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><h3 id="1114-Print-in-Order"><a href="#1114-Print-in-Order" class="headerlink" title="1114. Print in Order"></a>1114. Print in Order</h3><p>将各个线程按照顺序执行，有很多实现方式，挑一种方式实现就可以了，这里直接使用 <code>threading.Event</code> 。</p><p><code>threading.Event</code> 定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b1 = threading.Event()</span><br><span class="line">        self.b2 = threading.Event()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.b1.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b1.wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.b2.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b2.wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure><h3 id="1209-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#1209-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="1209. Remove All Adjacent Duplicates in String II"></a>1209. Remove All Adjacent Duplicates in String II</h3><p>这题描述有点别扭，给一个字符串，如果字符串中包含 k 个相邻且相等的字母，那么就原地删除，然后继续检测是否满足条件，重复执行操作。使用栈来记录最终结果，遍历字符串，如果当前自负和栈顶相同，且长度等于 k，那么就出栈，最终将栈中记录拼接为字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">if</span> len(stack) == <span class="number">0</span> <span class="keyword">or</span> stack[<span class="number">-1</span>][<span class="number">0</span>] != i:</span><br><span class="line">                stack.append([i, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[<span class="number">-1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">        ret = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> stack:</span><br><span class="line">            ret += t[<span class="number">0</span>] * t[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves&quot;&gt;&lt;a href=&quot;#1509-Minimum-Difference-Between-Largest-and-Sma
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第28周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/11/2020-%E7%AC%AC28%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/11/2020-第28周-LeetCode-记录/</id>
    <published>2020-07-11T21:50:54.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1502-Can-Make-Arithmetic-Progression-From-Sequence"><a href="#1502-Can-Make-Arithmetic-Progression-From-Sequence" class="headerlink" title="1502. Can Make Arithmetic Progression From Sequence"></a>1502. Can Make Arithmetic Progression From Sequence</h3><p>判断是否可以组成等差数列，将数组排序后，比较两两数字差是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        arr.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        diff = arr[<span class="number">0</span>] - arr[<span class="number">1</span>]</span><br><span class="line">        pre = arr[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> pre - i != diff:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            pre = i</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank"><a href="#1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank" class="headerlink" title="1503. Last Moment Before All Ants Fall Out of a Plank"></a>1503. Last Moment Before All Ants Fall Out of a Plank</h3><p>标签是“脑筋急转弯”，蚂蚁只要在一个点碰到，那么就会调换方向，但是蚂蚁始终是蚂蚁，因此可以忽略掉这个条件，直接找到最大值就可以了。</p><p>再次怀疑自己智商。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastMoment</span><span class="params">(self, n: int, left: List[int], right: List[int])</span> -&gt; int:</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            time = max(time, max(left))</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            time = max(time, n - min(right))</span><br><span class="line">        <span class="keyword">return</span> time</span><br></pre></td></tr></table></figure><h3 id="939-Minimum-Area-Rectangle"><a href="#939-Minimum-Area-Rectangle" class="headerlink" title="939. Minimum Area Rectangle"></a>939. Minimum Area Rectangle</h3><p>一般会选择完整本周周赛题目，然后去做其他的题，但是 1504 做不出，就找了到也是矩形相关的补一补 - - 。</p><p>找出最小矩形面积，需要先找到组成矩形的四个点，遍历所有点，将其记录下来，并遍历已记录的点，此时拿到了两个点，直接暴力判断这两个点的对称点是否存在，如果存在，则计算面积并更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAreaRect</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        mem = set()</span><br><span class="line">        <span class="keyword">for</span> x1,y1 <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">for</span> x2,y2 <span class="keyword">in</span> mem:</span><br><span class="line">                <span class="keyword">if</span> (x2,y1) <span class="keyword">in</span> mem <span class="keyword">and</span> (x1,y2) <span class="keyword">in</span> mem:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> area:</span><br><span class="line">                        area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> abs(x2-x1)*abs(y2-y1) &lt; area:</span><br><span class="line">                            area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">            mem.add((x1,y1))</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure><h3 id="1160-Find-Words-That-Can-Be-Formed-by-Characters"><a href="#1160-Find-Words-That-Can-Be-Formed-by-Characters" class="headerlink" title="1160. Find Words That Can Be Formed by Characters"></a>1160. Find Words That Can Be Formed by Characters</h3><p>使用 Counter 统计词汇表中的字母，遍历单词，如果单词中的每个字母数量小于词汇表中的字母数量，那么满足条件，否则跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCharacters</span><span class="params">(self, words: List[str], chars: str)</span> -&gt; int:</span></span><br><span class="line">        chars_cnt = collections.Counter(chars)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_cnt = collections.Counter(word)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word_cnt:</span><br><span class="line">                <span class="keyword">if</span> chars_cnt[c] &lt; word_cnt[c]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += len(word)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a>1048. Longest String Chain</h3><p>先对所有单词进行排序，使用哈希表记录当前单词所能组成的最长字符串链的长度。当遍历到某个单词是，通过字符串切片，判断其所有可能的情况，如果记录中存在，那么与当前最大值进行比较更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        words.sort(key=len)</span><br><span class="line">        note=&#123;&#125;</span><br><span class="line">        maxChain=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> note:</span><br><span class="line">                note[word]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(word)):</span><br><span class="line">                newWord=word[:i]+word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> (newWord) <span class="keyword">in</span> note:</span><br><span class="line">                    note[word]=max(note[word],note[newWord]+<span class="number">1</span>)</span><br><span class="line">            maxChain=max(maxChain,note[word])</span><br><span class="line">        <span class="keyword">return</span> maxChain</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1502-Can-Make-Arithmetic-Progression-From-Sequence&quot;&gt;&lt;a href=&quot;#1502-Can-Make-Arithmetic-Progression-From-Sequence&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第27周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/04/2020-%E7%AC%AC27%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/04/2020-第27周-LeetCode-记录/</id>
    <published>2020-07-04T09:17:15.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1492-The-kth-Factor-of-n"><a href="#1492-The-kth-Factor-of-n" class="headerlink" title="1492. The kth Factor of n"></a>1492. The kth Factor of n</h3><p>计算 n 的第 k 个因子，i 从 1 开始递增，如果 i 可以被 n 整除，则 k–，当 k == 0 时， i为所求值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthFactor</span><span class="params">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1493-Longest-Subarray-of-1’s-After-Deleting-One-Element"><a href="#1493-Longest-Subarray-of-1’s-After-Deleting-One-Element" class="headerlink" title="1493. Longest Subarray of 1’s After Deleting One Element"></a>1493. Longest Subarray of 1’s After Deleting One Element</h3><p>用 cnt1 记录删除一个元素之后当前最长全为 1 的数组长度，用 cnt2 记录当前最长全为 1 的数组长度。</p><p>遍历数组，当 num == 1 时，则 cnt1++, cnt2++，当 num != 1 时，cnt1 = cnt2，并将 cnt2 置 0。每次更新 cnt1 时，比较最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        cnt1, cnt2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line">                maxlen = max(maxlen, cnt1)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt1 = cnt2</span><br><span class="line">                cnt2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 == len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure><h3 id="1496-Path-Crossing"><a href="#1496-Path-Crossing" class="headerlink" title="1496. Path Crossing"></a>1496. Path Crossing</h3><p>起始点为 (0,0)，然后遍历 path，当为南北时，分别对 y 进行 +1，-1， 当为东西时，分别对 x 进行 +1，-1，每次走过一个路径，就判断当前所在节点是否已经在记录中，如果在直接返回 True，否则将其添加到记录中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPathCrossing</span><span class="params">(self, path: str)</span> -&gt; bool:</span></span><br><span class="line">        x = y = <span class="number">0</span></span><br><span class="line">        set = &#123;(<span class="number">0</span>, <span class="number">0</span>)&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'N'</span>:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'S'</span>:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'E'</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">in</span> set:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            set.add((x, y))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1497-Check-If-Array-Pairs-Are-Divisible-by-k"><a href="#1497-Check-If-Array-Pairs-Are-Divisible-by-k" class="headerlink" title="1497. Check If Array Pairs Are Divisible by k"></a>1497. Check If Array Pairs Are Divisible by k</h3><p>使用哈希表，分别将所有 arr 中的数字对 k 取余，然后遍历余数，如果余数不为0，且 k - 余数 在哈希表中并且 两个key 数值相同，则这两个数字所组成的数字对之和是可以被 k 整除的。如果余数为0，那么判断余数为0 的个数是否为偶数，如果为偶数，那么返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canArrange</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        mod = collections.Counter(num % k <span class="keyword">for</span> num <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="keyword">for</span> t, occ <span class="keyword">in</span> mod.items():</span><br><span class="line">            <span class="keyword">if</span> t &gt; <span class="number">0</span> <span class="keyword">and</span> (k - t <span class="keyword">not</span> <span class="keyword">in</span> mod <span class="keyword">or</span> mod[k - t] != occ):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> mod[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition"><a href="#1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition" class="headerlink" title="1498. Number of Subsequences That Satisfy the Given Sum Condition"></a>1498. Number of Subsequences That Satisfy the Given Sum Condition</h3><p>因为是非空子序列，因此不要求连续，只要满足条件的任意组合即可。</p><p>对数组进行排序，然后使用双指针，如果 nums[l] + nums[r] &gt; target，此时不符合条件，那么将 r–，如果符合，那么在结果中 l 到 r 这个距离中所有的组合都是满足条件的，2 ^ (r-l)，l++，结果相加后取模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubseq</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] &gt; target:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += pow(<span class="number">2</span>, r - l, mod)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res % mod</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1492-The-kth-Factor-of-n&quot;&gt;&lt;a href=&quot;#1492-The-kth-Factor-of-n&quot; class=&quot;headerlink&quot; title=&quot;1492. The kth Factor of n&quot;&gt;&lt;/a&gt;1492. The kth
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第26周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/28/2020-%E7%AC%AC26%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/28/2020-第26周-LeetCode-记录/</id>
    <published>2020-06-28T21:57:10.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1486-XOR-Operation-in-an-Array"><a href="#1486-XOR-Operation-in-an-Array" class="headerlink" title="1486. XOR Operation in an Array"></a>1486. XOR Operation in an Array</h3><p>遍历进行异或操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorOperation</span><span class="params">(self, n: int, start: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans ^= start + <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1487-Making-File-Names-Unique"><a href="#1487-Making-File-Names-Unique" class="headerlink" title="1487. Making File Names Unique"></a>1487. Making File Names Unique</h3><p>一道实际环境中会遇到的场景，使用哈希表记录已有的文件名，如果该文件已经存在在哈希表中，那么循环判断文件名 + <code>()</code> 数字是否也在哈希表中，如果还在，那么数字 + 1，直到数字不在。然后将结果记录到返回列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFolderNames</span><span class="params">(self, names: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        nameMap = &#123;&#125; <span class="comment"># baseName : largest k suffix</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> nameMap:</span><br><span class="line">                <span class="comment"># find k</span></span><br><span class="line">                k = nameMap[n] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> ( n + <span class="string">"("</span> + str(k) + <span class="string">")"</span> ) <span class="keyword">in</span> nameMap:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                nameMap[n] = k</span><br><span class="line">                n = n + <span class="string">"("</span> + str(k) + <span class="string">")"</span> <span class="comment"># with suffix is now considered a base name</span></span><br><span class="line">                </span><br><span class="line">            nameMap[n] = <span class="number">0</span> <span class="comment"># first time seeing this base name</span></span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a>701. Insert into a Binary Search Tree</h3><p>在二叉树中插入节点，如果 val &gt; node.val，插入到右子树，如果 val &lt; node.val，插入到左子树，最终返回 root 节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="comment"># insert into the right subtree</span></span><br><span class="line">            <span class="keyword">if</span> val &gt; node.val:</span><br><span class="line">                <span class="comment"># insert right now</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    node.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> root</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.right</span><br><span class="line">            <span class="comment"># insert into the left subtree</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># insert right now</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                    node.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> root</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.left</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br></pre></td></tr></table></figure><h3 id="1488-Avoid-Flood-in-The-City"><a href="#1488-Avoid-Flood-in-The-City" class="headerlink" title="1488. Avoid Flood in The City"></a>1488. Avoid Flood in The City</h3><p>遇到不下雨的时候先不去判断应该将哪个湖水抽干，而是等到某个湖下雨两次，再去从不下雨的天气里在湖两次下雨之间抽取第一个来抽干这个湖，防止洪水泛滥，如果找不到，则发生洪水。</p><blockquote><p><a href="https://www.youtube.com/watch?v=8sxeQyumrYc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8sxeQyumrYc</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoidFlood</span><span class="params">(self, rains: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">1</span>] * len(rains)</span><br><span class="line">        left = []</span><br><span class="line">        record = dict()</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(rains):</span><br><span class="line">            <span class="keyword">if</span> val &gt; <span class="number">0</span>:</span><br><span class="line">                ans[i] = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">in</span> record:</span><br><span class="line">                    pos = bisect_left(left, record[val])</span><br><span class="line">                    <span class="keyword">if</span> pos &gt;= len(left):</span><br><span class="line">                        <span class="keyword">return</span> []</span><br><span class="line">                    ans[left.pop(pos)] = val</span><br><span class="line">                record[val] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a>1047. Remove All Adjacent Duplicates In String</h3><p>遍历字符串，使用列表作为栈记录结果，如果当前栈大于0 且当前字母与栈顶相同，则出栈，否则将其加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> len(res) &gt;= <span class="number">1</span> <span class="keyword">and</span> i == res[<span class="number">-1</span>]:</span><br><span class="line">                res.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1486-XOR-Operation-in-an-Array&quot;&gt;&lt;a href=&quot;#1486-XOR-Operation-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1486. XOR Operation in an Array&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第25周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/20/2020-%E7%AC%AC25%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/20/2020-第25周-LeetCode-记录/</id>
    <published>2020-06-20T06:53:40.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1476-Subrectangle-Queries"><a href="#1476-Subrectangle-Queries" class="headerlink" title="1476. Subrectangle Queries"></a>1476. Subrectangle Queries</h3><p>二维数组的更新与查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubrectangleQueries</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rectangle: List[List[int]])</span>:</span></span><br><span class="line">        self.rect = rectangle</span><br><span class="line">        self.rows, self.cols = len(self.rect), len(self.rect[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateSubrectangle</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int, newValue: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row1, row2 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col1, col2 + <span class="number">1</span>):</span><br><span class="line">                self.rect[i][j] = newValue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self, row: int, col: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.rect[row][col]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SubrectangleQueries object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = SubrectangleQueries(rectangle)</span></span><br><span class="line"><span class="comment"># obj.updateSubrectangle(row1,col1,row2,col2,newValue)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getValue(row,col)</span></span><br></pre></td></tr></table></figure><h3 id="1480-Running-Sum-of-1d-Array"><a href="#1480-Running-Sum-of-1d-Array" class="headerlink" title="1480. Running Sum of 1d Array"></a>1480. Running Sum of 1d Array</h3><p>统计动态和，始终用一个变量记录当前值，遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runningSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            sum += i</span><br><span class="line">            res.append(sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1481-Least-Number-of-Unique-Integers-after-K-Removals"><a href="#1481-Least-Number-of-Unique-Integers-after-K-Removals" class="headerlink" title="1481. Least Number of Unique Integers after K Removals"></a>1481. Least Number of Unique Integers after K Removals</h3><p>对 arr 中出现数字的次数进行统计，并按照升序进行排序，遍历排序后的结果，如果 sum + elem_v 小于等于 k，那么表示此时还可以继续删除数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        res = dict(Counter(arr))</span><br><span class="line">        res = sorted(res.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        len_elem = len(res)</span><br><span class="line">        <span class="keyword">for</span> (elem_k,elem_v) <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> sum + elem_v &lt;= k:</span><br><span class="line">                len_elem -=<span class="number">1</span></span><br><span class="line">                sum += elem_v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> len_elem</span><br></pre></td></tr></table></figure><h3 id="1482-Minimum-Number-of-Days-to-Make-m-Bouquets"><a href="#1482-Minimum-Number-of-Days-to-Make-m-Bouquets" class="headerlink" title="1482. Minimum Number of Days to Make m Bouquets"></a>1482. Minimum Number of Days to Make m Bouquets</h3><p>对所有天数进行排序，使用二分法判断是否满足，其中判断是否可以组成k 朵花需要注意判断是否连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDays</span><span class="params">(self, bloomDay: List[int], m: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(bloomDay)</span><br><span class="line">        <span class="keyword">if</span> n &lt; m * k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(day: int)</span>:</span></span><br><span class="line">            num = sums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> num &gt;= m:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> bloomDay[i] &lt;= day:</span><br><span class="line">                    sums += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sums = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> sums == k:</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">                    sums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= m</span><br><span class="line">        days = sorted(set(bloomDay))</span><br><span class="line">        l, r = <span class="number">0</span>, len(days)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> count(days[mid]):</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> days[l]</span><br></pre></td></tr></table></figure><h3 id="1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><a href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree" class="headerlink" title="1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"></a>1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</h3><p>题目描述不清楚，我理解是 dfs ，只是传入的是两个 Tree，判断符合条件后直接返回另一个 Tree Node。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTargetCopy</span><span class="params">(self, original: TreeNode, cloned: TreeNode, target: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(original, cloned, target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> original <span class="keyword">or</span> <span class="keyword">not</span> cloned:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> original == target:</span><br><span class="line">                <span class="keyword">return</span> cloned</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> traverse(original.left, cloned.left, target) <span class="keyword">or</span> \</span><br><span class="line">                traverse(original.right, cloned.right, target)</span><br><span class="line">        <span class="keyword">return</span> traverse(original, cloned, target)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1476-Subrectangle-Queries&quot;&gt;&lt;a href=&quot;#1476-Subrectangle-Queries&quot; class=&quot;headerlink&quot; title=&quot;1476. Subrectangle Queries&quot;&gt;&lt;/a&gt;1476. Subr
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>从北京转到上海生活两周感受</title>
    <link href="https://zdyxry.github.io/2020/06/13/%E4%BB%8E%E5%8C%97%E4%BA%AC%E8%BD%AC%E5%88%B0%E4%B8%8A%E6%B5%B7%E7%94%9F%E6%B4%BB%E4%B8%A4%E5%91%A8%E6%84%9F%E5%8F%97/"/>
    <id>https://zdyxry.github.io/2020/06/13/从北京转到上海生活两周感受/</id>
    <published>2020-06-13T22:09:05.000Z</published>
    <updated>2020-08-16T02:29:02.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾，换个城市感受一下，正好公司在上海也有办公室，就直接转过来了，到今天已经工作了两周，写一下感受，扯一扯。</p><h2 id="租房"><a href="#租房" class="headerlink" title="租房"></a>租房</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>因为在5月份的时候疫情消停了一段时间，我就开始了远程看房的计划，因为有深圳同事也要转到上海，就计划一起合租，那么目标就是两居室。我们通过 Notion 协作写清楚需求（是的，还有猫的需求），然后各自开始了远程找房。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># yiran 的需求</span><br><span class="line">- 步行 30min 可到达公司</span><br><span class="line">- 民水民点</span><br><span class="line">- 厨房可用</span><br><span class="line">- 周围有商超</span><br><span class="line">- 不临街</span><br><span class="line"></span><br><span class="line">## 同事的需求</span><br><span class="line">- 希望是有电梯的(骑车穿锁鞋很难下楼)</span><br><span class="line">- 避免石膏墙</span><br><span class="line">- 询问一下居住证的问题</span><br><span class="line"></span><br><span class="line">## 猫的需求</span><br><span class="line">- 最好是有防盗网的窗户</span><br><span class="line">- 阳光</span><br><span class="line">- 够大</span><br><span class="line"></span><br><span class="line"># 避免</span><br><span class="line">- 窗户有树</span><br></pre></td></tr></table></figure><h3 id="了解中介"><a href="#了解中介" class="headerlink" title="了解中介"></a>了解中介</h3><p>如果个人在上海本地，那么还有可能通过豆瓣等平台找到房东直接签约没有中介费，但是像我这种时间紧任务重的，就放弃了这种方式选择中介。上海租房与北京租房最主要的不同就是中介费，北京是租客需要支付一个月的租金，而上海是租客与房东共支付一个月的租金作为中介费，所以租客只需要支付50% 的租金即可，这点比北京友好很多，所以我们开始也是倾向于通过中介与房东签约的房子。</p><p>中介主要是链家，我爱我家的房源很少，且质量不高，贝壳上还有些其他的小中介，因为担心有其他隐患，最后还是选择的链家。</p><h3 id="看房"><a href="#看房" class="headerlink" title="看房"></a>看房</h3><p>主要看了两天的时间，第一天看了很多公司周围的板楼，后来才知道这类房子叫“老公房”，房子质量很差，且隔音很是问题，无法接受，于是第二天开始看一些距离公司地铁20min 可达的房子，在看的时候发现我忽略了一个比较重要的点，就是猫，同事养了两只猫，但是我看房子时忽略了房东不让养宠物的可能，直到我看了一个各方面都符合要求的房子后，想要与房东签约，才想到这点，房东果断拒绝了，后续也看了几个房子各方面都很好，但是不让养宠物而错过的，也是没有办法。</p><h3 id="自如"><a href="#自如" class="headerlink" title="自如"></a>自如</h3><p>在看了两天之后，发现房子质量比较好的房东，都不同意租客养宠物，换位思考可以理解，因为时间比较紧张，把目光选择了自如，自如的收费与北京相同，没有差别，照片都是真实的，但是我还是线下去看了房子，确保没有问题，期间发现了一些在自如网站上无法发现的问题：</p><ol><li>隔音，部分房子隔音很差</li><li>周围环境，发现部分房子周围存在基建施工情况，看形式不是几天可以完工的</li><li>老旧小区改造，在北京吃过亏，租的房子是老房子，恰逢政府进行小区改造，两个月没有卫生间的日子还是太难过了</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如果当地有朋友，还是通过朋友那里了解到租房坑是最直接的方式</li><li>要确认好自己的需求，尤其是宠物这种可能会一票否决的事项更是要第一时间提出，否则白白浪费一个小时看房</li><li>找中介看房基本上不会按照自己的计划来安排时间的，每个中介都会拉着你去看几个类似的房子，所以做时间规划的时候最好要留有余地</li><li>实在没有选择就找自如吧，至少是有基本保证，但是要注意上海这边属于南方，宽带很可能没有联通选项</li></ol><p>附一张 Notion 的看房列表：</p><img src="/2020/06/13/从北京转到上海生活两周感受/2.png" title="Notion"><h2 id="搬家"><a href="#搬家" class="headerlink" title="搬家"></a>搬家</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>因为我在去上海前没有租好房子，所以不能先把行李快递走，当时有两个计划，优先计划 2：</p><ol><li>先去上海租房，回北京快递行李，再去上海</li><li>出发前先打包好行李、去上海租房、找同事帮忙快递行李</li></ol><h3 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h3><p>在出发前我已经将自己的行李打包好了，在淘宝买了质量还可以的纸箱子，然后找了北京同事帮忙寄快递，选择的是德邦物流，之前也问过几个朋友，貌似是比较稳妥的方式了，当时物流费用是 448，我进行了保价，一共花费了 488，还是可以接受的，毕竟也是200kg+ 的行李。</p><p>但是事实证明别人的稳妥只有实际体验才知道，德邦在我的纸箱子外套了层编织袋，当我打开行李的时候，发现里面的纸箱子已经接近散架的状态，全靠编织袋才坚持到了上海，不知道其他人是不是也是这样，还好我没有什么贵重的大件物品，否则感觉要完。</p><p>同事搬家选择的顺丰，并且选择了带托盘的方式，行李在出发前是什么样子，到达时就是什么样子，全程行李没有离开托盘，所以行李也没有任何的破损，体验非常好，当然价格也很好，1k+ 的快递费。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果普通物品选择德邦还是可以的，但是我之后应该会选择顺丰。</p><h3 id="气候"><a href="#气候" class="headerlink" title="气候"></a>气候</h3><h3 id="梅雨期"><a href="#梅雨期" class="headerlink" title="梅雨期"></a>梅雨期</h3><p>在来上海前，好多朋友同事都说我作为东北人，会无法适应上海的气候，我觉得还是要感受一下才能知道是否真正适合，不试试是不知道的。</p><p>正好过来收拾的差不多就到了 6 月份，在上班的时候看到一个新闻： <code>气象局宣布，上海入梅了！上海昨天由此进入梅雨期，较常年提早9天。</code> ，这应该是整个夏天最闷最潮湿的时候了，我的感受是，北京我没有感觉到有多干燥，但是上海的潮湿是真的潮，洗完衣服晾干，我都怀疑我的感知能力，这衣服真的干了么？无论什么时间，走在室外都感觉随时会出汗，中午的时候甚至有一种水汽往脸上扑的感觉。因为我个人比较容易出汗，所以来到上海还是出汗，感受倒是没差，只是衣服不干比较愁人，也买了各种除湿袋，不知道是否真的有用，同时也在考虑除湿机。</p><h3 id="下雨"><a href="#下雨" class="headerlink" title="下雨"></a>下雨</h3><p>我自己的鞋子都是网或者布料的，所以如果下大雨鞋子肯定会湿，于是特意买了一双皮质的鞋子想着防雨，但是我低估了上海的大雨，鞋子很快就湿了，又因为是皮质的，所以干的还慢。问了同事才知道，这时候需要拖鞋，于是我在公司和家里都放了拖鞋，如果下大雨就还是穿拖鞋吧。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>目前来看，需要多准备几件衣服防止没有晾干，多准备几双鞋子防止鞋子湿了没有更换，同时备着拖鞋。</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="地下"><a href="#地下" class="headerlink" title="地下"></a>地下</h3><p>平时上班做地铁，之前在北京搭乘地铁我有一个不好的习惯：倚靠安全门，来上海的第一天就被说了两次。。现在好多了。</p><p>上海地铁有一点不好，就是没有屏幕实时展示当前地铁行进状态，虽然有小屏幕滚动，但是不够及时，在地铁上玩手机就需要留意广播重的信息，防止坐过站。</p><h3 id="地上"><a href="#地上" class="headerlink" title="地上"></a>地上</h3><p>公司到家的距离是 5 公里，体验了一下骑车回家，上海的自行车道感受很好，首先很宽，其次没有机动车抢占的情况，整体体验要比北京好很多。发现上海的交通管控也要比北京严格一些，经常能在路口看到交警在指挥交通，毕竟很少看到闯红绿灯的情况。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>目前在上海两周，还没有什么不适，感觉不错，目前还有待确定的：1. 没有暖气的冬天；2. 除湿机是否需要。之后如果有了感受再更新上来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 第24周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/13/2020-第24周-LeetCode-记录/</id>
    <published>2020-06-13T07:38:57.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1470-Shuffle-the-Array"><a href="#1470-Shuffle-the-Array" class="headerlink" title="1470. Shuffle the Array"></a>1470. Shuffle the Array</h3><p>重新排列数组，使用 zip 对两个切分后的数组进行聚合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self, nums: List[int], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(nums[<span class="number">0</span>:n],nums[n:]):</span><br><span class="line">            res+=[i,j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1471-The-k-Strongest-Values-in-an-Array"><a href="#1471-The-k-Strongest-Values-in-an-Array" class="headerlink" title="1471. The k Strongest Values in an Array"></a>1471. The k Strongest Values in an Array</h3><p>找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStrongest</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">        median = arr[(len(arr) - <span class="number">1</span>) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> len(arr) + i - j &lt;= k:</span><br><span class="line">            <span class="keyword">if</span> median - arr[i] &gt; arr[j] - median:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[:i] + arr[j + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h3 id="1472-Design-Browser-History"><a href="#1472-Design-Browser-History" class="headerlink" title="1472. Design Browser History"></a>1472. Design Browser History</h3><p>用两个变量记录 homepage 和当前位置，处理几个场景：  </p><ol><li>从当前页跳转访问 url 对应的页面，需要将当前位置之后的所有历史列表清空</li><li>在浏览历史中后退 steps 步，需要与 0 比较，如果小于 0，则将其置为 0</li><li>在浏览历史中前进 steps 步，需要与当前历史记录长度比较，如果超过长度，则取历史记录中最后一个</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, homepage: str)</span>:</span></span><br><span class="line">        self.hist = [homepage]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, url: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        self.hist[self.pos:] = []</span><br><span class="line">        self.hist.append(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos -= steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &lt; <span class="number">0</span>:</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos += steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.hist):</span><br><span class="line">            self.pos = len(self.hist) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br></pre></td></tr></table></figure><h3 id="754-Reach-a-Number"><a href="#754-Reach-a-Number" class="headerlink" title="754. Reach a Number"></a>754. Reach a Number</h3><blockquote><p><a href="https://www.bilibili.com/video/av31621072/" target="_blank" rel="noopener">https://www.bilibili.com/video/av31621072/</a></p></blockquote><blockquote><p><a href="https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/</a></p></blockquote><p>首先， 由于坐标轴是对称的，往左往右走的几率相等，因此可以只考虑右半轴。先递推一下可以知道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步数        能到达的位置</span><br><span class="line">1:          1</span><br><span class="line">2:          3, 1</span><br><span class="line">3:          6, 4, 2, 0</span><br><span class="line">4:          10, 8, 6, 4, 0</span><br><span class="line">5:          15, 13, 11, 9, 7, 5, 3, 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看出来，每一步能到达的最大位置是上一步最大位置加上步数，而每一步所能达到的位置之间间隔都为2。<br>记f(n)为第n步能到达的位置，那么有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(f(n)) = max(f(n-1)) + n</span><br><span class="line">f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]</span><br></pre></td></tr></table></figure><p>如果target可以在第n步达到，那么target一定小于等于max(f(n))且max(f(n))与taget同奇同偶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachNumber</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        target = abs(target)</span><br><span class="line">        p, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; target <span class="keyword">or</span> (p + target) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            p = p + i</span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree"></a>1038. Binary Search Tree to Greater Sum Tree</h3><p>与 538 题相同，使用 dfs 遍历，优先遍历右节点，然后root 节点，最后左节点，使用 currSum 记录比当前节点数值大的数字和，然后将自身与数字和想家，并更新数字和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        currSum = [<span class="number">0</span>]</span><br><span class="line">        self.recurse(root, currSum)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, root, currSum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.recurse(root.right, currSum)</span><br><span class="line">        root.val = root.val + currSum[<span class="number">0</span>]</span><br><span class="line">        currSum[<span class="number">0</span>] = root.val</span><br><span class="line">        self.recurse(root.left, currSum)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1470-Shuffle-the-Array&quot;&gt;&lt;a href=&quot;#1470-Shuffle-the-Array&quot; class=&quot;headerlink&quot; title=&quot;1470. Shuffle the Array&quot;&gt;&lt;/a&gt;1470. Shuffle the A
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第23周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/06/2020-%E7%AC%AC23%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/06/2020-第23周-LeetCode-记录/</id>
    <published>2020-06-06T13:25:41.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays"><a href="#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays" class="headerlink" title="1460. Make Two Arrays Equal by Reversing Sub-arrays"></a>1460. Make Two Arrays Equal by Reversing Sub-arrays</h3><p>比较两个列表是否可以通过翻转等价，统计列表中字母出现的次数判断，或者可以直接排序判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canBeEqual</span><span class="params">(self, target: List[int], arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        c = collections.Counter(target)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            c[a] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c[a] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1464-Maximum-Product-of-Two-Elements-in-an-Array"><a href="#1464-Maximum-Product-of-Two-Elements-in-an-Array" class="headerlink" title="1464. Maximum Product of Two Elements in an Array"></a>1464. Maximum Product of Two Elements in an Array</h3><p>找到数组中最大的两个数字，分别将其数值 -1 然后相乘返回。可以直接升序排序后取最后两个数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max:=<span class="number">0</span></span><br><span class="line">    secondMax:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        e:=nums[i]</span><br><span class="line">        <span class="keyword">if</span> e&gt;max&#123;</span><br><span class="line">            secondMax = max</span><br><span class="line">            max = e</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> e&gt;secondMax&#123;</span><br><span class="line">            secondMax = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (max<span class="number">-1</span>)*(secondMax<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K"><a href="#1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K" class="headerlink" title="1461. Check If a String Contains All Binary Codes of Size K"></a>1461. Check If a String Contains All Binary Codes of Size K</h3><p>s 字符串中只包含0或1，滑动窗口计算 s 所有长度为 k 的组合，使用 set 去重，与 K 个数字的二进制字符串数量相比较，是否相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAllCodes</span><span class="params">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        m = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)-k+<span class="number">1</span>):</span><br><span class="line">            m.add(s[i:i+k])</span><br><span class="line">        <span class="keyword">return</span> len(m) == (<span class="number">1</span> &lt;&lt; k)</span><br></pre></td></tr></table></figure><h3 id="1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts"><a href="#1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts" class="headerlink" title="1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"></a>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</h3><p>分别对两个数组进行排序切割，找到两个元素之间间隔最大的数值，然后将其相乘为最终所求面积大小，对 <code>1e9 +7</code> 取余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(h <span class="keyword">int</span>, w <span class="keyword">int</span>, horizontalCuts []<span class="keyword">int</span>, verticalCuts []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxH, maxV := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">pre := <span class="number">0</span></span><br><span class="line">sort.Ints(horizontalCuts)</span><br><span class="line">sort.Ints(verticalCuts)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(horizontalCuts); i++ &#123;</span><br><span class="line">maxH = max(maxH, horizontalCuts[i] - pre)</span><br><span class="line">pre = horizontalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxH = max(maxH, h - pre)</span><br><span class="line">pre = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(verticalCuts); i++ &#123;</span><br><span class="line">maxV = max(maxV, verticalCuts[i] - pre)</span><br><span class="line">pre = verticalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxV = max(maxV, w - pre)</span><br><span class="line"><span class="keyword">return</span> (maxH * maxV) % <span class="number">1000000007</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><p>遍历 connections ，统计每个节点之间相邻的节点，使用 dfs 从 0 开始计算，当相邻节点已经访问过了，直接跳过，如果没有访问过，且相邻节点到当前节点方向不对，那么就将结果 +1，并将其添加到访问过的集合中，继续dfs 相邻节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        edges = &#123; (a,b) <span class="keyword">for</span> a, b <span class="keyword">in</span> connections &#125; <span class="comment"># instantly check if a-&gt;b</span></span><br><span class="line">        neighbors = &#123; i:[] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;     <span class="comment"># adjacent cities</span></span><br><span class="line">        visit = set()                             <span class="comment"># visit each city once</span></span><br><span class="line">        changes = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            neighbors[a].append(b)</span><br><span class="line">            neighbors[b].append(a)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs from City 0, count outgoing edges</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> edges, neighbors, visit, changes</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors[city]:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">in</span> visit:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># neighbor can't reach city</span></span><br><span class="line">                <span class="keyword">if</span> (neighbor, city) <span class="keyword">not</span> <span class="keyword">in</span> edges:</span><br><span class="line">                    changes += <span class="number">1</span></span><br><span class="line">                visit.add(neighbor)</span><br><span class="line">                dfs(neighbor)</span><br><span class="line">        </span><br><span class="line">        visit.add(<span class="number">0</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> changes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot;&gt;&lt;a href=&quot;#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第22周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/01/2020-%E7%AC%AC22%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/01/2020-第22周-LeetCode-记录/</id>
    <published>2020-06-01T05:44:57.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence"><a href="#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence" class="headerlink" title="1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence"></a>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</h3><p>切分句子然后遍历判断是否为前缀，需要返回索引 + 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, sentence: str, searchWord: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> idx, w <span class="keyword">in</span> enumerate(sentence.split(<span class="string">' '</span>)):</span><br><span class="line">            <span class="keyword">if</span> w.startswith(searchWord):</span><br><span class="line">                <span class="keyword">return</span> idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length"><a href="#1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length" class="headerlink" title="1456. Maximum Number of Vowels in a Substring of Given Length"></a>1456. Maximum Number of Vowels in a Substring of Given Length</h3><p>滑动窗口，使用字典统计每个元音出现的次数，每次更新最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxVowels</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'e'</span>: <span class="number">0</span>, <span class="string">'i'</span>: <span class="number">0</span>, <span class="string">'o'</span>: <span class="number">0</span>, <span class="string">'u'</span>: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[:k]:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> d:</span><br><span class="line">                d[c] += <span class="number">1</span></span><br><span class="line">        res = sum(d.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i-k] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i-k]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i]] += <span class="number">1</span></span><br><span class="line">            res = max(res, sum(d.values()))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1200-Minimum-Absolute-Difference"><a href="#1200-Minimum-Absolute-Difference" class="headerlink" title="1200. Minimum Absolute Difference"></a>1200. Minimum Absolute Difference</h3><p>遍历列表，记录前一个数值，每次计算绝对差值，更新最小值，如果差值等于最小值，则将其加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span><span class="params">(self, arr: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        m = float(<span class="string">'inf'</span>)</span><br><span class="line">        out = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">            prev = arr[i - <span class="number">1</span>]</span><br><span class="line">            curr = abs(prev - arr[i])</span><br><span class="line">            <span class="keyword">if</span> curr &lt; m:</span><br><span class="line">                out = [[prev, arr[i]]]</span><br><span class="line">                m = curr</span><br><span class="line">            <span class="keyword">elif</span> curr == m: out.append([prev, arr[i]])</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree"><a href="#1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree" class="headerlink" title="1457. Pseudo-Palindromic Paths in a Binary Tree"></a>1457. Pseudo-Palindromic Paths in a Binary Tree</h3><p>DFS 遍历二叉树，使用 set 记录已有数值，如果该数值已经存在，则删掉，如果不存在，则加入set。判断回文字符的依据是set 中剩余字母长度是否小于等于1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        s = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            res = dfs(root.left) + dfs(root.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res += len(s)&lt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence&quot;&gt;&lt;a href=&quot;#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第21周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/22/2020-%E7%AC%AC21%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/22/2020-第21周-LeetCode-记录/</id>
    <published>2020-05-22T22:28:29.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1446-Consecutive-Characters"><a href="#1446-Consecutive-Characters" class="headerlink" title="1446. Consecutive Characters"></a>1446. Consecutive Characters</h3><p>判断最长连续相同字符的长度，记录下当前字母，然后比较与 flag 是否相同，如果相同则 +1，不相同则重置为 1。</p><p>也可以通过 itertools.groupby 来实现（新学习的。。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPower</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp = s[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i == tmp:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = i</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            max_cnt = max(max_cnt, cnt)</span><br><span class="line">        <span class="keyword">return</span> max_cnt</span><br></pre></td></tr></table></figure><h3 id="1447-Simplified-Fractions"><a href="#1447-Simplified-Fractions" class="headerlink" title="1447. Simplified Fractions"></a>1447. Simplified Fractions</h3><p>遍历分子与分母，求最大公约数，如果最大公约数为1，则将结果保存下来。分母从 2 开始计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifiedFractions</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> gcd(i, j) == <span class="number">1</span> &#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, fmt.Sprintf(<span class="string">"%d/%d"</span>, j, i))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x%y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1448-Count-Good-Nodes-in-Binary-Tree"><a href="#1448-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="1448. Count Good Nodes in Binary Tree"></a>1448. Count Good Nodes in Binary Tree</h3><p>遍历所有节点，记录 root 节点到当前节点经过的最大值，当前节点数值与最大值进行比较，如果符合条件，则结果 +1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, curmax)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> node.val &gt;= curmax:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            curmax = max(curmax, node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                dfs(node.left, curmax)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                dfs(node.right, curmax)</span><br><span class="line">            </span><br><span class="line">        dfs(root, -float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h3><p>遍历开始时间和结束时间，判断查询时间是否在两者之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busyStudent</span><span class="params">(self, startTime: List[int], endTime: List[int], queryTime: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(a&lt;=queryTime&lt;=b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(startTime,endTime))</span><br></pre></td></tr></table></figure><h3 id="896-Monotonic-Array"><a href="#896-Monotonic-Array" class="headerlink" title="896. Monotonic Array"></a>896. Monotonic Array</h3><p>遍历数组，记录前一个数字与当前数字的差值，判断是否单调递增或递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt_inc = <span class="number">0</span>; cnt_dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: prev = v; <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>   v &gt; prev: cnt_inc += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; prev: cnt_dec += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt_inc <span class="keyword">and</span> cnt_dec: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            prev = v</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1446-Consecutive-Characters&quot;&gt;&lt;a href=&quot;#1446-Consecutive-Characters&quot; class=&quot;headerlink&quot; title=&quot;1446. Consecutive Characters&quot;&gt;&lt;/a&gt;1446
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第20周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/16/2020-%E7%AC%AC20%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/16/2020-第20周-LeetCode-记录/</id>
    <published>2020-05-16T10:17:49.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1441-Build-an-Array-With-Stack-Operations"><a href="#1441-Build-an-Array-With-Stack-Operations" class="headerlink" title="1441. Build an Array With Stack Operations"></a>1441. Build an Array With Stack Operations</h3><p>遍历数组，比较当前值与目标值是否相同，如果相同，则在结果追加 <code>Push</code> ，如果不同，则追加 <code>Push</code>, <code>Pop</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildArray</span><span class="params">(self, target: List[int], n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        keep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(<span class="string">"Push"</span>)</span><br><span class="line">            keep += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> target:</span><br><span class="line">                res.append(<span class="string">"Pop"</span>)</span><br><span class="line">                keep -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> keep == len(target):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a>1442. Count Triplets That Can Form Two Arrays of Equal XOR</h3><p>求子数组中是否存在左侧部分异或值与右侧部分异或值相等的情况，a==b -&gt; a ^ b = 0，也就是是否存在子数组所有元素异或值为0 的情况，如果存在，那么子数组所有的元素都可以符合条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                temp = temp^arr[j]</span><br><span class="line">                <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                    count += j-i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers"><a href="#1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers" class="headerlink" title="1317. Convert Integer to the Sum of Two No-Zero Integers"></a>1317. Convert Integer to the Sum of Two No-Zero Integers</h3><p>从 1 开始遍历判断两个拆分数字是否包含 <code>0</code> ，判断对 10 取余是否为0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNoZeroIntegers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.check(i) <span class="keyword">and</span> self.check(n - i):</span><br><span class="line">                <span class="keyword">return</span> [i, n - i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree"></a>1443. Minimum Time to Collect All Apples in a Tree</h3><p>通过字典来保证每条路径只走一次，判断子节点是否有苹果，如果没有，则将子节点从字典中删除，最终字典中保存的是必须要经过的节点，要走 2 次，所以需要 * 2 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTime</span><span class="params">(self, n: int, edges: List[List[int]],</span></span></span><br><span class="line"><span class="function"><span class="params">                hasApple: List[bool])</span> -&gt; int:</span></span><br><span class="line">        maps = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            maps[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            selfOrChildHasApple = hasApple[i]</span><br><span class="line">            <span class="keyword">for</span> nex <span class="keyword">in</span> maps[i]:</span><br><span class="line">                selfOrChildHasApple |= dfs(nex)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> selfOrChildHasApple:</span><br><span class="line">                <span class="keyword">del</span> maps[i]</span><br><span class="line">            <span class="keyword">return</span> selfOrChildHasApple</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, <span class="number">2</span> * (len(maps) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="807-Max-Increase-to-Keep-City-Skyline"><a href="#807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="807. Max Increase to Keep City Skyline"></a>807. Max Increase to Keep City Skyline</h3><p>分别找出每行、每列的最大值，然后遍历判断当前值距离两个最大值中的最小值需要增加多少，累加计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        max_cols = [max(col) <span class="keyword">for</span> col <span class="keyword">in</span> zip(*grid)]</span><br><span class="line">        max_rows = [max(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid]</span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[i])):</span><br><span class="line">                inc += (min(max_cols[j], max_rows[i]) - grid[i][j])</span><br><span class="line">        <span class="keyword">return</span> inc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1441-Build-an-Array-With-Stack-Operations&quot;&gt;&lt;a href=&quot;#1441-Build-an-Array-With-Stack-Operations&quot; class=&quot;headerlink&quot; title=&quot;1441. Buil
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>PyInstaller 与 RPM 配合使用踩坑</title>
    <link href="https://zdyxry.github.io/2020/05/13/PyInstaller-%E4%B8%8E-RPM-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"/>
    <id>https://zdyxry.github.io/2020/05/13/PyInstaller-与-RPM-配合使用踩坑/</id>
    <published>2020-05-13T20:35:50.000Z</published>
    <updated>2020-08-16T02:29:02.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配置会有坑，然后搜索下来几乎没看到有人提到，可能用 pyinstaller 和用 rpm 的完全是两类人吧 - -。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先列一下官方默认例子的输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/demo</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls</span></span><br><span class="line">demo.py</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> pyinstaller demo.py</span></span><br><span class="line">63 INFO: PyInstaller: 3.6</span><br><span class="line">63 INFO: Python: 3.6.8</span><br><span class="line">65 INFO: Platform: Linux-3.10.0-862.el7.x86_64-x86_64-with-centos-7.5.1804-Core</span><br><span class="line">65 INFO: wrote /tmp/demo/demo.spec</span><br><span class="line">67 INFO: UPX is not available.</span><br><span class="line">70 INFO: Extending PYTHONPATH with paths</span><br><span class="line">['/tmp/demo', '/tmp/demo']</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>来看一下生成文件的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── demo</span><br><span class="line">├── demo.py</span><br><span class="line">├── demo.spec</span><br><span class="line">├── dist</span><br><span class="line">│   └── demo</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── binascii.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _bisect.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _blake2.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">|       ├── ...</span><br><span class="line">│       ├── _codecs_kr.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _codecs_tw.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _datetime.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── demo</span><br><span class="line">│       ├── libbz2.so.1</span><br><span class="line">│       ├── libcom_err.so.2</span><br><span class="line">│       ├── libcrypto.so.10</span><br><span class="line">│       ├── libexpat.so.1</span><br><span class="line">│       ├── libgssapi_krb5.so.2</span><br><span class="line">│       ├── libk5crypto.so.3</span><br><span class="line">│       ├── libkeyutils.so.1</span><br><span class="line">│       ├── libtinfo.so.5</span><br><span class="line">│       ├── libkrb5support.so.0</span><br><span class="line">│       ├── liblzma.so.5</span><br><span class="line">│       ├── libpcre.so.1</span><br><span class="line">│       ├── libpython3.6m.so.1.0</span><br><span class="line">│       ├── libreadline.so.6</span><br><span class="line">│       ├── libz.so.1</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── demo.cpython-36.pyc</span><br></pre></td></tr></table></figure><p>看上去也没啥问题，编写一个 rpm spec，然后使用 rpmbuild 直接就可以生成一个 RPM出来，在 RedHat 系列的 OS上可以直接安装使用，具体的步骤可以参考之前的博客：<a href="https://zdyxry.github.io/2018/07/28/RPM-%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/">《RPM 常用构建方式》</a>，目前来看一切都正常，但是坑来了。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在验证完基础的功能后，我想要将这个 RPM 放到 ISO 中发布，在验证过程中，发现这个 RPM 会破坏系统其他的依赖检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:00:20 tmp]$cat packaging.log |grep so |grep 'No such file'</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error ...</span><br><span class="line">09:19:50,495 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /usr/bin/trust: error while loading shared libraries: libfreebl3.so: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,500 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,501 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>简单的过滤了一下，有这些包直接受到了影响，还有很多未知的，简单的说就是系统的一些核心依赖库缺失，没有安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:02:48 tmp]$cat packaging.log |grep 'scriptlet failed'</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(readline-6.2-10.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(gawk-4.0.2-4.el7_3.1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(info-5.1-4.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(qemu-kvm-aurora-0.3.3-1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,495 INFO packaging: warning: %post(glib2-2.50.3-3.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,499 INFO packaging: warning: %post(ca-certificates-2017.2.14-71.el7.noarch) scriptlet failed, exit status 127</span><br></pre></td></tr></table></figure><p>最初在排查是否是 anaconda 在检查 rpm 相互之间的依赖时出了 bug，但是最近版本没什么变化，理论上不会，又去瞧了瞧 anaconda 的代码，发现跟 rpm 相关的太多，一时也没看出什么头绪。</p><p>再来看一下相关的库， <code>libz.so.1</code> , <code>libtinfo.so.5</code> 有没有点眼熟，都是在 pyinstaller 生成的文件中的，但是有一点很奇怪，命令路径都不是系统路径，为什么在检查依赖的时候还是会检查到新加入的 rpm 上，而不是真正提供这些库的 RPM？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>今天的主角登场：Automatic Dependencies。</p><p>Automatic Dependencies 是 RPM 的一个特性，官方文档中是这么描述的：</p><blockquote><p>When a package is built by RPM, if any file in the package’s %files list is a shared library, the library’s soname is automatically added to the list of capabilities the package provides. The soname is the name used to determine compatibility between different versions of a library.</p></blockquote><blockquote><p>Note that this is not a filename. In fact, no aspect of RPM’s dependency processing is based on filenames. Many people new to RPM often make the assumption that a failed dependency represents a missing file. This is not the case.</p></blockquote><blockquote><p>Remember that RPM’s dependency processing is based on knowing what capabilities are provided by a package and what capabilities a package requires. We’ve seen how RPM automatically determines what shared library resources a package provides. But does it automatically determine what shared libraries a package requires?</p></blockquote><blockquote><p>Yes! RPM does this by running ldd on every executable program in a package’s %files list. Since ldd provides a list of the shared libraries each program requires, both halves of the equation are complete — that is, the packages that make shared libraries available, and the packages that require those shared libraries, are tracked by RPM. RPM can then take that information into account when packages are installed, upgraded, or erased.</p></blockquote><p>嗯，找到问题了，解决的方式也很简单，直接关掉就好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoReqProv: no</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说 pyinstaller 用的人不少，rpm 用的人也不少，这俩默认配置配合使用是一定会出问题的，但是没有找到相关的问题，可能真的不是一类人吧。</p><p>用同事的话作为结束语： <code>automatic 开头的东西，一个字都不要信</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第19周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/08/2020-%E7%AC%AC19%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/08/2020-第19周-LeetCode-记录/</id>
    <published>2020-05-08T07:48:12.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1436-Destination-City"><a href="#1436-Destination-City" class="headerlink" title="1436. Destination City"></a>1436. Destination City</h3><p>使用 set() 来计算每个城市是否处于起始和终止，集合差为终点站。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destCity</span><span class="params">(self, paths: List[List[str]])</span> -&gt; str:</span></span><br><span class="line">        a = set()</span><br><span class="line">        b = set()</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">            x, y = path</span><br><span class="line">            a.add(x)</span><br><span class="line">            b.add(y)</span><br><span class="line"></span><br><span class="line">        b = b - a</span><br><span class="line">        <span class="keyword">assert</span> len(b) == <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> b.pop()</span><br></pre></td></tr></table></figure><h3 id="1432-Max-Difference-You-Can-Get-From-Changing-an-Integer"><a href="#1432-Max-Difference-You-Can-Get-From-Changing-an-Integer" class="headerlink" title="1432. Max Difference You Can Get From Changing an Integer"></a>1432. Max Difference You Can Get From Changing an Integer</h3><p>分别求出给定数字可以转换的最大值和最小值，然后求差，最大值是将数字从前向后遍历，当数值不为9时，将其替换为 9；最小值要求首位不能为 0，则需要特殊判断，如果首位不为1，则将其替换为1，如果首位为1，则遍历后续数字，如果数字不为0，则替换为0，需要注意此时首位为1，如果数字为1然后替换为0会出现首位为0 情况，因此需要判断数字不为0且不为1，然后替换为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDiff</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        a = b = str(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> a:</span><br><span class="line">            <span class="keyword">if</span> digit != <span class="string">"9"</span>:</span><br><span class="line">                a = a.replace(digit, <span class="string">"9"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> b[<span class="number">0</span>] != <span class="string">"1"</span>:</span><br><span class="line">            b = b.replace(b[<span class="number">0</span>], <span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> digit <span class="keyword">in</span> b[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> digit <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"01"</span>:</span><br><span class="line">                    b = b.replace(digit, <span class="string">"0"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> int(a) - int(b)</span><br></pre></td></tr></table></figure><h3 id="1433-Check-If-a-String-Can-Break-Another-String"><a href="#1433-Check-If-a-String-Can-Break-Another-String" class="headerlink" title="1433. Check If a String Can Break Another String"></a>1433. Check If a String Can Break Another String</h3><p>检查两个字符串的字符序是否存在交叉情况，先对字符串进行排序，然后使用两个 flag 标记当前字符的大小，如果有大有小，那么直接返回 False，否则返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfCanBreak</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        s1= sorted(s1)</span><br><span class="line">        s2= sorted(s2)</span><br><span class="line">        res1, res2 = <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> zip(s1, s2):</span><br><span class="line">            com = ord(pair[<span class="number">0</span>]) - ord(pair[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> com &gt; <span class="number">0</span>:</span><br><span class="line">                res1 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> com &lt; <span class="number">0</span>:</span><br><span class="line">                res2 = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> res1 <span class="keyword">and</span> res2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away"><a href="#1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away" class="headerlink" title="1437. Check If All 1’s Are at Least Length K Places Away"></a>1437. Check If All 1’s Are at Least Length K Places Away</h3><p>检查每个数字 1 之间的间隔是否大于 k，如果不大于则返回 False，遍历数字，如果数字不为 1，则将间隔 +1，直到下次遇1时判断并重置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kLengthApart</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        zero_num = <span class="number">1e5</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> zero_num &lt; k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                zero_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                zero_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</h3><p>滑动窗口，遍历数字，每次更新最大值与最小值，如果符合条件，则窗口增大，否则从左侧缩小窗口，缩小窗口后需要注意更新最大值与最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int], limit: int)</span> -&gt; int:</span></span><br><span class="line">        minimal, maximal = float(<span class="string">"inf"</span>), float(<span class="string">"-inf"</span>)</span><br><span class="line">        size, current_size_start_number = <span class="number">0</span>, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            maximal = max(maximal, nums[i])</span><br><span class="line">            minimal = min(minimal, nums[i])</span><br><span class="line">            <span class="keyword">if</span> abs(maximal - minimal) &lt;= limit:</span><br><span class="line">                size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_size_start_number = nums[i-size]</span><br><span class="line">                <span class="keyword">if</span> current_size_start_number == minimal:</span><br><span class="line">                    minimal = min(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> current_size_start_number == maximal:</span><br><span class="line">                    maximal = max(nums[i - size + <span class="number">1</span>:i + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1436-Destination-City&quot;&gt;&lt;a href=&quot;#1436-Destination-City&quot; class=&quot;headerlink&quot; title=&quot;1436. Destination City&quot;&gt;&lt;/a&gt;1436. Destination City
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第18周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/01/2020-%E7%AC%AC18%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/01/2020-第18周-LeetCode-记录/</id>
    <published>2020-05-01T06:43:57.000Z</published>
    <updated>2020-08-16T02:29:02.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1422-Maximum-Score-After-Splitting-a-String"><a href="#1422-Maximum-Score-After-Splitting-a-String" class="headerlink" title="1422. Maximum Score After Splitting a String"></a>1422. Maximum Score After Splitting a String</h3><p>求出左侧 0 数量和右侧 1 数量之和最多的情况，遍历一次，每次更新最大值，注意要保证字符串始终被切分为 2 个子字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        right = s.count(<span class="string">'1'</span>)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        score = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[idx] == <span class="string">'1'</span>:</span><br><span class="line">                score = max(score, (left + right - <span class="number">1</span>))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                score = max(score, (left + <span class="number">1</span> + right))</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure><h3 id="1423-Maximum-Points-You-Can-Obtain-from-Cards"><a href="#1423-Maximum-Points-You-Can-Obtain-from-Cards" class="headerlink" title="1423. Maximum Points You Can Obtain from Cards"></a>1423. Maximum Points You Can Obtain from Cards</h3><p>先假设所有的数字都是从左侧获取的，然后依次遍历 k 个数值，每次遍历将左侧数字剔除，将右侧数字加入，比较最大值。</p><p>也可以转换问题为中间连续 len-k 长度数字和最小，然后所有数字之和减去最小值为所求结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxScore</span><span class="params">(cardPoints []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum + cardPoints[i]</span><br><span class="line">&#125;</span><br><span class="line">listLen := <span class="built_in">len</span>(cardPoints)</span><br><span class="line"><span class="keyword">if</span> k == listLen &#123;</span><br><span class="line"><span class="keyword">return</span> leftSum</span><br><span class="line">&#125;</span><br><span class="line">max := leftSum</span><br><span class="line"><span class="keyword">var</span> rightSum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">leftSum = leftSum - cardPoints[k-i<span class="number">-1</span>]</span><br><span class="line">rightSum = rightSum + cardPoints[listLen-i<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> leftSum+rightSum &gt; max &#123;</span><br><span class="line">max = leftSum + rightSum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a>1424. Diagonal Traverse II</h3><p>按照对角线方式打印出所有数字，考虑对角线部分数字为空的情况。在一个对角线上的数字，他们的横纵坐标之和都是相同的，使用一个二维数组存储，然后从上到下顺序打印出所有对角线的数值，需要注意每条对角线的数值输出应该是从下到上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="params">(ans []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    order := [<span class="number">1e5</span>][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(mat) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> mat[i] &#123;</span><br><span class="line">order[i+j] = <span class="built_in">append</span>(order[i+j], v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> order &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">ans = <span class="built_in">append</span>(ans, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a>498. Diagonal Traverse</h3><p>可以用 #1424 相同的方式处理，获取所有对角线的数值，然后遍历，注意输出的顺序，也可以直接模拟，需要处理好边界。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, n*m)</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(res); i++ &#123;</span><br><span class="line">res[i] = matrix[x][y]</span><br><span class="line"><span class="keyword">if</span> (x+y)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> y == m<span class="number">-1</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y++</span><br><span class="line">x--</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == n<span class="number">-1</span> &#123;</span><br><span class="line">y++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x++</span><br><span class="line">y--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h3><p>一个数字与全 1 进行异或，得到的数字为二进制取反。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findComplement</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">temp := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; temp &lt;= num; temp *= <span class="number">2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (temp - <span class="number">1</span>) ^ num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">5</span></span><br><span class="line">res := findComplement(num)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1422-Maximum-Score-After-Splitting-a-String&quot;&gt;&lt;a href=&quot;#1422-Maximum-Score-After-Splitting-a-String&quot; class=&quot;headerlink&quot; title=&quot;1422. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>在终端输入命令后系统做了什么</title>
    <link href="https://zdyxry.github.io/2020/04/25/%E5%9C%A8%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E5%90%8E%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://zdyxry.github.io/2020/04/25/在终端输入命令后系统做了什么/</id>
    <published>2020-04-25T15:18:03.000Z</published>
    <updated>2020-08-16T02:29:02.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>shell 是一个程序，也是一种编程语言，一个管理进程和运行程序的程序，在 Linux 中有很多 shell 可选，比如 bash、zsh、fish 等等，shell 主要有 3 个功能：</p><ol><li>运行程序</li><li>管理输入和输出</li><li>可编程</li></ol><p>运行程序很容易理解，在终端上输入的每个命令都是一个可执行程序，我们在 shell 中输入并执行程序；管理输入和输出，在 shell 中可以使用 <code>&lt;</code> <code>&gt;</code> <code>|</code> 符合控制输入、输出重定向，可以告诉 shell 将进程的输入和输出连接到一个文件或者其他的进程；编程，shell 是一种编程语言，可以进行变量赋值、循环、条件判断等操作。</p><h3 id="如何运行程序"><a href="#如何运行程序" class="headerlink" title="如何运行程序"></a>如何运行程序</h3><p>shell 永远在等待用户输入，输入完成按下回车键后，开始执行相应命令（程序），然后等待程序执行完成后打印相应输出，伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (! end_of_input)</span><br><span class="line">    get command</span><br><span class="line">    execute command</span><br><span class="line">    wait for command to finish</span><br></pre></td></tr></table></figure><p>在 shell 中因为需要执行其他的程序，需要用到 <code>execvp</code> ，<code>execvp</code> 会将指定的程序复制到调用它的进程，将指定的字符串组作为参数传递给程序，然后运行程序。这里存在一个问题， <code>execvp</code> 的执行过程是内核将程序加载到当前进程，替换当前进程的代码和数据，然后执行，那么原有进程的状态都被替换掉，在执行完程序就直接退出，不会再回到原程序等待下次输入。</p><p>为了保证我们在执行程序后回到 shell 中，需要每次创建新的进程来执行程序，调用 <code>fork</code> 指令，进程调用 fork 后，内核分配新的内存块和内核数据结构，复制原进程到新的进程，向运行进程添加新的进程，将控制返回给两个进程。通过 fork 返回值来判断当前进程是否为父进程或子进程。</p><p>shell 作为父进程通过调用 <code>fork</code> 创建子进程后，子进程通过 <code>execvp</code> 加载指定程序执行，父进程需要等待子进程退出，需要用到 <code>wait</code> ，在父进程 fork 出子进程后，父进程执行 <code>wait</code> 等待子进程执行，在调用时会传递一个整型变量地址，子进程执行完成后调用 <code>exit</code> 退出，内核将子进程的退出状态保存在这个变量中，用于父进程感知子进程退出状态。</p><h2 id="Golang-简易实现"><a href="#Golang-简易实现" class="headerlink" title="Golang 简易实现"></a>Golang 简易实现</h2><p>在 Golang 中可以调用 <code>os/exec</code> 来执行其他程序，然后在 main 中死循环不断的检测用户输入字符，同时也需要注意处理各种信号，比如 Ctrl-C 或者 Ctrl-D 之类的，下面是 Simon Jürgensmeyer 实现的一个简单的样例，可以了解一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">"&gt; "</span>)</span><br><span class="line">        <span class="comment">// Read the keyboad input.</span></span><br><span class="line">        input, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle the execution of the input.</span></span><br><span class="line">        <span class="keyword">if</span> err = execInput(input); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrNoPath is returned when 'cd' was called without a second argument.</span></span><br><span class="line"><span class="keyword">var</span> ErrNoPath = errors.New(<span class="string">"path required"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execInput</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Remove the newline character.</span></span><br><span class="line">    input = strings.TrimSuffix(input, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split the input separate the command and the arguments.</span></span><br><span class="line">    args := strings.Split(input, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for built-in commands.</span></span><br><span class="line">    <span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"cd"</span>:</span><br><span class="line">        <span class="comment">// 'cd' to home with empty path not yet supported.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrNoPath</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change the directory and return the error.</span></span><br><span class="line">        <span class="keyword">return</span> os.Chdir(args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the command to execute.</span></span><br><span class="line">    cmd := exec.Command(args[<span class="number">0</span>], args[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the correct output device.</span></span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the command and return the error.</span></span><br><span class="line">    <span class="keyword">return</span> cmd.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/" target="_blank" rel="noopener">https://sj14.gitlab.io/post/2018/07-01-go-unix-shell/</a></li><li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="noopener">https://book.douban.com/subject/1219329/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;无论是使用 VNC 连接还是 SSH 连接，每天都在用终端去执行命令，今天来了解下在执行命令后，系统具体做了什么，如何做的。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
