<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2020-03-13T13:03:41.866Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SR-IOV 基本概念</title>
    <link href="https://zdyxry.github.io/2020/03/12/SR-IOV-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://zdyxry.github.io/2020/03/12/SR-IOV-基本概念/</id>
    <published>2020-03-12T15:04:27.000Z</published>
    <updated>2020-03-13T13:03:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上周了解了 RDMA 的基础概念之后，发现在 KVM 平台无需其他配置就可使用，但是在 vSphere 场景下，需要面临一个取舍，其中的一个选择就是 SR-IOV ，今天来了解下 SR-IOV 。</p><h2 id="SR-IOV"><a href="#SR-IOV" class="headerlink" title="SR-IOV"></a>SR-IOV</h2><img src="/2020/03/12/SR-IOV-基本概念/sriov1.png" title="sriov1"><p>SR-IOV 全称 <code>Single Root I/O Virtualization</code>，是 Intel 在 2007年提出的一种基于硬件的虚拟化解决方案。</p><p>在虚拟化场景中，CPU 与内存是最先解决的，但是 I/O 设备一直没有很好的解决办法，Intel 有 VT-d（Virtualization Technology for Directed I/O）可以将物理服务器的 PCIe 设备直接提供给虚拟机使用，也就是我们常说的“直通”（passthrough），但是直通面临一个问题是 PCIe 设备只能给一个虚拟机使用，其他虚拟机就只能干瞪眼，这肯定是不行的，所以有了 SR-IOV，一个物理设备可以虚拟出多个虚拟设备给虚拟机使用。</p><p>SR-IOV 是一种规范，使得单根端口下的单个快速外围组件互连 (PCIe) 物理设备显示为管理程序或客户机操作系统的多个单独的物理设备，既有直通设备的性能优势，又可以支持多个虚拟机，一举两得。</p><img src="/2020/03/12/SR-IOV-基本概念/sriov2.png" title="sriov2"><p>SR-IOV 使用 physical functions (PF) 和 virtual functions (VF) 为 SR-IOV 设备管理全局功能。</p><ul><li>PF 包含SR-IOV 功能的完整PCIe设备，PF 作为普通的PCIe 设备被发现、管理和配置 。PF 通过分配VF 来配置和管理 SR-IOV 功能。禁用SR-IOV后，主机将在一个物理网卡上创建一个 PF。</li><li>VF 是轻量级 PCIe 功能（I/O 处理）的 PCIe 设备，每个 VF 都是通过 PF 来生成管理的，VF 的具体数量限制受限于 PCIe 设备自身配置及驱动程序的支持，启用S​​R-IOV后，主机将在一个物理NIC上创建单个PF和多个VF。 VF的数量取决于配置和驱动程序支持。</li></ul><blockquote><p>每个 SR-IOV 设备都可有一个 PF(Physical Functions)，并且每个 PF 最多可有64,000个与其关联的 VF(Virtual Function)。PF 可以通过寄存器创建 VF，这些寄存器设计有专用于此目的的属性。一旦在 PF 中启用了 SR-IOV，就可以通过 PF 的总线、设备和功能编号（路由 ID）访问各个 VF 的 PCI 配置空间。</p><p>每个 VF 都具有一个 PCI 内存空间，用于映射其寄存器集。VF设备驱动程序对寄存器集进行操作以启用其功能，并且显示为实际存在的PCI设备。创建 VF 后，可以直接将其指定给虚拟机或各个应用程序。此功能使得虚拟功能可以共享物理设备，并在没有CPU和虚拟机管理程序软件开销的情况下执行 I/O。</p></blockquote><h3 id="SR-IOV-with-RDMA"><a href="#SR-IOV-with-RDMA" class="headerlink" title="SR-IOV with RDMA"></a>SR-IOV with RDMA</h3><p>上面介绍了 SR-IOV 的基本概念，现在来说说什么时候会用到 SR-IOV，上周说我们产品中使用了 RDMA，那么在多种虚拟化平台下要想统一支持是比较困难的，KVM 是最轻松的，vSphere 就面临一个选择，SR-IOV 方式支持 vs vRDMA。</p><img src="/2020/03/12/SR-IOV-基本概念/sriov3.png" title="sriov3"><p>其中 SR-IOV 支持方式就如前面提到的概念一样，大概需要如下配置：</p><ul><li>在 BIOS 中启用网卡的 SR-IOV 功能</li><li>在 ESXi 安装 MFT vib 工具，用于管理和配置网卡 FW</li><li>在网卡 FW 中开启 SR-IOV，设置最大的 VF 数量</li><li>在 ESXi 网卡驱动中，开启 SRIOV，设置 VF 数量，需要重启 ESXi</li><li>创建对应的 vSwitch 并将 PF 作为上联网卡接入</li><li>创建虚拟机，添加 VF 作为 SR-IOV 网络适配器，并选择 PF 所在的 vSwitch 即可</li></ul><img src="/2020/03/12/SR-IOV-基本概念/sriov4.png" title="sriov4"><p>vRDMA 是 vSphere 提供的一种软件模拟 RDMA 的方式，但是他的性能受到很大影响，我们使用 RDMA 就是为了提高性能，所以这种就不会考虑了。<br>具体性能对比如下：</p><img src="/2020/03/12/SR-IOV-基本概念/sriov5.png" title="sriov5"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="SR-IOV-优点"><a href="#SR-IOV-优点" class="headerlink" title="SR-IOV 优点"></a>SR-IOV 优点</h3><ul><li>性能好</li><li>减少主机 CPU 消耗</li></ul><h3 id="SR-IOV-缺点"><a href="#SR-IOV-缺点" class="headerlink" title="SR-IOV 缺点"></a>SR-IOV 缺点</h3><ul><li>虚拟机使用 VF 后无法进行内存超分、快照、热迁移等高级功能</li><li>配置管理复杂</li></ul><p>不知道是不是接触的少，在日常中几乎没有遇到过使用 SR-IOV 的客户，只有少数客户会提出要有 SR-IOV 的需求，看到在 K8s 场景下有对应的 CNI 插件可以做到 SR-IOV 的管理，之后找时间看看是如何做到的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://octo.vmware.com/wp-content/uploads/2012/09/RDMAonvSphere.pdf" target="_blank" rel="noopener">https://octo.vmware.com/wp-content/uploads/2012/09/RDMAonvSphere.pdf</a></li><li><a href="https://docs.mellanox.com/pages/releaseview.action?pageId=15055422" target="_blank" rel="noopener">https://docs.mellanox.com/pages/releaseview.action?pageId=15055422</a></li><li><a href="https://en.wikipedia.org/wiki/Single-root_input/output_virtualization" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Single-root_input/output_virtualization</a></li><li><a href="https://github.com/intel/sriov-cni" target="_blank" rel="noopener">https://github.com/intel/sriov-cni</a></li><li><a href="https://github.com/hustcat/sriov-cni" target="_blank" rel="noopener">https://github.com/hustcat/sriov-cni</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上周了解了 RDMA 的基础概念之后，发现在 KVM 平台无需其他配置就可使用，但是在 vSphere 场景下，需要面临一个取舍，其中的一个
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第10周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/03/06/2020-%E7%AC%AC10%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/03/06/2020-第10周-LeetCode-记录/</id>
    <published>2020-03-06T13:10:06.000Z</published>
    <updated>2020-03-06T13:10:38.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number"><a href="#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number" class="headerlink" title="1365. How Many Numbers Are Smaller Than the Current Number"></a>1365. How Many Numbers Are Smaller Than the Current Number</h3><p>对数组升序排序，遍历排序后数组，判断是否与前一数字相同，若相同则该数字结果与前一结果相同，否则为当前索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums2 = sorted(nums)</span><br><span class="line">        mapping = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums2):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums2[i] == nums2[i<span class="number">-1</span>]:</span><br><span class="line">                mapping[nums2[i]] = mapping[nums2[i<span class="number">-1</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mapping[nums2[i]] = i</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res.append(mapping[num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1366-Rank-Teams-by-Votes"><a href="#1366-Rank-Teams-by-Votes" class="headerlink" title="1366. Rank Teams by Votes"></a>1366. Rank Teams by Votes</h3><p>考察排序，通过 dict 或者 list 统计所有字母的投票数值，然后进行排序，优先按照票数排序，如果票数相同，则按照字母序排序。</p><p>要熟练使用 sorted 和 sort.Slice 啊。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rankTeams</span><span class="params">(self, votes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type votes: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(votes[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 初始化哈希映射</span></span><br><span class="line">        ranking = collections.defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>] * n)</span><br><span class="line">        <span class="comment"># 遍历统计</span></span><br><span class="line">        <span class="keyword">for</span> vote <span class="keyword">in</span> votes:</span><br><span class="line">            <span class="keyword">for</span> i, vid <span class="keyword">in</span> enumerate(vote):</span><br><span class="line">                ranking[vid][i] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 取出所有的键值对</span></span><br><span class="line">        result = list(ranking.items())</span><br><span class="line">        <span class="keyword">print</span> result</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        result.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], -ord(x[<span class="number">0</span>])), reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join([vid <span class="keyword">for</span> vid, rank <span class="keyword">in</span> result])</span><br></pre></td></tr></table></figure><h3 id="1367-Linked-List-in-Binary-Tree"><a href="#1367-Linked-List-in-Binary-Tree" class="headerlink" title="1367. Linked List in Binary Tree"></a>1367. Linked List in Binary Tree</h3><p>递归判断，比较当前 head 和 root、root.left、root.right，如果 head 为空，则表示已找到所有匹配的链表，返回 True，如果 root 为空或 root.val != head.val ，则返回 False，否则递归判断 head.next, root.left, root.right。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubPath</span><span class="params">(self, head, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(head, root) <span class="keyword">or</span> self.isSubPath(head, root.left) <span class="keyword">or</span> self.isSubPath(head, root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, head, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> root.val != head.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dfs(head.next, root.left) <span class="keyword">or</span> self.dfs(head.next, root.right)</span><br></pre></td></tr></table></figure><h3 id="1309-Decrypt-String-from-Alphabet-to-Integer-Mapping"><a href="#1309-Decrypt-String-from-Alphabet-to-Integer-Mapping" class="headerlink" title="1309. Decrypt String from Alphabet to Integer Mapping"></a>1309. Decrypt String from Alphabet to Integer Mapping</h3><p>简单粗暴的办法可以进行一个 map，先把所有的映射都记录好，然后逐个字符判断，该字符后的2位是否为 <code>#</code> ，来进行映射判断。比较取巧的办法是直接在原字符串上进行替换，不使用多余空间。</p><p>在进行字符串转换时，需要注意两位数是从 10 开始计算，而一位数是从 1 开始计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">27</span>):</span><br><span class="line">            s = s.replace( str(i) + <span class="string">'#'</span>,chr(ord(<span class="string">'j'</span>) - <span class="number">10</span> + i) )</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">            s = s.replace( str(i), chr(ord(<span class="string">'a'</span>) - <span class="number">1</span> + i ) )</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">freqAlphabets</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(st)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> st</span><br><span class="line">            <span class="keyword">return</span> chr(int(st) + <span class="number">96</span>)</span><br><span class="line">        </span><br><span class="line">        i, res = <span class="number">0</span>, <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">2</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">2</span>] == <span class="string">"#"</span>:</span><br><span class="line">                res += get(s[i : i + <span class="number">2</span>])</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += get(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1137-N-th-Tribonacci-Number"><a href="#1137-N-th-Tribonacci-Number" class="headerlink" title="1137. N-th Tribonacci Number"></a>1137. N-th Tribonacci Number</h3><p>泰波那契数，方法与斐波那契数一样，递归求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tibo</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> self.cache:</span><br><span class="line">                <span class="keyword">return</span> self.cache[n]</span><br><span class="line">            </span><br><span class="line">            self.cache[n] = tibo(n<span class="number">-1</span>) + tibo(n<span class="number">-2</span>) + tibo(n<span class="number">-3</span>)</span><br><span class="line">            <span class="keyword">return</span> self.cache[n]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tibo(n)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number&quot;&gt;&lt;a href=&quot;#1365-How-Many-Numbers-Are-Smaller-Than-the-Current-Number&quot; clas
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>systemd 常用操作及配置</title>
    <link href="https://zdyxry.github.io/2020/03/06/systemd-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>https://zdyxry.github.io/2020/03/06/systemd-常用操作及配置/</id>
    <published>2020-03-06T13:02:49.000Z</published>
    <updated>2020-03-06T23:42:56.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在大多数 Linux 发行版是由 systemd 来进行系统管理了， systemd 也是越来越复杂，但是常用的操作就那么多，今天来说说自己常用的操作及配置。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="daemon-reload"><a href="#daemon-reload" class="headerlink" title="daemon-reload"></a>daemon-reload</h3><p>在给系统新增服务的时候，通常要不断的改 test.service 配置文件，在改配置文件后，通常需要执行 <code>systemctl daemon-reload</code> 来重新加在 systemd 配置。</p><h3 id="no-page"><a href="#no-page" class="headerlink" title="no-page"></a>no-page</h3><p>通常使用 journalctl 查看服务日志，但是当日志超过当前行可显示最大字符数时，默认会将日志截断，此时可以使用 <code>journalctl -u &lt;service&gt; --no-page</code> 来让日志自动折行。</p><h3 id="disk-usage"><a href="#disk-usage" class="headerlink" title="disk-usage"></a>disk-usage</h3><p>systemd 日志配置文件在 <code>/etc/systemd/journald.conf</code> ，那么如果我想查看一个服务的日志占用空间，可以用 <code>journalctl -u &lt;servie&gt; --disk-usage</code> 命令查看。</p><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>Linux 下关机命令有很多， <code>init</code>,<code>shutdown</code>,<code>poweroff</code> ，但是如果你注意过会发现以下事实：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> ll `<span class="built_in">which</span> init`</span></span><br><span class="line">lrwxrwxrwx. 1 root root 22 8月  22 2019 /usr/sbin/init -&gt; ../lib/systemd/systemd</span><br><span class="line">root@localhost:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> ll `<span class="built_in">which</span> poweroff`</span></span><br><span class="line">lrwxrwxrwx. 1 root root 16 8月  22 2019 /usr/sbin/poweroff -&gt; ../bin/systemctl</span><br><span class="line">root@localhost:~ </span><br><span class="line"><span class="meta"> $</span><span class="bash"> ll `<span class="built_in">which</span> shutdown`</span></span><br><span class="line">lrwxrwxrwx. 1 root root 16 8月  22 2019 /usr/sbin/shutdown -&gt; ../bin/systemctl</span><br></pre></td></tr></table></figure><p>是的，systemd 大法好，systemd 通过判断 <code>$0</code> 名称来执行对应命令，那我们就可以执行 <code>systemctl poweroff</code> 来进行关机。</p><h3 id="list-dependencies"><a href="#list-dependencies" class="headerlink" title="list-dependencies"></a>list-dependencies</h3><p>systemd 可以指定服务的依赖，在关键字 <code>After</code>,<code>Before</code>,<code>Requires</code> 来指定，通过 <code>systemctl list-dependencies &lt;service&gt;</code> 来显示服务的具体依赖路径。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Restart"><a href="#Restart" class="headerlink" title="Restart"></a>Restart</h3><p>大部分服务都是一个常驻进程，我们通常希望它能在 crash、kill、异常中断等情况下仍保持运行，所以我们可以在 <code>[Servie]</code> 中指定 <code>Restart=on-failure</code> 来完成目的。</p><h3 id="TimeoutStopSec"><a href="#TimeoutStopSec" class="headerlink" title="TimeoutStopSec"></a>TimeoutStopSec</h3><p>在通过 <code>systemctl stop</code> 进行服务停止时，如果在 <code>ExecStop</code> 中指定的操作耗时较长，我们可以通过添加 <code>TimeoutStopSec=10s</code> 来设置超时时间。</p><h3 id="RefuseManualStop"><a href="#RefuseManualStop" class="headerlink" title="RefuseManualStop"></a>RefuseManualStop</h3><p>如果有些服务我们只想让它处于启动状态，或者通过依赖自动启动，而不想受人为因素干扰，那么我们可以通过设置 <code>RefuseManualStop=true</code> 来保证服务无法被人工停止，比如 rdma.service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran 21:10:36 ~]$systemctl stop rdma</span><br><span class="line">Failed to stop rdma.service: Operation refused, unit rdma.service may be requested by dependency only (it is configured to refuse manual start/stop).</span><br><span class="line">See system logs and 'systemctl status rdma.service' for details.</span><br></pre></td></tr></table></figure><h3 id="PartOf"><a href="#PartOf" class="headerlink" title="PartOf"></a><code>PartOf</code></h3><p>与 Requires= 类似， 不同之处在于：仅作用于单元的停止或重启。 其含义是，当停止或重启这里列出的某个单元时， 也会同时停止或重启该单元自身。 注意，这个依赖是单向的， 该单元自身的停止或重启并不影响这里列出的单元。</p><p>如果 a.service 中包含了 PartOf=b.service ，那么这个依赖关系将在 b.service 的属性列表中显示为 ConsistsOf=a.service 。 也就是说，不能直接设置 ConsistsOf= 依赖。</p><h3 id><a href="#" class="headerlink" title="@"></a><code>@</code></h3><p>在 Linux 上配置过 openvpn 的同学应该都看到过一些 <a href="mailto:`openvpn@client.service" target="_blank" rel="noopener">`openvpn@client.service</a>` 这样的例子：</p><blockquote><p>若需在系统启动时自动启动 OpenVPN，对服务器端与客户端，都可以采用在对应机器上 启用 openvpn@<configuration>.service 的方式配置。例如，如果客户端配置文件是 /etc/openvpn/client.conf，则服务名称应为 <a href="mailto:openvpn@client.service" target="_blank" rel="noopener">openvpn@client.service</a>。或者，如果服务器端配置文件是 /etc/openvpn/server.conf，则服务名称应为 <a href="mailto:openvpn@server.service" target="_blank" rel="noopener">openvpn@server.service</a>。 </configuration></p></blockquote><p>我们来看下对应的 systemd 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">yiran@t480:~/Downloads </span><br><span class="line"> $ cat /lib/systemd/system/openvpn@.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenVPN connection to %i</span><br><span class="line">PartOf=openvpn.service</span><br><span class="line">ReloadPropagatedFrom=openvpn.service</span><br><span class="line">Before=systemd-user-sessions.service</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Documentation=man:openvpn(8)</span><br><span class="line">Documentation=https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage</span><br><span class="line">Documentation=https://community.openvpn.net/openvpn/wiki/HOWTO</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">PrivateTmp=true</span><br><span class="line">WorkingDirectory=/etc/openvpn</span><br><span class="line">ExecStart=/usr/sbin/openvpn --daemon ovpn-%i --status /run/openvpn/%i.status 10 --cd /etc/openvpn --script-security 2 --config /etc/openvpn/%i.conf --writepid /run/openvpn/%i.pid</span><br><span class="line">PIDFile=/run/openvpn/%i.pid</span><br><span class="line">KillMode=process</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">CapabilityBoundingSet=CAP_IPC_LOCK CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW CAP_SETGID CAP_SETUID CAP_SYS_CHROOT CAP_DAC_OVERRIDE CAP_AUDIT_WRITE</span><br><span class="line">LimitNPROC=100</span><br><span class="line">DeviceAllow=/dev/null rw</span><br><span class="line">DeviceAllow=/dev/net/tun rw</span><br><span class="line">ProtectSystem=true</span><br><span class="line">ProtectHome=true</span><br><span class="line">RestartSec=5s</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>可以看到其实我们 <code>@</code> 后面的字段，对应的就是配置文件中的 <code>%i</code> ，这样可以让我们很方便的针对同一个应用的不同实例来创建对应的服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>systemd 大法好，博大精深。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wiki.archlinux.org/index.php/OpenVPN_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#systemd_%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/OpenVPN_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#systemd_%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE</a></li><li><a href="http://www.huzs.net/?p=2180" target="_blank" rel="noopener">http://www.huzs.net/?p=2180</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;现在大多数 Linux 发行版是由 systemd 来进行系统管理了， systemd 也是越来越复杂，但是常用的操作就那么多，今天来说说自
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>DMA &amp; RDMA 基本概念</title>
    <link href="https://zdyxry.github.io/2020/03/02/RDMA-%E6%A6%82%E5%BF%B5/"/>
    <id>https://zdyxry.github.io/2020/03/02/RDMA-概念/</id>
    <published>2020-03-02T11:56:16.000Z</published>
    <updated>2020-03-02T12:10:09.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司的存储系统要支持 RDMA 了，但是我连 RDMA 具体是啥还不清楚，今天花点时间来学习下相关知识。</p><p>在了解 RDMA 之前，需要先知道 DMA 是什么，所以会一点点说。</p><p>P.S. 本文部分内容截取自 《OSTEP》。</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><img src="/2020/03/02/RDMA-概念/rdma1.png" title="rdma1"><p>先来看一个典型的系统架构，其中，CPU 通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能 I/O 设备通过常规的I/O 总线（I/O bus）连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下面是外围总（peripheral bus），比如 SCSI、SATA 或者 USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。</p><p>为什么会用这样的分层架构？因为物理布局及造价成本。越快的总线长度越短，因此高性能的内存总线没有足够的空间来接太多设备。另外，在工程上高性能总线的造价非常高。所以，系统的设计采用了这种分层的方式，这样可以让要求高性能的设备（比如显卡）离 CPU 更近一些，低性能的设备离 CPU 远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。</p><h3 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h3><img src="/2020/03/02/RDMA-概念/rdma2.png" title="rdma2"><p>现在来看一个标准设备（不是真实存在的），通过它来帮助我们更好地理解设备交互的制。从图 中，可以看到一个包含两部分重要组件的设备。<br>第一部分是向系统其他部分展现的硬件接口（interface）。同软件一样，硬件也需要一些接口，让系统软件来控它的操作。因此，所有设备都有自己的特定接口以及典型交互的协议。<br>第二部分是它的内部结构（internal structure）。这部分包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口。非常简单的设备通常用一个或几个芯片来实现它们的功能。更复杂的设备会包含简单的 CPU、一些通用内存、设备相关的特定芯片，来完成它们的工作。例如，现代 RAID 控制器通常包含成百上千行固件（firmware，即硬件设备中的软件），以实现其功能。</p><h3 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h3><p>在图 36.2 中，一个（简化的）设备接口包含 3 个寄存器：一个状态（status）寄存器，可以读取并查看设备的当前状态；一个命令（command）寄存器，用于通知设备执行某个具体任务；一个数据（data）寄存器，将数据传给设备或从设备接收数据。通过读写这些寄存器，操作系统可以控制设备的行为。</p><p>我们现在来描述操作系统与该设备的典型交互，以便让设备为它做某事。协议如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">While (STATUS == BUSY)</span><br><span class="line">; // wait until device is not busy</span><br><span class="line">Write data to DATA register</span><br><span class="line">Write command to COMMAND register</span><br><span class="line">(Doing so starts the device and executes the command)</span><br><span class="line">While (STATUS == BUSY)</span><br><span class="line">; // wait until device is done with your request</span><br></pre></td></tr></table></figure><p>该协议包含 4 步：</p><ol><li>操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询（polling）设备（基本上，就是问它正在做什么）。</li><li>操作系统下发数据到数据寄存器。例如，你可以想象如果这是一个磁盘，需要多次写入操作，将一个磁盘块（比如 4KB）传递给设备。如果主 CPU 参与数据移动（就像这个示例协议一样），我们就称之为编程的 I/O（programmed I/O，PIO）。</li><li>操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。</li><li>操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令（有可能得到一个指示成功或失败的错误码）。</li></ol><p>这个简单的协议好处是足够简单并且有效。但是难免会有一些低效和不方便。我们注意到这个协议存在的第一个问题就是轮询过程比较低效，在等待设备执行完成命令时浪费大量 CPU 时间，如果此时操作系统可以切换执行下一个就绪进程，就可以大大提高 CPU 的利用率。</p><h3 id="利用中断减少-CPU-开销"><a href="#利用中断减少-CPU-开销" class="headerlink" title="利用中断减少 CPU 开销"></a>利用中断减少 CPU 开销</h3><p>多年前，工程师们发明了我们目前已经很常见的中断（interrupt）来减少 CPU 开销。有了中断后，CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发 CPU 跳转执行操作系统预先定义好的中断服务例程（Interrupt Service Routine，ISR），或更为简单的中断处理程序（interrupt handler）。中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且唤醒等待 I/O 的进程继续执行。因此，中断允许计算与 I/O 重叠（overlap），这是提高 CPU 利用率的关键。下面的时间线展示了这一点：</p><img src="/2020/03/02/RDMA-概念/rdma3.png" title="rdma3"><p>其中，进程 1 在 CPU 上运行一段时间（对应 CPU 那一行上重复的 1），然后发出一个读取数据的 I/O 请求给磁盘。如果没有中断，那么操作系统就会简单自旋，不断轮询设备状态，直到设备完成 I/O 操作（对应其中的 p）。当设备完成请求的操作后，进程 1 又可继续运行。</p><p>如果我们利用中断并允许重叠，操作系统就可以在等待磁盘操作时做其他事情：</p><img src="/2020/03/02/RDMA-概念/rdma4.png" title="rdma4"><p>在这个例子中，在磁盘处理进程 1 的请求时，操作系统在 CPU 上运行进程 2。磁盘处理完成后，触发一个中断，然后操作系统唤醒进程 1 继续运行。这样，在这段时间，无论CPU 还是磁盘都可以有效地利用。注意，使用中断并非总是最佳方案。假如有一个非常高性能的设备，它处理请求很快：通常在 CPU 第一次轮询时就可以返回结果。此时如果使用中断，反而会使系统变慢：切换到其他进程，处理中断，再切换回之前的进程代价不小。因此，如果设备非常快，那么最好的办法反而是轮询。如果设备比较慢，那么采用允许发生重叠的中断更好。如果设备的速度未知，或者时快时慢，可以考虑使用混合（hybrid）策略，先尝试轮询一小段时间，如果设备没有完成操作，此时再使用中断。这种两阶段（two-phased）的办法可以实现两种方法的好处。</p><p>另一个最好不要使用中断的场景是网络。网络端收到大量数据包，如果每一个包都发生一次中断，那么有可能导致操作系统发生活锁（livelock），即不断处理中断而无法处理用户层的请求。例如，假设一个 Web 服务器因为“点杠效应”而突然承受很重的负载。这种情况下，偶尔使用轮询的方式可以更好地控制系统的行为，并允许 Web 服务器先服务一些用户请求，再回去检查网卡设备是否有更多数据包到达。另一个基于中断的优化就是合并（coalescing）。设备在抛出中断之前往往会等待一小段时间，在此期间，其他请求可能很快完成，因此多次中断可以合并为一次中断抛出，从而降低处理中断的代价。当然，等待太长会增加请求的延迟，这是系统中常见的折中。</p><h3 id="利用-DMA-进行更高效的数据传送"><a href="#利用-DMA-进行更高效的数据传送" class="headerlink" title="利用 DMA 进行更高效的数据传送"></a>利用 DMA 进行更高效的数据传送</h3><p>标准协议还有一点需要我们注意。具体来说，如果使用编程的 I/O 将一大块数据传给设备，CPU 又会因为琐碎的任务而变得负载很重，浪费了时间和算力，本来更好是用于运行其他进程。下面的时间线展示了这个问题：</p><img src="/2020/03/02/RDMA-概念/rdma6.png" title="rdma6"><p>进程 1 在运行过程中需要向磁盘写一些数据，所以它开始进行 I/O 操作，将数据从内存拷贝到磁盘（其中标示 c 的过程）。拷贝结束后，磁盘上的 I/O 操作开始执行，此时 CPU 才可以处理其他请求。</p><p>解决方案就是使用 DMA（Direct Memory Access）。DMA 引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要 CPU 介入。DMA 工作过程如下。为了能够将数据传送给设备，操作系统会通过编程告诉 DMA 引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以<br>处理其他请求了。当 DMA 的任务完成后，DMA 控制器会抛出一个中断来告诉操作系统自己已经完成数据传输。修改后的时间线如下：</p><img src="/2020/03/02/RDMA-概念/rdma7.png" title="rdma7"><p>从时间线中可以看到，数据的拷贝工作都是由 DMA 控制器来完成的。因为 CPU 在此时是空闲的，所以操作系统可以让它做一些其他事情，比如此处调度进程 2 到 CPU 来运行。因此进程 2 在进程 1 再次运行之前可以使用更多的 CPU。</p><h2 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>远程直接内存访问（英语：remote direct memory access，RDMA）是一种绕过远程主机操作系统内核访问其内存中数据的技术，由于不经过操作系统，不仅节省了大量CPU资源，同样也提高了系统吞吐量、降低了系统的网络通信延迟，尤其适合在大规模并行计算机集群中有广泛应用。在基于NVMe over Fabric的数据中心中，RDMA可以配合高性能的NVMe SSD构建高性能、低延迟的存储网络。</p></blockquote><p>这类绕过操作系统内核的技术称为内核旁路（Kernel-Bypass）。Kernel-Bypass 框架/API 有：DPDK、ibverbs 。</p><img src="/2020/03/02/RDMA-概念/rdma8.png" title="rdma8"><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>远程直接内存访问<br>在某些场景下类似于 DMA<br>低延迟<br>毫秒级别，无内核调用时间<br>零拷贝<br>无需拷贝 I/O buffers<br>硬件处理信息传输，节省 CPU</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>贵。我能想到的只有贵。<br>来自开发了大半年的 wenquan 同学总结：<br>编程，调优麻烦<br>与性能相关的点很多<br>对网络环境要求高<br>…</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="InfiniBand"><a href="#InfiniBand" class="headerlink" title="InfiniBand"></a>InfiniBand</h4><p>InfiniBand 是指两种完全不同的东西。一个是 InfiniBand 网络的物理链接层协议，另一个是高级编程 API，名为 InfiniBand Verbs API。InfiniBand Verbs API 是一种远程直接内存访问（RDMA）技术的实施。<br>InfiniBand 需要全套的网络设备才可以支持，成本高，性能好。</p><h4 id="RoCE-amp-iWARP"><a href="#RoCE-amp-iWARP" class="headerlink" title="RoCE &amp; iWARP"></a>RoCE &amp; iWARP</h4><p>iWARP，以通过Internet协议网络进行有效的数据传输。由于iWARP 基于TCP 协议因此它对网络的要求不高，可以在各种环境中部署，成本低，性能也是最差的。<br>RoCE，基于融合以太网的RDMA（英语：RDMA over Converged Ethernet，缩写RoCE）是一个网络协议，允许在一个以太网网络上使用远程直接内存访问（RDMA）。RoCE有RoCE v1和RoCE v2两个版本。RoCE v1是一个以太网链路层协议，因此允许同一个以太网广播域中的任意两台主机间进行通信。RoCE v2是一个网络层协议，因而RoCE v2数据包可以被路由。虽然RoCE协议受益于融合以太网网络的特征，但该协议也可用于传统或非融合的以太网网络，成本中等，性能比 IB 略差。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/</a></li><li><a href="https://www.junmajinlong.com/os/io_dma_rdma/" target="_blank" rel="noopener">https://www.junmajinlong.com/os/io_dma_rdma/</a></li><li><a href="https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf" target="_blank" rel="noopener">https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE</a></li><li><a href="https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf" target="_blank" rel="noopener">https://www.cs.utah.edu/~stutsman/cs6450/public/20.pdf</a></li><li><a href="https://www.mellanox.com/pdf/whitepapers/IB_Intro_WP_190.pdf" target="_blank" rel="noopener">https://www.mellanox.com/pdf/whitepapers/IB_Intro_WP_190.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司的存储系统要支持 RDMA 了，但是我连 RDMA 具体是啥还不清楚，今天花点时间来学习下相关知识。&lt;/p&gt;
&lt;p&gt;在了解 RDMA
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第9周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/02/28/2020-%E7%AC%AC9%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/02/28/2020-第9周-LeetCode-记录/</id>
    <published>2020-02-28T11:35:45.000Z</published>
    <updated>2020-02-28T11:37:15.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1300-Sum-of-Mutated-Array-Closest-to-Target"><a href="#1300-Sum-of-Mutated-Array-Closest-to-Target" class="headerlink" title="1300. Sum of Mutated Array Closest to Target"></a>1300. Sum of Mutated Array Closest to Target</h3><p>对 arr 进行降序排序，将 arr 中的最小值乘以 arr 长度与 target比较，若比 target 小，则将其丢弃，并将其从 target 中减去。<br>若 arr 为空，则表示 arr 中最大值乘以 arr 长度仍比 target 小，则返回 arr 中的最大值。<br>若 arr 不为空，则表示 arr 中存在大于目标值的数值，取 target 除以此时 arr 长度（arr 中所有数值均大于目标值），最终值四舍五入得到目标值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBestValue</span><span class="params">(self, arr, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        arr.sort(reverse = <span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> arr <span class="keyword">and</span> target &gt;= arr[<span class="number">-1</span>]*len(arr):</span><br><span class="line">            temp = arr[<span class="number">-1</span>]</span><br><span class="line">            target -= arr.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        res = target/float(len(arr))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res % <span class="number">1</span> &gt; <span class="number">0.5</span>:</span><br><span class="line">            <span class="keyword">return</span> int(res)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><p>也可用二分方式做，取 [0, max(arr)] 中间值为 mid，对 arr 求和：若数值大于 mid则取 mid，求和结果与 target 比较。<br>记录最小差值和最小差值时 mid 值，若求和数值大于 target，则将上限置为 mid-1，否则将下限置为 mid+1，如果求和数值与 target 相等，则直接返回 mid。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBestValue</span><span class="params">(self, arr, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">0</span>, max(arr)</span><br><span class="line">        sub, ans = float(<span class="string">"inf"</span>), float(<span class="string">"inf"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            tmp = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">if</span> num &gt; mid:</span><br><span class="line">                    tmp += mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp += num</span><br><span class="line">            </span><br><span class="line">            cur_sub = abs(tmp - target)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> cur_sub &lt; sub:</span><br><span class="line">                sub = cur_sub</span><br><span class="line">                ans = mid</span><br><span class="line">            <span class="keyword">elif</span> cur_sub == sub:</span><br><span class="line">                ans = min(ans, mid)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> tmp &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> tmp &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> tmp == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1299-Replace-Elements-with-Greatest-Element-on-Right-Side"><a href="#1299-Replace-Elements-with-Greatest-Element-on-Right-Side" class="headerlink" title="1299. Replace Elements with Greatest Element on Right Side"></a>1299. Replace Elements with Greatest Element on Right Side</h3><p>按照题意暴力解法，时间接近5s。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceElements</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> i == len(arr)<span class="number">-1</span>:</span><br><span class="line">                arr[i] = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">return</span> arr</span><br><span class="line">            arr[i] = max(arr[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>正确姿势为从后向前比较，每次比较最大值与 arr[i] 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceElements</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        greatest = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; greatest:</span><br><span class="line">                arr[i] = greatest</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[i], greatest = greatest, arr[i]</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h3 id="1363-Largest-Multiple-of-Three"><a href="#1363-Largest-Multiple-of-Three" class="headerlink" title="1363. Largest Multiple of Three"></a>1363. Largest Multiple of Three</h3><p>这是一道数学题，当一个数字可以被 3 整除时，那么这个数字每一位相加之和也可被 3 整除。</p><p>倒序排序，计算所有数字之和，如果可以被 3 整除，那么直接返回；<br>如果余数为1，则从数组中尝试删除 1，4，7 其中一个；<br>如果余数为2，则从数组中尝试删除 2，5，8 其中一个；<br>若仍不满足条件，且余数为 2 ，则从数组中尝试删除 1，4，7 其中两个；<br>若仍不满足条件，且余数为 1 ，则从数组中尝试删除 2，5，8 其中两个；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestMultipleOfThree</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        total = sum(A)</span><br><span class="line">        count = collections.Counter(A)</span><br><span class="line">        A.sort(reverse=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> count[i]:</span><br><span class="line">                A.remove(i)</span><br><span class="line">                count[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> any(A): <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">            <span class="keyword">if</span> sum(A) % <span class="number">3</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">''</span>.join(map(str, A))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> count[<span class="number">1</span>] + count[<span class="number">4</span>] + count[<span class="number">7</span>]:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">1</span>) <span class="keyword">or</span> f(<span class="number">4</span>) <span class="keyword">or</span> f(<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> count[<span class="number">2</span>] + count[<span class="number">5</span>] + count[<span class="number">8</span>]:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">2</span>) <span class="keyword">or</span> f(<span class="number">5</span>) <span class="keyword">or</span> f(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> f(<span class="number">1</span>) <span class="keyword">or</span> f(<span class="number">1</span>) <span class="keyword">or</span> f(<span class="number">4</span>) <span class="keyword">or</span> f(<span class="number">4</span>) <span class="keyword">or</span> f(<span class="number">7</span>) <span class="keyword">or</span> f(<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">2</span>) <span class="keyword">or</span> f(<span class="number">2</span>) <span class="keyword">or</span> f(<span class="number">5</span>) <span class="keyword">or</span> f(<span class="number">5</span>) <span class="keyword">or</span> f(<span class="number">8</span>) <span class="keyword">or</span> f(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="1362-Closest-Divisors"><a href="#1362-Closest-Divisors" class="headerlink" title="1362. Closest Divisors"></a>1362. Closest Divisors</h3><p>求 num 的平方根，倒序排序后，依次遍历检测是否被 (num + 1) 或 (num + 2) 整除，若整除则为所求结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestDivisors</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, int((num + <span class="number">2</span>) ** <span class="number">0.5</span>) + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (num + <span class="number">1</span>) % i:</span><br><span class="line">                <span class="keyword">return</span> [i, (num + <span class="number">1</span>) // i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (num + <span class="number">2</span>) % i:</span><br><span class="line">                <span class="keyword">return</span> [i, (num + <span class="number">2</span>) // i]</span><br></pre></td></tr></table></figure><h3 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228. Summary Ranges"></a>228. Summary Ranges</h3><p>这道题我在实际应用中遇到过，具体问题可以看这篇记录 <a href="https://zdyxry.github.io/2019/04/11/%E8%AE%B0%E4%B8%80%E6%AC%A1-libcgroup-%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5/">《记一次 libcgroup 配置失败》</a> 。</p><p>记录当前连续数字的 start 和 end，并遍历数组进行判断，如果 num = end + 1 ，那么更新 end 数值，如果不等于，那么将这段数字转换为字符串并添加到结果中，并重置 start &amp; end。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ranges = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> ranges</span><br><span class="line"></span><br><span class="line">        start, end = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(nums) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(nums) <span class="keyword">and</span> nums[i] == end + <span class="number">1</span>:</span><br><span class="line">                end = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                interval = str(start)</span><br><span class="line">                <span class="keyword">if</span> start != end:</span><br><span class="line">                    interval += <span class="string">"-&gt;"</span> + str(end)</span><br><span class="line">                ranges.append(interval)</span><br><span class="line">                <span class="keyword">if</span> i &lt; len(nums):</span><br><span class="line">                    start = end = nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ranges</span><br></pre></td></tr></table></figure><p>p.s. 贴一下自己用 shell 写的，写完就看不懂了。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function format_qemu_processors &#123;</span><br><span class="line">    # cgconfig.service could not be active when libcgroup &lt;= libcgroup-0.41-20.el7 and config field &gt;= 100 char</span><br><span class="line">    # use `-` format qemu_processors</span><br><span class="line">    # example:</span><br><span class="line">    # qemu_processors input (6,7,8,9,10),  output is "6-10"</span><br><span class="line">    # qemu_processors input (10,9,8,7,6),  output is "6-10"</span><br><span class="line">    # qemu_processors input (6,7,8,10,11), output is "6-8,10-11"</span><br><span class="line">    # qemu_processors input (1,3,5,7,9),   output is "1,3,5,7,9"</span><br><span class="line"></span><br><span class="line">    IFS=$'\n' sorted=($(sort -n &lt;&lt;&lt;"$&#123;qemu_processors[*]&#125;"))</span><br><span class="line">    unset IFS</span><br><span class="line"></span><br><span class="line">    QEMU_CPUS=""</span><br><span class="line">    TAG=""</span><br><span class="line">    for i in "$&#123;!sorted[@]&#125;";do</span><br><span class="line">        if [[ "$&#123;sorted[(i+1)]&#125;" == `expr $&#123;sorted[i]&#125; + 1` ]];then</span><br><span class="line">            if [[ $&#123;sorted[(i-1)]&#125; == $TAG ]];then</span><br><span class="line">                TAG=$&#123;sorted[i]&#125;</span><br><span class="line">                continue</span><br><span class="line">            fi</span><br><span class="line">            QEMU_CPUS=$QEMU_CPUS"$&#123;sorted[i]&#125;"</span><br><span class="line">            QEMU_CPUS=$QEMU_CPUS"-"</span><br><span class="line">            TAG="$&#123;sorted[i]&#125;"</span><br><span class="line">        else</span><br><span class="line">            QEMU_CPUS=$QEMU_CPUS"$&#123;sorted[i]&#125;"</span><br><span class="line">            if [[ $&#123;sorted[i]&#125;  != $&#123;sorted[-1]&#125; ]];then</span><br><span class="line">                QEMU_CPUS=$QEMU_CPUS","</span><br><span class="line">            fi</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    echo $&#123;QEMU_CPUS&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1300-Sum-of-Mutated-Array-Closest-to-Target&quot;&gt;&lt;a href=&quot;#1300-Sum-of-Mutated-Array-Closest-to-Target&quot; class=&quot;headerlink&quot; title=&quot;1300. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>zipstreamer 源码阅读</title>
    <link href="https://zdyxry.github.io/2020/02/21/zipstreamer-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2020/02/21/zipstreamer-源码阅读/</id>
    <published>2020-02-21T11:33:08.000Z</published>
    <updated>2020-02-21T14:07:52.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在之前的一篇博客<a href="https://zdyxry.github.io/2020/02/07/HTTP-Content-Length-%E5%AD%A6%E4%B9%A0/">《HTTP Content-Length 学习》</a> 中提到自己踩了一个坑，就是 <code>content-length</code> 与实际大小不匹配导致文件下载失败，在解决过程中用到了 zipstreamer ，今天来看看 zipstreamer 是如何工作的。</p><h2 id="zipfile"><a href="#zipfile" class="headerlink" title="zipfile"></a>zipfile</h2><p>Python 标准库中提供了 zipfile 用来对 Zip 文件进行操作，可以进行 Zip 的创建、写入、读取、解压等动作，但是 zipfile 只能对文件进行操作，没办法传入 stream，所以能做的操作有限。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        f = open(<span class="string">"file"</span> + str(i) + <span class="string">".txt"</span>, <span class="string">'w'</span>)</span><br><span class="line">        f.write(str(i))</span><br><span class="line">        f.close()</span><br><span class="line"> </span><br><span class="line">    f = zipfile.ZipFile(<span class="string">'filename.zip'</span>, <span class="string">'w'</span>, zipfile.ZIP_DEFLATED)</span><br><span class="line">    f.write(<span class="string">'file1.txt'</span>)</span><br><span class="line">    f.write(<span class="string">'file2.txt'</span>)</span><br><span class="line">    f.write(<span class="string">'file3.txt'</span>)</span><br><span class="line">    f.close()</span><br><span class="line"> </span><br><span class="line">    f = zipfile.ZipFile(<span class="string">'filename.zip'</span>)</span><br><span class="line">    f.extractall()</span><br><span class="line">    f.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h2 id="zipstreamer"><a href="#zipstreamer" class="headerlink" title="zipstreamer"></a>zipstreamer</h2><p>在提供文件下载接口时，有一个比较常见的需求是传过来一个 stream，然后我们要将 stream 作为 Zip 中的一个文件转发出去，实时下载，这时候就需要 zipstreamer 来实现了。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">z = ZipStream(files=[</span><br><span class="line">    ZipFile(<span class="string">'file.txt'</span>, <span class="number">4</span>, <span class="keyword">lambda</span>: StringIO(<span class="string">'test'</span>), <span class="keyword">None</span>, <span class="keyword">None</span>),</span><br><span class="line">    ZipFile(<span class="string">'emptydir/'</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>),</span><br><span class="line">    ZipFile(<span class="string">'dir/remote.txt'</span>, remote_file_size, get_remote_file, <span class="keyword">None</span>, <span class="keyword">None</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">size = z.size()</span><br><span class="line"></span><br><span class="line">res = Response(z.generate(), mimetype=<span class="string">'application/zip'</span>)</span><br><span class="line">res.headers[<span class="string">'Content-Length'</span>] = str(size)</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>在看代码之前，我们先看下 zip 文件的数据格式：</p><img src="/2020/02/21/zipstreamer-源码阅读/zip2.png" title="Zip Format"><img src="/2020/02/21/zipstreamer-源码阅读/zip.png" title="Zip Format"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/project/python-zipstreamer/zipstreamer</span><br><span class="line">master ✔ $ tree .</span><br><span class="line">.</span><br><span class="line">├── compat.py # py2 py3 兼容</span><br><span class="line">├── __init__.py # 主要逻辑</span><br><span class="line">└── __version__.py # 版本信息</span><br></pre></td></tr></table></figure><p>zipstreamer 的目录结构比较简单，所有逻辑都在 <code>__init__.py</code> 中，先来看看 <code>compat.py</code> 中做了什么，根据 Python 版本来决定 BytesIO 的引用，修改下默认的 str 定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#: Python 2.x?</span></span><br><span class="line">IS_PY2 = (_VER[<span class="number">0</span>] == <span class="number">2</span>)</span><br><span class="line"><span class="comment">#: Python 3.x?</span></span><br><span class="line">IS_PY3 = (_VER[<span class="number">0</span>] == <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_PY2:</span><br><span class="line">    <span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO <span class="keyword">as</span> BytesIO</span><br><span class="line">    str = unicode</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> IS_PY3:</span><br><span class="line">    <span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">    str = str</span><br></pre></td></tr></table></figure><p>那么来看看 <code>__init__.py</code> 中都定义了哪些类，根据示例我们知道有 <code>ZipStream</code>，并且它肯定实现了 <code>generate</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZipStream</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, files, comment=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_incr</span><span class="params">(self, buf)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_file</span><span class="params">(self, zip_file)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_dir_entry</span><span class="params">(self, entry)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_generate_zip_file</span><span class="params">(self)</span>:</span></span><br></pre></td></tr></table></figure><p>先来看看构造函数中定义了什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, files, comment=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(comment, str):</span><br><span class="line">        <span class="keyword">raise</span> ZipFileBytesRequired(<span class="string">'ZIP comment should bytes'</span>)</span><br><span class="line">    <span class="comment"># 所有 ZipFile 的集合</span></span><br><span class="line">    self.files = files</span><br><span class="line">    self.comment = comment</span><br><span class="line">    <span class="comment"># 定义初始值及必要的 flag</span></span><br><span class="line">    self._dir = <span class="keyword">None</span></span><br><span class="line">    self._pos = <span class="keyword">None</span> <span class="comment"># 计算文件大小时用到</span></span><br><span class="line">    self._generating = <span class="keyword">False</span></span><br><span class="line">    self._calculate_size = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>最终传给 Response 的是 <code>z.generate()</code> ，所以先看看 <code>generate()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数中定义的 flag，因为是生成器，如果已经执行过那么后续执行都会异常，所以这里提前判断</span></span><br><span class="line">    <span class="keyword">if</span> self._generating:</span><br><span class="line">        <span class="keyword">raise</span> ZipFileInProgress(<span class="string">'ZipFile generator already in progress'</span>)</span><br><span class="line"></span><br><span class="line">    self._generating = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> self._generate_zip_file():</span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._generating = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>继续看 <code>self._generate_zip_file()</code> 这里是整个 zipstreamer 中最核心的逻辑，包含了 Zip 文件内容定义，数据格式定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_zip_file</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._dir = []</span><br><span class="line">    self._pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> zip_file <span class="keyword">in</span> self.files:</span><br><span class="line">        <span class="comment"># 生成文件数据</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> self._generate_file(zip_file):</span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line">    <span class="comment"># 这里可以判断 self._generate_file 会修改 self._pos</span></span><br><span class="line">    start = self._pos</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> self._dir:</span><br><span class="line">        <span class="comment"># 生成文件夹数据</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> self._generate_dir_entry(entry):</span><br><span class="line">            <span class="keyword">yield</span> chunk</span><br><span class="line">    <span class="comment"># 同样 self._generate_dir_entry 也会修改 self._pos</span></span><br><span class="line">    end = self._pos</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以猜测在 self._generate_dir_entry 会更新 self._dir</span></span><br><span class="line">    cent_dir_count = len(self._dir)</span><br><span class="line">    cent_dir_size = end - start</span><br><span class="line">    cent_dir_offset = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据条件判断最终 Zip 文件是否为 64 位</span></span><br><span class="line">    <span class="keyword">if</span> (cent_dir_count &gt;= UINT16_MAX <span class="keyword">or</span> cent_dir_size &gt;= UINT32_MAX <span class="keyword">or</span> cent_dir_offset &gt;= UINT32_MAX):</span><br><span class="line">        zip64_end_rec = struct.pack(</span><br><span class="line">            STRUCT_END_ARCHIVE64, STRING_END_ARCHIVE64, <span class="number">44</span>, ZIP_VERSION_45,</span><br><span class="line">            ZIP_VERSION_45, <span class="number">0</span>, <span class="number">0</span>, cent_dir_count, cent_dir_count,</span><br><span class="line">            cent_dir_size, cent_dir_offset)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self._incr(zip64_end_rec)</span><br><span class="line"></span><br><span class="line">        zip64_loc_rec = struct.pack(</span><br><span class="line">            STRUCT_END_ARCHIVE64_LOCATOR, STRING_END_ARCHIVE64_LOCATOR, <span class="number">0</span>,</span><br><span class="line">            end, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self._incr(zip64_loc_rec)</span><br><span class="line"></span><br><span class="line">        cent_dir_count = UINT16_MAX</span><br><span class="line">        cent_dir_size = UINT32_MAX</span><br><span class="line">        cent_dir_offset = UINT32_MAX</span><br><span class="line"></span><br><span class="line">    eocd_comment = <span class="string">b''</span> <span class="keyword">if</span> self.comment <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> self.comment</span><br><span class="line"></span><br><span class="line">    endrec = struct.pack(</span><br><span class="line">        STRUCT_END_ARCHIVE, STRING_END_ARCHIVE, <span class="number">0</span>, <span class="number">0</span>, cent_dir_count,</span><br><span class="line">        cent_dir_count, cent_dir_size, cent_dir_offset, len(eocd_comment))</span><br><span class="line">    <span class="comment"># 返回 Zip 格式要求的 central 部分</span></span><br><span class="line">    <span class="keyword">yield</span> self._incr(endrec)</span><br><span class="line">    <span class="keyword">yield</span> self._incr(eocd_comment)</span><br></pre></td></tr></table></figure><p><code>self._generate_file</code> 和 <code>self._generate_dir_entry</code> 都涉及到具体的 Zip 数据格式的定义，这里不详细展开了，需要注意的是在 <code>self._generate_file</code> 中的传输 chunk 大小的定义，一次返回的数据大小为 4096字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> file_obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        buf = file_obj.read(<span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> buf:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="文件大小计算"><a href="#文件大小计算" class="headerlink" title="文件大小计算"></a>文件大小计算</h3><p>在示例代码中我们使用 <code>z.size()</code> 来获取打包后的 Zip 文件大小，来看看这里是怎么获取的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._generating:</span><br><span class="line">        <span class="keyword">raise</span> ZipFileInProgress(</span><br><span class="line">            <span class="string">'ZipFile generator already in progress. You need to call'</span></span><br><span class="line">            <span class="string">' size() before generate()'</span>)</span><br><span class="line"></span><br><span class="line">    self._calculate_size = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行一次 generate() 方法</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> self.generate():</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._calculate_size = <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 最终返回 self._pos</span></span><br><span class="line">    <span class="keyword">return</span> self._pos</span><br></pre></td></tr></table></figure><p>在 zipstream 执行 yield 的时候，都是跟着 <code>self._incr</code> 的，这里保存这文件大小的计算逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_incr</span><span class="params">(self, buf)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> isinstance(buf, str)</span><br><span class="line"></span><br><span class="line">    self._pos += len(buf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf</span><br></pre></td></tr></table></figure><p>我们只需要保证我们返回的所有数据都用 <code>self._incr</code> 封装了，那么最终的 <code>self._pos</code> 就是文件的总大小。</p><h3 id="Zip-文件格式"><a href="#Zip-文件格式" class="headerlink" title="Zip 文件格式"></a>Zip 文件格式</h3><p>大概了解了 zipstream 是怎么做的，回过头来看看 Zip 的文件格式，根据 yield 顺序汇总一下，可以看到与我们在看代码之前看到的 Zip 文件格式图表是一致的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># files</span></span><br><span class="line"><span class="keyword">yield</span> self._incr(header)</span><br><span class="line"><span class="keyword">yield</span> self._incr(filename)</span><br><span class="line"><span class="keyword">yield</span> self._incr(extra)</span><br><span class="line"><span class="keyword">yield</span> self._incr(buf)</span><br><span class="line"><span class="keyword">yield</span> self._incr(data_descriptor)</span><br><span class="line"><span class="comment"># dirs</span></span><br><span class="line"><span class="keyword">yield</span> self._incr(central_dir)</span><br><span class="line"><span class="keyword">yield</span> self._incr(entry.filename)</span><br><span class="line"><span class="keyword">yield</span> self._incr(extra)</span><br><span class="line"><span class="keyword">yield</span> self._incr(entry.comment)</span><br><span class="line"><span class="comment"># zip structure</span></span><br><span class="line"><span class="keyword">yield</span> self._incr(zip64_end_rec)</span><br><span class="line"><span class="keyword">yield</span> self._incr(zip64_loc_rec)</span><br><span class="line"><span class="keyword">yield</span> self._incr(endrec)</span><br><span class="line"><span class="keyword">yield</span> self._incr(eocd_comment)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/koofr/python-zipstreamer" target="_blank" rel="noopener">https://github.com/koofr/python-zipstreamer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在之前的一篇博客&lt;a href=&quot;https://zdyxry.github.io/2020/02/07/HTTP-Content-Leng
      
    
    </summary>
    
    
      <category term="Python" scheme="https://zdyxry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>K8s drain 命令源码阅读</title>
    <link href="https://zdyxry.github.io/2020/02/15/K8s-drain-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2020/02/15/K8s-drain-源码阅读/</id>
    <published>2020-02-15T03:22:13.000Z</published>
    <updated>2020-02-15T07:17:20.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前写过一篇 <a href="https://zdyxry.github.io/2019/08/01/Kubernetes-%E5%AE%9E%E6%88%98-%E5%B9%B3%E6%BB%91%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/">《Kubernetes 实战-平滑移除节点》</a> 讲如何从 K8s 集群中移除节点的，今天来看看 <code>kubectl drain</code> 命令具体做了什么，怎么实现的。</p><h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h2><p><code>drain</code> 相关命令都属于 <code>kubectl</code> 的自命令，因此需要先看下 <code>kubectl</code> 的入口，K8s 使用 cobra 作为命令行构建组建（我自己使用 cobra 觉得不怎么好用，而且文档也不清晰。。），统一入口在 <code>cmd/kubectl/kubectl.go</code> ，实际的处理逻辑在 <code>pkg/kubectl/cmd/cmd.go</code> 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   ...</span><br><span class="line">groups := templates.CommandGroups&#123;</span><br><span class="line">&#123;</span><br><span class="line">Message: <span class="string">"Basic Commands (Beginner):"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Message: <span class="string">"Deploy Commands:"</span>,</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Message: <span class="string">"Cluster Management Commands:"</span>,</span><br><span class="line">Commands: []*cobra.Command&#123;</span><br><span class="line">certificates.NewCmdCertificate(f, ioStreams),</span><br><span class="line">clusterinfo.NewCmdClusterInfo(f, ioStreams),</span><br><span class="line">top.NewCmdTop(f, ioStreams),</span><br><span class="line">drain.NewCmdCordon(f, ioStreams),</span><br><span class="line">drain.NewCmdUncordon(f, ioStreams),</span><br><span class="line">drain.NewCmdDrain(f, ioStreams),</span><br><span class="line">taint.NewCmdTaint(f, ioStreams),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">   groups.Add(cmds)</span><br></pre></td></tr></table></figure><p>可以看到在 <code>kubectl</code> 所有子命令的入口，我们今天要看的 <code>drain</code> 命令都属于集群管理命令，包含了：</p><ul><li>cordon</li><li>uncordon</li><li>drain</li></ul><h2 id="Cordon"><a href="#Cordon" class="headerlink" title="Cordon"></a>Cordon</h2><p>先来看看 <code>cordon</code> 命令，这条命令的用途是标记节点为不可调度状态，防止在进行节点维护时 K8s 仍调度资源到该节点上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCmdCordon</span><span class="params">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">o := NewDrainCmdOptions(f, ioStreams)</span><br><span class="line"></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:                   <span class="string">"cordon NODE"</span>,</span><br><span class="line">DisableFlagsInUseLine: <span class="literal">true</span>,</span><br><span class="line">Short:                 i18n.T(<span class="string">"Mark node as unschedulable"</span>),</span><br><span class="line">Long:                  cordonLong,</span><br><span class="line">Example:               cordonExample,</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">cmdutil.CheckErr(o.Complete(f, cmd, args))</span><br><span class="line">cmdutil.CheckErr(o.RunCordonOrUncordon(<span class="literal">true</span>))</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Flags().StringVarP(&amp;o.drainer.Selector, <span class="string">"selector"</span>, <span class="string">"l"</span>, o.drainer.Selector, <span class="string">"Selector (label query) to filter on"</span>)</span><br><span class="line">cmdutil.AddDryRunFlag(cmd)</span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看 <code>Run</code> 中的内容，先忽略 <code>cmdutil.CheckErr</code> ，这里主要执行了两个方法：<code>o.Complete</code> 和 <code>o.RunCordonOrUncordon</code> 。这里就必须提一下 <code>kubectl</code> 的实现方式，<code>kubectl</code> 的根本目的是发送对应的 HTTP 请求到 APIServer，<code>kubectl</code> 通过 <code>Builder</code> 和 <code>Visitor</code> 来实现了一层封装，使每个子命令的实现方式统一、简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder provides convenience functions for taking arguments and parameters</span></span><br><span class="line"><span class="comment">// from the command line and converting them to a list of resources to iterate</span></span><br><span class="line"><span class="comment">// over using the Visitor interface.</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Visitor lets clients walk a list of resources.</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">Visit(VisitorFunc) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>o.Complete</code> 中构建了对应的 <code>builder</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 根据命令行参数构建 builder 实例</span></span><br><span class="line">builder := f.NewBuilder().</span><br><span class="line">WithScheme(scheme.Scheme, scheme.Scheme.PrioritizedVersionsAllGroups()...).</span><br><span class="line">NamespaceParam(o.Namespace).DefaultNamespace().</span><br><span class="line">ResourceNames(<span class="string">"nodes"</span>, args...).</span><br><span class="line">SingleResourceType().</span><br><span class="line">Flatten()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(o.drainer.Selector) &gt; <span class="number">0</span> &#123;</span><br><span class="line">builder = builder.LabelSelectorParam(o.drainer.Selector).</span><br><span class="line">ResourceTypes(<span class="string">"nodes"</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// builder.Do 返回带有 Visitor 的 Result 对象</span></span><br><span class="line">    r := builder.Do()</span><br></pre></td></tr></table></figure><p>来看看 <code>builder.Do()</code> 接下来是怎么做的来返回了 Result 类型资源：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Do</span><span class="params">()</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用 visitorResult 返回 Result 类型</span></span><br><span class="line">r := b.visitorResult()</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">visitorResult</span><span class="params">()</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 跳过其他步骤，直接看最简单的通过 Name 来获取 Result</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(b.names) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.visitByName()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">visitByName</span><span class="params">()</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明 Result 对象</span></span><br><span class="line">result := &amp;Result&#123;</span><br><span class="line">singleItemImplied:  <span class="built_in">len</span>(b.names) == <span class="number">1</span>,</span><br><span class="line">targetsSingleItems: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取 K8s client</span></span><br><span class="line">client, err := b.getClient(mapping.GroupVersionKind.GroupVersion())</span><br><span class="line">...</span><br><span class="line">visitors := []Visitor&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> b.names &#123;</span><br><span class="line">info := &amp;Info&#123;</span><br><span class="line">Client:    client,</span><br><span class="line">Mapping:   mapping,</span><br><span class="line">Namespace: selectorNamespace,</span><br><span class="line">Name:      name,</span><br><span class="line">Export:    b.export,</span><br><span class="line">&#125;</span><br><span class="line">visitors = <span class="built_in">append</span>(visitors, info)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// VisitorList 也实现了 Visit 接口，遍历执行 Visitor 的 Visit 方法</span></span><br><span class="line">result.visitor = VisitorList(visitors)</span><br><span class="line">result.sources = visitors</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了如何获取 Result 类型对象，我们再来看 <code>o.Complete</code> 如何处理的，传入一个 VisitorFunc，Result 的 visitor 都实现了 <code>Visit</code> 接口，<code>Visit</code> 接口的作用是接收 <code>VisitorFunc</code> 并执行。 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> r.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *resource.Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v DecoratedVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> v.decorators &#123;</span><br><span class="line"><span class="keyword">if</span> err := v.decorators[i](info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看 <code>o.RunCordonOrUncordon</code> 做了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DrainCmdOptions)</span> <span class="title">RunCordonOrUncordon</span><span class="params">(desired <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cordonOrUncordon := <span class="string">"cordon"</span></span><br><span class="line"><span class="keyword">if</span> !desired &#123;</span><br><span class="line">cordonOrUncordon = <span class="string">"un"</span> + cordonOrUncordon</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 通过 Visit 获取到的 nodeInfos 列表</span></span><br><span class="line"><span class="keyword">for</span> _, nodeInfo := <span class="keyword">range</span> o.nodeInfos &#123;</span><br><span class="line">        ...</span><br><span class="line">gvk := nodeInfo.ResourceMapping().GroupVersionKind</span><br><span class="line"><span class="keyword">if</span> gvk.Kind == <span class="string">"Node"</span> &#123;</span><br><span class="line">c, err := drain.NewCordonHelperFromRuntimeObject(nodeInfo.Object, scheme.Scheme, gvk)</span><br><span class="line"><span class="keyword">if</span> updateRequired := c.UpdateIfRequired(desired); !updateRequired &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> o.drainer.DryRunStrategy != cmdutil.DryRunClient &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// 修改对应节点的配置</span></span><br><span class="line">err, patchErr := c.PatchOrReplace(o.drainer.Client, o.drainer.DryRunStrategy == cmdutil.DryRunServer)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CordonHelper)</span> <span class="title">PatchOrReplace</span><span class="params">(clientset kubernetes.Interface, serverDryRun <span class="keyword">bool</span>)</span> <span class="params">(error, error)</span></span> &#123;</span><br><span class="line">client := clientset.CoreV1().Nodes()</span><br><span class="line">    oldData, err := json.Marshal(c.node)</span><br><span class="line">    <span class="comment">// 更新 node Spec 的 Unschedulable 字段</span></span><br><span class="line">c.node.Spec.Unschedulable = c.desired</span><br><span class="line">newData, err := json.Marshal(c.node)</span><br><span class="line">    <span class="comment">// merge 数据，通过 diff 然后获取</span></span><br><span class="line">patchBytes, patchErr := strategicpatch.CreateTwoWayMergePatch(oldData, newData, c.node)</span><br><span class="line"><span class="keyword">if</span> patchErr == <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">_, err = client.Patch(context.TODO(), c.node.Name, types.StrategicMergePatchType, patchBytes, patchOptions)</span><br><span class="line">&#125; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Drain"><a href="#Drain" class="headerlink" title="Drain"></a>Drain</h2><p>看完了 Cordon，再来看 Drain：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCmdDrain</span><span class="params">(f cmdutil.Factory, ioStreams genericclioptions.IOStreams)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">...</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">cmdutil.CheckErr(o.Complete(f, cmd, args))</span><br><span class="line">cmdutil.CheckErr(o.RunDrain())</span><br><span class="line">&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>直接看 <code>o.RunDrain</code>，我们会看到第一件事情就就是执行 <code>o.RunCordonOrUncordon</code> ，就是标记节点为不可调度，所以我之前写的那篇博客其实说法不正确，如果是想将节点下线，那么直接执行 <code>kubectl drain</code> 就好：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DrainCmdOptions)</span> <span class="title">RunDrain</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := o.RunCordonOrUncordon(<span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">drainedNodes := sets.NewString()</span><br><span class="line"><span class="keyword">var</span> fatal error</span><br><span class="line"><span class="keyword">for</span> _, info := <span class="keyword">range</span> o.nodeInfos &#123;</span><br><span class="line">        <span class="comment">// 驱逐 Pod</span></span><br><span class="line"><span class="keyword">if</span> err := o.deleteOrEvictPodsSimple(info); err == <span class="literal">nil</span> &#123;</span><br><span class="line">drainedNodes.Insert(info.Name)</span><br><span class="line">printObj(info.Object, o.Out)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果驱逐 Pod 失败，则显示对应的 Node 信息</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(remainingNodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Fprintf(o.ErrOut, <span class="string">"There are pending nodes to be drained:\n"</span>)</span><br><span class="line"><span class="keyword">for</span> _, nodeName := <span class="keyword">range</span> remainingNodes &#123;</span><br><span class="line">fmt.Fprintf(o.ErrOut, <span class="string">" %s\n"</span>, nodeName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>deleteOrEvictPodsSimple</code> 中，先通过 Node 名称获取对应的 Pod 信息，然后进行驱逐动作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *DrainCmdOptions)</span> <span class="title">deleteOrEvictPodsSimple</span><span class="params">(nodeInfo *resource.Info)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">list, errs := o.drainer.GetPodsForDeletion(nodeInfo.Name)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> err := o.drainer.DeleteOrEvictPods(list.Pods()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>GetPodsForDeletion</code> 会进行一个过滤，包含以下几种场景的过滤，需要注意的是，这里的过滤场景是有严格的顺序的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Helper)</span> <span class="title">makeFilters</span><span class="params">()</span> []<span class="title">podFilter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []podFilter&#123;</span><br><span class="line">        <span class="comment">// 被标记删除的 Pod(DeletionTimestamp 不为0)</span></span><br><span class="line">        d.skipDeletedFilter,</span><br><span class="line">        <span class="comment">// 属于 DaemonSet 的 Pod</span></span><br><span class="line">        d.daemonSetFilter,</span><br><span class="line">        <span class="comment">// mirror pod 其实就是 static pod，</span></span><br><span class="line">        <span class="comment">// 是我们在 /etc/kubernetes/manifests/ 中定义的由 kubelet 负责生命周期管理的 Pod</span></span><br><span class="line">        <span class="comment">// 在 `Annotations` 中会包含 `kubernetes.io/config.mirror` </span></span><br><span class="line">        d.mirrorPodFilter,</span><br><span class="line">        <span class="comment">// 包含本地存储的 Pod，Pod 中的 Volume 字段不为空</span></span><br><span class="line">        d.localStorageFilter,</span><br><span class="line">        <span class="comment">// 不属于 replicate 的 pod，`Controlled By` 不为空的 pod</span></span><br><span class="line">d.unreplicatedFilter,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到过滤后的 Pod 列表后，就开始执行驱逐动作，每个 Pod 起一个 goroutine ，提交驱逐动作后会等待，直到 Pod 驱逐完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Helper)</span> <span class="title">evictPods</span><span class="params">(pods []corev1.Pod, policyGroupVersion <span class="keyword">string</span>, getPodFn <span class="keyword">func</span>(namespace, name <span class="keyword">string</span>)</span> <span class="params">(*corev1.Pod, error)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">returnCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line">ctx, cancel := context.WithTimeout(d.getContext(), globalTimeout)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(pod corev1.Pod, returnCh <span class="keyword">chan</span> error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// 驱逐超时</span></span><br><span class="line">returnCh &lt;- fmt.Errorf(<span class="string">"error when evicting pod %q: global timeout reached: %v"</span>, pod.Name, globalTimeout)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 驱逐 Pod 动作，最终执行 d.Client.PolicyV1beta1().Evictions(eviction.Namespace).Evict(eviction)</span></span><br><span class="line">err := d.EvictPod(pod, policyGroupVersion)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">params := waitForDeleteParams&#123;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待驱逐动作完成</span></span><br><span class="line">_, err := waitForDelete(params)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">returnCh &lt;- <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">returnCh &lt;- fmt.Errorf(<span class="string">"error when waiting for pod %q terminating: %v"</span>, pod.Name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(pod, returnCh)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>waitForDelete</code> 如果没有立即完成，会将 <code>ConditionFunc</code> 传入 <code>WaitFor</code> 循环检测，其中 <code>ConditionFunc</code> 的检测依据是 Pod 存在且 ObjectMeta UID发生了改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitFor</span><span class="params">(wait WaitFunc, fn ConditionFunc, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stopCh)</span><br><span class="line">c := wait(stopCh)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> _, open := &lt;-c:</span><br><span class="line">ok, err := runConditionWithCrashProtection(fn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !open &#123;</span><br><span class="line"><span class="keyword">return</span> ErrWaitTimeout</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span> ErrWaitTimeout</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>kubectl drain</code> 相关命令的实现还是很简单的，没有特别负责的逻辑，K8s 能够做到这种效果一个重要的原因是所有动作都是声明式的，声明之后等待执行完成就好，不需要主动的去做某些很脏的动作。在驱逐 Pod 的行为中，并不是所有的 Pod 都会被驱逐到其他节点，这里需要格外的注意，在节点下线前需要检查是否有单纯的 Pod 资源仍在节点上运行，是否有使用本地存储的 Pod等类似情况。</p><p>平时写代码很糙，见到这种多种设计模式组合的形式看了半天，找机会重新学习下设计模式。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://qiankunli.github.io/2018/12/23/kubernetes_source_kubectl.html" target="_blank" rel="noopener">https://qiankunli.github.io/2018/12/23/kubernetes_source_kubectl.html</a></li><li><a href="https://juejin.im/post/5a113e686fb9a0452936596c" target="_blank" rel="noopener">https://juejin.im/post/5a113e686fb9a0452936596c</a></li><li><a href="https://rootdeep.github.io/k8s-source-code-analysis/kubectl/construct-visitor.html" target="_blank" rel="noopener">https://rootdeep.github.io/k8s-source-code-analysis/kubectl/construct-visitor.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前写过一篇 &lt;a href=&quot;https://zdyxry.github.io/2019/08/01/Kubernetes-%E5%AE%
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Content-Length 学习</title>
    <link href="https://zdyxry.github.io/2020/02/07/HTTP-Content-Length-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zdyxry.github.io/2020/02/07/HTTP-Content-Length-学习/</id>
    <published>2020-02-07T14:54:14.000Z</published>
    <updated>2020-02-07T14:56:22.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前提供了一个用于下载文件的 API，使用到了 <code>Content-Length</code> 字段并踩了个坑： <code>Content-Length</code> 与实际的数据大小不一致。今天来学习下这个字段相关的知识。</p><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><blockquote><p>Content-Length 是一个实体消息首部，用来指明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目。</p></blockquote><p>当客户端向服务器发送一个请求时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端需要接收多少数据。除了使用 <code>Transfer-Encoding</code>，当<code>Content-Length</code> 存在是必须与实际传输的数据大小一致，如果前者大，则会导致请求一直等待直至超时；如果后者大，则会导致数据被截断，在最近版本的 Chrome 中，会直接提示 <code>net::ERR_CONTENT_LENGTH_MISMATCH</code> 报错导致加载失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">w.Header().Set(<span class="string">"Content-Length"</span>, <span class="string">"20"</span>)</span><br><span class="line"><span class="comment">//w.Header().Set("Content-Length", "12")</span></span><br><span class="line">w.WriteHeader(<span class="number">200</span>)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world\n"</span>))</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request URL: http://127.0.0.1:8080/</span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: 200 OK</span><br><span class="line">Remote Address: 127.0.0.1:8080</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line">Content-Length: 12</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Date: Fri, 07 Feb 2020 14:36:40 GMT</span><br><span class="line">X-DNS-Prefetch-Control: off</span><br></pre></td></tr></table></figure><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><img src="/2020/02/07/HTTP-Content-Length-学习/http.png" title="Transfer-Encoding"><blockquote><p>Transfer-Encoding 消息首部指明了将 entity 安全传递给用户所采用的编码形式。Transfer-Encoding 是一个逐跳传输消息首部，即仅应用于两个节点之间的消息传递，而不是所请求的资源本身。一个多节点连接中的每一段都可以应用不同的Transfer-Encoding 值。</p></blockquote><p>如果在传输前不知道消息大小，那么就可以使用 <code>Transfer-Encoding</code> 。当设置了 <code>Transfer-Encoding</code> ， <code>Content-Length</code> 会被忽略，两者无法共存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"io"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world, the web server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        w.WriteHeader(<span class="number">200</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">                io.WriteString(w, <span class="string">"hello, world!\n"</span>)</span><br><span class="line">                w.(http.Flusher).Flush()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">"/"</span>, HelloServer)</span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request URL: http://127.0.0.1:8080/</span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: 200 OK</span><br><span class="line">Remote Address: 127.0.0.1:8080</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Date: Fri, 07 Feb 2020 13:56:54 GMT</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-DNS-Prefetch-Control: off</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length</a></li><li><a href="https://blog.piaoruiqing.com/2019/09/08/do-you-know-content-length/#Content-Length-3" target="_blank" rel="noopener">https://blog.piaoruiqing.com/2019/09/08/do-you-know-content-length/#Content-Length-3</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前提供了一个用于下载文件的 API，使用到了 &lt;code&gt;Content-Length&lt;/code&gt; 字段并踩了个坑： &lt;code&gt;Con
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://zdyxry.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Server-Sent Events 简单使用</title>
    <link href="https://zdyxry.github.io/2020/02/03/Server-Sent-Events-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://zdyxry.github.io/2020/02/03/Server-Sent-Events-简单使用/</id>
    <published>2020-02-02T23:36:46.000Z</published>
    <updated>2020-02-02T23:37:14.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在刷 Twitter 的时候，发现 Twitter 会实时更新已加载页面的内容，以为是 Websocket，看了下请求发现是 Server-sent events，之前没有了解过这个，今天来学习一下。</p><h2 id="Server-sent-events"><a href="#Server-sent-events" class="headerlink" title="Server-sent events"></a>Server-sent events</h2><p>引用维基百科：</p><blockquote><p>Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via HTTP connection. The Server-Sent Events EventSource API is standardized as part of HTML5[1] by the W3C. </p></blockquote><p>SSE 通常与 Websocket 相比较：</p><ul><li>SSE 提供单向通信，Websocket 提供双向通信；</li><li>SSE 是通过 HTTP 协议实现的，Websocket 是单独的协议；</li><li>实现上来说 SSE 比较容易，Websocket 复杂一些；</li><li>对浏览器来说，IE/Edge 不支持 SSE，其它的都是支持的。</li><li>SSE 有最大连接数限制</li><li>WS 可以传输二进制数据和文本数据，而 SSE 只有文本数据</li></ul><p>SSE 使用场景：</p><ul><li>股票行情自动收录</li><li>社交网站自动更新（Twitter）</li><li>…</li></ul><p>Websocket 使用场景：</p><ul><li>VNC</li><li>协同编辑</li><li>…</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Golang 有 <a href="https://github.com/antage/eventsource" target="_blank" rel="noopener">eventsource</a> 可以直接使用，示例如下：</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"gopkg.in/antage/eventsource.v1"</span></span><br><span class="line">        <span class="string">"log"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        es := eventsource.New(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">defer</span> es.Close()</span><br><span class="line">        http.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"./public"</span>)))</span><br><span class="line">        http.Handle(<span class="string">"/events"</span>, es)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                        <span class="comment">// 每 2 秒发送一条消息，并打印对应客户端数量</span></span><br><span class="line">                        es.SendEventMessage(<span class="string">"hello"</span>, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">                        log.Printf(<span class="string">"Hello has been sent (consumers: %d)"</span>, es.ConsumersCount())</span><br><span class="line">                        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        log.Print(<span class="string">"Open URL http://localhost:8080/ in your browser."</span>)</span><br><span class="line">        err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      window.addEventListener("DOMContentLoaded", function () &#123;</span></span><br><span class="line"><span class="undefined">        var evsrc = new EventSource("/events");</span></span><br><span class="line"><span class="undefined">        evsrc.onmessage = function (ev) &#123;</span></span><br><span class="line"><span class="undefined">          document.getElementById("log")</span></span><br><span class="line"><span class="xml">            .insertAdjacentHTML("beforeend", "<span class="tag">&lt;<span class="name">li</span>&gt;</span>" + ev.data + "<span class="tag">&lt;/<span class="name">li</span>&gt;</span>");</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        evsrc.onerror = function (ev) &#123;</span></span><br><span class="line"><span class="undefined">          console.log("readyState = " + ev.currentTarget.readyState);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"log"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SSE 很适合 Twitter 这种场景，还特意观察了下微博，发现微博没有。。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource" target="_blank" rel="noopener">https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在刷 Twitter 的时候，发现 Twitter 会实时更新已加载页面的内容，以为是 Websocket，看了下请求发现是 Serve
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zdyxry.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>使用 Raft 实现 VIP 功能</title>
    <link href="https://zdyxry.github.io/2020/01/17/%E4%BD%BF%E7%94%A8-Raft-%E5%AE%9E%E7%8E%B0-VIP-%E5%8A%9F%E8%83%BD/"/>
    <id>https://zdyxry.github.io/2020/01/17/使用-Raft-实现-VIP-功能/</id>
    <published>2020-01-17T14:48:28.000Z</published>
    <updated>2020-01-17T14:49:46.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HAProxy 也存在单点故障，因此需要多个 HAProxy 来保证业务不中断，这时候我们需要另一个软件配合：Keepalived。通常我用 Keepalived 仅用来提供 VIP，保证当一个 Keepalived 故障，VIP 自动在其他 Keepalived 节点配置。</p><p>Keepalived 有一个问题是 virtual route ID 必须是同一网段内唯一的，当我们想要在一个网段内部署多个集群时，就需要人为的介入去分配 virtual route ID，不方便。这次来使用 Raft 自己实现 VIP 逻辑。</p><h2 id="hashicorp-raft"><a href="#hashicorp-raft" class="headerlink" title="hashicorp/raft"></a>hashicorp/raft</h2><p>Raft 有很多开源实现，其中 Hashicorp 实现的 <a href="https://github.com/hashicorp/raft" target="_blank" rel="noopener">Raft 库</a> 已经被 Consul 等软件使用，且接口友善，选择使用它来实现。在 Github 上有很多 Raft 的使用示例，比较简单且完整的是 <a href="https://github.com/otoolep/hraftd" target="_blank" rel="noopener">otoolep/hraftd</a>，我们来看看他是怎么使用的。</p><h3 id="otoolep-hraftd"><a href="#otoolep-hraftd" class="headerlink" title="otoolep/hraftd"></a>otoolep/hraftd</h3><h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><p>在 main.go 中主要做了 4 件事情：<code>store.New</code>, <code>store.Open</code>, <code>http.New</code>, <code>http.Start</code>，先来看看程序是如何启动的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置命令行参数</span></span><br><span class="line">flag.BoolVar(&amp;inmem, <span class="string">"inmem"</span>, <span class="literal">false</span>, <span class="string">"Use in-memory storage for Raft"</span>)</span><br><span class="line">...</span><br><span class="line">flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: %s [options] &lt;raft-data-path&gt; \n"</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">flag.PrintDefaults()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 解析命令行参数</span></span><br><span class="line">flag.Parse()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建一个 Store 对象</span></span><br><span class="line">s := store.New(inmem)</span><br><span class="line">s.RaftDir = raftDir</span><br><span class="line">    s.RaftBind = raftAddr</span><br><span class="line">    <span class="comment">// 运行 Store </span></span><br><span class="line"><span class="keyword">if</span> err := s.Open(joinAddr == <span class="string">""</span>, nodeID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to open store: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 新建一个 http 对象并运行</span></span><br><span class="line">h := httpd.New(httpAddr, s)</span><br><span class="line"><span class="keyword">if</span> err := h.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to start HTTP service: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 joinAddr 参数不为空，则处理 join 请求</span></span><br><span class="line"><span class="keyword">if</span> joinAddr != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := join(joinAddr, raftAddr, nodeID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to join node at %s: %s"</span>, joinAddr, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"hraftd started successfully"</span>)</span><br><span class="line">    <span class="comment">// 监听系统信号，若接收到 os.Interrupt 则程序退出</span></span><br><span class="line">terminate := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(terminate, os.Interrupt)</span><br><span class="line">&lt;-terminate</span><br><span class="line">log.Println(<span class="string">"hraftd exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>看了 main.go 我们知道调用了 <code>http.Start</code>， 先不管 Store 是什么，先来看看 http 相关实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start starts the service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Service 实现了 ServeHTTP 方法</span></span><br><span class="line">http.Handle(<span class="string">"/"</span>, s)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := server.Serve(s.ln)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(r.URL.Path, <span class="string">"/key"</span>) &#123;</span><br><span class="line">s.handleKeyRequest(w, r)</span><br><span class="line">    <span class="comment">// 先忽略其他分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要处理请求的是 <code>s.handleKeyRequest</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">handleKeyRequest</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"GET"</span>:</span><br><span class="line">k := getKey()</span><br><span class="line"><span class="keyword">if</span> k == <span class="string">""</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">&#125;</span><br><span class="line">v, err := s.store.Get(k)</span><br><span class="line">...</span><br><span class="line">io.WriteString(w, <span class="keyword">string</span>(b))</span><br><span class="line"><span class="keyword">case</span> <span class="string">"POST"</span>:</span><br><span class="line"><span class="comment">// Read the value from the POST body.</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> err := s.store.Set(k, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在 <code>s.handleKeyRequest</code> 中根据请求方法，去调用 store 对应的方法，那么 store 实现了哪些接口呢？这也是在 http 模块中定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(key <span class="keyword">string</span>) (<span class="keyword">string</span>, error)</span><br><span class="line">Set(key, value <span class="keyword">string</span>) error</span><br><span class="line">Delete(key <span class="keyword">string</span>) error</span><br><span class="line">Join(nodeID <span class="keyword">string</span>, addr <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 Join 看着比较奇怪，其他的都是一个 K/V 系统该有的接口，接下来就看看 Store 具体方法的实现。</p><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>这个模块的编写涉及到了 Raft 中的具体概念，建议先阅读 siddontang 写的 Raft 相关博客快速了解（链接在参考链接列出）。</p><p>以下以设置 Key 为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.raft.State() != raft.Leader &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"not leader"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装具体执行的动作</span></span><br><span class="line">c := &amp;command&#123;</span><br><span class="line">Op:    <span class="string">"set"</span>,</span><br><span class="line">Key:   key,</span><br><span class="line">Value: value,</span><br><span class="line">&#125;</span><br><span class="line">b, err := json.Marshal(c)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将 command 应用于 FSM</span></span><br><span class="line">f := s.raft.Apply(b, raftTimeout)</span><br><span class="line"><span class="keyword">return</span> f.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 FSM Apply 方法实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply applies a Raft log entry to the key-value store.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fsm)</span> <span class="title">Apply</span><span class="params">(l *raft.Log)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">var</span> c command</span><br><span class="line"><span class="comment">// 根据操作动作的不同，执行不同的方法，这里以设置 Key 为例</span></span><br><span class="line"><span class="keyword">switch</span> c.Op &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"set"</span>:</span><br><span class="line"><span class="keyword">return</span> f.applySet(c.Key, c.Value)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fsm)</span> <span class="title">applySet</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    f.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.mu.Unlock()</span><br><span class="line">    <span class="comment">// 设置 Map 中的 Key/Value</span></span><br><span class="line">f.m[key] = value</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h4><p>看了上面的具体动作实现，接下来看看 Raft 具体启动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">Open</span><span class="params">(enableSingle <span class="keyword">bool</span>, localID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置 Raft 配置</span></span><br><span class="line">config := raft.DefaultConfig()</span><br><span class="line">config.LocalID = raft.ServerID(localID)</span><br><span class="line">    <span class="comment">// 设置 Raft 通信</span></span><br><span class="line">addr, err := net.ResolveTCPAddr(<span class="string">"tcp"</span>, s.RaftBind)</span><br><span class="line">    ...</span><br><span class="line">transport, err := raft.NewTCPTransport(s.RaftBind, addr, <span class="number">3</span>, <span class="number">10</span>*time.Second, os.Stderr)</span><br><span class="line">    <span class="comment">// 设置 Raft 存储对象</span></span><br><span class="line">snapshots, err := raft.NewFileSnapshotStore(s.RaftDir, retainSnapshotCount, os.Stderr)</span><br><span class="line"><span class="keyword">var</span> logStore raft.LogStore</span><br><span class="line"><span class="keyword">var</span> stableStore raft.StableStore</span><br><span class="line"><span class="keyword">if</span> s.inmem &#123;</span><br><span class="line">logStore = raft.NewInmemStore()</span><br><span class="line">stableStore = raft.NewInmemStore()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">boltDB, err := raftboltdb.NewBoltStore(filepath.Join(s.RaftDir, <span class="string">"raft.db"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"new bolt store: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">logStore = boltDB</span><br><span class="line">stableStore = boltDB</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 创建 raft 示例，并使用该 raft 实例启动集群</span></span><br><span class="line">ra, err := raft.NewRaft(config, (*fsm)(s), logStore, stableStore, snapshots, transport)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"new raft: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s.raft = ra</span><br><span class="line"><span class="keyword">if</span> enableSingle &#123;</span><br><span class="line">...</span><br><span class="line">ra.BootstrapCluster(configuration)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 Raft 所需接口为 FSM 和 Snapshot，具体的实现方式根据需求来实现，一般与 hraftd 相仿，大概了解了 hashicorp/raft 的使用，那么我们来实现具体的 VIP 功能。</p><h2 id="VIP"><a href="#VIP" class="headerlink" title="VIP"></a>VIP</h2><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>既然是跟 IP 相关，那么肯定需要给对应网卡配置时间，在 Linux 中我们可以通过 <code>ip</code> 命令来设置，Golang 中使用 <a href="https://github.com/vishvananda/netlink" target="_blank" rel="noopener">vishvananda/netlink</a> 来实现。</p><p> <code>netlink.AddrAdd</code> 可以在指定的网络设备上添加 IP 地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nc *NetworkConfig)</span> <span class="title">addIP</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">res, err := nc.IsSet()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"ip check in AddIP failed"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := netlink.AddrAdd(nc.link, nc.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"could not add ip"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>netlink.AddrDel</code> 可以将 IP 从指定网络设备上删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nc *NetworkConfig)</span> <span class="title">delIP</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">res, err := nc.IsSet()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"ip check in DelIP failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !res &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := netlink.AddrDel(nc.link, nc.address); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"could not delete ip"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="raft-1"><a href="#raft-1" class="headerlink" title="raft"></a>raft</h3><p>实现了 IP 设置相关，我们不需要提供 HTTP 接口，直接编写 Raft 相关实现，跟 hraftd 实现不同，在 hraftd 中需要进行信息写入读取，而我们的 VIP 仅依赖于 Raft 选举 Leader，所以只需要编写好对应的方法，不需要做额外操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FSM <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fsm FSM)</span> <span class="title">Apply</span><span class="params">(log *raft.Log)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fsm FSM)</span> <span class="title">Restore</span><span class="params">(snap io.ReadCloser)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fsm FSM)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="params">(raft.FSMSnapshot, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Snapshot&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(snapshot Snapshot)</span> <span class="title">Persist</span><span class="params">(sink raft.SnapshotSink)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(snapshot Snapshot)</span> <span class="title">Release</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serve"><a href="#serve" class="headerlink" title="serve"></a>serve</h3><p>基础方法都已经实现了，那么接下来编写集群启动逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(manager *VIPManager)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化 raft 配置、存储对象、通信</span></span><br><span class="line"><span class="keyword">for</span> id, ip := <span class="keyword">range</span> manager.peers &#123;</span><br><span class="line">configuration.Servers = <span class="built_in">append</span>(configuration.Servers, raft.Server&#123;ID: raft.ServerID(id), Address: raft.ServerAddress(ip)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Raft 集群，这里与 hraftd 不同，需要注意</span></span><br><span class="line"><span class="keyword">if</span> error := raft.BootstrapCluster(config, logStore, stableStore, snapshots, transport, configuration); error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 raft 实例</span></span><br><span class="line">raftServer, error := raft.NewRaft(config, manager.fsm, logStore, stableStore, snapshots, transport)</span><br><span class="line">    ...</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">isLeader := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 服务启动时先删除 VIP，防止集群中同时存在节点都配置了 VIP</span></span><br><span class="line">manager.deleteIP(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 当前节点是 Leader 节点，则设置 VIP</span></span><br><span class="line"><span class="keyword">case</span> leader := &lt;-raftServer.LeaderCh():</span><br><span class="line"><span class="keyword">if</span> leader &#123;</span><br><span class="line">isLeader = <span class="literal">true</span></span><br><span class="line">log.Info(<span class="string">"Leading"</span>)</span><br><span class="line">manager.addIP(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 定时检测，如果是 Leader，则检测 VIP 是否正确设置，如果没有就再次配置 VIP</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line"><span class="keyword">if</span> isLeader &#123;</span><br><span class="line">result, error := manager.networkConfigurator.IsSet()</span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">log.WithFields(log.Fields&#123;<span class="string">"error"</span>: error, <span class="string">"ip"</span>: manager.networkConfigurator.IP(), <span class="string">"interface"</span>: manager.networkConfigurator.Interface()&#125;).Error(<span class="string">"Could not check ip"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result == <span class="literal">false</span> &#123;</span><br><span class="line">log.Error(<span class="string">"Lost IP"</span>)</span><br><span class="line"></span><br><span class="line">manager.addIP(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里与 hraftd 的实现不同，hraftd 先实例 raft，然后使用该 raft 实例启动集群，这样做的好处是哪怕集群只有一个节点，就是第一个节点，那么集群也是可以正常工作的，坏处是集群启动顺序是固定的，必须要先启动第一个节点，然后其他节点通过 Join 请求添加到 Raft 集群中（我们忽略了 Join 的走读）。</p><p>重新想一下我们的需求：集群、高可用、故障。当这几个词放在一起，我们就知道 hraftd 的方法不适合我们，有以下原因：</p><ol><li>集群节点启动顺序要求</li><li>各个节点配置文件不同，有的需要 Join 参数</li></ol><p>所以我们是直接使用 <code>raft.BootstrapCluster</code> 来启动集群，虽然只有一个节点集群无法正常工作，但是这个是可以容忍的。</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在实现完上述功能后，我以为大功告成了，就开始自测，但是测试过程中发现了很诡异的现象，虽然我们通过 Raft 自身选举实现了 VIP 的故障自动漂移，但是实际测试中发现业务访问随着 VIP 的重建并没有立即恢复，，检查 ARP 记录发现集群中各个节点关于 VIP 的 ARP 记录各不相同，甚至是完全不同。</p><p>我们来重温下 ARP 协议内容：</p><blockquote><p>地址解析协议（英語：Address Resolution Protocol，缩写：ARP）是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。ARP最初在1982年的RFC 826（征求意见稿）[1]中提出并纳入互联网标准 STD 37. ARP 也可能指是在多数操作系统中管理其相关地址的一个进程。</p></blockquote><blockquote><p>在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p></blockquote><p>如果 VIP 与真实节点对应的 MAC 地址不同，就相当于 ARP 攻击了，所以我们的 Leader 节点设置完 VIP 后，还需要发送 ARP 请求广播，告诉广播域中的其他节点 VIP 正确的 MAC 地址。采用的方式是 gratuitous ARP（免费 ARP）。这里我们直接找一个开源的 ARP 实现来完成这个需求：</p><p><a href="https://github.com/google/seesaw" target="_blank" rel="noopener">google/seesaw</a> 是一个负载均衡器，里面实现了这个功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARPSendGratuitous sends a gratuitous ARP message via the specified interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ncc *SeesawNCC)</span> <span class="title">ARPSendGratuitous</span><span class="params">(arp *ncctypes.ARPGratuitous, out *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">iface, err := net.InterfaceByName(arp.IfaceName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get interface %q: %v"</span>, arp.IfaceName, err)</span><br><span class="line">&#125;</span><br><span class="line">log.V(<span class="number">2</span>).Infof(<span class="string">"Sending gratuitous ARP for %s (%s) via %s"</span>, arp.IP, iface.HardwareAddr, iface.Name)</span><br><span class="line">m, err := gratuitousARPReply(arp.IP, iface.HardwareAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sendARP(iface, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 hashicorp/raft 可以很简单方便的实现需要选举 Leader 的分布式应用，虽然我司的 Slogan 是 <code>Make IT Simple</code> ，但是愈发感觉 Hashicorp 才是这句话的忠实体现，他们的 Terraform、Vault、Consul、Nomad、Vagrant 等软件，都是让基础设施的适用与管理更简单方便的，还是很爽的。</p><p>本文的具体实现在 <a href="https://github.com/zdyxry/sparrow" target="_blank" rel="noopener">sparrow</a> 可以看到。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/138b4d267084" target="_blank" rel="noopener">https://www.jianshu.com/p/138b4d267084</a></li><li><a href="https://www.jianshu.com/p/2b60542640e2" target="_blank" rel="noopener">https://www.jianshu.com/p/2b60542640e2</a></li><li><a href="https://www.jianshu.com/p/1bbd7162727d" target="_blank" rel="noopener">https://www.jianshu.com/p/1bbd7162727d</a></li><li><a href="https://www.jianshu.com/p/99562bfec5c2" target="_blank" rel="noopener">https://www.jianshu.com/p/99562bfec5c2</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE</a></li><li><a href="https://github.com/darxkies/virtual-ip/blob/master/pkg/manager.go" target="_blank" rel="noopener">https://github.com/darxkies/virtual-ip/blob/master/pkg/manager.go</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在部署应用时想要应用是高可用，通常会在应用前放置一个 HAProxy，当任何一个 Server 故障，HAProxy 会自动切换，但是 HA
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPad T480 &amp; Ubuntu 19.10 连接多显示器方式</title>
    <link href="https://zdyxry.github.io/2020/01/12/ThinkPad-T480-Ubuntu-19-10-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://zdyxry.github.io/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/</id>
    <published>2020-01-12T12:26:35.000Z</published>
    <updated>2020-01-12T13:17:29.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>平时工作使用的电脑是 ThinkPad T480，之前一直安装的 Win10，连接多显示器很正常，没有问题，后来重装为了 Ubuntu，发现连接多显示器很诡异，在我的这套设备之上，如果想要正常使用，需要按照一个奇怪的顺序，记录一下。</p><h2 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h2><table><thead><tr><th>设备类型</th><th>设备</th><th>型号</th></tr></thead><tbody><tr><td>笔记本</td><td>ThinkPad</td><td>T480</td></tr><tr><td>拓展坞</td><td>联想/闪联 USB-C 集线器</td><td>C120</td></tr><tr><td>连接线</td><td>山泽 HDMI 数字高清线</td><td>SM-8855</td></tr><tr><td>连接线</td><td>VGA 高清视频线</td><td></td></tr><tr><td>显示器</td><td>DELL 24 寸</td><td>U2412Mb</td></tr><tr><td>显示器</td><td>DELL 24 寸</td><td>U2417H</td></tr></tbody></table><p>（不要问我为啥 Type-C 遍地走的现在，还在用 VGA，现在这套还是东拼西凑出来的。。。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/ubuntu.png" title="Ubuntu 19.10"><h2 id="设备接口"><a href="#设备接口" class="headerlink" title="设备接口"></a>设备接口</h2><p>T480 作为 ThinkPad 的 T 系列产品，接口还是很丰富的：</p><ul><li>2 x USB 3.1 Gen 1** (one Always On)</li><li>1 x USB 3.1 Gen 1** Type-C (Power Delivery, DisplayPort, Data transfer)</li><li><ul><li>x USB 3.1 Gen 2** Type-C / Intel Thunderbolt 3 (Power Delivery, DisplayPort, Data transfer)</li></ul></li><li>Headphone and microphone combo jack</li><li>4-in-1 SD card reader (SD, MMC, SDHC, SDXC)</li><li>HDMI</li><li>RJ45 Gigabit Ethernet</li><li>Optional Smart card reader</li></ul><p>ThinkPad T480 左视图：</p><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/t480-1.png" title="T480 左视图"><ul><li>1 x USB 3.1 Gen 1** Type-C (Power Delivery, DisplayPort, Data transfer)</li><li>1 x USB 3.1 Gen 2** Type-C / Intel Thunderbolt 3 (Power Delivery, DisplayPort, Data transfer)</li></ul><p>这里分别用 Type-C1 和 Type-C2 代指从左到右的两个接口。</p><p>ThinkPad T480 右视图：</p><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/t480-2.png" title="T480 右视图"><p>右侧有一个 HDMI 接口。</p><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><img src="/2020/01/12/ThinkPad-T480-Ubuntu-19-10-连接多显示器方式/connection.png" title="连接图"><h2 id="连接顺序"><a href="#连接顺序" class="headerlink" title="连接顺序"></a>连接顺序</h2><ol><li>VGA 连接 U2412Mb</li><li>HDMI 连接 U2417H</li><li>VGA 连接 C120</li><li>电源连接 C120</li><li>C120 连接 Type-C2</li><li>电源断开 C120</li><li>电源连接 Type-C1</li><li>HDMI 连接 T480 HDMI</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个顺序在尝试过程中感觉跟 T480 供电正相关，但是没有找到直接问题，只能用这种连接顺序来保证这套东西正常工作了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;平时工作使用的电脑是 ThinkPad T480，之前一直安装的 Win10，连接多显示器很正常，没有问题，后来重装为了 Ubuntu，发现
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么 flannel.1 丢失后不会自动重建</title>
    <link href="https://zdyxry.github.io/2020/01/03/%E4%B8%BA%E4%BB%80%E4%B9%88-flannel-1-%E4%B8%A2%E5%A4%B1%E5%90%8E%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E9%87%8D%E5%BB%BA/"/>
    <id>https://zdyxry.github.io/2020/01/03/为什么-flannel-1-丢失后不会自动重建/</id>
    <published>2020-01-03T14:20:37.000Z</published>
    <updated>2020-01-04T03:34:50.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在用 K8s 的同学应该多少都使用过 Flannel 作为自己的网络插件，不讨论性能稳定性，在复杂的网络环境配置中 Flannel 的要求应该是最低的，所以我通常使用 Flannel 作为 让 K8s Ready 的最后一步。</p><p>在使用过程中，遇到过多次 flannel.1 这个 link 消失的情况，查看官方 Issue 中有人提到过： <a href="https://github.com/coreos/flannel/issues/869" target="_blank" rel="noopener">flannel.1 is deleted by <code>service network restart</code>, and never recreated again.</a> ，但是这个 Issue 从 2017年创建一直到现在都处于 Open 状态，看上去社区也不打算去解决，其实不只是重启网络，如果没有特殊指定的话，找到默认网关所在的网卡，直接 ifdown ，flannel.1 也会丢失，并且不会重建，那为什么会出现这个问题，今天来看一看。</p><h2 id="CNI-Flannel-Plugin"><a href="#CNI-Flannel-Plugin" class="headerlink" title="CNI Flannel Plugin"></a>CNI Flannel Plugin</h2><p>我们常说的 Flannel 分为两部分：<a href="https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel" target="_blank" rel="noopener">CNI Flannel Plugin</a> 及 Flannel。</p><p>CNI Flannel Plugin 是 Flannel CNI 插件的具体接口实现， CNI 要求实现的 <code>cmdAdd</code> <code>cmdDel</code> <code>cmdCheck</code> 都是在这里实现的，来看看具体的调用流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdAdd</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从标准输入加载配置</span></span><br><span class="line">n, err := loadFlannelNetConf(args.StdinData) </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 加载子网配置：/run/flannel/subnet.env</span></span><br><span class="line">fenv, err := loadFlannelSubnetEnv(n.SubnetFile) </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行添加动作</span></span><br><span class="line"><span class="keyword">return</span> doCmdAdd(args, n, fenv) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCmdAdd</span><span class="params">(args *skel.CmdArgs, n *NetConf, fenv *subnetEnv)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">n.Delegate[<span class="string">"name"</span>] = n.Name</span><br><span class="line"><span class="keyword">if</span> !hasKey(n.Delegate, <span class="string">"type"</span>) &#123;</span><br><span class="line">n.Delegate[<span class="string">"type"</span>] = <span class="string">"bridge"</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> n.CNIVersion != <span class="string">""</span> &#123;</span><br><span class="line">n.Delegate[<span class="string">"cniVersion"</span>] = n.CNIVersion</span><br><span class="line">&#125;</span><br><span class="line">n.Delegate[<span class="string">"ipam"</span>] = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"type"</span>:   <span class="string">"host-local"</span>,</span><br><span class="line"><span class="string">"subnet"</span>: fenv.sn.String(),</span><br><span class="line"><span class="string">"routes"</span>: []types.Route&#123;</span><br><span class="line">&#123;</span><br><span class="line">Dst: *fenv.nw,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 进行配置解析及填充后，执行委托类型插件进行配置，默认是 bridge，创建过程中会将配置保存到 /var/lib/cni/flannel ，删除时会用到</span></span><br><span class="line"><span class="keyword">return</span> delegateAdd(args.ContainerID, n.DataDir, n.Delegate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里已经跟 Flannel Plugin 无关了，是调用的其他插件完成的具体动作，再来看看删除动作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdDel</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">nc, err := loadFlannelNetConf(args.StdinData)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行删除动作</span></span><br><span class="line"><span class="keyword">return</span> doCmdDel(args, nc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCmdDel</span><span class="params">(args *skel.CmdArgs, n *NetConf)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从 /var/lib/cni/flannel 中根据 ContainerID 读取配置，并在读取后删除配置</span></span><br><span class="line">    netconfBytes, err := consumeScratchNetConf(args.ContainerID, n.DataDir) </span><br><span class="line">    ...</span><br><span class="line">nc := &amp;types.NetConf&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err = json.Unmarshal(netconfBytes, nc); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to parse netconf: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 委托其他插件执行删除动作，默认 bridge</span></span><br><span class="line"><span class="keyword">return</span> invoke.DelegateDel(context.TODO(), nc.Type, netconfBytes, <span class="literal">nil</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们来捋一捋整个流程：</p><ol><li>kubelet 启动时查找可用 CNI 插件，并根据配置加载</li><li>kubelet 创建容器前，通过 CNI Interface 调用相应方法执行 cmdAdd/cmdDel 命令</li><li>CNI 根据配置信息调用对应的 Plugin 执行 cmdAdd/cmdDel</li></ol><h3 id="相应文件路径"><a href="#相应文件路径" class="headerlink" title="相应文件路径"></a>相应文件路径</h3><h4 id="var-lib-cni-flannel"><a href="#var-lib-cni-flannel" class="headerlink" title="/var/lib/cni/flannel"></a>/var/lib/cni/flannel</h4><p>每个 Pod 的具体网络配置，配置内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 09:29:48 cni]$pwd</span><br><span class="line">/var/lib/cni</span><br><span class="line">[root@install2 09:29:51 cni]$cat flannel/d3f1220d58a72ebe5a92f8febbe6dd45d3bff65dce0ff6960f732f202026c24c |jq</span><br><span class="line">&#123;</span><br><span class="line">  "cniVersion": "0.3.1",</span><br><span class="line">  "hairpinMode": true,</span><br><span class="line">  "ipMasq": false,</span><br><span class="line">  "ipam": &#123;</span><br><span class="line">    "routes": [</span><br><span class="line">      &#123;</span><br><span class="line">        "dst": "10.244.0.0/16"</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    "subnet": "10.244.1.0/24",</span><br><span class="line">    "type": "host-local"</span><br><span class="line">  &#125;,</span><br><span class="line">  "isDefaultGateway": true,</span><br><span class="line">  "isGateway": true,</span><br><span class="line">  "mtu": 1450,</span><br><span class="line">  "name": "cbr0",</span><br><span class="line">  "type": "bridge"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="var-lib-cni-networks"><a href="#var-lib-cni-networks" class="headerlink" title="/var/lib/cni/networks"></a>/var/lib/cni/networks</h4><p>IP 地址分配配置路径，默认 Flannel 使用的 ipam 是 host-local，bridge 是 cbr0 ，在这下面是已分配的 IP 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 09:31:48 cni]$pwd</span><br><span class="line">/var/lib/cni</span><br><span class="line">[root@install2 09:31:49 cni]$tree networks/</span><br><span class="line">networks/</span><br><span class="line">└── cbr0</span><br><span class="line">    ├── 10.244.1.160</span><br><span class="line">    ├── 10.244.1.161</span><br><span class="line">    ├── 10.244.1.162</span><br><span class="line">    ├── last_reserved_ip.0</span><br><span class="line">    └── lock</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br><span class="line">[root@install2 09:31:53 cni]$cat networks/cbr0/10.244.1.162</span><br><span class="line">d3f1220d58a72ebe5a92f8febbe6dd45d3bff65dce0ff6960f732f202026c24c</span><br><span class="line">[root@install2 09:32:07 cni]$cat networks/cbr0/last_reserved_ip.0</span><br><span class="line">10.244.1.162</span><br></pre></td></tr></table></figure><h4 id="etc-cni-net-d"><a href="#etc-cni-net-d" class="headerlink" title="/etc/cni/net.d"></a>/etc/cni/net.d</h4><p>CNI 插件配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 09:34:47 net.d]$pwd</span><br><span class="line">/etc/cni/net.d</span><br><span class="line">[root@install2 09:34:48 net.d]$cat 10-flannel.conflist</span><br><span class="line">&#123;</span><br><span class="line">  "name": "cbr0",</span><br><span class="line">  "cniVersion": "0.3.1",</span><br><span class="line">  "plugins": [</span><br><span class="line">    &#123;</span><br><span class="line">      "type": "flannel",</span><br><span class="line">      "delegate": &#123;</span><br><span class="line">        "hairpinMode": true,</span><br><span class="line">        "isDefaultGateway": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "type": "portmap",</span><br><span class="line">      "capabilities": &#123;</span><br><span class="line">        "portMappings": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概了解了 CNI Flannel Plugin ，说好的 <code>flannel.1</code> 呢？既然确定了 <code>flannel.1</code> 不是 CNI Plugin 里面实现的，那肯定就是 Flannel 自己的行为了，接下来看 <code>Flannel</code> 代码就可以了。</p><h2 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h2><p>提到 Flannel，就不得不拿出这张图：</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/go/src/github.com/coreos/flannel</span><br><span class="line">master ✗ $ tree . -L 1</span><br><span class="line">├── backend # 后端实现：vxlan,udp,hostgw</span><br><span class="line">├── main.go # 入口</span><br><span class="line">├── network # IPtables 相关配置</span><br><span class="line">├── pkg     # 辅助功能，如 IP，Namespace</span><br><span class="line">├── README.md</span><br><span class="line">├── subnet  # 子网管理，K8s 通信相关</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>我们先来回想一下 K8s 集群部署，我们通过 kubeadm 指定了 Pod CIDR 为 <code>10.244.0.0/16</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line"><span class="attr">  dnsDomain:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  podSubnet:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">  serviceSubnet:</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p>然后我们直接执行 <code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code> 等待 Node Ready 即可，这样做的前提是因为我们指定的 Pod 子网是 Flannel 默认子网，两者必须相同才可以配置正确。</p><h3 id="代码入口"><a href="#代码入口" class="headerlink" title="代码入口"></a>代码入口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">sm, err := newSubnetManager()</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 从 K8s 中获取配置信息，主要是子网信息</span></span><br><span class="line">config, err := getConfig(ctx, sm)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 创建 backend manager 并创建用来创建 backend 和注册网络</span></span><br><span class="line">bm := backend.NewManager(ctx, sm, extIface)</span><br><span class="line">be, err := bm.GetBackend(config.BackendType)</span><br><span class="line">  ...</span><br><span class="line">bn, err := be.RegisterNetwork(ctx, wg, config)</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 运行 backend </span></span><br><span class="line">log.Info(<span class="string">"Running backend."</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">bn.Run(ctx)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main.go 中获取配置的来源是 ConfigMap：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@install1</span> <span class="number">11</span><span class="string">:00:39</span> <span class="string">~]$kubectl</span> <span class="string">get</span> <span class="string">cm</span> <span class="string">kube-flannel-cfg</span> <span class="bullet">-n</span> <span class="string">kube-system</span> <span class="bullet">-o</span> <span class="string">yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">cni-conf.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "name": "cbr0",</span></span><br><span class="line"><span class="string">      "cniVersion": "0.3.1",</span></span><br><span class="line"><span class="string">      "plugins": [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "type": "flannel",</span></span><br><span class="line"><span class="string">          "delegate": &#123;</span></span><br><span class="line"><span class="string">            "hairpinMode": true,</span></span><br><span class="line"><span class="string">            "isDefaultGateway": true</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "type": "portmap",</span></span><br><span class="line"><span class="string">          "capabilities": &#123;</span></span><br><span class="line"><span class="string">            "portMappings": true</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  net-conf.json: |</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "Network": "10.244.0.0/16",</span></span><br><span class="line"><span class="string">      "Backend": &#123;</span></span><br><span class="line"><span class="string">        "Type": "vxlan"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="string">"2019-12-30T02:37:21Z"</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">flannel</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">node</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kube-flannel-cfg</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"235454"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/api/v1/namespaces/kube-system/configmaps/kube-flannel-cfg</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">fd9f67ee-ee1b-411d-8403-23ab05de56c8</span></span><br></pre></td></tr></table></figure><p>可以看到默认的 Backend 是 vxlan，我们接着看 backend 和 vxlan 相关处理，在 backend/ 路径下放着些统一的接口定义，vxlan 是接口的具体实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~/go/src/github.com/coreos/flannel</span><br><span class="line">master ✗ $ tree backend -L 1</span><br><span class="line">backend</span><br><span class="line">├── common.go</span><br><span class="line">├── manager.go</span><br><span class="line">├── route_network.go</span><br><span class="line">├── route_network_test.go</span><br><span class="line">├── route_network_windows.go</span><br><span class="line">├── simple_network.go</span><br><span class="line">├── udp</span><br><span class="line">└── vxlan</span><br><span class="line">    ├── device.go</span><br><span class="line">    ├── device_windows.go</span><br><span class="line">    ├── vxlan.go</span><br><span class="line">    ├── vxlan_network.go</span><br><span class="line">    ├── vxlan_network_windows.go</span><br><span class="line">    └── vxlan_windows.go</span><br></pre></td></tr></table></figure><p>如 <code>RegisterNetwork</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Called when the backend should create or begin managing a new network</span></span><br><span class="line">RegisterNetwork(ctx context.Context, wg sync.WaitGroup, config *subnet.Config) (Network, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看 vxlan RegisterNetwork 做了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(be *VXLANBackend)</span> <span class="title">RegisterNetwork</span><span class="params">(ctx context.Context, wg sync.WaitGroup, config *subnet.Config)</span> <span class="params">(backend.Network, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 解析配置</span></span><br><span class="line">cfg := <span class="keyword">struct</span> &#123;</span><br><span class="line">VNI           <span class="keyword">int</span></span><br><span class="line">Port          <span class="keyword">int</span></span><br><span class="line">GBP           <span class="keyword">bool</span></span><br><span class="line">Learning      <span class="keyword">bool</span></span><br><span class="line">DirectRouting <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">VNI: defaultVNI,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vtep 配置信息</span></span><br><span class="line">devAttrs := vxlanDeviceAttrs&#123;</span><br><span class="line">vni:       <span class="keyword">uint32</span>(cfg.VNI),</span><br><span class="line">name:      fmt.Sprintf(<span class="string">"flannel.%v"</span>, cfg.VNI),</span><br><span class="line">vtepIndex: be.extIface.Iface.Index,</span><br><span class="line">vtepAddr:  be.extIface.IfaceAddr,</span><br><span class="line">vtepPort:  cfg.Port,</span><br><span class="line">gbp:       cfg.GBP,</span><br><span class="line">learning:  cfg.Learning,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 vtep</span></span><br><span class="line">dev, err := newVXLANDevice(&amp;devAttrs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">dev.directRouting = cfg.DirectRouting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newVXLANDevice</span><span class="params">(devAttrs *vxlanDeviceAttrs)</span> <span class="params">(*vxlanDevice, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// netlink 是 Golang 中操作网络相关的库，提供了创建 Vxlan 设备的接口</span></span><br><span class="line">link := &amp;netlink.Vxlan&#123;</span><br><span class="line">LinkAttrs: netlink.LinkAttrs&#123;</span><br><span class="line">Name: devAttrs.name,</span><br><span class="line">&#125;,</span><br><span class="line">VxlanId:      <span class="keyword">int</span>(devAttrs.vni),</span><br><span class="line">VtepDevIndex: devAttrs.vtepIndex,</span><br><span class="line">SrcAddr:      devAttrs.vtepAddr,</span><br><span class="line">Port:         devAttrs.vtepPort,</span><br><span class="line">Learning:     devAttrs.learning,</span><br><span class="line">GBP:          devAttrs.gbp,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link, err := ensureLink(link)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;vxlanDevice&#123;</span><br><span class="line">link: link,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ensureLink</span><span class="params">(vxlan *netlink.Vxlan)</span> <span class="params">(*netlink.Vxlan, error)</span></span> &#123;</span><br><span class="line">err := netlink.LinkAdd(vxlan)</span><br><span class="line"><span class="keyword">if</span> err == syscall.EEXIST &#123;</span><br><span class="line"><span class="comment">// it's ok if the device already exists as long as config is similar</span></span><br><span class="line">    log.V(<span class="number">1</span>).Infof(<span class="string">"VXLAN device already exists"</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 如果存在，则娇艳 原有设备是否兼容，如果不兼容则删除并重新创建设备</span></span><br><span class="line"><span class="keyword">if</span> err = netlink.LinkAdd(vxlan); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to create vxlan interface: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">return</span> vxlan, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们就知道了是 Flannel 在进行 backend 注册的时候创建的 <code>flannel.1</code> 设备，如果我们想要简单粗暴的去修改代码实现，我们可以在 <code>backend.Run()</code> 方法中加入 <code>ensureLink</code> 检测逻辑，保证当发现对应 vtep 设备消失时，重新创建。但是这种实现方式就比较侵入，而且破坏了 backend 通用逻辑，我理解正确的处理方式应该是通过 health 探针去检测，如果检测到 Pod 处于 unhealthy 状态，自动重建 Pod，会重新进行 <code>backend.RegisterNetwork</code> 逻辑，就不存在这个问题了。</p><p>来看下默认的 Flannel YAML 文件，发现其中并没有 health 探针配置，还是有点奇怪的，这么一个基础的服务，居然没有做任何的健康检查，听上去有些不合道理。</p><p>于是我又去 Github 上查找相关的 Issue，果然发现了很多人遇到这个问题，倒是最终都没有提出比较好的方案来解决，其中 Eduard Català 分别提交了 2 个 PR 用来增加 Health Check 机制，但是不知道因为什么最终都没有合并：</p><ul><li><a href="https://github.com/coreos/flannel/pull/917" target="_blank" rel="noopener">https://github.com/coreos/flannel/pull/917</a></li><li><a href="https://github.com/coreos/flannel/pull/920" target="_blank" rel="noopener">https://github.com/coreos/flannel/pull/920</a></li></ul><p>我们来看看他的对应实现，通过检测对应的设备是否存在，如果不存在则不健康：</p><p>backend/vxlan/vxlan.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(be *VXLANBackend)</span> <span class="title">CheckHealthz</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := net.InterfaceByName(be.extIface.Iface.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"Master interface %v disappeared. Waiting its return..."</span>, be.extIface.Iface.Name)</span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">_, err = net.InterfaceByName(be.extIface.Iface.Name)</span><br><span class="line">&#125;</span><br><span class="line">log.Errorf(<span class="string">"Master interface: %v reappeared"</span>, be.extIface.Iface.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = net.InterfaceByName(be.network.dev.link.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"Flannel interface: %v not found - Requiring flannel restart "</span>, be.network.dev.link.Name)</span><br><span class="line"><span class="keyword">return</span> backend.FlannelRestart</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flannel 社区活跃度不高，合并 PR 的速度更是慢的离谱，有很多存在很久的 Issue 也没有解决，感觉还是用着玩玩就好。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/containernetworking/plugins.git" target="_blank" rel="noopener">https://github.com/containernetworking/plugins.git</a></li><li><a href="https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/cni%20plugin/flannel%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.md" target="_blank" rel="noopener">https://github.com/Kevin-fqh/learning-k8s-source-code/blob/master/cni%20plugin/flannel%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.md</a></li><li><a href="https://cizixs.com/2016/07/16/flannel-source-code-insight/" target="_blank" rel="noopener">https://cizixs.com/2016/07/16/flannel-source-code-insight/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在用 K8s 的同学应该多少都使用过 Flannel 作为自己的网络插件，不讨论性能稳定性，在复杂的网络环境配置中 Flannel 的要求应
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>2019 年终总结</title>
    <link href="https://zdyxry.github.io/2019/12/31/2019-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://zdyxry.github.io/2019/12/31/2019-年终总结/</id>
    <published>2019-12-31T01:21:48.000Z</published>
    <updated>2019-12-29T01:56:26.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>2019 年就要结束了，今年用数据记录了很多，可以很好的支撑我做一个年终总结碎碎念。</p><h2 id="读书观影"><a href="#读书观影" class="headerlink" title="读书观影"></a>读书观影</h2><p>一整年都是两点一线：家里和公司，没有什么特别大的变化，周末的时间也都给了书和电影。</p><p>读书记录之前已经发过了，上半年看的比较多，下半年忙起来时间上少了很多，加上看的书的质量也比上半年高，所以看的比较细，用了很多时间去查相关资料。因为年后有些计划，所以集中把自己刚刚工作的时候买的纸质书（一直没看）清理了一下，愈发觉得刚工作的自己真是个愣头青，买的书都是水书，还是应该多看些经典书籍，需要更多思考的书。</p><p>电影看的多，至少豆瓣上标记的数量很吓人，周末基本上都会看几部。今年看的种类都比较阴暗，自己本意是放松一下的，看着看着心情更加沉重了。电影是另外一种了解世界的方式，我们可以看到不同的人，不同的风景，同时也会代入思考如果是自己会怎么做。在现实世界很多观点无法表述的现在，还是很有趣的。</p><p>书籍推荐：</p><ul><li>《操作系统导论》</li><li>《图解密码技术（第3版）》</li><li>《编码的奥秘》</li></ul><p>电影推荐：</p><ul><li>《平衡》</li><li>《电话亭》</li><li>《婚姻故事》</li></ul><img src="/2019/12/31/2019-年终总结/douban.png" title="Douban"><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>2019 年算是养成了 2 个好习惯：刷题和写博客。</p><p>因为自己一直习惯早起（6点钟左右），以前都是当天要做什么工作，早上起来做一些准备之类的事情，有两点不好：一是把自己的时间都给了工作，导致自己会有种抵触；二是不规律，我喜欢规律。</p><p>所以从 4 月份开始，每天早上会做一道 LeetCode 题，目前一直坚持到现在。要说刷题有带给我什么质的变化么，那显然是没有的，但是我上面提到的两点不好，在刷题这里都消失了。刷题让我去认真的学习数据结构和算法，去了解一道题的不同种解法（往往会冒出“这tm的真是个人才”的感叹），而且会让我的生活更加规律，能从工作中抽出来，强烈推荐大家去试试。像我从 Easy 开始分类的做，最开始不会花费太长时间，做不出来就看看其他人怎么做，后续就会有些自己的想法。但是最近我做 Medium 的题耗时就比之前长好多了，有些题及时看着答案也要想很久，导致我又起的更早了。。</p><img src="/2019/12/31/2019-年终总结/github.png" title="GitHub"><p>2019 年自己定了每周更新一篇博客的目标，目标完成。一开始写博客是为了记录下自己的踩坑经历和一些经验分享，随后是自己发现一些新东西的时候自己学习了解的过程。要锻炼自己对外输出的能力，保证自己能够有逻辑的输出自己的观点，哪怕不能有逻辑的说出来，至少要有逻辑的写出来。</p><img src="/2019/12/31/2019-年终总结/blog.png" title="GoogleAnalytics"><h2 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h2><p>没有买什么新玩具，也没有什么特别大的开支，当然也没有存到什么钱。</p><h3 id="真实物品"><a href="#真实物品" class="headerlink" title="真实物品"></a>真实物品</h3><p>主要的开销在吃饭和房租，年初买了一个 iPad 用来看 PDF，毕竟无论是 Kindle 还是手机都不能很好的阅读，iPad 看 PDF 的效果是很好的，我也用它来看了一些书，但是有个问题是完整在 iPad 看完的书不到 10本，也是一个 <code>买前生产力，买后bilibili</code> 的例子了。</p><h3 id="虚拟物品"><a href="#虚拟物品" class="headerlink" title="虚拟物品"></a>虚拟物品</h3><p>自己平时需要跑一些 crontab 做事情，所以有一个祖传搬瓦工一直在供着，但是今年上网格外的困难，搬瓦工 IP 被封，所以又在 Azure 上搞了一个 VPS，目前看上去这套东西运转的还算顺利。</p><p>趁着年底活动，买了 RescueTime 的会员，估计明年会买 Pocket，毕竟重度用户。</p><p>P.S. 从带给自己生活感受的提升上，VPS 性价比可太高了。</p><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><p>平时总是感觉自己时间不够用，就用了 RescueTime 记录自己的时间开销，12月份是一个比较完整的记录：家里的电脑，公司的电脑以及自己的手机。</p><img src="/2019/12/31/2019-年终总结/time.png" title="RescueTime"><p>真实情况是自己一个月在公司的时间 218 小时，真正写代码的时间 96 小时，平均下来一天有 5小时的高产出时间，跟自己预想的偏差很小，没什么意外。</p><img src="/2019/12/31/2019-年终总结/alltime.png" title="RescueTime"><p>抛开工作时间不提，手机占用了比较多的时间，而具体占用时间的大头部分在微信、Twitter 和浏览器。这部分是有很大程度优化的空间的。除了必要的社交，平时用浏览器阅读的习惯大概是这样：看到不错的文章如果不长，就在手机上看完，如果稍长或者没时间，就会收藏到 Pocket 中，等到每周五晚上再集中处理。这样会面临一个问题是我的 Pocket 有时候变成了一个收藏夹，什么东西都往里面放，而且我的很多时间也都通过 Pocket 来绑定，那些博客有读的必要么，有收藏的必要么，要仔细想想了。</p><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>都用数据记录下来的好处就是可以量化的改进：</p><ol><li>保持看书状态，把部分观影时间也用来看书，并形成读书笔记</li><li>刷题不能停，把解题思路完整的记录下来，或文字，或图片</li><li>宁可不写也不要水博客，多记录些自己平时忽略的地方</li><li>合理利用软件，不依赖软件，尝试 GTD</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019&quot;&gt;&lt;a href=&quot;#2019&quot; class=&quot;headerlink&quot; title=&quot;2019&quot;&gt;&lt;/a&gt;2019&lt;/h2&gt;&lt;p&gt;2019 年就要结束了，今年用数据记录了很多，可以很好的支撑我做一个年终总结碎碎念。&lt;/p&gt;
&lt;h2 id=&quot;读书观影&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次 libcgroup 配置失败（二）</title>
    <link href="https://zdyxry.github.io/2019/12/25/%E8%AE%B0%E4%B8%80%E6%AC%A1-libcgroup-%E9%85%8D%E7%BD%AE%E5%A4%B1%E8%B4%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zdyxry.github.io/2019/12/25/记一次-libcgroup-配置失败（二）/</id>
    <published>2019-12-25T13:49:06.000Z</published>
    <updated>2019-12-25T14:10:42.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天同事找到我，说有一台服务器上的 cgroup 没有创建出来，导致其他程序出现了问题，记录一下。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在我们的服务器上，通常会通过 libcgconfig 来进行 cgroup 的配置，供其他服务使用。结果发现对应的 cgroup 没有创建出来，于是查看 cgconfig.service 的状态，发现是异常退出的：</p><img src="/2019/12/25/记一次-libcgroup-配置失败（二）/1.png" title="img1"><p>报错信息比较重要的是这一条：</p><p><code>failed to set /sys/fs/cgroup/cpuset/zbs/cpuset.mems: Invalid argument</code>。</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><p>检查下 /etc/cgconfig.conf 中的配置是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">group . &#123;</span><br><span class="line">    cpuset &#123;</span><br><span class="line">        cpuset.memory_pressure_enabled = "1";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group zbs &#123;</span><br><span class="line">    cpu &#123;</span><br><span class="line">        cpu.rt_runtime_us = "950000";</span><br><span class="line">        cpu.rt_period_us = "1000000";</span><br><span class="line">    &#125;</span><br><span class="line">    cpuset &#123;</span><br><span class="line">        cpuset.cpus = "0,1,2,3,4,5";</span><br><span class="line">        cpuset.mems = "0-1";</span><br><span class="line">        cpuset.cpu_exclusive = "1";</span><br><span class="line">        cpuset.mem_hardwall = "1";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>配置看上去没啥问题，这里的 <code>cpuset.mems</code> 指定的是 NUMA Node ID。</p><p>那么我们就来看看 NUMA 状态，使用 <code>numactl</code> 查看节点 NUMA 信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node 21:53:25 ~]$numactl -H</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</span><br><span class="line">node 0 size: 0 MB</span><br><span class="line">node 0 free: 0 MB</span><br><span class="line">node 1 cpus: 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</span><br><span class="line">node 1 size: 32654 MB</span><br><span class="line">node 1 free: 10234 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  20</span><br><span class="line">  1:  20  10</span><br></pre></td></tr></table></figure><p>发现问题了，这个节点上有2个 CPU，但是其中的一个 CPU 上对应的节点内存出现了故障，导致 node0 对应的内存是 0MB。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>所以我们正确的姿势是将 <code>cpuset.mems</code> 从 <code>0-1</code> 改为 <code>1</code> ，然后重启 cgconfig。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node 22:09:43 ~]$systemctl status cgconfig</span><br><span class="line">● cgconfig.service - Control Group configuration service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/cgconfig.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (exited) since Fri 2019-12-20 16:41:24 CST; 5 days ago</span><br><span class="line"> Main PID: 913 (code=exited, status=0/SUCCESS)</span><br><span class="line">    Tasks: 0</span><br><span class="line">   Memory: 0B</span><br><span class="line">   CGroup: /system.slice/cgconfig.service</span><br><span class="line"></span><br><span class="line">Dec 20 16:41:24 node systemd[1]: Starting Control Group configuration service...</span><br><span class="line">Dec 20 16:41:24 node systemd[1]: Started Control Group configuration service.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前几天同事找到我，说有一台服务器上的 cgroup 没有创建出来，导致其他程序出现了问题，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;现象&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-Cluster API 升级流程</title>
    <link href="https://zdyxry.github.io/2019/12/22/Kubernetes-%E5%AE%9E%E6%88%98-Cluster-API-%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B/"/>
    <id>https://zdyxry.github.io/2019/12/22/Kubernetes-实战-Cluster-API-升级流程/</id>
    <published>2019-12-22T08:53:55.000Z</published>
    <updated>2019-12-22T08:54:32.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前已经介绍过 ClusterAPI 及相应实现方式，但是针对使用 ClusterAPI 部署的 K8s 集群社区中一直没有升级方案，其中 vmware 实现了一个简单的<a href="https://github.com/vmware/cluster-api-upgrade-tool" target="_blank" rel="noopener">升级工具</a>，可以在社区没实现之前提供使用，今天来看下这个工具是如何实现的。</p><h2 id="cluster-api-upgrade-tool"><a href="#cluster-api-upgrade-tool" class="headerlink" title="cluster-api-upgrade-tool"></a>cluster-api-upgrade-tool</h2><p>项目地址：<a href="https://github.com/vmware/cluster-api-upgrade-tool" target="_blank" rel="noopener">https://github.com/vmware/cluster-api-upgrade-tool</a></p><p>因为这只是一个单独的工具，因此代码结构比较简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">yiran@t480:~/go/src/github.com/vmware/cluster-api-upgrade-tool </span><br><span class="line">master ✔ $ tree .</span><br><span class="line">.</span><br><span class="line">├── CODE-OF-CONDUCT.md</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── hack</span><br><span class="line">│   └── tools</span><br><span class="line">│       ├── go.mod</span><br><span class="line">│       ├── go.sum</span><br><span class="line">│       └── main.go</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── main.go # 命令行入口</span><br><span class="line">├── Makefile</span><br><span class="line">├── NOTICE.txt</span><br><span class="line">├── pkg</span><br><span class="line">│   ├── internal</span><br><span class="line">│   │   └── kubernetes</span><br><span class="line">│   │       ├── client.go # 获取 client</span><br><span class="line">│   │       └── pod_exec.go</span><br><span class="line">│   ├── logging</span><br><span class="line">│   │   └── logrus_logr.go</span><br><span class="line">│   └── upgrade</span><br><span class="line">│       ├── config.go </span><br><span class="line">│       ├── control_plane.go # 主要升级逻辑</span><br><span class="line">│       └── control_plane_test.go</span><br><span class="line">├── README.md</span><br><span class="line">└── test</span><br><span class="line">    └── integration</span><br><span class="line">        ├── go.mod</span><br><span class="line">        ├── go.sum</span><br><span class="line">        └── main_test.go</span><br></pre></td></tr></table></figure><h2 id="升级流程"><a href="#升级流程" class="headerlink" title="升级流程"></a>升级流程</h2><p>首先在 main.go 封装了相应的命令行用于升级，获取到相应配置后，开始升级：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upgrader, err := upgrade.NewControlPlaneUpgrader(newLogger(), finalConfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> upgrader.Upgrade()</span><br></pre></td></tr></table></figure><p>在 control_plane.go 文件中是升级的主要逻辑，所有的步骤都是顺序执行的，摘要下主要的步骤：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade does the upgrading of the control plane.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *ControlPlaneUpgrader)</span> <span class="title">Upgrade</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">machines, err := u.listMachines()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> err := u.reconcileKubeadmConfigMapAPIEndpoints(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = u.updateKubeletConfigMapIfNeeded(u.desiredVersion)</span><br><span class="line">err = u.updateKubeletRbacIfNeeded(u.desiredVersion)</span><br><span class="line">    <span class="keyword">if</span> err := u.etcdClusterHealthCheck(<span class="number">15</span> * time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := u.UpdateProviderIDsToNodes(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> updateKubeadmKubernetesVersion(in, <span class="string">"v"</span>+u.desiredVersion.String())</span><br><span class="line"><span class="keyword">if</span> err := u.updateMachines(machines); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := u.reconcileKubeadmConfigMapAPIEndpoints(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>u.listMachines</code>获取 TargetCluster 所有的 ControlPlane 节点<br> a. 通过 label 来进行 machine 过滤<br> b. 如果 Machine 的 DeletionTimestamp 字段为 0，则追加到列表中</li><li><code>u.reconcileKubeadmConfigMapAPIEndpoints</code> 这里主要是确保对应的 APIEndpoints 节点都在 k8s 集群中，通过对比 nodeList 与 APIEndpoints 来进行过滤</li><li><code>u.updateKubeletConfigMapIfNeeded</code> 在 k8s 中，在 ConfigMap 中是有保存 kubelet 配置信息的，在升级过程中，需要重新创建对应版本的 kubelet 配置信息，这个函数中直接将原版本的 kubelet 复制了一份，创建一份目标版本的 kublet 配置 ConfigMap</li><li><code>u.updateKubeletRbacIfNeeded</code> 创建目标版本的 Role 和 RoleBinding 资源</li><li><code>u.etcdClusterHealthCheck</code> 检查 etcd 集群是否健康，这里主要通过 <code>endpoint health --endpoints</code> 来检查 etcd 是否健康</li><li><code>u.UpdateProviderIDsToNodes</code> 通过 Cluster-API 创建出来的节点，需要设置 node.ProviderID 才可以被 Cluster-API 识别为 running 状态，ProviderId 格式为：<code>vmware://xxxxx</code> ，这里根据 ProviderID 来检测出具体的 ID，并将其作为一个 map 返回</li><li><code>u.updateKubeadmKubernetesVersion</code> 将 kubeadm ConfigMap 中的  <code>kubernetesVersion</code> 字段更新为目标版本，便于后续添加节点时指定的是目标版本</li><li><code>u.updateMachines</code> 在所有配置文件已经准备、更新完成后，开始做整个升级中最重要的部分，节点（Machine）升级，首先遍历所有 Machine 资源，针对每个 Machine，进行如下动作：<br> a. <code>u.etcdClusterHealthCheck</code> 检查 etcd 集群是否健康，如果不健康，则退出升级<br> b. <code>generateReplacementMachineName</code> 生成替代 Machine 相应配置信息，如 MachineName<br> c. <code>u.updateInfrastructureReference</code> 创建替代 Machine 的 Infrastructure Object<br> d. <code>u.updateBootstrapConfig</code> 创建替代 Machine 的 Bootstrap Config，因为默认 Cluster-API 使用的 kubeadm Bootstrap，所以这里其实是生成替代 Machine 执行的 kubeadm 配置<br> e. <code>u.updateMachine</code> 真正创建替代 Machine 的步骤，创建对应的目标虚拟机，等待目标虚拟机添加到 K8s 集群中且处于 Ready 后，将原虚拟机对应 etcd 节点从 etcd 集群中移除，随后将原虚拟机对应节点从 K8s 集群中移除  </li><li><code>u.reconcileKubeadmConfigMapAPIEndpoints</code> 等待所有 Machine 替换完成后，重新配置 kubeadm ConfigMap 保证 kubeadm ConfigMap 中保存所有的 APIEndpoints 信息。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cluster-API 作为 K8s cluster-lifecycle SIG 的一个还处于 Alpha 阶段的项目，还处于一个快速更新迭代的状态，因此最终升级流程是怎样还不确定，但是从 vmware 的这个工具来看，后续很有可能采用这种方案，毕竟 Cluster-API 不想通过 SSH 这种比较麻（恶）烦（心）的方式对节点进行管理，从 kubeadm Bootstrap 使用 Cloud-init 就可以看出，尤其是当支持多种 Linux 发行版后，可以预想这是一个灾难。因此使用这种节点逐一替换的方式是很方便的，具体实现看 v1alpha3 发布之后社区的讨论结果吧。</p><p>吐槽：<br>Cluster-API 项目在代码中很少使用缩写，带来的好处很明显，易读易懂，上手容易，我自己的项目也一直秉承着这种观点，但是当我看到 <code>reconcileKubeadmConfigMapAPIEndpoints</code> 这种长度的变量名，还是很崩溃的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/vmware/cluster-api-upgrade-tool" target="_blank" rel="noopener">https://github.com/vmware/cluster-api-upgrade-tool</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前已经介绍过 ClusterAPI 及相应实现方式，但是针对使用 ClusterAPI 部署的 K8s 集群社区中一直没有升级方案，其中 
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-高可用集群部署（无LB）</title>
    <link href="https://zdyxry.github.io/2019/12/19/Kubernetes-%E5%AE%9E%E6%88%98-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%EF%BC%88%E6%97%A0LB%EF%BC%89/"/>
    <id>https://zdyxry.github.io/2019/12/19/Kubernetes-实战-高可用集群部署（无LB）/</id>
    <published>2019-12-19T13:38:16.000Z</published>
    <updated>2019-12-19T13:38:41.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前写过一篇<a href="https://zdyxry.github.io/2019/06/15/Kubernetes-%E5%AE%9E%E6%88%98-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">《Kubernetes 实战-高可用集群部署》</a> 博客讲 K8S 高可用配置，当时采用的方式是使用 keepalived 配合 HAProxy 自建 LB 的方式，但是最近发现无论是 Kubespray 还是 Rancher RKE 都没有采用这种方式，而是在 worker node 上配置 nginx/haproxy 代理 APIServer 达到目的。今天来手动配置下这种方式，了解下注意事项。</p><p>本文配置方式参考 Kubespray，主要是想加深自己对这方面的理解，如果只是单纯的想要搭建环境，那么直接使用 Kubespray 就好。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table><thead><tr><th>IP</th><th>role</th></tr></thead><tbody><tr><td>192.168.17.11</td><td>ControlPlane1</td></tr><tr><td>192.168.17.12</td><td>ControlPlane2</td></tr><tr><td>192.168.17.13</td><td>ControlPlane3</td></tr><tr><td>192.168.17.14</td><td>WorkerNode1</td></tr></tbody></table><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>这部分准备工作与之前一样，没什么不同，因此不详细说明，需要安装 kubectl,kubeadm,kubelet 。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="ControlPlane1"><a href="#ControlPlane1" class="headerlink" title="ControlPlane1"></a>ControlPlane1</h3><p>kubeadm 配置文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@install1 17:55:09 tmp]$cat kubeadm.yaml</span><br><span class="line">---</span><br><span class="line">apiServer: &#123;&#125;</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta1</span><br><span class="line">certificatesDir: ""</span><br><span class="line">clusterName: test</span><br><span class="line">controlPlaneEndpoint: "192.168.17.11:6443"</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  type: ""</span><br><span class="line">etcd: &#123;&#125;</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: ""</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: ""</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">  serviceSubnet: ""</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta1</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: "192.168.17.11"</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  name: 'install1'</span><br></pre></td></tr></table></figure><p>执行部署动作：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@install1 17:55:10 tmp]$kubeadm init --config kubeadm.yaml --upload-certs</span><br><span class="line">...</span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of the control-plane node running the following command on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 192.168.17.11:6443 --token 0xsbed.rcfk0ew0nlgrpjv0 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:1be9652019ef048fdd1d16385907c519e5559a1b786aa3ff1c46eeb489e1a6ef \</span><br><span class="line">    --control-plane --certificate-key 2368ee7ebe6697164c46812e358539638de1d7665b3111afde949bce73275029</span><br><span class="line"></span><br><span class="line">Please note that the certificate-key gives access to cluster sensitive data, keep it secret!</span><br><span class="line">As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use </span><br><span class="line">"kubeadm init phase upload-certs --upload-certs" to reload certs afterward.</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.17.11:6443 --token 0xsbed.rcfk0ew0nlgrpjv0 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:1be9652019ef048fdd1d16385907c519e5559a1b786aa3ff1c46eeb489e1a6ef</span><br></pre></td></tr></table></figure></p><h3 id="ControlPlane2"><a href="#ControlPlane2" class="headerlink" title="ControlPlane2"></a>ControlPlane2</h3><p>kubeadm 配置文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 17:40:52 tmp]$cat kubeadm.yaml</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: JoinConfiguration</span><br><span class="line">discovery:</span><br><span class="line">  bootstrapToken:</span><br><span class="line">    apiServerEndpoint: 192.168.17.11:6443</span><br><span class="line">    token: 0xsbed.rcfk0ew0nlgrpjv0</span><br><span class="line">    unsafeSkipCAVerification: true</span><br><span class="line">  timeout: 5m0s</span><br><span class="line">  tlsBootstrapToken: 0xsbed.rcfk0ew0nlgrpjv0</span><br><span class="line">controlPlane:</span><br><span class="line">  localAPIEndpoint:</span><br><span class="line">    advertiseAddress: 192.168.17.12</span><br><span class="line">    bindPort: 6443</span><br><span class="line">  certificateKey: 2368ee7ebe6697164c46812e358539638de1d7665b3111afde949bce73275029</span><br><span class="line">nodeRegistration:</span><br><span class="line">  name: installer2</span><br></pre></td></tr></table></figure><p>执行部署动作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@install2 17:40:58 tmp]$kubeadm join --config kubeadm.yaml</span><br><span class="line">...</span><br><span class="line">This node has joined the cluster and a new control plane instance was created:</span><br><span class="line"></span><br><span class="line">* Certificate signing request was sent to apiserver and approval was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line">* Control plane (master) label and taint were applied to the new node.</span><br><span class="line">* The Kubernetes control plane instances scaled up.</span><br><span class="line">* A new etcd member was added to the local/stacked etcd cluster.</span><br><span class="line"></span><br><span class="line">To start administering your cluster from this node, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">        mkdir -p $HOME/.kube</span><br><span class="line">        sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">        sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' to see this node join the cluster.</span><br></pre></td></tr></table></figure><h3 id="ControlPlane3"><a href="#ControlPlane3" class="headerlink" title="ControlPlane3"></a>ControlPlane3</h3><p>kubeadm 配置文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@install3 17:47:24 tmp]$cat kubeadm.yaml</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: JoinConfiguration</span><br><span class="line">discovery:</span><br><span class="line">  bootstrapToken:</span><br><span class="line">    apiServerEndpoint: 192.168.17.11:6443</span><br><span class="line">    token: 0xsbed.rcfk0ew0nlgrpjv0</span><br><span class="line">    unsafeSkipCAVerification: true</span><br><span class="line">  timeout: 5m0s</span><br><span class="line">  tlsBootstrapToken: 0xsbed.rcfk0ew0nlgrpjv0</span><br><span class="line">controlPlane:</span><br><span class="line">  localAPIEndpoint:</span><br><span class="line">    advertiseAddress: 192.168.17.13</span><br><span class="line">    bindPort: 6443</span><br><span class="line">  certificateKey: 2368ee7ebe6697164c46812e358539638de1d7665b3111afde949bce73275029</span><br><span class="line">nodeRegistration:</span><br><span class="line">  name: installer2</span><br></pre></td></tr></table></figure><p>执行部署动作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@install3 17:47:25 tmp]$kubeadm join --config kubeadm.yaml</span><br><span class="line">...</span><br><span class="line">This node has joined the cluster and a new control plane instance was created:</span><br><span class="line"></span><br><span class="line">* Certificate signing request was sent to apiserver and approval was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line">* Control plane (master) label and taint were applied to the new node.</span><br><span class="line">* The Kubernetes control plane instances scaled up.</span><br><span class="line">* A new etcd member was added to the local/stacked etcd cluster.</span><br><span class="line"></span><br><span class="line">To start administering your cluster from this node, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">        mkdir -p $HOME/.kube</span><br><span class="line">        sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">        sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' to see this node join the cluster.</span><br></pre></td></tr></table></figure><h3 id="node1"><a href="#node1" class="headerlink" title="node1"></a>node1</h3><p>3 个 ControlPlane 节点已经部署完成，我们可以通过 kubectl 命令获取对应的状态信息，因为没有部署 CNI，所以这里还是 NotReady 的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@install1 18:00:50 tmp]$kubectl get node -o wide</span><br><span class="line">NAME         STATUS     ROLES    AGE     VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                        CONTAINER-RUNTIME</span><br><span class="line">install1     NotReady   master   5m2s    v1.16.3   172.18.19.11    &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1062.1.2.el7.smartx.1.x86_64   docker://19.3.5</span><br><span class="line">installer2   NotReady   master   4m22s   v1.16.3   192.168.17.12   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1062.1.2.el7.smartx.1.x86_64   docker://19.3.5</span><br><span class="line">installer3   NotReady   master   3m1s    v1.16.3   192.168.17.13   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1062.1.2.el7.smartx.1.x86_64   docker://19.3.5</span><br><span class="line">[root@install1 18:00:53 tmp]$</span><br></pre></td></tr></table></figure><p>现在要来部署 worker node，当我们有可用的 LB，时，我们无需关心 APIServer 的可用性，由 LB 来决定。那么现在没有可用的 LB，我们的 worker node 想要与 k8s 进行通信，就需要每个 worker node 自身启动一个 proxy，将自己的 kubelet 连接到自己本地，然后通过 proxy 到集群中已有的 APIServer 。</p><h4 id="配置-Proxy"><a href="#配置-Proxy" class="headerlink" title="配置 Proxy"></a>配置 Proxy</h4><p>这里以 nginx 举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[root@install4 18:05:03 ~]$mkdir /etc/nginx</span><br><span class="line">[root@install4 18:06:02 ~]$chmod 700 /etc/nginx</span><br><span class="line">[root@install4 18:14:23 ~]$cat /etc/nginx/nginx.conf</span><br><span class="line">error_log stderr notice;</span><br><span class="line"></span><br><span class="line">worker_processes 2;</span><br><span class="line">worker_rlimit_nofile 130048;</span><br><span class="line">worker_shutdown_timeout 10s;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  multi_accept on;</span><br><span class="line">  use epoll;</span><br><span class="line">  worker_connections 16384;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">  upstream kube_apiserver &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.17.11:6443;</span><br><span class="line">    server 192.168.17.12:6443;</span><br><span class="line">    server 192.168.17.13:6443;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen        127.0.0.1:6443;</span><br><span class="line">    proxy_pass    kube_apiserver;</span><br><span class="line">    proxy_timeout 10m;</span><br><span class="line">    proxy_connect_timeout 1s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  aio threads;</span><br><span class="line">  aio_write on;</span><br><span class="line">  tcp_nopush on;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">  keepalive_timeout 5m;</span><br><span class="line">  keepalive_requests 100;</span><br><span class="line">  reset_timedout_connection on;</span><br><span class="line">  server_tokens off;</span><br><span class="line">  autoindex off;</span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 8081;</span><br><span class="line">    location /healthz &#123;</span><br><span class="line">      access_log off;</span><br><span class="line">      return 200;</span><br><span class="line">    &#125;</span><br><span class="line">    location /stub_status &#123;</span><br><span class="line">      stub_status on;</span><br><span class="line">      access_log off;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">[root@install4 18:18:29 manifests]$vim /etc/sysctl.conf </span><br><span class="line">[root@install4 18:18:54 manifests]$sysctl -p </span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv4.ip_local_reserved_ports = 30000-32767</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br></pre></td></tr></table></figure><h4 id="加入-K8s-集群"><a href="#加入-K8s-集群" class="headerlink" title="加入 K8s 集群"></a>加入 K8s 集群</h4><p>执行部署动作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@install4 18:31:10 tmp]$kubeadm join 192.168.17.11:6443 --token 0xsbed.rcfk0ew0nlgrpjv0 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:1be9652019ef048fdd1d16385907c519e5559a1b786aa3ff1c46eeb489e1a6ef </span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup</span><br><span class="line">/cri/</span><br><span class="line">        [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 19.03.5. Latest validated version: 18.09</span><br><span class="line">        [WARNING Hostname]: hostname "install4" could not be reached</span><br><span class="line">        [WARNING Hostname]: hostname "install4": lookup install4 on 192.168.31.215:53: no such host</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'</span><br><span class="line">[kubelet-start] Downloading configuration for the kubelet from the "kubelet-config-1.16" ConfigMap in the kube-system namespace</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><p>此时在 K8s 集群中存在 4个节点，其中 3 个是 ControlPlane 节点，1 个是 worker 节点，但是此时 worker 节点是连接的 192.168.17.11:6443 APIServer，如果 这个 APIServer 故障了，那么的 worker 节点就无法正常与集群通讯了，需要进行以下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@install4 18:37:51 kubernetes]$systemctl stop kubelet docker</span><br><span class="line">[root@install4 18:38:09 manifests]$pwd</span><br><span class="line">/etc/kubernetes/manifests</span><br><span class="line">[root@install4 18:38:12 manifests]$cat nginx-proxy.yml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-proxy</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">    k8s-app: kube-nginx</span><br><span class="line">  annotations:</span><br><span class="line">spec:</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  dnsPolicy: ClusterFirstWithHostNet</span><br><span class="line">  nodeSelector:</span><br><span class="line">    beta.kubernetes.io/os: linux</span><br><span class="line">  priorityClassName: system-node-critical</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx-proxy</span><br><span class="line">    image: docker.io/library/nginx:1.17</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 25m</span><br><span class="line">        memory: 32M</span><br><span class="line">    securityContext:</span><br><span class="line">      privileged: true</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /healthz</span><br><span class="line">        port: 8081</span><br><span class="line">    readinessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /healthz</span><br><span class="line">        port: 8081</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /etc/nginx</span><br><span class="line">      name: etc-nginx</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: etc-nginx</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /etc/nginx</span><br></pre></td></tr></table></figure><p>修改 kubelet 配置文件，将 Server 字段替换为 <code>127.0.0.1:6443</code> ，启动 kubelet 和 docker 即可。</p><h2 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h2><p>最开始我以为到这里就结束了，结果在自己测试的过程中，发现了一点问题，使用 kubeadm 部署集群，在添加 ControlPlane 的时候，会将 kubelet 所连接的 APIServer 配置为 controlPlaneEndpoint 地址，这在没有 LB 的场景下是致命的，单点故障。</p><p>所以我们需要依次的修改所有节点的 kubelet 配置，修改内容如下：</p><h3 id="ControlPlane"><a href="#ControlPlane" class="headerlink" title="ControlPlane"></a>ControlPlane</h3><p>因为所有的 ControlPlane 节点都会自己运行 APIServer，那么 kubelet 连接自身即可。</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Worker 节点因为没有 APIServer，所以我们刚刚通过配置本地的 Proxy 来达到相同的目的，这里无需再次修改。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我们的集群已经配置完成了，无论是 ControlPlane 节点故障，还是 Worker 节点故障，都不是单点的，可以起到高可用的作用。这种方式其实是没有 LB 的一种妥协，这里引用 Kubespray 关于 HA 模式的文档：</p><blockquote><p>K8s components require a loadbalancer to access the apiservers via a reverse proxy. Kubespray includes support for an nginx-based proxy that resides on each non-master Kubernetes node. This is referred to as localhost loadbalancing. It is less efficient than a dedicated load balancer because it creates extra health checks on the Kubernetes apiserver, but is more practical for scenarios where an external LB or virtual IP management is inconvenient. </p></blockquote><p>如果有 LB 肯定还是优先 LB 的，但是在没有 LB 的情况下我们如何选择，就看我们自己的场景了，如果真的是自建 Keepalived &amp; HAProxy ，那么之后的集群管理是一个很麻烦的事情，而且 Keepalived 在使用上没有那么的友好，尤其是网络环境复杂之后（我之前碰到过一次 ovs &amp; keepalived 不工作的情况）。</p><p>目前社区中关于 K8S 生命周期管理的工具越来越多，但是如果仔细看看，其实大家的做法都是大同小异。还是要自己了解一下具体的问题点在哪里，如何解决才是硬道理。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/kubernetes-sigs/kubespray" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubespray</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前写过一篇&lt;a href=&quot;https://zdyxry.github.io/2019/06/15/Kubernetes-%E5%AE%9
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://zdyxry.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>邻居发现协议（NDP）简易实现</title>
    <link href="https://zdyxry.github.io/2019/12/11/%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE%EF%BC%88NDP%EF%BC%89%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zdyxry.github.io/2019/12/11/邻居发现协议（NDP）简易实现/</id>
    <published>2019-12-11T13:29:59.000Z</published>
    <updated>2019-12-13T12:22:13.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做节点管理时，经常面临节点自动扫描，自动关联等功能，这时候需要 NDP 来帮助我们来完成，关于 NDP 的实现有几种方式，今天来聊一下这个。</p><h2 id="邻居发现协议（NDP）"><a href="#邻居发现协议（NDP）" class="headerlink" title="邻居发现协议（NDP）"></a>邻居发现协议（NDP）</h2><p>引用维基百科的介绍：</p><blockquote><p>The Neighbor Discovery Protocol (NDP, ND)[1] is a protocol in the Internet protocol suite used with Internet Protocol Version 6 (IPv6). It operates at the link layer of the Internet model (RFC 1122), and is responsible for gathering various information required for internet communication, including the configuration of local connections and the domain name servers and gateways used to communicate with more distant systems.[2]</p></blockquote><p>这里有两点需要关注：</p><ol><li>与 IPv6 一起使用</li><li>工作在数据链路层（link layer）</li></ol><h3 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h3><p>在 IPv6 中，无论我们的网络环境是否存在 DHCP Server，我们只要配置网卡启动 IPv6 选项，将网卡置为 active 状态，就能获取到对应的 IPv6 地址，这是因为 IPv6中支持 IP 自动配置，大概流程如下：</p><ol><li>根据 MAC 地址产生链路本地地址（link-local address）</li><li>发出邻居发现请求，进行重复地址检测，如果重复，则停止配置</li><li>链路本地地址生效，发送路由请求报文（RS）</li></ol><h4 id="单播地址"><a href="#单播地址" class="headerlink" title="单播地址"></a>单播地址</h4><p>单播地址中又分为三类：</p><ol><li>可聚合的全局单播地址，相当于公网 IPv4 地址</li><li>链路本地地址，相当于IPv4里面的169.254.0.0/16地址，一般自动生成</li><li>独特本地单播地址</li></ol><h4 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h4><table><thead><tr><th>IPv6 常用组播地址</th><th>IPv4 常用组播地址</th><th>组播组</th></tr></thead><tbody><tr><td>节点-本地范围</td><td>节点-本地范围</td><td>节点-本地范围</td></tr><tr><td>FF01::1</td><td>224.0.0.1</td><td>所有-节点地址</td></tr><tr><td>FF01::2</td><td>224.0.0.2</td><td>所有-路由器地址</td></tr><tr><td>链路-本地范围</td><td>链路-本地范围</td><td>链路-本地范围</td></tr><tr><td>FF02::1</td><td>224.0.0.1</td><td>所有-节点地址</td></tr><tr><td>FF02::2</td><td>224.0.0.2</td><td>所有-路由器地址</td></tr><tr><td>FF02::5</td><td>224.0.0.5</td><td>OSPF IGP</td></tr><tr><td>FF02::6</td><td>224.0.0.6</td><td>OSPF IGP DR</td></tr></tbody></table><h4 id="任播地址"><a href="#任播地址" class="headerlink" title="任播地址"></a>任播地址</h4><p>在 IPv6 中，没有广播的概念，而是使用任播代替。在任播中，网络地址与网络节点之前存在一对多的关系：每一个地址对应一群接收节点，但是在任何给定时间，只有其中之一可以接收到传送端发来的信息。</p><p>邻居发现协议 NDP 是 IPv6 协议体系中一个重要的基础协议，替代了IPv4的 ARP 和 ICMP 路由器发现，定义了使用 ICMPv6 报文实现地址解析、跟踪邻居状态、重复地址检测、路由器发现以及重定向等功能。</p><h2 id="IPv6-地址发现"><a href="#IPv6-地址发现" class="headerlink" title="IPv6 地址发现"></a>IPv6 地址发现</h2><p>因为我本人也没有完整阅读过相应 RFC 文档，在这里也不详细描述每个报文的具体格式及每个字段是什么意思了，直接看看怎么实现。</p><h3 id="ping6-amp-组播"><a href="#ping6-amp-组播" class="headerlink" title="ping6 &amp; 组播"></a>ping6 &amp; 组播</h3><p>如果我们知道了一个主机的 IPv6 地址，我们可以通过 <code>ping6</code> 来检测是否联通：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/nnn</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ping6 fe80::5054:ff:fe80:95d9%eth0</span></span><br><span class="line">PING fe80::5054:ff:fe80:95d9%eth0(fe80::5054:ff:fe80:95d9%eth0) 56 data bytes</span><br><span class="line">64 bytes from fe80::5054:ff:fe80:95d9%eth0: icmp_seq=1 ttl=64 time=0.045 ms</span><br><span class="line">64 bytes from fe80::5054:ff:fe80:95d9%eth0: icmp_seq=2 ttl=64 time=0.055 ms</span><br><span class="line">^C</span><br><span class="line">--- fe80::5054:ff:fe80:95d9%eth0 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.045/0.050/0.055/0.005 ms</span><br></pre></td></tr></table></figure><p>那么有了这个 <code>ping6</code> 命令和上面提到的组播地址，我们就可以通过 <code>ping6</code> 直接 ping 组播地址就能知道那些地址可以联通了，那么应该选择哪个？应该选择 <code>FF01::1</code> ，因为我们想要实现的是获取 IPv6 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/nnn</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ping6 -c1 -I eth0 <span class="string">'ff02::1%eth0'</span></span></span><br><span class="line">PING ff02::1%eth0(ff02::1%eth0) from fe80::5054:ff:fe80:95d9%eth0 eth0: 56 data bytes</span><br><span class="line">64 bytes from fe80::5054:ff:fe80:95d9%eth0: icmp_seq=1 ttl=64 time=0.045 ms</span><br><span class="line"></span><br><span class="line">--- ff02::1%eth0 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.045/0.045/0.045/0.000 ms</span><br></pre></td></tr></table></figure><p>因为我的实验环境里节点太多，这里使用 <code>-c</code> 参数限制发送 ECHO_REQUEST 包的数量为 1。</p><p>在发送组播之后，如果能够联通，那么系统会记录对应的 ARP 信息，我们可以通过 <code>ip</code> 命令直接获取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/nnn</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ip -6 neighbor show dev eth0 | head -n 5</span></span><br><span class="line">fe80::8c6e:a0ff:fe19:f146 lladdr 8e:6e:a0:19:f1:46 DELAY</span><br><span class="line">fe80::8010:f1ff:fe02:af40 lladdr 82:10:f1:02:af:40 DELAY</span><br><span class="line">fe80::baca:3aff:feec:fdac lladdr b8:ca:3a:ec:fd:ac DELAY</span><br><span class="line">fe80::f11c:e35a:912:dbc9 lladdr 52:54:00:0a:b3:fc DELAY</span><br><span class="line">fe80::570d:aa51:dc3b:1f02 lladdr 00:50:56:9b:f6:6c DELAY</span><br></pre></td></tr></table></figure><p>这样就拿到了自己节点在二层联通的所有 IPv6 地址了。</p><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><p>既然已经使用了 <code>ping6</code>，那么可以使用一些更高级的工具，比如 Nmap，Nmap可以检测目标主机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。 它通常用来评估网络系统安全。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/nnn</span><br><span class="line"><span class="meta"> $</span><span class="bash"> nmap -6 <span class="string">"--script=targets-ipv6-multicast-*"</span> | head -n 10</span></span><br><span class="line"></span><br><span class="line">Starting Nmap 6.40 ( http://nmap.org ) at 2019-12-12 07:22 CST</span><br><span class="line">Pre-scan script results:</span><br><span class="line">| targets-ipv6-multicast-echo:</span><br><span class="line">|   IP: fe80::e4a5:4fff:fea7:79af  MAC: e6:a5:4f:a7:79:af  IFACE: eth0</span><br><span class="line">|   IP: fe80::250:56ff:fe85:647e   MAC: 00:50:56:85:64:7e  IFACE: eth0</span><br><span class="line">|   IP: fe80::250:56ff:fe9e:2473   MAC: 00:50:56:9e:24:73  IFACE: eth0</span><br><span class="line">|   IP: fe80::ae53:a418:ca0:83e8   MAC: 00:50:56:9f:43:ca  IFACE: eth0</span><br><span class="line">|   IP: fe80::250:56ff:fe9e:bcb6   MAC: 00:50:56:9e:bc:b6  IFACE: eth0</span><br><span class="line">|   IP: fe80::250:56ff:fe9f:6153   MAC: 00:50:56:9f:61:53  IFACE: eth0</span><br><span class="line">WARNING: No targets were specified, so 0 hosts scanned.</span><br></pre></td></tr></table></figure><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>往往我们的需求不只是获取到 IP 这么简单，我们现在更进一步，我们要求扫描的结果中与我们预期的版本相同，那么此时就需要与对应节点进行通信了。</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>一个比较简单的实现，就是在目标节点开机的时候自动启动一个 API server，提供一个 Entrypoint，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/api/v1/version')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">version</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">"version"</span>:<span class="string">"v1.0.0"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'::'</span>, port=<span class="number">5000</span>, debug=<span class="keyword">True</span>) <span class="comment"># 要兼容 IPv6</span></span><br></pre></td></tr></table></figure><p>然后我们可以在得到 IPv6 地址后，通过 curl 或者 Python urllib2 来发送对应的请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/nnn</span><br><span class="line"><span class="meta"> $</span><span class="bash"> curl -g -6 <span class="string">'http://fe80::5054:ff:fe80:95d9%eth0:5000/api/v1/version'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "version": "v1.0.0"</span><br><span class="line">&#125;#</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = urllib2.urlopen(<span class="string">"http://fe80::5054:ff:fe80:95d9%eth0:5000/api/v1/version"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.read()</span><br><span class="line"><span class="string">'&#123;\n  "version": "v1.0.0"\n&#125;'</span></span><br></pre></td></tr></table></figure><p>这样虽然可以达到我们想要的效果，但是效率太低了，要先后进行2次操作，一次是扫描对应的 IPv6 地址，一次是得到地址后进行 HTTP 请求。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>我们可以通过 socket 通信来达到类似的效果，与 HTTP 不同的是，我们可以直接使用 socket 发送组播，来进行消息传递，这样上面的两步就可以通过一步来解决了，这里给出对应的 server 和 client 代码示例：</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)</span><br><span class="line">        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        s.bind((<span class="string">''</span>, <span class="number">30000</span>))</span><br><span class="line">        s.setblocking(<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            rlist, _, _ = select.select([s], [], [s], <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> rlist:</span><br><span class="line">                string, address = s.recvfrom(<span class="number">20000</span>)</span><br><span class="line">                <span class="keyword">print</span> string, address</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    data = json.loads(string)</span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                owner = data.get(<span class="string">"owner"</span>)</span><br><span class="line">                <span class="keyword">if</span> owner == <span class="string">"yiran"</span>:</span><br><span class="line">                    info = &#123;<span class="string">"version"</span>: <span class="string">"v1.0"</span>,</span><br><span class="line">                            <span class="string">"owner"</span>: <span class="string">"yiran"</span>,</span><br><span class="line">                            <span class="string">"nic"</span>: address[<span class="number">0</span>].split(<span class="string">"%"</span>, <span class="number">1</span>)[<span class="number">1</span>]&#125;</span><br><span class="line">                    s.sendto(json.dumps(info), address)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    server()</span><br></pre></td></tr></table></figure><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    s= socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, <span class="number">5000000</span>)</span><br><span class="line">    nics = socket.getaddrinfo(<span class="string">"%s%%%s"</span> % (<span class="string">'ff02::1'</span>, <span class="string">'eth0'</span>), <span class="number">30000</span>, socket.AF_INET6, socket.SOCK_DGRAM)</span><br><span class="line">    data = &#123;<span class="string">"owner"</span>: <span class="string">"yiran"</span>&#125;</span><br><span class="line">    string = json.dumps(data)</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> nic <span class="keyword">in</span> nics:</span><br><span class="line">            _, _, _, _, address = nic</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                s.sendto(string, address)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        rlist, _, _ = select.select([s], [], [s], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> rlist:</span><br><span class="line">            json_string, address = s.recvfrom(<span class="number">10000</span>)</span><br><span class="line">            results[address] = json_string</span><br><span class="line"></span><br><span class="line">    s.close()</span><br><span class="line">    ips = []</span><br><span class="line">    <span class="keyword">for</span> address, json_test <span class="keyword">in</span> results.iteritems():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = json.loads(json_test)</span><br><span class="line">            <span class="keyword">if</span> data.get(<span class="string">"version"</span>, <span class="keyword">None</span>) == <span class="string">"v1.0"</span>:</span><br><span class="line">                info = &#123;&#125;</span><br><span class="line">                info[<span class="string">'ipv6_address'</span>] = address[<span class="number">0</span>]</span><br><span class="line">                info[<span class="string">'test'</span>] = data</span><br><span class="line"></span><br><span class="line">                ips.append(info)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ips</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pprint(client())</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruijie.com.cn/fa/xw-hlw/83116/" target="_blank" rel="noopener">http://www.ruijie.com.cn/fa/xw-hlw/83116/</a></li><li><a href="https://tools.ietf.org/html/rfc4861" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc4861</a></li><li><a href="https://security.stackexchange.com/questions/12826/which-tool-apart-from-nmap-can-i-use-to-scan-a-range-of-ipv6-addresses" target="_blank" rel="noopener">https://security.stackexchange.com/questions/12826/which-tool-apart-from-nmap-can-i-use-to-scan-a-range-of-ipv6-addresses</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在做节点管理时，经常面临节点自动扫描，自动关联等功能，这时候需要 NDP 来帮助我们来完成，关于 NDP 的实现有几种方式，今天来聊一下这个
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
      <category term="Network" scheme="https://zdyxry.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>2019年读书记录</title>
    <link href="https://zdyxry.github.io/2019/12/09/2019%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2019/12/09/2019年读书记录/</id>
    <published>2019-12-09T12:07:34.000Z</published>
    <updated>2019-12-13T12:23:56.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><ul><li><a href="https://zdyxry.github.io/2016/12/31/2016%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2016</a><ul><li>计划读 5 本，实际读 13 本。</li></ul></li><li><a href="https://zdyxry.github.io/2017/12/31/2017%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2017</a><ul><li>计划 32 本，实际读完 23 本。</li></ul></li><li><a href="https://zdyxry.github.io/2018/12/30/2018%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2018</a><ul><li>计划 30 本，实际25本。</li></ul></li><li>2019<ul><li>计划 30 本，实际 43 本。</li></ul></li></ul><p>今年是第 4 年写读书记录了，感觉手上这本 TLPI 年底之前是看不完了，就总结一下。与之前不同的是今年把周末的时间利用的比较好，通常周末两天会拿出一整天的时间来看书，保证自己的精力集中，效率会高很多。</p><p>因为博客集成了豆瓣，所以就不列出 <code>在读</code> 和 <code>想读</code> 列表了，想的太多，耽误事。希望接下来读一些经典的技术书，把自己的基础知识补齐。</p><h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ol><li>《用Python写网络爬虫》  </li><li>《Wireshark网络分析就这么简单》  </li><li>《如何有效阅读一本书 : 超实用笔记读书法》</li><li>《冷场》  </li><li>《Go程序设计语言》  </li><li>《爱你就像爱生命》  </li><li>《Go by Example》</li><li>《显微镜下的大明》</li><li>《流浪地球》</li><li>《情感勒索》</li><li>《Go语言实战》</li><li>《活着》</li><li>《悉达多》</li><li>《Go in Practice》</li><li>《奈飞文化手册》  </li><li>《刻意练习》  </li><li>《软件测试的艺术》  </li><li>《Redis实战》  </li><li>《雪崩》  </li><li>《TCP/IP详解 卷1：协议》</li><li>《Structure and Interpretation of Computer Programs - 2nd Edition (MIT)》</li><li>《编码的奥秘》</li><li>《Kubernetes in Action》</li><li>《计算机组成：结构化方法》</li><li>《人月神话》</li><li>《自己动手写Docker》</li><li>《好文案一句话就够了》</li><li>《跟老男孩学Linux运维：Web集群实战》</li><li>《计算机组成与设计》</li><li>《简约至上》</li><li>《Go Web编程》</li><li>《大话数据结构》</li><li>《Python Web开发实战》</li><li>《Programming Kubernetes》</li><li>《Istio入门与实战》</li><li>《刷新》</li><li>《奇特的一生》</li><li>《图解密码技术（第3版）》</li><li>《细节》</li><li>《生活大爆炸里的科学》</li><li>《操作系统导论》</li><li>《RESTful Web APIs中文版》</li><li>《正则表达式必知必会》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zdyxry.github.io/2016/12/31/2016%E5%B9%
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>SSH known_hosts 显示 IP 地址</title>
    <link href="https://zdyxry.github.io/2019/12/06/SSH-known-hosts-%E6%98%BE%E7%A4%BA-IP-%E5%9C%B0%E5%9D%80/"/>
    <id>https://zdyxry.github.io/2019/12/06/SSH-known-hosts-显示-IP-地址/</id>
    <published>2019-12-06T13:54:25.000Z</published>
    <updated>2019-12-06T15:11:12.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>工作上使用的电脑因为各种各样的原因，被我安装为 Ubuntu 19.04，平时使用上没什么问题，但是最近发现它默认的 SSH 配置随着版本升级发生了变化，known_hosts 文件中记录的不再是 IP 地址，而是一串字符，这导致了当我想要删除某个主机的 key 时，无法准确的找到，因此想办法解决这个事情。</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>我们使用 Linux 系统的一个最基本的服务应该就是 SSH 了，除了偶尔我们通过 VNC 或者 KVM(Keyboard Virtual Manager)连接控制主机外，都是通过 SSH 到 Linux 主机上进行某些操作。那么 SSH 就是 Secure Shell，安全外壳协议。可在不安全的网络中为网络服务提供安全的传输环境。SSH 通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。</p><p>SSH 最重要的就是安全，采用的是非对称加密，关于加密相关的部分，可以看我之前写的一篇<a href="https://zdyxry.github.io/2019/09/14/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《图解密码技术》读书笔记</a> 里面有比较完整的相关知识。</p><p>这里主要说一下使用密码登陆和密钥登陆的流程。</p><h3 id="密码登陆"><a href="#密码登陆" class="headerlink" title="密码登陆"></a>密码登陆</h3><ol><li>客户端向服务端发起连接请求</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@test-hostname-ubuntu-s-1804:~# ssh 192.168.67.90</span><br><span class="line">The authenticity of host '192.168.67.90 (192.168.67.90)' can't be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:ca9Zk/7pR4f6rrNP3wi1WK+CQMtG4Ka+kkouwQYU0nY.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><ol start="2"><li>客户端会提示，知道服务端的唯一标示，确认连接么</li><li>确认连接，输入 yes</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@test-hostname-ubuntu-s-1804:~# ssh 192.168.67.90</span><br><span class="line">The authenticity of host '192.168.67.90 (192.168.67.90)' can't be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:ca9Zk/7pR4f6rrNP3wi1WK+CQMtG4Ka+kkouwQYU0nY.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added '192.168.67.90' (ECDSA) to the list of known hosts.</span><br><span class="line">root@192.168.67.90's password:</span><br></pre></td></tr></table></figure><ol start="4"><li>服务端传输公钥给客户端，客户端输入密码，使用服务端公钥加密并发送给服务端</li><li>服务端使用私钥解密，验证密码正确，登陆成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@test-hostname-ubuntu-s-1804:~# ssh 192.168.67.90</span><br><span class="line">The authenticity of host '192.168.67.90 (192.168.67.90)' can't be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:ca9Zk/7pR4f6rrNP3wi1WK+CQMtG4Ka+kkouwQYU0nY.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added '192.168.67.90' (ECDSA) to the list of known hosts.</span><br><span class="line">root@192.168.67.90's password:</span><br><span class="line">Last login: Fri Dec  6 21:51:00 2019 from 192.168.73.54</span><br><span class="line">[root@node90 22:30:29 ~]$</span><br></pre></td></tr></table></figure><h3 id="密钥登陆"><a href="#密钥登陆" class="headerlink" title="密钥登陆"></a>密钥登陆</h3><ol><li>客户端向服务端发起连接请求</li><li>服务端收到客户端的请求，找到对应客户端的公钥，生成随机数</li><li>服务端使用客户端的公钥对随机数进行加密，发送给客户端</li><li>客户端使用私钥进行解密，得到随机数，并将随机数与 session key 拼接，并将结果通过 MD5 算出散列值</li><li>服务端同样使用随机数与 session key 拼接，并将结果通过 MD5 算出散列值</li><li>服务端对两个散列值进行校验，如果想通，则登陆成功</li></ol><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><h3 id="ssh-id-rsa"><a href="#ssh-id-rsa" class="headerlink" title="~/.ssh/id_rsa"></a>~/.ssh/id_rsa</h3><p>当前节点生成的私钥，使用 RSA 算法。</p><h3 id="ssh-id-rsa-pub"><a href="#ssh-id-rsa-pub" class="headerlink" title="~/.ssh/id_rsa.pub"></a>~/.ssh/id_rsa.pub</h3><p>当前节点生成的公钥，使用 RSA 算法，与 id_rsa 成对出现。</p><h3 id="ssh-authorized-keys"><a href="#ssh-authorized-keys" class="headerlink" title="~/.ssh/authorized_keys"></a>~/.ssh/authorized_keys</h3><p>用于保存已经授权（信任）的客户端公钥。</p><h3 id="ssh-known-hosts"><a href="#ssh-known-hosts" class="headerlink" title="~/.ssh/known_hosts"></a>~/.ssh/known_hosts</h3><p>known_hosts 中存放 SSH 自动维护并检查的一个数据库，该数据库包含曾经连接过的所有主机的标识。</p><p>这个文件也是今天的主角。</p><h2 id="known-hosts"><a href="#known-hosts" class="headerlink" title="known_hosts"></a>known_hosts</h2><p>当我们客户端尝试连接服务端，会有一条提示，服务端主机的唯一标示是xxx，确认连接么，如果输入yes，那么这个主机的标示就会记录到 known_hosts，一般我们的 known_hosts 会长这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@test-hostname-ubuntu-s-1804:~# cat .ssh/known_hosts</span><br><span class="line">|1|+YgY28AEikbKxdosHK1Cxb6zJqs=|yEi41f2MIl6hU9uQOvXyzK0hByM= ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHJscGQ4nUV7b7+nUtHVFPgm38JrUJwMapVqkq+oF1RR7mniCGhrkIGpb2cqKINrcZFyKFRqWhuAgYtMyFALOrM=</span><br></pre></td></tr></table></figure><p>或者长这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:~</span><br><span class="line">   head -n 1 .ssh/known_hosts</span><br><span class="line">192.168.70.250 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHNWt8CDe7sPvATsqx5zH5v9wJzYrFhu9fmYnshIYLEnuoXmCmVu2cGU8s/IjK2jU8hnFad4T1gMhst7cXLmqAo=</span><br></pre></td></tr></table></figure><p>了解 https 相关知识的同学应该知道，证书的重要性。在 SSH 场景下，我们没有证书，那么就需要我们自己人为的确保我们要连接的服务端是可信的。如果我们第一次登陆 192.168.1.1 后，系统保存了主机唯一标示到了 ~/.ssh/known_hosts，如果我们下一次登陆 192.168.1.1 客户端发现主机唯一标示产生了变化，那么就会禁止我们登陆了。</p><p>在工作中经常遇到这种场景，可能的原因有很多：系统重装、快照回滚、IP 冲突等等。通常我们的做法就是闭着眼睛删除 known_hosts 里面的对应主机信息，然后重新登陆就可以了。</p><p>但是最近发现 Ubuntu 19.04 中记录的 known_hosts 是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@test-hostname-ubuntu-s-1804:~# cat .ssh/known_hosts</span><br><span class="line">|1|+YgY28AEikbKxdosHK1Cxb6zJqs=|yEi41f2MIl6hU9uQOvXyzK0hByM= ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHJscGQ4nUV7b7+nUtHVFPgm38JrUJwMapVqkq+oF1RR7mniCGhrkIGpb2cqKINrcZFyKFRqWhuAgYtMyFALOrM=</span><br></pre></td></tr></table></figure><p>是的，我们无法在一堆看似乱码中找到我们想要的主机并删掉它，这其实是 OpenSSH 新版本中的一项安全改进。</p><p>在 <a href="https://zdyxry.github.io/2019/10/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%B3%BB%E7%BB%9F%E8%A2%AB%E5%85%A5%E4%BE%B5%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/">记一次系统被入侵分析过程</a> 博客中有提到，现在好多病毒在入侵之后都是通过 SSH 相关信息进行横向扩散的，所以我们应该尽可能的少在系统中保存明文的 IP 地址相关信息。</p><p>但是对我测试环境来说，是没什么关系的，因此我需要禁止这个安全配置，来达到我的目的。</p><p>正确的姿势是修改 SSH 客户端的配置，将 <code>HashKnownHosts</code> 置为 no ，清空 known_hosts 文件，再连接服务端，就可以看到 known_hosts 已经显示 IP 地址了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@test-hostname-ubuntu-s-1804:~# cat /etc/ssh/ssh_config |grep -i hash</span><br><span class="line">    HashKnownHosts no</span><br><span class="line">root@test-hostname-ubuntu-s-1804:~# cat .ssh/known_hosts</span><br><span class="line">192.168.67.90 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHJscGQ4nUV7b7+nUtHVFPgm38JrUJwMapVqkq+oF1RR7mniCGhrkIGpb2cqKINrcZFyKFRqWhuAgYtMyFALOrM=</span><br></pre></td></tr></table></figure><p>当然如果你想搞破坏，可以尝试下这篇<a href="https://blog.rootshell.be/2010/11/03/bruteforcing-ssh-known_hosts-files/" target="_blank" rel="noopener">博客</a>中提供的脚本：<a href="https://blog.rootshell.be/wp-content/uploads/2010/11/known_hosts_bruteforcer.pl.txt" target="_blank" rel="noopener">https://blog.rootshell.be/wp-content/uploads/2010/11/known_hosts_bruteforcer.pl.txt</a> （谨慎使用）</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Secure_Shell</a></li><li><a href="https://blog.rootshell.be/2010/11/03/bruteforcing-ssh-known_hosts-files/" target="_blank" rel="noopener">https://blog.rootshell.be/2010/11/03/bruteforcing-ssh-known_hosts-files/</a></li><li><a href="https://unix.stackexchange.com/questions/31549/is-it-possible-to-find-out-the-hosts-in-the-known-hosts-file" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/31549/is-it-possible-to-find-out-the-hosts-in-the-known-hosts-file</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;工作上使用的电脑因为各种各样的原因，被我安装为 Ubuntu 19.04，平时使用上没什么问题，但是最近发现它默认的 SSH 配置随着版本升
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 引导那些事儿</title>
    <link href="https://zdyxry.github.io/2019/12/01/Linux-%E5%BC%95%E5%AF%BC%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>https://zdyxry.github.io/2019/12/01/Linux-引导那些事儿/</id>
    <published>2019-11-30T16:32:26.000Z</published>
    <updated>2019-11-30T16:32:49.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在平时工作中我自己可能80% 的时间都在使用 Linux 进行工作，无论是软件开发还是环境维护，那么对于 Linux 发行版自然也是有比较熟悉的，比如 RHEL 系列。平时大家可能多多少少都会听到或接触到一些命令（术语），比如：grub,chroot,isolinux,bios 等等。今天打算就用 CentOS 发行版的 ISO 来谈谈自己对于 Linux 系统引导，安装，启动的理解。</p><p>CentOS ISO 目录树如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── CentOS_BuildTag</span><br><span class="line">├── EFI</span><br><span class="line">├── EULA</span><br><span class="line">├── GPL</span><br><span class="line">├── images</span><br><span class="line">├── isolinux</span><br><span class="line">├── LiveOS</span><br><span class="line">├── Packages</span><br><span class="line">├── repodata</span><br><span class="line">├── RPM-GPG-KEY-CentOS-7</span><br><span class="line">├── RPM-GPG-KEY-CentOS-Testing-7</span><br><span class="line">└── TRANS.TBL</span><br></pre></td></tr></table></figure><h2 id="isolinux"><a href="#isolinux" class="headerlink" title="isolinux"></a>isolinux</h2><h3 id="ISO-9660"><a href="#ISO-9660" class="headerlink" title="ISO 9660"></a>ISO 9660</h3><p>ISO 9660 是一种文件系统，也是一种规范，它规定了 ISO 文件应该是什么样子，常见的 Linux 发行版 ISO 都符合该规范。</p><h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><p>有了 ISO，有了计算机，那么我们需要使用 ISO 安装想要的操作系统，通常我们会将 ISO 通过光盘/USB/网络等方式挂载到计算机上，通过设置 BIOS/UEFI 选项，将启动项设置为 ISO，然后启动进行安装。接下来一个一个来说。</p><p>BIOS/UEFI 通常存放在闪存中，在计算机开机自检完成后，加载引导程序（bootloader），这个初始化过程称为引导。BIOS/UEFI 通常允许用户设置加载选项，即从系统的众多设备中按照顺序进行加载，常见的比如：硬盘、光盘、网络、USB 等。当第一个设备加载失败后，会尝试第二个设备，以此类推，如果最终所有设备都无法加载，那么系统处于开机但未引导状态。</p><h4 id="磁盘引导"><a href="#磁盘引导" class="headerlink" title="磁盘引导"></a>磁盘引导</h4><p>如果从硬盘引导，那么计算机首先会读取 MBR（主引导记录 or 主引导扇区），MBR 在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。有时也将其开头的 446 字节内容特指为“主引导记录”（MBR），其后是4个16字节的“磁盘分区表”（DPT），以及2字节的结束标志（55AA）。</p><p>也就是说，如果我们的磁盘是一个包含 MBR 的磁盘，那么它的 446 字节到 446 + 16 * 4 = 510 字节部分是引导记录，而 510 字节地址记录的应该是 <code>55AA</code> 这个结束标志，我们来找个磁盘看下是否是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> dd <span class="keyword">if</span>=/dev/vda of=a bs=512 count=1</span></span><br><span class="line">记录了1+0 的读入</span><br><span class="line">记录了1+0 的写出</span><br><span class="line">512字节(512 B)已复制，0.000403482 秒，1.3 MB/秒</span><br><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> hexdump a</span></span><br><span class="line">0000000 63eb 1090 d08e 00bc b8b0 0000 d88e c08e</span><br><span class="line">...</span><br><span class="line">00001f0 0000 0000 0000 0000 0000 0000 0000 aa55</span><br><span class="line">0000200</span><br></pre></td></tr></table></figure><p>在确认了磁盘可引导之后，BIOS 将 MBR 中的 446 字节内容复制到内存中，并将控制权转给引导设备（即磁盘），之后根据 MBR 中的引导程序（bootloader）进行后续工作。这里 UEFI 与 BIOS 略有不同，UEFI 是通过查找磁盘上 FAT 分区中加载 EFI loader 来进行引导，可以说 UEFI 是基于文件系统的。</p><p>到这里，我们已经进行了引导的第一步，也是最关键的一步，那么现在运行的 bootloader 是什么呢？Linux 常见的有两种：LILO 全称 LInux LOader，是一种 Linux 引导程序，它自身很简单，甚至说简陋，目前使用场景很少。GRUB 全称 GNU GRUB，是一种引导程序，它允许启动不同的操作系统或者不同的内核，目前大多数 Linux 发行版均采用 GRUB 作为引导程序。</p><p>当引导程序为 GRUB 时，因为 MBR 大小有限，因此存放在 MBR 中的内容是 boot.img，作用是加载真正的 GRUB core.img，GRUB 运行后，会根据 grub.cfg 选项来加载真正的内核映像，并进入到 OS 启动阶段。</p><p>GRUB 加载的文件有两个：vmlinuz 和 initrd.img 。</p><p>vmlinuz(vmlinux)，压缩后可引导的 Linux kernel 内核映像，VM 代表 Virtual Memory，通常是 bzImage 格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/boot</span><br><span class="line"><span class="meta"> $</span><span class="bash"> file vmlinuz-3.10.0-693.11.6.el7.x86_64</span></span><br><span class="line">vmlinuz-3.10.0-693.11.6.el7.x86_64: Linux kernel x86 boot executable bzImage, version 3.10.0-693.11.6.el7.x86_64 (builder@kbuilder.dev.centos.org) #1, RO-rootFS, swap_dev 0x5, Normal VGA</span><br></pre></td></tr></table></figure><p>initramfs.img（init ramdisk.img），有了可引导的内核映像还不够，因为我们不能确保我们的硬件设备是 kernel 可以直接识别的，往往需要加载一些启动来保证硬件的识别，这时候就需要 initramfs.img 来提供一个临时文件系统，运行在内存中。</p><p>有时候我们也会看到 initrd.img 文件，initrd 是 initramfs 出现之前的方式，因为它内部有文件系统，运行在内存中造成了一定的空间浪费，而 initramfs 是 tmpfs，在使用上更方便。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/boot</span><br><span class="line"><span class="meta"> $</span><span class="bash"> file initrd-plymouth.img</span></span><br><span class="line">initrd-plymouth.img: gzip compressed data, from Unix, last modified: Wed Mar 28 13:41:54 2018, max compression</span><br><span class="line">root@yiran-30-250:/boot</span><br><span class="line"><span class="meta"> $</span><span class="bash"> file initramfs-3.10.0-693.11.6.el7.x86_64.img</span></span><br><span class="line">initramfs-3.10.0-693.11.6.el7.x86_64.img: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure><p>到这里已经比较清楚了，接下来就是挂载相应配置的文件系统，执行 systemd（pid 为1）的进程，这里不再详细描述。</p><h4 id="光盘引导"><a href="#光盘引导" class="headerlink" title="光盘引导"></a>光盘引导</h4><p>在介绍了常规的磁盘引导后，我们来看看光盘引导的流程。</p><p>根据 El-Torito 规范，BIOS 会读取 ISO 的准确地址进行判断，ISO 是否可以进行引导启动（在第 71 字节地址保存引导目录）。如果判断可引导，那么就加载对应的引导程序（bootloader）。</p><p>常见的引导程序有：SYSLINUX,ISOLINUX,PXELINUX,EXTLINUX 等，这些可以统称为 Syslinux，目前最常见的应该是 ISOLINUX。PXELINUX 用于从网络引导，EXTLINUX 用于 ext 系列文件系统引导。</p><p>注意：由于目前 UEFI 的普遍性，部分 LiveCD ISO 会同时带有 ISOLINUX 和 GRUB 两种引导程序。</p><p>我们来看看 ISO 中 isolinux 路径下放了什么文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> $</span><span class="bash"> tree </span></span><br><span class="line">├── boot.cat # 启动目录</span><br><span class="line">├── boot.msg # 启动信息</span><br><span class="line">├── grub.conf # GRUB 配置文件</span><br><span class="line">├── initrd.img # 临时文件系统</span><br><span class="line">├── isolinux.bin # ISOLINUX 引导程序</span><br><span class="line">├── isolinux.cfg # ISOLINUX 引导配置文件</span><br><span class="line">├── memtest # 内存测试可执行文件</span><br><span class="line">├── splash.png # ISOLINUX 引导背景图片</span><br><span class="line">├── TRANS.TBL # 扩展文件名</span><br><span class="line">├── vesamenu.c32 # Menu 配置</span><br><span class="line">└── vmlinuz # 内核映像</span><br></pre></td></tr></table></figure><p>根据以上文件信息及用途描述，我们来看下光盘引导的大概流程：</p><ol><li>加载 isolinux.bin</li><li>加载 isolinux.cfg,vesamenu.c32,splash.png 生成启动菜单</li><li>根据选项决定是否加载 vmlinuz, initrd.img </li></ol><p>关于 isolinux 目录和 Linux 引导部分大概是这样，主要是要理清楚整个流程。</p><h2 id="EFI"><a href="#EFI" class="headerlink" title="EFI"></a>EFI</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> $</span><span class="bash"> tree </span></span><br><span class="line">.</span><br><span class="line">├── BOOT</span><br><span class="line">│   ├── BOOTIA32.EFI  # 32位系统 EFI 启动程序</span><br><span class="line">│   ├── BOOTX64.EFI # 64位系统 EFI 启动程序</span><br><span class="line">│   ├── fonts # 字体</span><br><span class="line">│   │   ├── TRANS.TBL</span><br><span class="line">│   │   └── unicode.pf2</span><br><span class="line">│   ├── grub.cfg # GRUB 配置</span><br><span class="line">│   ├── grubia32.efi # GRUB 32位引导程序</span><br><span class="line">│   ├── grubx64.efi # GRUB 64位引导程序</span><br><span class="line">│   ├── mmia32.efi # 内存测试 32 位执行程序</span><br><span class="line">│   ├── mmx64.efi # 内存测试 64 位执行程序</span><br><span class="line">│   └── TRANS.TBL</span><br><span class="line">└── TRANS.TBL</span><br></pre></td></tr></table></figure><p>有了前面 isolinux 关于引导部分的介绍，这里 EFI 完全可以一一对应，如果计算器启动模式为 BIOS，那么是通过 ISOLINUX 引导，如果启动模式是 UEFI，那么是通过 EFI（GRUB）引导。</p><h2 id="images"><a href="#images" class="headerlink" title="images"></a>images</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> $</span><span class="bash"> tree </span></span><br><span class="line">├── efiboot.img</span><br><span class="line">├── pxeboot</span><br><span class="line">│   ├── initrd.img</span><br><span class="line">│   ├── TRANS.TBL</span><br><span class="line">│   └── vmlinuz</span><br><span class="line">└── TRANS.TBL</span><br></pre></td></tr></table></figure><p>这个路径文件很突兀，没有什么配置文件，看上去系统也没有用到，其实这里是为了文件复用而把 vmlinuz 和 initrd.img 提取出来了，在 EFI 路径下的 BOOT/grub.cfg 中有很多选项都是使用的 pxeboot/vmlinuz 。当然它最大的作用也是跟路径名一样，images，当你要配置一个发行版作为网络安装时，需要对应的 vmlinuz 和 initrd.img，那么可以从这个路径下获取，不会造成我要通过 PXELINUX 引导，却需要去 EFI 路径下获取文件的困扰。</p><h2 id="LiveOS"><a href="#LiveOS" class="headerlink" title="LiveOS"></a>LiveOS</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> $</span><span class="bash"> tree </span></span><br><span class="line">├── squashfs.img</span><br><span class="line">└── TRANS.TBL</span><br></pre></td></tr></table></figure><p>LiveOS，字面意思就是运行在内存中的 OS，现在大多数发行版为了让用户第一时间不用安装到磁盘上即可体验发行版的某些功能，而支持将 OS 运行在内存中，简单快捷。</p><blockquote><p>squashfs.img，是一套供Linux核心使用的GPL 开源只读压缩档案系统。Squashfs能够为档案系统内的档案、inode及目录结构进行压缩，并支援最大1024 千位元组的区段，以提供更大的压缩比。</p></blockquote><p>根据维基百科描述，squashfs.img 应该是包含了一个完整的 Linux映像的，我们来尝试挂载查看下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls squashfs.img</span></span><br><span class="line">squashfs.img</span><br><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> file squashfs.img</span></span><br><span class="line">squashfs.img: Squashfs filesystem, little endian, version 4.0, 368572502 bytes, 3 inodes, blocksize: 131072 bytes, created: Tue Sep  5 21:35:03 2017</span><br><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> mount -t squashfs squashfs.img /tmp/yiran</span></span><br><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls /tmp/yiran/LiveOS/rootfs.img</span></span><br><span class="line">/tmp/yiran/LiveOS/rootfs.img</span><br><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> file /tmp/yiran/LiveOS/rootfs.img</span></span><br><span class="line">/tmp/yiran/LiveOS/rootfs.img: Linux rev 1.0 ext4 filesystem data, UUID=e2fddbe2-a003-4b98-b272-3defe7b377c4, volume name "Anaconda" (extents) (64bit) (huge files)</span><br><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> mount /tmp/yiran/LiveOS/rootfs.img /tmp/yiran-root</span></span><br><span class="line">root@yiran-30-250:/tmp</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls /tmp/yiran-root</span></span><br><span class="line">bin  dev  etc  firmware  lib  lib64  lost+found  mnt  modules  proc  root  run  sbin  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>既然是一个完整的 Linux 映像，我们可以直接通过 chroot 命令切换根目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@yiran-30-250 00:24:30 yiran-root]$pwd</span><br><span class="line">/tmp/yiran-root</span><br><span class="line">[root@yiran-30-250 00:24:31 yiran-root]$ls</span><br><span class="line">bin  dev  etc  firmware  lib  lib64  lost+found  mnt  modules  proc  root  run  sbin  sys  tmp  usr  var</span><br><span class="line">[root@yiran-30-250 00:24:32 yiran-root]$chroot .</span><br><span class="line">bash: /var/log/bash.log: 只读文件系统</span><br><span class="line">[root@yiran-30-250 16:24:34 /]$cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">bash: /var/log/bash.log: 只读文件系统</span><br><span class="line">[root@yiran-30-250 16:24:36 /]$exit</span><br></pre></td></tr></table></figure><p>因为文件系统是只读的，所以我们只是进行了简单的读取操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 CentOS 发行版，我们一点点从计算机上电开始，走通整个流程，这只是一个最简单的流程，之前博客也多少提到过通过 KickStart 或者其他自动化方式安装等方式，这里不再描述。</p><p>在做事情之前最好把整个流程想通，再去研究细节部分。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wiki.osdev.org/ISO_9660#The_Boot_Record" target="_blank" rel="noopener">https://wiki.osdev.org/ISO_9660#The_Boot_Record</a></li><li><a href="https://wiki.syslinux.org/wiki/index.php?title=Doc/isolinux" target="_blank" rel="noopener">https://wiki.syslinux.org/wiki/index.php?title=Doc/isolinux</a></li><li><a href="https://wiki.osdev.org/El-Torito" target="_blank" rel="noopener">https://wiki.osdev.org/El-Torito</a></li><li><a href="https://wiki.syslinux.org/wiki/index.php?title=ISOLINUX" target="_blank" rel="noopener">https://wiki.syslinux.org/wiki/index.php?title=ISOLINUX</a></li><li><a href="https://zh.wikipedia.org/wiki/SquashFS" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/SquashFS</a></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在平时工作中我自己可能80% 的时间都在使用 Linux 进行工作，无论是软件开发还是环境维护，那么对于 Linux 发行版自然也是有比较熟
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
