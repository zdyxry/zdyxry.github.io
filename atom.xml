<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2022-06-26T03:30:00.942Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MacOS 使用 Hammerspoon 进行窗口管理</title>
    <link href="https://zdyxry.github.io/2022/06/18/MacOS-%E4%BD%BF%E7%94%A8-Hammerspoon-%E8%BF%9B%E8%A1%8C%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <id>https://zdyxry.github.io/2022/06/18/MacOS-使用-Hammerspoon-进行窗口管理/</id>
    <published>2022-06-18T10:47:07.000Z</published>
    <updated>2022-06-26T03:30:00.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近把公司电脑从 Windows 换到了 MacOS， 在重新配置 OS 阶段，发现在 MacOS 上进行窗口管理比较痛苦，自己之前的个人 MaCOS 一直使用的是Moom 来进行管理，但是使用功能很有限，加上现在 MacOS 自身的窗口提示会与 Moom 冲突，所以决定更换一个。我个人对于窗口管理的需求就是方便的在不同显示器切换，焦点窗口全屏、半屏、1/3 屏转换快速。对于平铺式窗口管理觉得学习成本和适应成本可能有些高，不打算折腾，之前看到 disksing 使用 Hammerspoon 进行窗口管理的文章： <a href="https://disksing.com/desktop-layout/" target="_blank" rel="noopener">适合程序员的桌面窗口管理方案</a> ，打算尝试一下。</p><h2 id="Hammerspoon"><a href="#Hammerspoon" class="headerlink" title="Hammerspoon"></a>Hammerspoon</h2><p>Hammerspoon 是一个开源的自动化工具，可以实现很多功能，包含不限于：窗口管理、桌面管理、Wifi 触发器、时钟管理等等，所有功能都是通过 Lua 语言来实现的。用户可以自己编写 Lua，或者使用 Spoons 中提供的一些 Lua 模块来简化配置。</p><p>官网包含了一个简单的 Window resize 示例，还是比较好理解的，先找到当前focuse 窗口，然后找到当前窗口大小，调整大小为目标值，重新设置窗口：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"Left"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> win = hs.window.focusedWindow()</span><br><span class="line">  <span class="keyword">local</span> f = win:frame()</span><br><span class="line">  <span class="keyword">local</span> screen = win:screen()</span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">max</span> = screen:frame()</span><br><span class="line"></span><br><span class="line">  f.x = <span class="built_in">max</span>.x</span><br><span class="line">  f.y = <span class="built_in">max</span>.y</span><br><span class="line">  f.w = <span class="built_in">max</span>.w / <span class="number">2</span></span><br><span class="line">  f.h = <span class="built_in">max</span>.h</span><br><span class="line">  win:setFrame(f)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 窗口管理</span><br><span class="line"></span><br><span class="line">在 Github 上可以看到很多 Hammerspoon 的示例，目前写的比较完善的有以下几个：</span><br><span class="line">* https://github.com/ashfinal/awesome-hammerspoon</span><br><span class="line">* https://github.com/wangshub/hammerspoon-<span class="built_in">config</span></span><br><span class="line">* https://github.com/S1ngS1ng/HammerSpoon</span><br><span class="line"></span><br><span class="line">虽然 Hammerspoon 提供了很多功能，但是我不想用它来实现很多功能，毕竟 AllinOne 我（没）不（什）是（么）很（好）喜（下）欢（场）。目前还没有使用 MacOS 存在一个常用的布局，所以先实现一些快捷键来满足需求就好。这里使用的 Spoon 包含两个：WinWin 和 ModalMgr。也不打算进行配置拆分，所有配置都在 init.lua 中写明，具体配置如下：</span><br><span class="line"></span><br><span class="line">```lua</span><br><span class="line">hs.hotkey.alertDuration = <span class="number">0</span></span><br><span class="line">hs.hints.showTitleThresh = <span class="number">0</span></span><br><span class="line">hs.window.animationDuration = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">hsreload_keys = hsreload_keys <span class="keyword">or</span> &#123;&#123;<span class="string">"cmd"</span>, <span class="string">"shift"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"R"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">len</span>(hsreload_keys[<span class="number">2</span>]) &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    hs.hotkey.bind(hsreload_keys[<span class="number">1</span>], hsreload_keys[<span class="number">2</span>], <span class="string">"重新加载配置!"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> hs.reload() <span class="keyword">end</span>)</span><br><span class="line">    hs.alert.show(<span class="string">"配置文件已经重新加载！ "</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">hs.loadSpoon(<span class="string">"ModalMgr"</span>)</span><br><span class="line">hs.loadSpoon(<span class="string">"WinWin"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> spoon.WinWin <span class="keyword">then</span></span><br><span class="line">    spoon.ModalMgr:new(<span class="string">"resizeM"</span>)</span><br><span class="line">    <span class="keyword">local</span> cmodal = spoon.ModalMgr.modal_list[<span class="string">"resizeM"</span>]</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'escape'</span>, <span class="string">'退出 '</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.ModalMgr:deactivate(&#123;<span class="string">"resizeM"</span>&#125;) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'Q'</span>, <span class="string">'退出'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.ModalMgr:deactivate(&#123;<span class="string">"resizeM"</span>&#125;) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'tab'</span>, <span class="string">'键位提示'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.ModalMgr:toggleCheatsheet() <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'A'</span>, <span class="string">'向左移动'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"left"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"left"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'D'</span>, <span class="string">'向右移动'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"right"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"right"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'W'</span>, <span class="string">'向上移动'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"up"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"up"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'S'</span>, <span class="string">'向下移动'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"down"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepMove(<span class="string">"down"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'H'</span>, <span class="string">'左半屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"halfleft"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'L'</span>, <span class="string">'右半屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"halfright"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'K'</span>, <span class="string">'上半屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"halfup"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'J'</span>, <span class="string">'下半屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"halfdown"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'Y'</span>, <span class="string">'屏幕左上角'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"cornerNW"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'O'</span>, <span class="string">'屏幕右上角'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"cornerNE"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'U'</span>, <span class="string">'屏幕左下角'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"cornerSW"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'I'</span>, <span class="string">'屏幕右下角'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"cornerSE"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'F'</span>, <span class="string">'全屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"fullscreen"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'C'</span>, <span class="string">'居中'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"center"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'G'</span>, <span class="string">'左三分之二屏居中分屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"centermost"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'Z'</span>, <span class="string">'展示显示'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"show"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'V'</span>, <span class="string">'编辑显示'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"shows"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'X'</span>, <span class="string">'二分之一居中分屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"center-2"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'='</span>, <span class="string">'窗口放大'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:moveAndResize(<span class="string">"expand"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:moveAndResize(<span class="string">"expand"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'-'</span>, <span class="string">'窗口缩小'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:moveAndResize(<span class="string">"shrink"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:moveAndResize(<span class="string">"shrink"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">'ctrl'</span>, <span class="string">'H'</span>, <span class="string">'向左收缩窗口'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"left"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"left"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">'ctrl'</span>, <span class="string">'L'</span>, <span class="string">'向右扩展窗口'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"right"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"right"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">'ctrl'</span>, <span class="string">'K'</span>, <span class="string">'向上收缩窗口'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"up"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"up"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">'ctrl'</span>, <span class="string">'J'</span>, <span class="string">'向下扩镇窗口'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"down"</span>) <span class="keyword">end</span>, <span class="literal">nil</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stepResize(<span class="string">"down"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'left'</span>, <span class="string">'窗口移至左边屏幕'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveToScreen(<span class="string">"left"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'right'</span>, <span class="string">'窗口移至右边屏幕'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveToScreen(<span class="string">"right"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'up'</span>, <span class="string">'窗口移至上边屏幕'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveToScreen(<span class="string">"up"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'down'</span>, <span class="string">'窗口移动下边屏幕'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveToScreen(<span class="string">"down"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'space'</span>, <span class="string">'窗口移至下一个屏幕'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveToScreen(<span class="string">"next"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'B'</span>, <span class="string">'撤销最后一个窗口操作'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:undo() <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'R'</span>, <span class="string">'重做最后一个窗口操作'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:redo() <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'['</span>, <span class="string">'左三分之二屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"mostleft"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">']'</span>, <span class="string">'右三分之二屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"mostright"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">','</span>, <span class="string">'左三分之一屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"lesshalfleft"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'.'</span>, <span class="string">'中分之一屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"onethird"</span>) <span class="keyword">end</span>)</span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'/'</span>, <span class="string">'右三分之一屏'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:stash() spoon.WinWin:moveAndResize(<span class="string">"lesshalfright"</span>) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    cmodal:bind(<span class="string">''</span>, <span class="string">'t'</span>, <span class="string">'将光标移至所在窗口中心位置'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> spoon.WinWin:centerCursor() <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    hsresizeM_keys = hsresizeM_keys <span class="keyword">or</span> &#123;<span class="string">"alt"</span>, <span class="string">"R"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">len</span>(hsresizeM_keys[<span class="number">2</span>]) &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        spoon.ModalMgr.supervisor:bind(hsresizeM_keys[<span class="number">1</span>], hsresizeM_keys[<span class="number">2</span>], <span class="string">"进入窗口管理模式"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            spoon.ModalMgr:deactivateAll()</span><br><span class="line">            spoon.ModalMgr:activate(&#123;<span class="string">"resizeM"</span>&#125;, <span class="string">"#B22222"</span>)</span><br><span class="line">        <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spoon.ModalMgr.supervisor:enter()</span><br></pre></td></tr></table></figure><p>目前尝试增加应用切换窗口自动处理，但是 M1 上的 Hammerspoon 模块会 hang，还没搞清楚怎么回事，后续有时间再看看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近把公司电脑从 Windows 换到了 MacOS， 在重新配置 OS 阶段，发现在 MacOS 上进行窗口管理比较痛苦，自己之前的个人 
      
    
    </summary>
    
    
      <category term="MacOS" scheme="https://zdyxry.github.io/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Celery/Kombu MongoDB 连接异常调查记录</title>
    <link href="https://zdyxry.github.io/2022/05/09/Celery-Kombu-MongoDB-%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2022/05/09/Celery-Kombu-MongoDB-连接异常调查记录/</id>
    <published>2022-05-09T14:44:42.000Z</published>
    <updated>2022-06-26T03:30:00.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>产品组件 JobCenter 使用 Celery 实现异步任务中心，同时会运行 job-center-worker （celery worker） 和 job-center-scheduler(celery beat) 两个进程，使用 MongoDB 作为 Backend 存储 message 等信息（Celery 官方已说明不再维护对 MongoDB 的支持）。其中 MongoDB 配置了 ReplicaSet 保证高可用。</p><p>近期 Celery/Kombu 中遇到了 <a href="https://github.com/celery/kombu/issues/1504#event-6304977800" target="_blank" rel="noopener"><code>No free channel ids</code> 问题</a>，经过排查在这个 <a href="https://github.com/celery/kombu/commit/1c2b9723851db3caa913b8da19d6ccad447f3568" target="_blank" rel="noopener">PR</a> 中解决了该问题，在考虑 cherry-pick 的工作量和可维护性考虑，最终将产品中的 celery 和 kombu 组件从 3.x 统一升级到了 4.x 版本。</p><p>测试同学反馈近期在进行可靠性测试时，发现将 MongoDB 节点的存储网络 <code>ifdown</code> 会导致 JobCenter hang. 针对该问题进行调查。</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><h3 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h3><p>先尝试复现该问题，首先尝试 ifdown Primary 节点存储网络，现象复现；尝试 ifdown Secondary 节点存储网络，无法复现；<br>尝试 stop MongoDB service 替代 ifdown，Primary 或 Secondary 均无法复现。推测与 MongoDB 连接处理有关。</p><p>观察现象复现的日志，在存储网络异常时，日志无任何输出，在存储网络恢复正常后，可以看到 Celery 记录在尝试连接 Broker （MongoDB）时发生了异常，尝试重连。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[2022-05-07 10:13:01,362: WARNING/MainProcess] consumer: Connection to broker lost. Trying to re-establish the connection...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/celery/worker/consumer/consumer.py"</span>, line 318, <span class="keyword">in</span> start</span><br><span class="line">    blueprint.start(self)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/celery/bootsteps.py"</span>, line 119, <span class="keyword">in</span> start</span><br><span class="line">    step.start(parent)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/celery/worker/consumer/consumer.py"</span>, line 596, <span class="keyword">in</span> start</span><br><span class="line">    c.loop(*c.loop_args())</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/celery/worker/loops.py"</span>, line 121, <span class="keyword">in</span> synloop</span><br><span class="line">    connection.drain_events(timeout=2.0)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/connection.py"</span>, line 315, <span class="keyword">in</span> drain_events</span><br><span class="line">    <span class="built_in">return</span> self.transport.drain_events(self.connection, **kwargs)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py"</span>, line 963, <span class="keyword">in</span> drain_events</span><br><span class="line">    get(self._deliver, timeout=timeout)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/utils/scheduling.py"</span>, line 56, <span class="keyword">in</span> get</span><br><span class="line">    <span class="built_in">return</span> self.fun(resource, callback, **kwargs)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py"</span>, line 1001, <span class="keyword">in</span> _drain_channel</span><br><span class="line">    <span class="built_in">return</span> channel.drain_events(callback=callback, timeout=timeout)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py"</span>, line 745, <span class="keyword">in</span> drain_events</span><br><span class="line">    <span class="built_in">return</span> self._poll(self.cycle, callback, timeout=timeout)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py"</span>, line 402, <span class="keyword">in</span> _poll</span><br><span class="line">    <span class="built_in">return</span> cycle.get(callback)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/utils/scheduling.py"</span>, line 56, <span class="keyword">in</span> get</span><br><span class="line">    <span class="built_in">return</span> self.fun(resource, callback, **kwargs)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/transport/virtual/base.py"</span>, line 405, <span class="keyword">in</span> _get_and_deliver</span><br><span class="line">    message = self._get(queue)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/site-packages/kombu/transport/mongodb.py"</span>, line 141, <span class="keyword">in</span> _get</span><br><span class="line">    remove=True,</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/pymongo/collection.py"</span>, line 2315, <span class="keyword">in</span> find_and_modify</span><br><span class="line">    allowable_errors=[_NO_OBJ_ERROR])</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/pymongo/collection.py"</span>, line 205, <span class="keyword">in</span> _command</span><br><span class="line">    read_concern=read_concern)</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/pymongo/pool.py"</span>, line 218, <span class="keyword">in</span> <span class="built_in">command</span></span><br><span class="line">    self._raise_connection_failure(error)</span><br><span class="line">  File <span class="string">"/usr/lib64/python2.7/site-packages/pymongo/pool.py"</span>, line 346, <span class="keyword">in</span> _raise_connection_failure</span><br><span class="line">    raise error</span><br><span class="line">AutoReconnect: connection closed</span><br><span class="line">[2022-05-07 10:13:01,363: WARNING/MainProcess] Restoring 1 unacknowledged message(s)</span><br></pre></td></tr></table></figure><p>对应 Celery 代码在 worker/consumer/consumer.py，Blueprint 是 Celery 启动入口，可以看到在 <code>blueprint.start(self)</code> 阶段进行了异常处理，针对 <code>self.connection_errors</code> 来触发重连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">CONNECTION_RETRY = <span class="string">"""\</span></span><br><span class="line"><span class="string">consumer: Connection to broker lost. \</span></span><br><span class="line"><span class="string">Trying to re-establish the connection...\</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">    blueprint = self.blueprint</span><br><span class="line">    <span class="keyword">while</span> blueprint.state != CLOSE:</span><br><span class="line">        maybe_shutdown()</span><br><span class="line">        <span class="keyword">if</span> self.restart_count:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._restart_state.step()</span><br><span class="line">            <span class="keyword">except</span> RestartFreqExceeded <span class="keyword">as</span> exc:</span><br><span class="line">                crit(<span class="string">'Frequent restarts detected: %r'</span>, exc, exc_info=<span class="number">1</span>)</span><br><span class="line">                sleep(<span class="number">1</span>)</span><br><span class="line">        self.restart_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            blueprint.start(self)</span><br><span class="line">        <span class="keyword">except</span> self.connection_errors <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="comment"># If we're not retrying connections, no need to catch</span></span><br><span class="line">            <span class="comment"># connection errors</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.app.conf.broker_connection_retry:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(exc, OSError) <span class="keyword">and</span> exc.errno == errno.EMFILE:</span><br><span class="line">                <span class="keyword">raise</span>  <span class="comment"># Too many open files</span></span><br><span class="line">            maybe_shutdown()</span><br><span class="line">            <span class="keyword">if</span> blueprint.state != CLOSE:</span><br><span class="line">                <span class="keyword">if</span> self.connection:</span><br><span class="line">                    self.on_connection_error_after_connected(exc)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.on_connection_error_before_connected(exc)</span><br><span class="line">                self.on_close()</span><br><span class="line">                blueprint.restart(self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connection_error_before_connected</span><span class="params">(self, exc)</span>:</span></span><br><span class="line">    error(CONNECTION_ERROR, self.conninfo.as_uri(), exc,</span><br><span class="line">          <span class="string">'Trying to reconnect...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_connection_error_after_connected</span><span class="params">(self, exc)</span>:</span></span><br><span class="line">    warn(CONNECTION_RETRY, exc_info=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.connection.collect()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>self.connection_errors</code> 对应的其实是 Kombu 中 Transport 定义的 ，可以在 <code>kombu/kombu/transport/mongodb.py</code> 中查看，在当前版本中，定义为 <code>pymongo.errors.ConnectionFailure</code> ，pymongo 中常见的网络连接异常 <code>AutoReconnect</code> 或 <code>NetworkTimeout</code> 均继承自 <code>ConnectionFailure</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transport</span><span class="params">(virtual.Transport)</span>:</span></span><br><span class="line">    Channel = Channel</span><br><span class="line"></span><br><span class="line">    can_parse_url = <span class="keyword">True</span></span><br><span class="line">    polling_interval = <span class="number">1</span></span><br><span class="line">    default_port = DEFAULT_PORT</span><br><span class="line">    connection_errors = (</span><br><span class="line">        virtual.Transport.connection_errors + (errors.ConnectionFailure, )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>从目前来看，Celery 可以正确处理 kombu 上报的异常，但是在存储网络异常时，Kombu 没有抛出异常，于是问题调查从 Celery 转到 Kombu。</p><h3 id="Kombu"><a href="#Kombu" class="headerlink" title="Kombu"></a>Kombu</h3><p>主要看 MongoDB Transport 关于建立连接部分的处理，代码执行路径依次是： <code>client</code> -&gt; <code>_create_client</code> -&gt; <code>_open</code> -&gt; <code>_parse_uri</code> ，其中 <code>_open</code> 是真正建立连接的处理，连接所采用的参数是在 <code>_parse_uri</code> 返回的，<code>_parse_uri</code> 最终调用的是 <code>pymongo.uri_parser.parse_uri</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_open</span><span class="params">(self, scheme=<span class="string">'mongodb://'</span>)</span>:</span></span><br><span class="line">    hostname, dbname, options = self._parse_uri(scheme=scheme)</span><br><span class="line"></span><br><span class="line">    conf = self._prepare_client_options(options)</span><br><span class="line">    conf[<span class="string">'host'</span>] = hostname</span><br><span class="line"></span><br><span class="line">    env = _detect_environment()</span><br><span class="line">    <span class="keyword">if</span> env == <span class="string">'gevent'</span>:</span><br><span class="line">        <span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">        monkey.patch_all()</span><br><span class="line">    <span class="keyword">elif</span> env == <span class="string">'eventlet'</span>:</span><br><span class="line">        <span class="keyword">from</span> eventlet <span class="keyword">import</span> monkey_patch</span><br><span class="line">        monkey_patch()</span><br><span class="line"></span><br><span class="line">    mongoconn = MongoClient(**conf)</span><br><span class="line">    database = mongoconn[dbname]</span><br><span class="line"></span><br><span class="line">    version_str = mongoconn.server_info()[<span class="string">'version'</span>]</span><br><span class="line">    version = tuple(map(int, version_str.split(<span class="string">'.'</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> version &lt; (<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">raise</span> VersionMismatch(E_SERVER_VERSION.format(version_str))</span><br><span class="line">    <span class="keyword">elif</span> self.ttl <span class="keyword">and</span> version &lt; (<span class="number">2</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">raise</span> VersionMismatch(E_NO_TTL_INDEXES.format(version_str))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> database</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_uri</span><span class="params">(self, scheme=<span class="string">'mongodb://'</span>)</span>:</span></span><br><span class="line">    <span class="comment"># See mongodb uri documentation:</span></span><br><span class="line">    <span class="comment"># http://docs.mongodb.org/manual/reference/connection-string/</span></span><br><span class="line">    client = self.connection.client</span><br><span class="line">    hostname = client.hostname</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hostname.startswith(scheme):</span><br><span class="line">        hostname = scheme + hostname</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hostname[len(scheme):]:</span><br><span class="line">        hostname += self.default_hostname</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> client.userid <span class="keyword">and</span> <span class="string">'@'</span> <span class="keyword">not</span> <span class="keyword">in</span> hostname:</span><br><span class="line">        head, tail = hostname.split(<span class="string">'://'</span>)</span><br><span class="line">        credentials = client.userid</span><br><span class="line">        <span class="keyword">if</span> client.password:</span><br><span class="line">            credentials += <span class="string">':'</span> + client.password</span><br><span class="line">        hostname = head + <span class="string">'://'</span> + credentials + <span class="string">'@'</span> + tail</span><br><span class="line"></span><br><span class="line">    port = client.port <span class="keyword">if</span> client.port <span class="keyword">else</span> self.default_port</span><br><span class="line">    parsed = uri_parser.parse_uri(hostname, port)</span><br><span class="line">    dbname = parsed[<span class="string">'database'</span>] <span class="keyword">or</span> client.virtual_host</span><br><span class="line">    <span class="keyword">if</span> dbname <span class="keyword">in</span> (<span class="string">'/'</span>, <span class="keyword">None</span>):</span><br><span class="line">        dbname = self.default_database</span><br><span class="line">    options = &#123;</span><br><span class="line">        <span class="string">'auto_start_request'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'ssl'</span>: self.ssl,</span><br><span class="line">        <span class="string">'connectTimeoutMS'</span>: (int(self.connect_timeout * <span class="number">1000</span>)</span><br><span class="line">                             <span class="keyword">if</span> self.connect_timeout <span class="keyword">else</span> <span class="keyword">None</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    options.update(parsed[<span class="string">'options'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hostname, dbname, options</span><br></pre></td></tr></table></figure><p>假设我们连接参数是 <code>mongodb://192.168.1.1:27017,192.168.1.2:27017/yiran</code> ，那么 <code>pymongo.uri_parser.parse_uri</code> 解析的结果会是： <code>{&#39;username&#39;: None, &#39;nodelist&#39;: [(&#39;192.168.1.1&#39;, 27017), (&#39;192.168.1.2&#39;, 27017)], &#39;database&#39;: &#39;yiran&#39;, &#39;collection&#39;: None, &#39;password&#39;: None, &#39;options&#39;: {}}</code> 。</p><p>socketTimeoutMS在我们的环境中，MongoDB 的 URI 中并没有指定 options，所以 <code>pymongo.uri_parser.parse_uri</code> 结果的 <code>options</code> 为空。最终连接所使用的 <code>options</code> 就是在 <code>_parse_uri</code> 中定义的 options ，其中类变量 <code>connect_timeout</code> 在 Channel 定义为 None，所以最终 Kombu 建立 MongoDB 连接并没有设置 <code>socketTimeoutMS</code>，如果不设置 <code>socketTimeoutMS</code> ，默认是 None，永久等待。当网络出现异常时，直观看到的现象会是 hang 住。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span><span class="params">(virtual.Channel)</span>:</span></span><br><span class="line">    <span class="string">"""MongoDB Channel."""</span></span><br><span class="line"></span><br><span class="line">    supports_fanout = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mutable container. Shared by all class instances</span></span><br><span class="line">    _fanout_queues = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Options</span></span><br><span class="line">    ssl = <span class="keyword">False</span></span><br><span class="line">    ttl = <span class="keyword">False</span></span><br><span class="line">    connect_timeout = <span class="keyword">None</span></span><br><span class="line">    capped_queue_size = <span class="number">100000</span></span><br><span class="line">    calc_queue_size = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="Celery-与-Kombu-参数传递"><a href="#Celery-与-Kombu-参数传递" class="headerlink" title="Celery 与 Kombu 参数传递"></a>Celery 与 Kombu 参数传递</h3><p>现在观察到连接参数不符合预期，为什么之前的 3.x 版本没有问题？切换到 3.x 分支查看对应的代码，可以看到大体逻辑都是类似的，关于 options 的处理，3.x 存在一行 ： <code>options.update(client.transport_options)</code> ，这里的 client 在函数最开始赋值，对应的是 <code>self.connection.client</code> ，<code>self.connection</code> 是 Transport 构造传入的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_uri</span><span class="params">(self, scheme=<span class="string">'mongodb://'</span>)</span>:</span></span><br><span class="line">    <span class="comment"># See mongodb uri documentation:</span></span><br><span class="line">    <span class="comment"># http://docs.mongodb.org/manual/reference/connection-string/</span></span><br><span class="line">    client = self.connection.client</span><br><span class="line">    hostname = client.hostname</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hostname.startswith(scheme):</span><br><span class="line">        hostname = scheme + hostname</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hostname[len(scheme):]:</span><br><span class="line">        hostname += DEFAULT_HOST</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> client.userid <span class="keyword">and</span> <span class="string">'@'</span> <span class="keyword">not</span> <span class="keyword">in</span> hostname:</span><br><span class="line">        head, tail = hostname.split(<span class="string">'://'</span>)</span><br><span class="line"></span><br><span class="line">        credentials = client.userid</span><br><span class="line">        <span class="keyword">if</span> client.password:</span><br><span class="line">            credentials += <span class="string">':'</span> + client.password</span><br><span class="line"></span><br><span class="line">        hostname = head + <span class="string">'://'</span> + credentials + <span class="string">'@'</span> + tail</span><br><span class="line"></span><br><span class="line">    port = client.port <span class="keyword">if</span> client.port <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> DEFAULT_PORT</span><br><span class="line"></span><br><span class="line">    parsed = uri_parser.parse_uri(hostname, port)</span><br><span class="line"></span><br><span class="line">    dbname = parsed[<span class="string">'database'</span>] <span class="keyword">or</span> client.virtual_host</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dbname <span class="keyword">in</span> (<span class="string">'/'</span>, <span class="keyword">None</span>):</span><br><span class="line">        dbname = <span class="string">'kombu_default'</span></span><br><span class="line"></span><br><span class="line">    options = &#123;</span><br><span class="line">        <span class="string">'auto_start_request'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'ssl'</span>: client.ssl,</span><br><span class="line">        <span class="string">'connectTimeoutMS'</span>: (int(client.connect_timeout * <span class="number">1000</span>)</span><br><span class="line">                             <span class="keyword">if</span> client.connect_timeout <span class="keyword">else</span> <span class="keyword">None</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    options.update(client.transport_options)</span><br><span class="line">    options.update(parsed[<span class="string">'options'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hostname, dbname, options</span><br></pre></td></tr></table></figure><p><code>connection</code> 对应的就是 Kombu 中的 <code>Connection</code> ，Kombu 对外隐藏了 Transport ，Celery 在初始化阶段，会建立连接，调用路径是 <code>celery/app/base.py:Celery._connection</code> -&gt; <code>celery/app/amqp.py:AMQP.Connection</code> -&gt; <code>kombu/connection.py:Connection</code> 。传递参数 <code>transport_options</code> 就是在 Celery app 声明时配置的参数，具体可配置参数可以参考文档： <a href="https://docs.celeryq.dev/en/stable/userguide/configuration.html。" target="_blank" rel="noopener">https://docs.celeryq.dev/en/stable/userguide/configuration.html。</a></p><p>在我们的场景中，声明了以下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BROKER_TRANSPORT_OPTIONS = &#123;</span><br><span class="line">    &quot;connect&quot;: False,</span><br><span class="line">    &quot;maxPoolSize&quot;: 5 if &quot;worker&quot; in process_cmdline else 2,</span><br><span class="line">    &quot;socketTimeoutMS&quot;: 5000,</span><br><span class="line">    &quot;connectTimeoutMS&quot;: 5000,</span><br><span class="line">    &quot;serverSelectionTimeoutMS&quot;: 5000,</span><br><span class="line">    &quot;w&quot;: 0,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kombu 使用 MongoDB Transport 时，最终会带有这些参数创建 MongoDB 连接，所以不会出现此问题说描述的现象。</p><h2 id="Celery-改动背景"><a href="#Celery-改动背景" class="headerlink" title="Celery 改动背景"></a>Celery 改动背景</h2><p>@rmihael 上报了一个问题： <a href="https://github.com/celery/celery/issues/1047" target="_blank" rel="noopener">Celery events are not removed from MongoDB broker #1047</a> ，表示在使用 Celery Flower（Celery 监控组件）后，<code>messages</code> 中的事件不会清除，导致占用了大量的 MongoDB 存储空间。该 Issue 中讨论最终决定使用 MongoDB TTL 来解决此问题。</p><p>在 Kombu 4.x 开发周期中，@daevaorn 提交了 <a href="https://github.com/celery/kombu/pull/537" target="_blank" rel="noopener">MongoDB TTL support and refactorings #537</a> 用来支持 MongoDB TTL，在该 PR 中包含了大量与 TTL 无关的 commit，并且包含了一定的重构，commit 如下：</p><ul><li>Complete unit tests suit for MongoDB transport</li><li>Optional TTL support for MongoDB transport. AMQP TTL headers: x-messa… </li><li>Rearrange methods at MongoDB channel class</li><li>Another MongoDB transport clean up and refactor. Use of transport opt… </li><li>Opt-out for queue size calculation</li><li>Use natural sort for more FIFO semantic</li><li>Fix docstrings</li></ul><p>其中 <code>Optional TTL support for MongoDB transport.</code> 是最关键的改动，忽略 TTL 的改动，主要看建立 MongoDB 连接的改动。在 <code>Channel</code> Class 中新增了一些类变量用于标识当前配置，在 <code>_parse_uri</code> 中，将 SSL,connectTImeoutMS 从 <code>client</code> 替换为了 <code>self</code> ，并删除了 <code>options.update(client.transport_options)</code> 。其中删除了 <code>options.update(client.transport_options)</code> 是导致这个问题的关键。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> class Channel(virtual.Channel):</span><br><span class="line">     _client = None</span><br><span class="line">     supports_fanout = True</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    # Mutable containers. Shared by all class instances</span></span><br><span class="line">     _fanout_queues = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+    # Options</span></span><br><span class="line"><span class="addition">+    connect_timeout = None</span></span><br><span class="line"><span class="addition">+    ssl = False</span></span><br><span class="line"><span class="addition">+    capped_queue_size = 100000</span></span><br><span class="line"><span class="addition">+    ttl = False</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    from_transport_options = (</span></span><br><span class="line"><span class="addition">+        virtual.Channel.from_transport_options</span></span><br><span class="line"><span class="addition">+        + ('connect_timeout', 'ssl', 'ttl', 'capped_queue_size'))</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     def __init__(self, *vargs, **kwargs):</span><br><span class="line">         super(Channel, self).__init__(*vargs, **kwargs)</span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">    def _parse_uri(self, scheme='mongodb://'):</span><br><span class="line">        ...</span><br><span class="line">         options = &#123;</span><br><span class="line">             'auto_start_request': True,</span><br><span class="line"><span class="deletion">-            'ssl': client.ssl,</span></span><br><span class="line"><span class="deletion">-            'connectTimeoutMS': (int(client.connect_timeout * 1000)</span></span><br><span class="line"><span class="deletion">-                                 if client.connect_timeout else None),</span></span><br><span class="line"><span class="addition">+            'ssl': self.ssl,</span></span><br><span class="line"><span class="addition">+            'connectTimeoutMS': (int(self.connect_timeout * 1000)</span></span><br><span class="line"><span class="addition">+                                 if self.connect_timeout else None),</span></span><br><span class="line">         &#125;</span><br><span class="line"><span class="deletion">-        options.update(client.transport_options)</span></span><br><span class="line">         options.update(parsed['options'])</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Celery Kombu 代码管理感觉有些不清晰，在多个分支上想要对比非常困难。必要组件升级大版本进行全集测试是必要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;产品组件 JobCenter 使用 Celery 实现异步任务中心，同时会运行 job-center-worker （celery work
      
    
    </summary>
    
    
      <category term="Python" scheme="https://zdyxry.github.io/tags/Python/"/>
    
      <category term="Celery" scheme="https://zdyxry.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>Yum 寻找 Best Package 评分机制</title>
    <link href="https://zdyxry.github.io/2022/04/29/Yum-%E5%AF%BB%E6%89%BE-Best-Package-%E8%AF%84%E5%88%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://zdyxry.github.io/2022/04/29/Yum-寻找-Best-Package-评分机制/</id>
    <published>2022-04-29T23:04:16.000Z</published>
    <updated>2022-06-26T03:30:00.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司产品最终交付形态是 ISO，在涉及一个产品的多个 OEM 场景时，会选择在标准版本的基础上，删除某些软件包，新增某些软件包的形式来减少构建时间。产品的 BaseOS 是 CentOS，包管理器是 RPM 系，也就需要使用 <code>rpm</code> / <code>yum</code> 等命令来实现。<br>其中新增某些软件包是使用 <code>yumdownloader</code> 来完成的。在 Yum Repository 中会包含同一软件包的多个版本，预期 <code>yumdownloader</code> 会下载 Yum Repository 中某个软件最新版本的包，比如 <code>yumdownloader zbs-5.1.2*</code> ，则会下载 zbs-5.1.2 大版本的最新 release 版本。</p><p>但是最近发现，从某个版本开始 <code>yumdownloader</code> 没有下载最新的软件包，反而停在了一个两个月之前构建的版本，于是开始调查原因。</p><h2 id="Yumdownloader"><a href="#Yumdownloader" class="headerlink" title="Yumdownloader"></a>Yumdownloader</h2><p><code>yumdownloader</code> 工具集是由 <code>yum-utils</code> 提供，同时还提供了 <code>repotrack</code>，<code>repoquery</code>, <code>reposync</code> 等有用的工具。<code>yumdownloader</code> 使用方式是 <code>yumdownloader $pkg</code> 即可。在 <code>yum-utils</code> 中会大量引用 <code>yum</code> module，因此需要同时查找两个 Git repo。</p><p><code>yum-utils</code> 代码仓库地址： <a href="https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py" target="_blank" rel="noopener">https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py</a><br><code>yum</code> 代码仓库地址：<a href="https://github.com/rpm-software-management/yum" target="_blank" rel="noopener">https://github.com/rpm-software-management/yum</a></p><h3 id="下载逻辑"><a href="#下载逻辑" class="headerlink" title="下载逻辑"></a>下载逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def main(self):</span><br><span class="line">    # Add command line option specific to yumdownloader</span><br><span class="line">    self.addCmdOptions()</span><br><span class="line">    ...</span><br><span class="line">    # make yumdownloader work as non root user.</span><br><span class="line">    if not self.setCacheDir():</span><br><span class="line">        self.logger.error(&quot;Error: Could not make cachedir, exiting&quot;)</span><br><span class="line">        sys.exit(50)</span><br><span class="line">    ...</span><br><span class="line">    # Setup yum (Ts, RPM db, Repo &amp; Sack)</span><br><span class="line">    self.doUtilYumSetup()</span><br><span class="line">    # Do the real action</span><br><span class="line">    self.exit_code = self.downloadPackages(opts)</span><br></pre></td></tr></table></figure><ul><li>解析命令行参数</li><li>检查执行用户权限</li><li>配置 Yum Repo 正确性</li><li>下载 RPM</li></ul><p>其中前几项不是很重要，直接看 <code>self.downloadPackages(opts)</code> 逻辑。主要做了以下几件事情：  </p><ol><li>根据 PKG 列表进行 Repo 中的查询，查询出所有的软件包；  </li><li>根据查询结果，进行解析匹配，其中精确匹配和模糊匹配会进行后续处理；</li><li>根据 RPM <code>name+arch</code> 作为 key 来将所有的 Pkg 列表转换为 Dict；</li><li>遍历 Dict，从列表中找到 Best Package ，并将其添加到下载列表中；</li><li>根据下载列表信息进行下载。</li></ol><p>Github: <a href="https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py#L136" target="_blank" rel="noopener">https://github.com/rpm-software-management/yum-utils/blob/master/yumdownloader.py#L136</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadPackages</span><span class="params">(self,opts)</span>:</span></span><br><span class="line">    </span><br><span class="line">    toDownload = [] <span class="comment"># 最终要下载的 RPM</span></span><br><span class="line"></span><br><span class="line">    packages = self.cmds</span><br><span class="line">    <span class="keyword">for</span> pkg <span class="keyword">in</span> packages:</span><br><span class="line">        toActOn = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pkg <span class="keyword">or</span> pkg[<span class="number">0</span>] != <span class="string">'@'</span>:</span><br><span class="line">            pkgnames = [pkg] <span class="comment"># 如果 PKG 名称不以 `@` 开头，那么就是单个软件包；如果以 `@` 开头，那么表示是一个 Group；</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Group 处理逻辑，忽略</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        pos = self.pkgSack.returnPackages(patterns=pkgnames) <span class="comment"># 在 Yum repo 中根据 pkgnames 来获取查询到的包列表</span></span><br><span class="line">        exactmatch, matched, unmatched = parsePackages(pos, pkgnames) <span class="comment"># 根据 pkgnames 名称 从 pos 中解析具体的匹配结果，其中如果精确匹配则添加到 exactmatch，如果模糊匹配则添加到 matched。在本文场景下所有匹配为模糊匹配，所以在 matched 列表中</span></span><br><span class="line">        installable = (exactmatch + matched) <span class="comment"># 最终可安装的是精确匹配和模糊匹配的集合</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> installable:</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> newpkg <span class="keyword">in</span> installable:</span><br><span class="line">            toActOn.extend(_best_convert_pkg2srcpkgs(self, opts, newpkg)) <span class="comment"># 根据解析结果，将所有处于 installable 中的包都找到具体来源</span></span><br><span class="line">        <span class="keyword">if</span> toActOn:</span><br><span class="line">            pkgGroups = self._groupPackages(toActOn) <span class="comment"># 使用 RPM `name` 和 `arch` 针对 toActOn 列表进行初步分组，转换为 dict</span></span><br><span class="line">            <span class="keyword">for</span> group <span class="keyword">in</span> pkgGroups:</span><br><span class="line">                pkgs = pkgGroups[group]</span><br><span class="line">                <span class="keyword">if</span> opts.source:</span><br><span class="line">                    ...     <span class="comment"># 根据 yumdownloader 命令参数进行额外的处理，忽略</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    toDownload.extend(self.bestPackagesFromList(pkgs)) <span class="comment"># 从 pkgs 列表中选择 best Package，然后添加到 toDownload 列表中</span></span><br><span class="line">                        </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># set localpaths</span></span><br><span class="line">    <span class="keyword">for</span> pkg <span class="keyword">in</span> toDownload:</span><br><span class="line">        pkg.repo.copy_local = <span class="keyword">True</span></span><br><span class="line">        pkg.repo.cache = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># use downloader from YumBase</span></span><br><span class="line">    exit_code = <span class="number">0</span></span><br><span class="line">    probs = self.downloadPkgs(toDownload) <span class="comment"># 下载具体 RPM </span></span><br><span class="line">    <span class="keyword">if</span> probs:</span><br><span class="line">        exit_code = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> probs:</span><br><span class="line">            <span class="keyword">for</span> error <span class="keyword">in</span> probs[key]:</span><br><span class="line">                self.logger.error(<span class="string">'%s: %s'</span>, key, error)</span><br><span class="line">    <span class="keyword">return</span> exit_code</span><br></pre></td></tr></table></figure></p><p>在我的场景中，问题出在查找 Best Package 步骤中，相关日志如下，可以观察到在 Yum repo 中查询到了 zbs-5.1.2 所有的 release RPM，分别为 rc1 ,rc2 一直到 rc14 ，排序方式是字母序。 parsePackages 解析出所有的 PKG 均在 matched 中，因为都是模糊匹配，最终传入 bestPackagesFromList 方法中的参数是所有到的 release RPM，预期是返回最新的 release RPM ，即 zbs-5.1.2-rc14，但是返回的是 rc7 。接下来需要调查 bestPackagesFromList 是如何判断的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'zbs-5.1.2*'</span>]</span><br><span class="line">pos: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;]</span><br><span class="line">exactmatch: []</span><br><span class="line">matched: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;]</span><br><span class="line">unmatched: []</span><br><span class="line">pkgGroups: &#123;<span class="string">'zbs.x86_64'</span>: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;]&#125;</span><br><span class="line">pkgs: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc14.0.release.git.g42733ba17.el7.SMTX.HCI.x86_64 (0x2bf6fd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc13.0.release.git.g339708733.el7.SMTX.HCI.x86_64 (0x2bf6f90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc2.0.release.git.gfa5212d39.el7.SMTX.HCI.x86_64 (0x2c03050)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc3.0.release.git.ge4ecabe7b.el7.SMTX.HCI.x86_64 (0x2c03090)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc9.0.release.git.g238ab2320.el7.SMTX.HCI.x86_64 (0x2c03210)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc6.0.release.git.g51f0f1277.el7.SMTX.HCI.x86_64 (0x2c03150)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc4.0.release.git.g6e9ed979b.el7.SMTX.HCI.x86_64 (0x2c030d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc10.0.release.git.g228f49070.el7.SMTX.HCI.x86_64 (0x2bf6dd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc8.0.release.git.g763bb9046.el7.SMTX.HCI.x86_64 (0x2c031d0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc12.0.release.git.g9a6400652.el7.SMTX.HCI.x86_64 (0x2bf6bd0)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc11.0.release.git.g6d5d763ee.el7.SMTX.HCI.x86_64 (0x2bf6d90)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc1.0.release.git.g0cb56434e.el7.SMTX.HCI.x86_64 (0x2bf6e50)&gt;, &lt;YumAvailablePackageSqlite : zbs-5.1.2-rc5.0.release.git.gfa8bab6ad.el7.SMTX.HCI.x86_64 (0x2c03110)&gt;]</span><br><span class="line">toDownload: [&lt;YumAvailablePackageSqlite : zbs-5.1.2-rc7.0.release.git.gccd6dbf2a.el7.SMTX.HCI.x86_64 (0x2c03190)&gt;]</span><br></pre></td></tr></table></figure><h2 id="Yum"><a href="#Yum" class="headerlink" title="Yum"></a>Yum</h2><p><code>yumdownloader</code> 是 <code>yum</code> module 的功能分装，具体的 <code>bestPackagesFromList</code> 是在 <code>yum</code> module 中实现的。<code>bestPackagesFromList</code> 自身先根据 pkg arch 来进行分类，其中判断依据为：</p><p>Github： <a href="https://github.com/rpm-software-management/yum/blob/master/rpmUtils/arch.py#L153:5" target="_blank" rel="noopener">https://github.com/rpm-software-management/yum/blob/master/rpmUtils/arch.py#L153:5</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># dict mapping arch -&gt; ( multicompat, best personality, biarch personality )</span><br><span class="line">multilibArches = &#123; &quot;x86_64&quot;:  ( &quot;athlon&quot;, &quot;x86_64&quot;, &quot;athlon&quot; ),</span><br><span class="line">                   &quot;sparc64v&quot;: ( &quot;sparcv9v&quot;, &quot;sparcv9v&quot;, &quot;sparc64v&quot; ),</span><br><span class="line">                   &quot;sparc64&quot;: ( &quot;sparcv9&quot;, &quot;sparcv9&quot;, &quot;sparc64&quot; ),</span><br><span class="line">                   &quot;ppc64&quot;:   ( &quot;ppc&quot;, &quot;ppc&quot;, &quot;ppc64&quot; ),</span><br><span class="line">                   &quot;s390x&quot;:   ( &quot;s390&quot;, &quot;s390x&quot;, &quot;s390&quot; ),</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure></p><p>Github: <a href="https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4432" target="_blank" rel="noopener">https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4432</a>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bestPackagesFromList</span><span class="params">(self, pkglist, arch=None, single_name=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                            req=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the best packages from a list of packages.  This</span></span><br><span class="line"><span class="string">    function is multilib aware, so that it will not compare</span></span><br><span class="line"><span class="string">    multilib to singlelib packages.</span></span><br><span class="line"><span class="string">    :param pkglist: the list of packages to return the best</span></span><br><span class="line"><span class="string">        packages from</span></span><br><span class="line"><span class="string">    :param arch: packages will be selected that are compatible</span></span><br><span class="line"><span class="string">        with the architecture specified by *arch*</span></span><br><span class="line"><span class="string">    :param single_name: whether to return a single package name</span></span><br><span class="line"><span class="string">    :param req: the requirement from the user</span></span><br><span class="line"><span class="string">    :return: a list of the best packages from *pkglist*</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    returnlist = []</span><br><span class="line">    compatArchList = self.arch.get_arch_list(arch)</span><br><span class="line">    multiLib = []</span><br><span class="line">    singleLib = []</span><br><span class="line">    noarch = []</span><br><span class="line">    <span class="keyword">for</span> po <span class="keyword">in</span> pkglist: <span class="comment"># 根据架构来进行筛选，x86_64 是 multiLibArch</span></span><br><span class="line">        <span class="keyword">if</span> po.arch <span class="keyword">not</span> <span class="keyword">in</span> compatArchList:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> po.arch <span class="keyword">in</span> (<span class="string">"noarch"</span>):</span><br><span class="line">            noarch.append(po)</span><br><span class="line">        <span class="keyword">elif</span> isMultiLibArch(arch=po.arch):</span><br><span class="line">            multiLib.append(po) <span class="comment"># 最终所有 pkg 添加到 multiLib 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singleLib.append(po)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># we now have three lists.  find the best package(s) of each</span></span><br><span class="line">    multi = self._bestPackageFromList(multiLib, req=req) <span class="comment"># 根据不同架构找到 best package</span></span><br><span class="line">    single = self._bestPackageFromList(singleLib, req=req)</span><br><span class="line">    no = self._bestPackageFromList(noarch, req=req)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnlist</span><br></pre></td></tr></table></figure><p>继续追踪 <code>_bestPackageFromList</code> 的实现，可以看到</p><p>Github: <a href="https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4409" target="_blank" rel="noopener">https://github.com/rpm-software-management/yum/blob/master/yum/__init__.py#L4409</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_bestPackageFromList</span><span class="params">(self, pkglist, req=None)</span>:</span></span><br><span class="line">    <span class="string">"""take list of package objects and return the best package object.</span></span><br><span class="line"><span class="string">        If the list is empty, return None. </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Note: this is not aware of multilib so make sure you're only</span></span><br><span class="line"><span class="string">        passing it packages of a single arch group.</span></span><br><span class="line"><span class="string">        :param pkglist: the list of packages to return the best</span></span><br><span class="line"><span class="string">            packages from</span></span><br><span class="line"><span class="string">        :param req: the requirement from the user</span></span><br><span class="line"><span class="string">        :return: a list of the best packages from *pkglist*</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ...</span><br><span class="line">    bestlist = self._compare_providers(pkglist, reqpo=<span class="keyword">None</span>, req=req)</span><br><span class="line">    <span class="keyword">return</span> bestlist[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>终于找到最关键的部分： <code>_compare_providers</code> ，这是一个巨大的函数，300行，根据注释可以看到主要用户给 pkg 打分：</p><p>Github: <a href="https://github.com/rpm-software-management/yum/blob/master/yum/depsolve.py#L1465" target="_blank" rel="noopener">https://github.com/rpm-software-management/yum/blob/master/yum/depsolve.py#L1465</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compare_providers</span><span class="params">(self, pkgs, reqpo, req=None)</span>:</span></span><br><span class="line">    <span class="string">"""take the list of pkgs and score them based on the requesting package</span></span><br><span class="line"><span class="string">        return a dictionary of po=score"""</span></span><br><span class="line">    self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">            _(<span class="string">"Running compare_providers() for %s"</span>) %(str(pkgs)))</span><br></pre></td></tr></table></figure></p><p>接下来是具体的打分流程，先根据 repo id 的字母序进行过滤，如果多个 repo 均提供了同一版本的 PKG，那么会根据 repo 字母序进行选取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Do a NameArch filtering, based on repo. __cmp__</span></span><br><span class="line">unique_nevra_pkgs = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> pkgs:</span><br><span class="line">    <span class="keyword">if</span> (pkg.pkgtup <span class="keyword">in</span> unique_nevra_pkgs <span class="keyword">and</span></span><br><span class="line">        unique_nevra_pkgs[pkg.pkgtup].repo &lt;= pkg.repo):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    unique_nevra_pkgs[pkg.pkgtup] = pkg</span><br><span class="line">pkgs = unique_nevra_pkgs.values()</span><br></pre></td></tr></table></figure><p>其中 pkg.repo 的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository</span>:</span></span><br><span class="line">    <span class="string">"""this is an actual repository object"""</span>       </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, repoid)</span>:</span></span><br><span class="line">        self.id = repoid</span><br><span class="line">        self.quick_enable_disable = &#123;&#125;</span><br><span class="line">        self.disable()</span><br><span class="line">        self._xml2sqlite_local = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">""" Sort base class repos. by alphanumeric on their id, also</span></span><br><span class="line"><span class="string">            see __cmp__ in YumRepository(). """</span></span><br><span class="line">        <span class="keyword">if</span> self.id &gt; other.id:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.id &lt; other.id:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>初始化 pkgresults ，其中 value 是对应的分数，第一步打分是检查目标 pkg 是否已经存在于当前主机上，会通过查询 rpmdb 来获取信息，如果已经存在了，那么这种情况是升级情况，需要与当前主机上 newest 的 pkg 进行比较，如果当前主机上最新的包版本小于 pkg，则 +5 分，如果等于则 +1000 分，如果小于则 -1024 分。如果当前主机上没有，则跳过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pkgresults = &#123;&#125;</span><br><span class="line">penalize = set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> pkgs:</span><br><span class="line">    pkgresults[pkg] = <span class="number">0</span> <span class="comment"># 初始化各个 pkg 的分数为 0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hand this off to our plugins</span></span><br><span class="line">self.plugins.run(<span class="string">"compare_providers"</span>, providers_dict=pkgresults, </span><br><span class="line">                              reqpo=reqpo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> pkgresults.keys():</span><br><span class="line">    rpmdbpkgs = self.rpmdb.searchNevra(name=pkg.name)</span><br><span class="line">    <span class="keyword">if</span> rpmdbpkgs:</span><br><span class="line">        <span class="comment">#  We only want to count things as "installed" if they are</span></span><br><span class="line">        <span class="comment"># older than what we are comparing, because this then an update</span></span><br><span class="line">        <span class="comment"># so we give preference. If they are newer then obsoletes/etc.</span></span><br><span class="line">        <span class="comment"># could play a part ... this probably needs a better fix.</span></span><br><span class="line">        newest = sorted(rpmdbpkgs)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> newest.verLT(pkg):</span><br><span class="line">            <span class="comment"># give pkgs which are updates just a SLIGHT edge</span></span><br><span class="line">            <span class="comment"># we should also make sure that any pkg</span></span><br><span class="line">            <span class="comment"># we are giving an edge to is not obsoleted by</span></span><br><span class="line">            <span class="comment"># something else in the transaction. :(</span></span><br><span class="line">            <span class="comment"># there are many ways I hate this - this is but one</span></span><br><span class="line">            pkgresults[pkg] += <span class="number">5</span></span><br><span class="line">        <span class="keyword">elif</span> newest.verEQ(pkg):</span><br><span class="line">            <span class="comment">#  We get here from bestPackagesFromList(), give a giant</span></span><br><span class="line">            <span class="comment"># bump to stuff that is already installed.</span></span><br><span class="line">            pkgresults[pkg] += <span class="number">1000</span></span><br><span class="line">        <span class="keyword">elif</span> newest.verGT(pkg):</span><br><span class="line">            <span class="comment"># if the version we're looking at is older than what we have installed</span></span><br><span class="line">            <span class="comment"># score it down like we would an obsoleted pkg</span></span><br><span class="line">            pkgresults[pkg] -= <span class="number">1024</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># just b/c they're not installed pkgs doesn't mean they should</span></span><br><span class="line">        <span class="comment"># be ignored entirely. Just not preferred</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>O(n^2)遍历 pkgs，先获取 Yum repo 中 newest version，然后保存下来，进行比对，如果当前 pkg 不等于 newest version，则 -1024 分。当前 repo 中匹配的 pkgs 列表一共 14 个， 遍历结束后每个 pkg 的分数应该是 13 * (-1024) = -13312。如果 pkg 被 nextpkg 所废除，那么 pkg 分数继续 -1024。如果传递了 arch 相关参数，那么会根据 arch 进行比较，如果哪个 pkg 提供了当前 arch 的包，那么会 +5 分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">lpos = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> po <span class="keyword">in</span> pkgs:</span><br><span class="line">    <span class="keyword">for</span> nextpo <span class="keyword">in</span> pkgs:</span><br><span class="line">        <span class="keyword">if</span> po == nextpo:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#  If this package isn't the latest version of said package,</span></span><br><span class="line">        <span class="comment"># treat it like it's obsoleted. The problem here is X-1</span></span><br><span class="line">        <span class="comment"># accidentally provides FOO, so you release X-2 without the</span></span><br><span class="line">        <span class="comment"># provide, but X-1 is still picked over a real provider.</span></span><br><span class="line">        <span class="keyword">if</span> po.name <span class="keyword">not</span> <span class="keyword">in</span> lpos:</span><br><span class="line">            lpos[po.name] = self.pkgSack.returnNewestByName(po.name)[:<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lpos[po.name] <span class="keyword">or</span> <span class="keyword">not</span> po.verEQ(lpos[po.name][<span class="number">0</span>]):</span><br><span class="line">            pkgresults[po] -= <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">        obsoleted = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> po.obsoletedBy([nextpo]):</span><br><span class="line">            obsoleted = <span class="keyword">True</span></span><br><span class="line">            pkgresults[po] -= <span class="number">1024</span></span><br><span class="line">                        </span><br><span class="line">            self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">                _(<span class="string">"%s obsoletes %s"</span>) % (nextpo, po))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> reqpo:</span><br><span class="line">            arches = (reqpo.arch, self.arch.bestarch)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arches = (self.arch.bestarch,)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> thisarch <span class="keyword">in</span> arches:</span><br><span class="line">            res = _compare_arch_distance(po, nextpo, thisarch)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.verbose_logger.log(logginglevels.DEBUG_4,                   </span><br><span class="line">               _(<span class="string">'archdist compared %s to %s on %s\n  Winner: %s'</span> % (po, nextpo, thisarch, res)))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> res == po:</span><br><span class="line">                pkgresults[po] += <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># End of O(N*N): for nextpo in pkgs:</span></span><br></pre></td></tr></table></figure><p>接下来会根据 pkg 是否存在 source rpm，是否是弱引用，是否是直接引用，是否存在冲突等进行分数的增减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># End of O(N*N): for nextpo in pkgs:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Respect the repository priority for each provider, the default is 80</span></span><br><span class="line">pkgresults[po] += (<span class="number">100</span> - po.repo.compare_providers_priority) * <span class="number">10</span></span><br><span class="line">self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">    _(<span class="string">'compare_providers_priority for %s is %s'</span> % (po, po.repo.compare_providers_priority)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _common_sourcerpm(po, reqpo):</span><br><span class="line">    self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">        _(<span class="string">'common sourcerpm %s and %s'</span> % (po, reqpo)))</span><br><span class="line">    pkgresults[po] += <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> _weak_req(po, reqpo):</span><br><span class="line">    self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">        _(<span class="string">'weak req %s and %s'</span> % (po, reqpo)))</span><br><span class="line">    pkgresults[po] += <span class="number">666</span></span><br><span class="line"><span class="keyword">if</span> _info_req(po, reqpo):</span><br><span class="line">    self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">        _(<span class="string">'informational req %s and %s'</span> % (po, reqpo)))</span><br><span class="line">    pkgresults[po] += <span class="number">333</span></span><br><span class="line"><span class="keyword">if</span> _conflict_req(po, reqpo):</span><br><span class="line">    self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">        _(<span class="string">'conflict req %s and %s'</span> % (po, reqpo)))</span><br><span class="line">    penalize.add(po)</span><br><span class="line"><span class="keyword">if</span> self.isPackageInstalled(po.base_package_name):</span><br><span class="line">    self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">        _(<span class="string">'base package %s is installed for %s'</span> % (po.base_package_name, po)))</span><br><span class="line">    pkgresults[po] += <span class="number">5</span> <span class="comment"># Same as before - - but off of base package name</span></span><br><span class="line"><span class="keyword">if</span> reqpo:</span><br><span class="line">    cpl = _common_prefix_len(po.name, reqpo.name)</span><br><span class="line">    <span class="keyword">if</span> cpl &gt; <span class="number">2</span>:</span><br><span class="line">        self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">            _(<span class="string">'common prefix of %s between %s and %s'</span> % (cpl, po, reqpo)))</span><br><span class="line">    </span><br><span class="line">        pkgresults[po] += cpl*<span class="number">2</span></span><br></pre></td></tr></table></figure><p>当基本分数进行打分完成后， 还存在多个 best pkg，那么会根据当前 OS 安装 pkg 所需依赖数量进行判定，依赖数量越少，则分数越高，最终依赖数量少的 pkg 分数 +1。此时部分 pkg 分数从 -13112 变为 -13111。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  If we have more than one "best", see what would happen if we picked</span></span><br><span class="line"><span class="comment"># each package ... ie. what things do they require that _aren't_ already</span></span><br><span class="line"><span class="comment"># installed/to-be-installed. In theory this can screw up due to:</span></span><br><span class="line"><span class="comment">#   pkgA =&gt; requires pkgX</span></span><br><span class="line"><span class="comment">#   pkgB =&gt; requires pkgY, requires pkgZ</span></span><br><span class="line"><span class="comment"># ...but pkgX requires 666 other things. Going recursive is</span></span><br><span class="line"><span class="comment"># "non-trivial" though, python != prolog. This seems to do "better"</span></span><br><span class="line"><span class="comment"># from simple testing though.</span></span><br><span class="line">bestnum = max(pkgresults.values()) <span class="comment"># 将当前 pkg 分数最大的置为 bestnum</span></span><br><span class="line">rec_depsolve = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> po <span class="keyword">in</span> pkgs:</span><br><span class="line">    <span class="keyword">if</span> pkgresults[po] != bestnum: <span class="comment"># 如果当前 pkg 分数不等于最高分，跳过</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    rec_depsolve[po] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> len(rec_depsolve) &gt; <span class="number">1</span>: <span class="comment"># 如果仍有多个 pkg，则进行依赖判定</span></span><br><span class="line">    <span class="keyword">for</span> po <span class="keyword">in</span> rec_depsolve:</span><br><span class="line">        fake_txmbr = TransactionMember(po)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  Note that this is just requirements, so you could also have</span></span><br><span class="line">        <span class="comment"># 4 requires for a single package. This might be fixable, if</span></span><br><span class="line">        <span class="comment"># needed, but given the above it's probably better to leave it</span></span><br><span class="line">        <span class="comment"># like this.</span></span><br><span class="line">        reqs = self._checkInstall(fake_txmbr) <span class="comment"># 检查安装 pkg 所需依赖</span></span><br><span class="line">        rec_depsolve[po] = len(reqs) <span class="comment"># 将依赖数量置为当前 pkg 的分数</span></span><br><span class="line"></span><br><span class="line">    bestnum = min(rec_depsolve.values()) <span class="comment"># 找到依赖数量最少的分数作为 bestnum </span></span><br><span class="line">    self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">                            _(<span class="string">'requires minimal: %d'</span>) % bestnum)</span><br><span class="line">    <span class="keyword">for</span> po <span class="keyword">in</span> rec_depsolve:</span><br><span class="line">        <span class="keyword">if</span> rec_depsolve[po] == bestnum: </span><br><span class="line">            self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">                    _(<span class="string">' Winner: %s'</span>) % po)</span><br><span class="line">            pkgresults[po] += <span class="number">1</span> <span class="comment"># 将依赖数量结果填充会 pkgresults 中，依赖数量最少的分数 +1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = rec_depsolve[po]</span><br><span class="line">            self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">                    _(<span class="string">' Loser(with %d): %s'</span>) % (num, po))</span><br></pre></td></tr></table></figure><p>将当前分数最高的置为 bestnum，遍历 pkgs，如果当前 pkg 分数等于 bestnum，则将其分数 +1000，并将其分数 +(pkg.name)*-1 。如果 -13111 + 1000 +(-3) = -12114。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  We don't want to decide to use a "shortest first", if something else</span></span><br><span class="line"><span class="comment"># has told us to pick something else. But we want to pick between</span></span><br><span class="line"><span class="comment"># multiple "best" packages. So we spike all the best packages (so</span></span><br><span class="line"><span class="comment"># only those can win) and then bump them down by package name length.</span></span><br><span class="line">bestnum = max(pkgresults.values())</span><br><span class="line"><span class="keyword">for</span> po <span class="keyword">in</span> pkgs:</span><br><span class="line">    <span class="keyword">if</span> pkgresults[po] != bestnum:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    pkgresults[po] += <span class="number">1000</span></span><br><span class="line">    pkgresults[po] += (len(po.name)*<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bump down any packages that we identified as "last-resort" in such a</span></span><br><span class="line"><span class="comment"># way that they all score below the worst overall score whilst keeping</span></span><br><span class="line"><span class="comment"># their relative differences.</span></span><br><span class="line">shift = max(pkgresults.values()) - min(pkgresults.values()) + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> po <span class="keyword">in</span> penalize:</span><br><span class="line">    pkgresults[po] -= shift</span><br><span class="line"></span><br><span class="line">bestorder = sorted(pkgresults.items(),</span><br><span class="line">                   key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>]), reverse=<span class="keyword">True</span>)</span><br><span class="line">self.verbose_logger.log(logginglevels.DEBUG_4,</span><br><span class="line">        _(<span class="string">'Best Order: %s'</span> % str(bestorder)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bestorder</span><br></pre></td></tr></table></figure><p>最终根据 pkg 分数进行重新排序，返回第一个结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发现这个问题最初是猜测是 Yum Repository 配置问题，阅读代码之后判定是 RPM 在某个版本依赖发生了改变，增加了某些依赖项，导致了 Yum 打分认为其分数较低，从而无法通过 yumdownloader 下载最新的 RPM。与相关同事确认，rc8 版本开始增加了部分依赖，调查结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司产品最终交付形态是 ISO，在涉及一个产品的多个 OEM 场景时，会选择在标准版本的基础上，删除某些软件包，新增某些软件包的形式来减少构
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 init 进程运行 Container</title>
    <link href="https://zdyxry.github.io/2022/03/05/%E4%BD%BF%E7%94%A8-init-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C-Container/"/>
    <id>https://zdyxry.github.io/2022/03/05/使用-init-进程运行-Container/</id>
    <published>2022-03-05T15:10:39.000Z</published>
    <updated>2022-06-26T03:30:00.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>关注过 Bare Metal 相关项目的同学应该都了解过系统的启动流程、如何快速的置备一台物理服务器等之类的实现方式，通常都需要运行一个 LiveOS 来实现某些动作。<br>在 Tinkerbell 项目中，使用 Linuxkit 来作为 LiveOS，Plunder 项目中使用 BOOTy 来作为 LiveOS。前几天 @thebsdbox 将 BOOTy 中的一部分抽离了出来，作为 ginit 展示主要的实现方式，可以更好的让我们理解安装环节中的具体细节。 今天来看一下这个项目。</p><p>如果安装一个 CentOS，那么通常是会通过 kernel + initramfs.img 启动，initramfs.img 中会包含 systemd 、anaconda、dracut 等一些列组件，然后通过 systemd 指定不同的 Target 所属/依赖/顺序来完成最终 Anaconda 调用。Anaconda 通过解析 <code>/proc/cmdline</code> 中的 KickStart 参数来决定自己的安装方式。</p><p>ginit 项目展示了以下内容：</p><ul><li>制作 initramfs.img </li><li>通过 Container image 制作一个 RAW image</li><li>通过 QEMU 使用 RAW image 和 Linux Kernel 来运行一个虚拟机</li><li>ginit 自动运行 Container 中 entrypoint 指令</li></ul><h2 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h2><h3 id="通过-Container-image-制作一个-RAW-image"><a href="#通过-Container-image-制作一个-RAW-image" class="headerlink" title="通过 Container image 制作一个 RAW image"></a>通过 Container image 制作一个 RAW image</h3><p>RAW image 中最终不会包含 Kernel 部分，以 Nginx Container 为例。提取 nginx:latest image 中的 <code>Entrypoint</code> ，通过 <code>dd</code> 置备一个 RAW image，并格式化为 ext4 ，raw image 作为 loop 设备挂载到本地，通过 <code>docker export</code> 将 Nginx Image 拷贝到挂载点下，卸载挂载点，最终 RAW image 包含了 Nginx Container 的所有内容。这里的 RAW image 因为不包含 kernel，所以无法直接启动，只是作为后续动作的依赖。</p><p>Nginx Container 默认的 <code>Entrypoint</code> 是 <code>docker-entrypoint.sh</code> ，通过这个脚本来做一些参数检查动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Lets build you a disk image!&quot;</span><br><span class="line">docker pull $1</span><br><span class="line">ENTRYPOINT=$(docker inspect -f &apos;&#123;&#123;.Config.Entrypoint&#125;&#125;&apos; $1 | sed &apos;s/[][]//g&apos;)</span><br><span class="line">echo &quot;Creating a 200MB Disk&quot;</span><br><span class="line">dd if=/dev/zero of=disk.img bs=1024k count=200</span><br><span class="line">mkfs.ext4 -F disk.img</span><br><span class="line">mkdir -p /tmp/disk</span><br><span class="line">mount -t ext4 -o loop disk.img /tmp/disk/</span><br><span class="line">echo &quot;Converting $1 to disk image&quot;</span><br><span class="line">docker create --name exporter $1 null</span><br><span class="line">docker export exporter | tar xv -C /tmp/disk</span><br><span class="line">docker rm exporter</span><br><span class="line">umount /tmp/disk</span><br><span class="line">echo The command $ENTRYPOINT will start this container</span><br></pre></td></tr></table></figure><h3 id="使用-ginit-制作-initramfs-img"><a href="#使用-ginit-制作-initramfs-img" class="headerlink" title="使用 ginit 制作 initramfs.img"></a>使用 ginit 制作 initramfs.img</h3><p>静态编译 ginit；下载并编译 busybox ，将 ginit 编译结果 init 放置到 <code>/</code> 路径下，通过 cpio 将 busybox 归档，使用 gzip 进行压缩。所有流程完成后，将最终得到的 initramfs.cpio.gz 拷贝到项目路径下。 initramfs 最终包含的是 busybox + ginit 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># syntax=docker/dockerfile:experimental</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Build ginit as an init</span><br><span class="line">FROM golang:1.17-alpine as dev</span><br><span class="line">RUN apk add --no-cache git ca-certificates gcc linux-headers musl-dev</span><br><span class="line">COPY . /go/src/github.com/thebsdbox/ginit/</span><br><span class="line">WORKDIR /go/src/github.com/thebsdbox/ginit</span><br><span class="line">ENV GO111MODULE=on</span><br><span class="line">RUN --mount=type=cache,sharing=locked,id=gomod,target=/go/pkg/mod/cache \</span><br><span class="line">    --mount=type=cache,sharing=locked,id=goroot,target=/root/.cache/go-build \</span><br><span class="line">    CGO_ENABLED=1 GOOS=linux go build -a -ldflags &quot;-linkmode external -extldflags &apos;-static&apos; -s -w&quot; -o init</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># Build Busybox</span><br><span class="line">FROM gcc:10.1.0 as Busybox</span><br><span class="line">RUN apt-get update; apt-get install -y cpio</span><br><span class="line">RUN curl -O https://busybox.net/downloads/busybox-1.31.1.tar.bz2</span><br><span class="line">RUN tar -xf busybox*bz2</span><br><span class="line">WORKDIR busybox-1.31.1</span><br><span class="line">RUN make defconfig; make LDFLAGS=-static CONFIG_PREFIX=./initramfs install</span><br><span class="line"></span><br><span class="line">WORKDIR initramfs </span><br><span class="line">COPY --from=dev /go/src/github.com/thebsdbox/ginit/init .</span><br><span class="line"></span><br><span class="line"># Package initramfs</span><br><span class="line">RUN find . -print0 | cpio --null -ov --format=newc &gt; ../initramfs.cpio </span><br><span class="line">RUN gzip ../initramfs.cpio</span><br><span class="line">RUN mv ../initramfs.cpio.gz /</span><br><span class="line"></span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=Busybox /initramfs.cpio.gz .</span><br></pre></td></tr></table></figure><h3 id="通过-QEMU-运行-Container-中的-EntryPoint-指令"><a href="#通过-QEMU-运行-Container-中的-EntryPoint-指令" class="headerlink" title="通过 QEMU 运行 Container 中的 EntryPoint 指令"></a>通过 QEMU 运行 Container 中的 EntryPoint 指令</h3><p>到目前状态，我们得到了 initramfs.img ，得到了 raw image，但是还缺少 Linux Kernel 。可以直接从 Ubuntu 提供的 <a href="http://archive.ubuntu.com/ubuntu/dists/focal-updates/main/installer-amd64/current/legacy-images/netboot/ubuntu-installer/amd64/" target="_blank" rel="noopener">netboot</a> 下载 <code>boot executable bzImage</code> 文件。</p><p>现在所有的准备工作都进行完成了，我们可以直接通过 QEMU 来运行虚拟机，其中 Nginx 所需运行环境在 RAW Image 中，ginit 所需运行环境在 initramfs 中。</p><p>前面有提到，Nginx Container 默认的 <code>Entrypoint</code> 是 <code>docker-entrypoint.sh</code>，用来做一些参数包装，所以这里我将参数改为了 <code>/usr/sbin/nginx</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -nographic \</span><br><span class="line">  -kernel ./linux \</span><br><span class="line">  -append &quot;entrypoint=/usr/sbin/nginx root=/dev/sda console=ttyS0&quot; \</span><br><span class="line">  -initrd ./initramfs.cpio.gz \</span><br><span class="line">  -hda ./disk.img \</span><br><span class="line">  -m 1G</span><br></pre></td></tr></table></figure><p>虚拟机 console 是 <code>ttyS0</code> ，通过终端运行可以直接查看启动日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[    1.469920] rtc_cmos 00:00: setting system clock to 2022-03-05T06:36:19 UTC (1646462179)</span><br><span class="line">[    1.525397] ata1.00: ATA-7: QEMU HARDDISK, 2.5+, max UDMA/100</span><br><span class="line">[    1.525579] ata1.00: 409600 sectors, multi 16: LBA48 </span><br><span class="line">[    1.532980] ata2.00: ATAPI: QEMU DVD-ROM, 2.5+, max UDMA/100</span><br><span class="line">[    1.540741] scsi 0:0:0:0: Direct-Access     ATA      QEMU HARDDISK    2.5+ PQ: 0 ANSI: 5</span><br><span class="line">[    1.545673] sd 0:0:0:0: [sda] 409600 512-byte logical blocks: (210 MB/200 MiB)</span><br><span class="line">[    1.547063] sd 0:0:0:0: [sda] Write Protect is off</span><br><span class="line">[    1.547515] sd 0:0:0:0: Attached scsi generic sg0 type 0</span><br><span class="line">[    1.548188] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn&apos;t support DPO or FUA</span><br><span class="line">[    1.550227] scsi 1:0:0:0: CD-ROM            QEMU     QEMU DVD-ROM     2.5+ PQ: 0 ANSI: 5</span><br><span class="line">[    1.568178] sd 0:0:0:0: [sda] Attached SCSI disk</span><br><span class="line">[    1.578345] sr 1:0:0:0: [sr0] scsi3-mmc drive: 4x/4x cd/rw xa/form2 tray</span><br><span class="line">[    1.578736] cdrom: Uniform CD-ROM driver Revision: 3.20</span><br><span class="line">[    1.582611] sr 1:0:0:0: Attached scsi generic sg1 type 5</span><br><span class="line">[    1.595655] Freeing unused decrypted memory: 2040K</span><br><span class="line">[    1.666044] Freeing unused kernel image memory: 2712K</span><br><span class="line">[    1.666482] Write protecting the kernel read-only data: 22528k</span><br><span class="line">[    1.669246] Freeing unused kernel image memory: 2008K</span><br><span class="line">[    1.670507] Freeing unused kernel image memory: 1192K</span><br><span class="line">[    1.742691] x86/mm: Checked W+X mappings: passed, no W+X pages found.</span><br><span class="line">[    1.743002] Run /init as init process</span><br><span class="line">INFO[0000] Folder created [dev] -&gt; [/dev]          </span><br><span class="line">INFO[0000] Folder created [proc] -&gt; [/proc]        </span><br><span class="line">INFO[0000] Folder created [sys] -&gt; [/sys]          </span><br><span class="line">INFO[0000] Folder created [tmp] -&gt; [/tmp]          </span><br><span class="line">INFO[0000] Mounted [dev] -&gt; [/dev]                 </span><br><span class="line">INFO[0000] Mounted [proc] -&gt; [/proc]               </span><br><span class="line">INFO[0000] Mounted [sys] -&gt; [/sys]                 </span><br><span class="line">INFO[0000] Mounted [tmp] -&gt; [/tmp]                 </span><br><span class="line">INFO[0000] Starting DHCP client                    </span><br><span class="line">INFO[0000] Starting ginit                          </span><br><span class="line">ERRO[0000] Error finding adapter [Link not found]  </span><br><span class="line">[    2.209227] tsc: Refined TSC clocksource calibration: 2893.182 MHz</span><br><span class="line">[    2.209573] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x29b41aa25d4, max_idle_ns: 440795325238 ns</span><br><span class="line">[    2.209984] clocksource: Switched to clocksource tsc</span><br><span class="line">INFO[0002] Beginning provisioning process          </span><br><span class="line">ERRO[0002] route ip+net: no such network interface </span><br><span class="line">INFO[0002] Folder created [root] -&gt; [/mnt]         </span><br><span class="line">[    3.902861] random: fast init done</span><br><span class="line">[    3.912319] EXT4-fs (sda): recovery complete</span><br><span class="line">[    3.913757] EXT4-fs (sda): mounted filesystem with ordered data mode. Opts: (null)</span><br><span class="line">[    3.914463] ext4 filesystem being mounted at /mnt supports timestamps until 2038 (0x7fffffff)</span><br><span class="line">INFO[0002] Mounted [root] -&gt; [/mnt]                </span><br><span class="line">INFO[0002] Mounted [dev] -&gt; [/mnt/dev]             </span><br><span class="line">INFO[0002] Mounted [proc] -&gt; [/mnt/proc]           </span><br><span class="line">INFO[0002] Starting Shell                          </span><br><span class="line">INFO[0002] Waiting for command to finish...        </span><br><span class="line">/ #</span><br></pre></td></tr></table></figure><p>其中 <code>[    1.743002] Run /init as init process</code> 中的 <code>/init</code> 已经是我们上面编译的 <code>ginit</code> ，<code>ginit</code> 运行的日志输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">INFO[0000] Folder created [dev] -&gt; [/dev]          </span><br><span class="line">INFO[0000] Folder created [proc] -&gt; [/proc]        </span><br><span class="line">INFO[0000] Folder created [sys] -&gt; [/sys]          </span><br><span class="line">INFO[0000] Folder created [tmp] -&gt; [/tmp]          </span><br><span class="line">INFO[0000] Mounted [dev] -&gt; [/dev]                 </span><br><span class="line">INFO[0000] Mounted [proc] -&gt; [/proc]               </span><br><span class="line">INFO[0000] Mounted [sys] -&gt; [/sys]                 </span><br><span class="line">INFO[0000] Mounted [tmp] -&gt; [/tmp]                 </span><br><span class="line">INFO[0000] Starting DHCP client                    </span><br><span class="line">INFO[0000] Starting ginit                          </span><br><span class="line">ERRO[0000] Error finding adapter [Link not found]  </span><br><span class="line">[    2.209227] tsc: Refined TSC clocksource calibration: 2893.182 MHz</span><br><span class="line">[    2.209573] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x29b41aa25d4, max_idle_ns: 440795325238 ns</span><br><span class="line">[    2.209984] clocksource: Switched to clocksource tsc</span><br><span class="line">INFO[0002] Beginning provisioning process          </span><br><span class="line">ERRO[0002] route ip+net: no such network interface </span><br><span class="line">INFO[0002] Folder created [root] -&gt; [/mnt]         </span><br><span class="line">[    3.902861] random: fast init done</span><br><span class="line">[    3.912319] EXT4-fs (sda): recovery complete</span><br><span class="line">[    3.913757] EXT4-fs (sda): mounted filesystem with ordered data mode. Opts: (null)</span><br><span class="line">[    3.914463] ext4 filesystem being mounted at /mnt supports timestamps until 2038 (0x7fffffff)</span><br><span class="line">INFO[0002] Mounted [root] -&gt; [/mnt]                </span><br><span class="line">INFO[0002] Mounted [dev] -&gt; [/mnt/dev]             </span><br><span class="line">INFO[0002] Mounted [proc] -&gt; [/mnt/proc]           </span><br><span class="line">INFO[0002] Starting Shell                          </span><br><span class="line">INFO[0002] Waiting for command to finish...</span><br></pre></td></tr></table></figure><p>主要做了几件事情：创建必要的路径，创建对应的设备，启动一个 DHCP Client 来获取 IP 地址，挂载 RAW Image 到 /mnt 下，通过 <code>chroot</code> 运行 <code>entrypoint</code> 参数中指定的程序，在这里是 <code>/usr/sbin/nginx</code> ，最终提供一个 Shell 环境给用户。我们可以通过 <code>ps</code> 命令查看当前所运行的进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/ # ps -ef |grep -v &apos;\[&apos;</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 0         0:01 /init</span><br><span class="line">  178 0         0:00 nginx: master process /usr/sbin/nginx</span><br><span class="line">  179 0         0:00 /bin/sh</span><br><span class="line">  180 101       0:00 nginx: worker process</span><br><span class="line">  193 0         0:00 ps -ef</span><br><span class="line">/ # df </span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">devtmpfs                497020         4    497016   0% /dev</span><br><span class="line">tmpfs                   502392         0    502392   0% /tmp</span><br><span class="line">/dev/sda                181984    150940     16708  90% /mnt</span><br><span class="line">devtmpfs                497020         4    497016   0% /mnt/dev</span><br><span class="line">/ # ls /mnt/docker-entrypoint.sh </span><br><span class="line">/mnt/docker-entrypoint.sh</span><br><span class="line">/ # ls /mnt/usr/sbin/nginx</span><br><span class="line">/mnt/usr/sbin/nginx</span><br><span class="line">/ # ls -hl /init</span><br><span class="line">-rwxr-xr-x    1 0        0           3.4M Mar  5 04:20 /init</span><br></pre></td></tr></table></figure><p>现在我们已经将一个 Container Image 中要运行的指令，通过 Linux kernel 配合 initramfs 来运行了起来，在 Bare Metal 场景下，我们可以将 Nginx 内置到 initramfs 中，将 Nginx 替换为 Docker 或者 Container 然后暴露出去，物理服务器作为 Docker Server，置备服务器作为 Docker Client 连接物理服务器进行指定容器的运行，最终完成物理服务器 OS 的安装，这也是目前 TinkerBell 的实现方式。</p><h2 id="ginit-具体实现"><a href="#ginit-具体实现" class="headerlink" title="ginit 具体实现"></a>ginit 具体实现</h2><h3 id="创建系统设备并挂载"><a href="#创建系统设备并挂载" class="headerlink" title="创建系统设备并挂载"></a>创建系统设备并挂载</h3><p>在 <code>DefaultMounts</code> 和 <code>DefaultDevices</code> 中定义了一些必须的设备如 <code>/dev/null</code>, <code>/dev/random</code>, <code>/dev/urandom</code> ，和挂载点，如 <code>/dev</code>,<code>/proc</code>, <code>/tmp</code>, <code>/sys</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">urandom := Device&#123;</span><br><span class="line">CreateDevice: false,</span><br><span class="line"></span><br><span class="line">Name:  &quot;urandom&quot;,</span><br><span class="line">Path:  &quot;/dev/urandom&quot;,</span><br><span class="line">Mode:  syscall.S_IFCHR,</span><br><span class="line">Major: 1,</span><br><span class="line">Minor: 9,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dev := Mount&#123;</span><br><span class="line">CreateMount: false,</span><br><span class="line">EnableMount: false,</span><br><span class="line">Name:        &quot;dev&quot;,</span><br><span class="line">Source:      &quot;devtmpfs&quot;,</span><br><span class="line">Path:        &quot;/dev&quot;,</span><br><span class="line">FSType:      &quot;devtmpfs&quot;,</span><br><span class="line">Flags:       syscall.MS_MGC_VAL,</span><br><span class="line">Mode:        0777,</span><br><span class="line">&#125;</span><br><span class="line">m.Mount = append(m.Mount, dev)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//cmd.Execute()</span><br><span class="line">m := realm.DefaultMounts()</span><br><span class="line">d := realm.DefaultDevices()</span><br><span class="line">dev := m.GetMount(&quot;dev&quot;)</span><br><span class="line">dev.CreateMount = true</span><br><span class="line">dev.EnableMount = true</span><br><span class="line"></span><br><span class="line">proc := m.GetMount(&quot;proc&quot;)</span><br><span class="line">proc.CreateMount = true</span><br><span class="line">proc.EnableMount = true</span><br><span class="line"></span><br><span class="line">tmp := m.GetMount(&quot;tmp&quot;)</span><br><span class="line">tmp.CreateMount = true</span><br><span class="line">tmp.EnableMount = true</span><br><span class="line"></span><br><span class="line">sys := m.GetMount(&quot;sys&quot;)</span><br><span class="line">sys.CreateMount = true</span><br><span class="line">sys.EnableMount = true</span><br><span class="line"></span><br><span class="line">// Create all folders</span><br><span class="line">m.CreateFolder()</span><br><span class="line">// Ensure that /dev is mounted (first)</span><br><span class="line">m.MountNamed(&quot;dev&quot;, true)</span><br><span class="line"></span><br><span class="line">// Create all devices</span><br><span class="line">d.CreateDevice()</span><br><span class="line"></span><br><span class="line">// Mount any additional mounts</span><br><span class="line">m.MountAll()</span><br></pre></td></tr></table></figure><p>在基本环境准备完成后，启动 DHCP Client，获取 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">log.Println(&quot;Starting DHCP client&quot;)</span><br><span class="line">go realm.DHCPClient()</span><br><span class="line"></span><br><span class="line">// HERE IS WHERE THE MAIN CODE GOES</span><br><span class="line">log.Infoln(&quot;Starting ginit&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line"></span><br><span class="line">log.Infoln(&quot;Beginning provisioning process&quot;)</span><br><span class="line"></span><br><span class="line">mac, err := realm.GetMAC()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorln(err)</span><br><span class="line">//realm.Shell()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(mac)</span><br></pre></td></tr></table></figure><p>现在系统环境准备好了，网络也准备好了，那么可以运行具体的指令了，获取指令的方式是通过解析 <code>/proc/cmdline</code> ，<code>/proc/cmdline</code> 是通过我们在创建 VM 的时候通过 <code>--append</code> 传递的：</p><p>在解析到 <code>root</code> 和 <code>entrypoint</code> 参数值后，通过 <code>Mount</code> 将 <code>root</code> 挂载到对应的挂载点，通过 <code>chroot</code> 运行 <code>entrypoint</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   stuffs, err := ParseCmdLine(CmdlinePath)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorln(err)</span><br><span class="line">&#125;</span><br><span class="line">_, err = realm.MountRootVolume(stuffs[&quot;root&quot;])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;Disk Error: [%v]&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(&quot;/usr/sbin/chroot&quot;, []string&#123;&quot;/mnt&quot;, stuffs[&quot;entrypoint&quot;]&#125;...)</span><br><span class="line">cmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr</span><br><span class="line"></span><br><span class="line">err = cmd.Start()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;command error [%v]&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">err = cmd.Wait()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;error [%v]&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">realm.Shell()</span><br></pre></td></tr></table></figure><p>所有程序运行完成后，提供一个Shell 环境给用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Shell will Start a userland shell</span><br><span class="line">func Shell() &#123;</span><br><span class="line">// Shell stuff</span><br><span class="line">log.Println(&quot;Starting Shell&quot;)</span><br><span class="line"></span><br><span class="line">// TTY hack to support ctrl+c</span><br><span class="line">cmd := exec.Command(&quot;/usr/bin/setsid&quot;, &quot;cttyhack&quot;, &quot;/bin/sh&quot;)</span><br><span class="line">cmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr</span><br><span class="line"></span><br><span class="line">err := cmd.Start()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;Shell error [%v]&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(&quot;Waiting for command to finish...&quot;)</span><br><span class="line">err = cmd.Wait()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Errorf(&quot;Shell error [%v]&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ginit 作为一个最小实现方便我们快速了解 init 具体做了什么，将 ginit 替换为 systemd 同理，但是直接看 systemd bootup 容易迷失在成堆的 Target 依赖中。在查找资料的过程中还看到了 <a href="https://github.com/QuentinPerez/busygox" target="_blank" rel="noopener">https://github.com/QuentinPerez/busygox</a> 做了类似的事情，可以作为参考。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/thebsdbox/ginit" target="_blank" rel="noopener">https://github.com/thebsdbox/ginit</a></li><li><a href="https://unix.stackexchange.com/questions/146284/minimal-linux-with-kernel-and-busybox-etc-inittab-is-ignored-only-init-is-ex/147688#147688" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/146284/minimal-linux-with-kernel-and-busybox-etc-inittab-is-ignored-only-init-is-ex/147688#147688</a></li><li><a href="https://github.com/QuentinPerez/busygox" target="_blank" rel="noopener">https://github.com/QuentinPerez/busygox</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;关注过 Bare Metal 相关项目的同学应该都了解过系统的启动流程、如何快速的置备一台物理服务器等之类的实现方式，通常都需要运行一个 L
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>编写一个友好的命令行工具</title>
    <link href="https://zdyxry.github.io/2022/02/26/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%8B%E5%A5%BD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>https://zdyxry.github.io/2022/02/26/编写一个友好的命令行工具/</id>
    <published>2022-02-26T19:50:44.000Z</published>
    <updated>2022-06-26T03:30:00.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>关于命令行设计的一点总结。</p><h3 id="有用的帮助信息"><a href="#有用的帮助信息" class="headerlink" title="有用的帮助信息"></a>有用的帮助信息</h3><p>提供的命令行中所有的命令、子命令、选项都有明确的帮助信息，便于用户在使用过程中查看。帮助信息查看方式最好统一，比如统一使用 <code>-h</code> 格式、 <code>COMMAND help</code> 或者 <code>COMMAND --help</code> 。</p><h3 id="尽量使用-Flags-而不是-Args"><a href="#尽量使用-Flags-而不是-Args" class="headerlink" title="尽量使用 Flags 而不是 Args"></a>尽量使用 Flags 而不是 Args</h3><p>命令行可以接受 2 种类型的参数输入：Flags 和 Args。Flags 需要更多的输入，但会使命令行更清晰。我在实现一个命令行时，通常会将必选项设置为 Args ，将可选项设置为 Flags，但是有时候会导致用户在使用过程中觉得传递参数方式不统一，而且当 Args 有多个时（是的，我之前设计的一个命令行输入的 Args 多达 5 个）用户敲着敲着就不知道自己该输入什么了。如果在后续对命令行进行重构时，为了保证接口的兼容性，Args 通常是需要保证不变的，而 Flags 没有这个困扰。</p><h3 id="明确显示当前版本"><a href="#明确显示当前版本" class="headerlink" title="明确显示当前版本"></a>明确显示当前版本</h3><p>在使用过程中，如果遇到了问题，那么通常需要上报命令行版本反馈，需要明确给出当前命令行所指定的版本。通常会有 <code>-v</code>, <code>-V</code>, <code>--version</code>, <code>version</code> 等子命令，其中 <code>-v</code> 和 <code>-V</code> 有可能会跟 <code>verbose</code> 混淆，建议将版本作为一个独立的子命令 <code>version</code> 来实现。</p><h3 id="针对-stdint-stdout-stderr-正确处理"><a href="#针对-stdint-stdout-stderr-正确处理" class="headerlink" title="针对 stdint, stdout, stderr 正确处理"></a>针对 stdint, stdout, stderr 正确处理</h3><p>如果已知一个命令行的执行耗时较长，那么用户通常执行命令时会选择将 stdout 重定向到指定文件中，便于后续查看执行过程输出，留存。但是如果在执行过程中出现异常，那么尽量将异常信息通过 stderr 输出，及时暴露给用户。默认情况下 stdout 被重定向之后，stderr 仍会打印在终端中。</p><h3 id="明确的错误信息"><a href="#明确的错误信息" class="headerlink" title="明确的错误信息"></a>明确的错误信息</h3><p>当用户在执行命令过程中遇到错误，需要尽可能的显示多的、有用的信息出来：错误码、错误描述、错误信息。给出的信息是人类友好的，毕竟针对错误进行调试的是我们自己。尽量保证自己的命令行提供调试模式（类似于 Shell 中的 <code>set -x</code> ），便于 debug。</p><h3 id="不要过分花里胡哨"><a href="#不要过分花里胡哨" class="headerlink" title="不要过分花里胡哨"></a>不要过分花里胡哨</h3><p>现在许多命令行会在执行过程中，为了保证自己的输出尽可能的“好看”，可能会做各种丧心病狂的事情（比如塞入 emoji），我建议尽量不要做这种事情，会带来很多心智负担。</p><h3 id="（如果可能的话）不要输出表格"><a href="#（如果可能的话）不要输出表格" class="headerlink" title="（如果可能的话）不要输出表格"></a>（如果可能的话）不要输出表格</h3><p>有时候命令执行结果返回中，包含的信息量很大，那么通常会使用各种 table lib 来“友好”的展示信息。这类信息可能会导致在后续进行二次处理（sed, awk）过程中增加工作量，需要额外的过滤表格中的字符。如果一定需要展，那么尽可能提供可选项，给出一个其他的输出格式，比如 json，比如 yaml 等等。</p><h3 id="保证执行速度"><a href="#保证执行速度" class="headerlink" title="保证执行速度"></a>保证执行速度</h3><p>尽量保证命令行执行耗时较短，如果耗时较长，那么可能遇到的网络问题导致命令执行中断的概率增加。在执行过程中，尽量让用户感受到命令是在执行的，给出明确的交互状态，不要让用户感觉命令 hang 住。</p><h3 id="处理好信号"><a href="#处理好信号" class="headerlink" title="处理好信号"></a>处理好信号</h3><p>当用户在执行一个命令的时候，保证用户可以最终停止它。在处理信号的过程中，可以合理的输出一些有用的提示告知用户当前正在进行什么动作。</p><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>尽量保证命令行幂等，当命令执行失败之后，可以让用户再次执行该命令以完成最终目的，否则会相当痛苦。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://clig.dev/?utm_source=pocket_mylist" target="_blank" rel="noopener">https://clig.dev/?utm_source=pocket_mylist</a></li><li><a href="https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46" target="_blank" rel="noopener">https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;关于命令行设计的一点总结。&lt;/p&gt;
&lt;h3 id=&quot;有用的帮助信息&quot;&gt;&lt;a href=&quot;#有用的帮助信息&quot; class=&quot;headerlin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于 Yamux 的内网穿透简易实现</title>
    <link href="https://zdyxry.github.io/2022/02/09/%E5%9F%BA%E4%BA%8E-Yamux-%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zdyxry.github.io/2022/02/09/基于-Yamux-的内网穿透简易实现/</id>
    <published>2022-02-09T11:57:51.000Z</published>
    <updated>2022-06-26T03:30:00.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-Yamux-的内网穿透简易实现"><a href="#基于-Yamux-的内网穿透简易实现" class="headerlink" title="基于 Yamux 的内网穿透简易实现"></a>基于 Yamux 的内网穿透简易实现</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>模拟真实服务器，假设运行在内网环境，端口 8881。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(&quot;/hello&quot;, HelloHandler)</span><br><span class="line">    fmt.Println(&quot;Server started at port 8881&quot;)</span><br><span class="line">    log.Fatal(http.ListenAndServe(&quot;:8881&quot;, nil))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HelloHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    fmt.Fprintf(w, &quot;Hello, there\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hub"><a href="#Hub" class="headerlink" title="Hub"></a>Hub</h3><p>运行在公网环境的 Hub，用于 Agent 连接，并保持会话。端口 8882。</p><p>提供 session 管理机制，主要用来保存 Yamux session 和 Agent 对应关系。<br>每个内网可以运行多个 Agent，每次新建连接会从已有的 Agent session 列表中随机选择一个 session，并通过创建一个新的 Yamux Stream 机制复用连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SessionManager <span class="keyword">interface</span> &#123;</span><br><span class="line">AddSession(key <span class="keyword">string</span>, sess *yamux.Session)</span><br><span class="line">DialTarget(key <span class="keyword">string</span>) (net.Conn, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSessionManager</span><span class="params">()</span> <span class="title">SessionManager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;sessionManager&#123;</span><br><span class="line">sessions: <span class="keyword">map</span>[<span class="keyword">string</span>][]*yamux.Session&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sessionManager <span class="keyword">struct</span> &#123;</span><br><span class="line">sessions <span class="keyword">map</span>[<span class="keyword">string</span>][]*yamux.Session</span><br><span class="line">mutex    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *sessionManager)</span> <span class="title">AddSession</span><span class="params">(key <span class="keyword">string</span>, sess *yamux.Session)</span></span> &#123;</span><br><span class="line">m.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">curr := m.sessions[key]</span><br><span class="line"><span class="keyword">if</span> curr == <span class="literal">nil</span> &#123;</span><br><span class="line">curr = []*yamux.Session&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">curr = <span class="built_in">append</span>(curr, sess)</span><br><span class="line">m.sessions[key] = curr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *sessionManager)</span> <span class="title">DialTarget</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">m.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">ss := m.sessions[key]</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ss) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"no session found in '%s'"</span>, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx := rand.Intn(<span class="built_in">len</span>(ss))</span><br><span class="line">conn, err := ss[idx].Open()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"removing session #%d of '%s' due to dial error: %s"</span>, idx, key, err)</span><br><span class="line">ss[idx].Close()</span><br><span class="line">ss = <span class="built_in">append</span>(ss[:idx], ss[idx+<span class="number">1</span>:]...)</span><br><span class="line">m.sessions[key] = ss</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"find session with key '%s'"</span>, key)</span><br><span class="line"><span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hub 自身暴露两个 API 接口，其中 <code>/api/v1/hubs/:id</code> 用于 Agent 建立 WebSocket 连接，<code>api/v1/proxy/:id/*proxyPath</code> 用于后续 Client 通过 Hub 访问 Server 。当用户访问 <code>/api/v1/proxy/</code> 并指定 Agent ID 时，通过<code>NewSingleHostReverseProxy</code> 创建反向代理，并指定 Transport 中的 conn 为 Yamux Stream。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupHandlers</span><span class="params">(r *gin.RouterGroup)</span></span> &#123;</span><br><span class="line">m := NewSessionManager()</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">"/hubs/:id"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">upgrader := websocket.Upgrader&#123;</span><br><span class="line">ReadBufferSize:  <span class="number">1024</span>,</span><br><span class="line">WriteBufferSize: <span class="number">1024</span>,</span><br><span class="line">&#125;</span><br><span class="line">conn, err := upgrader.Upgrade(c.Writer, c.Request, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: fmt.Sprintf(<span class="string">"failed to upgrade to WebSocket: %s"</span>, err)&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session, err := yamux.Server(conn.UnderlyingConn(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: fmt.Sprintf(<span class="string">"failed to multiplex channel: %s"</span>, err)&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.AddSession(c.Param(<span class="string">"id"</span>), session)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Any(<span class="string">"/proxy/:id/*proxyPath"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">u, err := url.Parse(<span class="string">"http://127.0.0.1"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rp := httputil.NewSingleHostReverseProxy(u)</span><br><span class="line">key := c.Param(<span class="string">"id"</span>)</span><br><span class="line">rp.Transport = &amp;http.Transport&#123;</span><br><span class="line">DialContext: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network <span class="keyword">string</span>, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">conn, err := m.DialTarget(key)</span><br><span class="line"><span class="keyword">return</span> conn, err</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">rp.ErrorHandler = <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, err error)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"msg"</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hostInQuery, exist := c.GetQuery(<span class="string">"x-proxy-host"</span>)</span><br><span class="line"><span class="keyword">if</span> exist == <span class="literal">true</span> &#123;</span><br><span class="line">c.Request.Header.Add(<span class="string">"X-Proxy-Host"</span>, hostInQuery)</span><br><span class="line">&#125;</span><br><span class="line">c.Request.Header.Add(<span class="string">"X-Proxy-Path"</span>, c.Param(<span class="string">"proxyPath"</span>))</span><br><span class="line">rp.ServeHTTP(c.Writer, c.Request)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupRouter</span><span class="params">()</span> <span class="params">(*gin.Engine, error)</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">v1 := r.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">SetupHandlers(v1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>内网可以运行多个 Agent 用于连接 Hub，Agent 会通过 WebSocket 连接 Hub，后续所有通信均通过该连接进行传输。在连接建立后，创建 ReverseProxy，配置 Direcotr 修改 Request 参数，指定 host,path。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setup</span><span class="params">(connectURL <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">dialer := websocket.DefaultDialer</span><br><span class="line">dialer.TLSClientConfig = &amp;tls.Config&#123;</span><br><span class="line">InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">wsConn, _, err := dialer.Dial(connectURL, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(fmt.Sprintf(<span class="string">"failed to dial hub %q: %s"</span>, connectURL, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sess, err := yamux.Client(wsConn.UnderlyingConn(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(fmt.Sprintf(<span class="string">"failed to create multiplex channel: %s"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">"connected to hub"</span>)</span><br><span class="line"></span><br><span class="line">director := <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line">log.Println(req)</span><br><span class="line">host := req.Header.Get(<span class="string">"X-Proxy-Host"</span>)</span><br><span class="line">path := req.Header.Get(<span class="string">"X-Proxy-Path"</span>)</span><br><span class="line">req.Header.Add(<span class="string">"X-Forwarded-Host"</span>, req.Host)</span><br><span class="line">req.Header.Add(<span class="string">"X-Origin-Host"</span>, host)</span><br><span class="line">req.URL.Scheme = <span class="string">"http"</span></span><br><span class="line">req.URL.Host = host</span><br><span class="line">req.URL.Path = path</span><br><span class="line">req.Host = <span class="string">""</span></span><br><span class="line">log.Println(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy := &amp;httputil.ReverseProxy&#123;Director: director&#125;</span><br><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">Handler: proxy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idleConnsClosed := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">sigint := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(sigint, os.Interrupt)</span><br><span class="line">signal.Notify(sigint, syscall.SIGTERM)</span><br><span class="line">&lt;-sigint</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := server.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"failed to shutdown server: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(idleConnsClosed)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"starting proxy"</span>)</span><br><span class="line"><span class="keyword">if</span> err := server.Serve(sess); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(fmt.Sprintf(<span class="string">"error running proxy: %s"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-idleConnsClosed</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>Client 可以通过访问 Hub 的 proxy API，将真实请求转发至 Agent ，再由 Agent 请求 Server。</p><h3 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h3><ol><li>运行 Hub 对外提供服务</li><li>运行 Agent 通过 WebSocket 连接至 Hub，并创建 ReverseProxy</li><li>Client 请求 Hub proxy API</li><li>Hub 在已有 Session（WebSocket）上 Yamux Stream 将请求转发至 Agent</li><li>Agent 解析 Request，并将请求转发至 Server，返回</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/hashicorp/yamux" target="_blank" rel="noopener">https://github.com/hashicorp/yamux</a></li><li><a href="https://github.com/smartxworks/kopilot" target="_blank" rel="noopener">https://github.com/smartxworks/kopilot</a></li><li><a href="https://gist.github.com/fengye87/76791723511f6867b02723ba0c437315" target="_blank" rel="noopener">https://gist.github.com/fengye87/76791723511f6867b02723ba0c437315</a></li><li><a href="https://stackoverflow.com/questions/60657906/websocket-over-yamux-over-websocket-not-working" target="_blank" rel="noopener">https://stackoverflow.com/questions/60657906/websocket-over-yamux-over-websocket-not-working</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于-Yamux-的内网穿透简易实现&quot;&gt;&lt;a href=&quot;#基于-Yamux-的内网穿透简易实现&quot; class=&quot;headerlink&quot; title=&quot;基于 Yamux 的内网穿透简易实现&quot;&gt;&lt;/a&gt;基于 Yamux 的内网穿透简易实现&lt;/h2&gt;&lt;h3 id=&quot;S
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://zdyxry.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>2021 年读书记录</title>
    <link href="https://zdyxry.github.io/2021/12/31/2021-%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2021/12/31/2021-年读书记录/</id>
    <published>2021-12-31T09:01:41.000Z</published>
    <updated>2022-06-26T03:30:00.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><ul><li><a href="https://zdyxry.github.io/2016/12/31/2016%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2016</a><ul><li>计划读 5 本，实际读 13 本。</li></ul></li><li><a href="https://zdyxry.github.io/2017/12/31/2017%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2017</a><ul><li>计划 32 本，实际读完 23 本。</li></ul></li><li><a href="https://zdyxry.github.io/2018/12/30/2018%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2018</a><ul><li>计划 30 本，实际25本。</li></ul></li><li><a href="https://zdyxry.github.io/2019/12/09/2019%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2019</a><ul><li>计划 30 本，实际 43 本。</li></ul></li><li><a href="https://zdyxry.github.io/2020/12/28/2020%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2020</a><ul><li>计划 30 本，实际 40 本。</li></ul></li><li>2021<ul><li>计划 50 本，实际 47 本。</li></ul></li></ul><h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ol><li>《Linux C编程一站式学习》</li><li>《现代操作系统：原理与实现》</li><li>《封锁》</li><li>《指数基金投资》</li><li>《指数基金投资指南》</li><li>《小狗钱钱》</li><li>《富爸爸穷爸爸》</li><li>《The Almanack of Naval Ravikant》</li><li>《让时间陪你慢慢变富》</li><li>《韭菜的自我修养》</li><li>《labuladong的算法小抄》</li><li>《人人都能用英语》</li><li>《仿制药的真相》</li><li>《Kubernetes源码剖析》</li><li>《如何高效学习》</li><li>《你的第一本保险指南》</li><li>《跑步圣经》</li><li>《当我谈跑步时我谈些什么》</li><li>《柴犬绅士》</li><li>《咖啡新规则》</li><li>《深度休息》</li><li>《爱上跑步的13周》</li><li>《金阁寺》</li><li>《UNIX传奇》</li><li>《间客》</li><li>《工薪族财务自由说明书》</li><li>《分布式缓存》</li><li>《剑指Offer》</li><li>《商业的本质和互联网》</li><li>《哈利·波特》</li><li>《Go语言编程》</li><li>《卡片笔记写作法》</li><li>《图解网络硬件》</li><li>《喜剧这回事》</li><li>《gRPC与云原生应用开发》</li><li>《HTTP/2 in Action 中文版》</li><li>《代码整洁之道》</li><li>《李诞脱口秀工作手册》</li><li>《娱乐至死》</li><li>《深入浅出 HTTPS：从原理到实战》</li><li>《骆驼祥子》</li><li>《沉默的大多数》</li><li>《智能时代》</li><li>《被看见的力量》</li><li>《拒看新聞的生活藝術》</li><li>《JavaScript DOM编程艺术 （第2版）》</li><li>《非暴力沟通》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zdyxry.github.io/2016/12/31/2016%E5%B9%
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>DHCP lease 生命周期</title>
    <link href="https://zdyxry.github.io/2021/12/18/DHCP-lease-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://zdyxry.github.io/2021/12/18/DHCP-lease-生命周期/</id>
    <published>2021-12-18T18:42:08.000Z</published>
    <updated>2022-06-26T03:30:00.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天配合一个同事排查虚拟机 IP 发生了变化的问题，正好整理一下 DHCP lease 生命周期以及变化流程。</p><h2 id="DHCP-lease-生命周期"><a href="#DHCP-lease-生命周期" class="headerlink" title="DHCP lease 生命周期"></a>DHCP lease 生命周期</h2><ul><li>Allocation：一个客户端开始时没有有效的租约，因此也没有 DHCP 分配的地址。它通过一个分配过程获得一个租约。</li><li>Reallocation：如果一个客户端已经有了一个来自现有租约的地址，那么当它重启或关闭后启动时，它将与授予它租约的 DHCP 服务器联系，以确认租约并获得操作参数。这有时被称为重新分配；它与完全分配过程相似，但时间更短。</li><li>Normal Operation：一旦租约被激活，客户端就会正常工作，在租约周期内使用其分配的IP地址和其他参数。客户端被称为与租约和地址绑定。</li><li>Renewal：在租约时间的某一部分过期后，客户端将试图联系最初授予租约的服务器，以更新租约，这样它就可以继续使用其 IP 地址。</li><li>Rebinding：如果与最初的租约服务器续约失败（例如，因为该服务器已经下线），那么客户端将尝试重新绑定到任何活跃的 DHCP 服务器，试图在任何允许它这样做的服务器上延长其当前租约。</li><li>Release：客户端可以在任何时候决定它不再希望使用它被分配的IP地址，并可以终止租约，释放 IP 地址。</li></ul><h2 id="Allocation-流程"><a href="#Allocation-流程" class="headerlink" title="Allocation 流程"></a>Allocation 流程</h2><pre><code>- 1.客户端创建 DHCPDISCOVER 消息  客户端开始处于INIT（初始化）状态。它没有IP地址，甚至不知道网络上是否有 DHCP 服务器或在哪里。为了找到一个，它创建了一个 DHCPDISCOVER 消息，包括以下信息。    - 在消息的 CHAddr 字段中包含自己的硬件地址，用来识别自身。    - 一个随机的交易标识符，放在 XID 字段中，这被用来识别以后的消息是同一事务的一部分。    - 另外，客户可以使用 `Requested IP Address` DHCP 选项请求一个特定的IP地址，使用IP地址 `Lease Time` 选项请求一个特定的租约长度，或通过在报文中加入`Parameter Request List`选项请求特定的配置参数。- 2.客户端发送 DHCPDISCOVER 消息  客户端在本地网络上广播 DHCPDISCOVER 消息。客户端过渡到 SELECTING 状态，在那里等待对其消息的回复。- 3.服务器接收并处理 DHCPDISCOVER 消息  本地网络上的每个 DHCP 服务器都会收到客户的 DHCPDISCOVER 消息并进行检查。服务器在其数据库中查找客户的硬件地址，并确定它是否能够为客户提供租约，以及租约的条款是什么。如果客户对一个特定的IP地址、租约长度或其他参数提出了要求，服务器将试图满足这些要求，但并不要求这样做。如果一个服务器没有被设定为为某一特定客户提供服务，它没有剩余的IP地址，或出于其他原因，它可以决定不向该客户提供租约。- 4.服务器创建 DHCPOFFER 消息  每个选择响应客户端的服务器都会创建一个包括以下信息的DHCPOFFER消息。    - 在 YIAddr 字段中包含要分配给客户的IP地址，如果服务器以前曾为该客户租用过，它将尝试重新使用上次使用的 IP 地址。如果没有，它将尝试使用客户要求的地址（如果存在）；否则，它将选择任何可用的地址。    - 所提供的租约长度。    - 客户端要求的任何特定于客户端的配置参数，或者在服务器返回给客户端的参数。    - 任何要返回给所有客户端或该客户端类别中的一般配置参数。    - DHCP 服务器标识符选项中的服务器标识符。    - 与 DHCPDISCOVER 消息中使用的交易ID（XID）相同。- 5. 服务器探测，保留提供的地址（可选）  DHCP标准规定，在向客户发送DHCPOFFER之前，服务器 &quot;应该 &quot;通过向该地址发送一个 ICMP Echo 消息来检查该IP地址是否已经被使用。如果探测到该地址正在使用，服务器当然不会将其提供给客户。这可以由管理员禁用。它被认为是DHCP服务器冲突检测功能的一个关键部分。  无论它是否探测所提供的地址，服务器也可以保留该地址，以便如果客户决定使用它，它将是可用的。这不是强制性的，因为正如我们将在下面看到的，协议会处理提供的租约被收回的情况。如果服务器保留地址，效率会更高，但如果IP地址非常短缺，这种保留可能并不实际。- 6. 服务器发送 DHCPOFFER 消息  每个服务器都会发送其 DHCPOFFER 消息。当然，它们不一定都是在完全相同的时间发送。如前所述，这些消息可以是单播的，也可以是广播的。- 7. 客户端收集和处理 DHCPOFFER 消息  客户端等待 DHCPOFFER 消息的到来，作为对其 DHCPDISCOVER 的回应。客户端在这里的确切行为是与实现有关的。为了方便起见，客户可能决定简单地接受它收到的第一个提议。或者它也可以选择通过等待一段时间来进行比较。然后它可以处理每一个 DHCPOFFER，并选择具有最有利条件的 DHCPOFFER--例如，具有最长租期的那一个。  如果没有收到 DHCPOFFER 消息，客户端将进入重传模式，并尝试在一段时间内再次发送DHCPDISCOVER。- 8. 客户端创建 DHCPREQUEST 消息  客户端为其选择的服务器 DHCPOFFER 创建一个 DHCPREQUEST 消息。这个消息有两个作用：它告诉客户接受其提议的服务器 &quot;是的，我接受你的提议，假设它仍然可用&quot;，同时也告诉其他服务器 &quot;对不起，你的提议被拒绝&quot;。在这个消息中，客户端包括以下信息。    - 在 DHCP 服务器标识符选项中，被选中的服务器的标识符。    - DHCP 服务器在 DHCPOFFER 消息中分配给客户的 IP 地址，客户在 `Requested IP Address` DHCP选项中把它作为确认地址    - 它在消息中的参数请求列表选项中想要的任何其他配置参数。- 9. 客户端发送 DHCPREQUEST 消息  客户端发送 DHCPREQUEST 消息。由于它不只是针对选定的 DHCP 服务器，而是针对所有的DHCP 服务器，所以它是广播的。这样做之后，客户端过渡到 REQUESTING 状态，在那里它等待来自所选服务器的回复。- 10. 服务器接收和处理 DHCPREQUEST 消息  每个服务器都接收并处理客户的请求信息。未被选中的服务器将把该消息视为拒绝。然而，请注意，客户可能会选择一个OFFER ，试图请求租约单没有成功完成。然后，客户可以通过发送包含不同服务器标识符的 DHCPREQUEST 来尝试其 &quot;第二选择 &quot;的 OFFER。这意味着，如果服务器A收到一个服务器标识符为服务器B的单一DHCPREQUEST，这并不一定意味着服务器A已经完成了。由于这个原因，&quot;被拒绝 &quot;的服务器在向另一个客户提供先前提供的租约之前会等待一段时间。- 11. 服务器发送 DHCPACK 或 DHCPNAK 消息  被选中的服务器将看到它的租约已被选中。如果它以前没有保留提供给客户的 IP 地址，它必须检查以确保它仍然可用。如果不是，服务器会发回一个 DHCPNAK（否定确认）消息。通常情况下，服务器仍然拥有该租约。它将为该客户创建一个绑定，并发回一个 DHCPACK（确认）消息，确认该租约并包含该客户端的所有相关配置参数。- 12. 客户端接收并处理 DHCPACK 或 DHCPNAK 消息  客户端收到对其请求的肯定或否定的确认。如果该消息是DHCPNAK，客户端过渡到 INIT 状态并重新开始：回到原点（步骤#1）。如果是DHCPACK，客户端从 YIAddr 字段中读取 IP 地址，并从各种消息字段和 DHCP 选项中记录租约长度和其他参数。  如果客户端没有收到任何消息，它可以将 DHCPREQUEST 消息重传一次或多次。如果它继续什么也没听到，那么它必须得出结论，服务器已经失效，并回到步骤#1。- 13. 客户端检查地址是否正在使用  客户端设备应该进行最后的检查，以确保新地址在结束租约过程之前没有被使用。这通常是通过在本地网络上生成一个 ARP 请求来完成的，看看是否有其他设备认为它已经拥有该客户端刚刚租赁的IP地址。如果有其他设备响应，客户端就向服务器发送一个 DHCPDECLINE 消息，然后，客户端回到步骤1，重新开始。- 14. 客户端最终完成租约分配  假设该地址还没有被使用，客户端最终确定租约并过渡到 BOUND 状态。它还设置了它的两个租赁计时器，T1 和T2。现在它已经准备好进行正常操作了。</code></pre><h2 id="Reallocation-流程"><a href="#Reallocation-流程" class="headerlink" title="Reallocation 流程"></a>Reallocation 流程</h2><pre><code>- 1. 客户端创建 DHCPREQUEST 消息  客户端以 INIT-REBOOT 状态而不是 INIT 状态开始。它创建了一个 DHCPREQUEST 消息，试图找到一个具有其当前租约信息的服务器。注意，这可能不是最初授予租约的服务器；理论上，负责租约的服务器可能在客户端获得租约后发生变化。因此，与分配过程中第8步的 DHCPREQUEST 消息不同，客户端不包括DHCP 服务器标识符选项。它确实包括以下信息。    - 在消息的 CHAddr 字段中包含它自己的硬件地址，以识别自己。    - 在 `Requested IP Address` DHCP选项中包含其现有租约的IP地址，这个地址没有被放到CIAddr 字段中。    - 一个随机的交易标识符，放在XID字段中。这被用来识别以后的信息是同一事务的一部分。    - 任何它想要的额外配置参数，放在消息中的参数请求列表选项中。- 2. 客户端发送DHCPREQUEST消息  客户端广播了 DHCPREQUEST 消息。然后，它过渡到 REBOOTING 状态，等待来自服务器的回复。- 3. 服务器接收和处理 DHCPREQUEST 消息并生成回复  网络上的每个 DHCP 服务器都接收并处理客户端的请求。服务器在其数据库中查找客户端，试图找到有关租约的信息。然后每个 DHCP 服务器决定如何回复客户端。    - 服务器拥有有效的客户租约信息。服务器拥有客户的租约信息。它发送一个 DHCPACK 消息来确认租约。它还将重申客户应该使用的任何参数。    - 服务器确定客户端租约无效。服务器确定客户的租约不再有效。发生这种情况的常见原因是客户在搬到一个不同的网络后试图确认租约，或者在事实上至少已经过期后。在这种情况下，服务器会发送一个 DHCPNAK 消息来否定租赁请求。    - 服务器没有关于客户租约的明确信息。没有租约信息的服务器不作回应。除非一个服务器的信息被保证是准确的，否则它也被要求不做回应。例如，如果一个服务器知道一个过期的租约，它不能假定该租约不再有效并发送 DHCPNAK，除非它也知道没有其他服务器为该客户提供更新的、有效的租约。- 4. 服务器发送回复  将要对客户的 DHCPREQUEST 做出响应的服务器会发送他们的DHCPACK或DHCPNAK消息。- 5. 客户端接收并处理 DHCPACK 或 DHCPNAK 消息  客户端等待一段时间以获得对其请求的回复。同样，有三种可能性，与上一步中的三种可能性相匹配。    - 正面确认。客户端收到一个 DHCPACK 消息；这确认了租赁的有效性。客户端将准备再次开始使用该租约，并继续进行下面的步骤。    - 否定的确认。该消息是一个 DHCPNAK ，它告诉客户端，它的租约不再有效。客户端过渡到 INIT 状态，以获得一个新的租约--分配过程中的第1步。    - 没有回复。如果客户端根本没有收到回复，它可以重新发送 DHCPREQUEST 消息。如果在一段时间后没有收到回复，它将得出结论，没有服务器拥有它的租约信息，并将返回 INIT 状态，尝试获得新的租约。- 6. 客户端检查地址是否正在使用  在恢复使用其租约之前，客户端设备应该执行最后的检查，以确保新地址没有被使用。尽管在租约已经存在的情况下不应该这样做，但作为一种安全措施，还是要这样做。该检查与分配过程的第13步所述相同：在本地网络上发出一个 ARP 请求，看看是否有其他设备认为它已经拥有该客户端刚刚租赁的 IP 地址。如果有其他设备响应，客户端就向服务器发送一个 DHCPDECLINE 消息，告诉它租约无效，因为有其他设备正在使用这个地址。然后，客户端回到INIT状态，获得一个新的租约。- 7. 客户端最终完成租约的分配  假设该地址还没有被使用，客户端最终完成租约并过渡到 BOUND 状态。现在它已经准备好进行正常操作了。</code></pre><h2 id="Renewal-amp-Rebinding-流程"><a href="#Renewal-amp-Rebinding-流程" class="headerlink" title="Renewal &amp; Rebinding 流程"></a>Renewal &amp; Rebinding 流程</h2><pre><code>- 1. 续约定时器（T1）过期  续约定时器，T1，默认设置为租赁长度的50%。当定时器关闭时，客户端从 BOUND 状态过渡到RENEWING状态。  客户端可以在 T1 定时器到期前启动租约更新。- 2. 客户端发送 DHCPREQUEST 更新消息  客户端创建一个 DHCPREQUEST 消息，标识自己和它的租约。然后，它将消息直接传送给最初授予租约的服务器，单播。这与分配/再分配过程中使用的 DHCPREQUEST 消息不同，后者的DHCPREQUEST是广播的。客户端可以请求一个特定的新租约长度，就像它在分配过程中请求租约长度一样，服务器对租约长度做最后的决定。- 3. 服务器接收和处理 DHCPREQUEST 消息并创建回复  假设服务器可以到达，它将接收并处理客户的更新请求。有两种可能的回应。    - 服务器同意更新客户租约。服务器决定客户的租约可以被续约。它准备向客户发送一个DHCPACK消息，以确认租约的更新，指出新的租约长度以及自租约创建或最后一次更新以来可能发生变化的任何参数。    - 服务器拒绝更新客户租约。服务器出于任何原因决定不更新客户的租约。它将创建一个DHCPNAK消息。- 4. 服务器发送回复  服务器将DHCPACK或DHCPNAK消息发回给客户。- 5. 客户端接收并处理服务器回复  客户端对服务器的回复采取适当的行动。    - 正面确认。客户端收到一个DHCPACK消息，更新租约。客户端注意到新的租约到期时间和服务器发送的任何变化的参数，重置T1和T2定时器，并过渡到BOUND状态。注意，客户端在更新时不需要做ARP IP地址检查。    - 否定确认。该消息是一个DHCPNAK，它告诉客户端它的续租请求被拒绝了。客户端将立即过渡到INIT状态，以获得一个新的租约--分配过程中的第1步。- 6. 重新绑定定时器（T2）过期  如果客户端没有收到服务器的回复，它将保持在 RENEWING 状态，并定期向服务器重传单播DHCPREQUEST。在这段时间内，从用户的角度来看，客户端仍在正常运行。如果没有收到来自服务器的响应，最终重新绑定计时器（T2）会过期。这将导致客户端过渡到REBINDING状态。回顾一下，默认情况下，T2定时器被设置为租赁长度的87.5%（8分之7）。- 7. 客户端发送DHCPREQUEST重新绑定消息  由于没有收到最初授予租约的服务器的回应，客户端 放弃该服务器，并试图联系任何可能能够延长其现有租约的服务器。它创建了一个DHCPREQUEST消息，并把它的IP地址放在CIAddr字段中，明确表示它目前拥有该地址。然后，它在本地网络上广播该请求。- 8. 服务器接收和处理DHCPREQUEST消息并发送回复  每台 DHCP 服务器都会收到请求，并根据它所掌握的客户信息作出回应。    - 服务器同意重新绑定客户租约。服务器拥有客户的租约信息并同意延长租约。它为客户准备了一个DHCPACK消息，以确认租约的更新，并指出自租约创建或最后一次更新以来可能发生的任何参数。    - 服务器决定客户不能延长其当前租约。服务器决定，无论出于什么原因，这个客户的租约不应该被延长。它准备向客户发送一个DHCPNAK消息。- 9. 服务器发送回复  每个响应客户的服务器都会发送其DHCPACK或DHCPNAK消息。- 10. 客户端收到服务器回复  客户端对上一步中的两种可能性采取适当的行动。    - 正面确认。客户端收到一个DHCPACK消息，重新绑定租约。客户端注意到现在负责这个租约的服务器，新的租约到期时间，以及服务器发送的任何改变的参数。它重置了T1和T2计时器，并过渡到BOUND状态。(它也可以像在常规租约分配期间那样探测新地址)。    - 否定确认。该消息是一个DHCPNAK，它告诉客户端，一些服务器已经确定租约不应该被延长。客户端立即过渡到INIT状态，以获得一个新的租约--分配过程中的第1步。- 11. 租约过期      如果客户端没有收到对其广播重新绑定请求的响应，它将像在RENEWING状态下一样，定期重发该请求。如果在租约到期时没有收到任何响应，它将过渡到INIT状态以获得新的租约。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;昨天配合一个同事排查虚拟机 IP 发生了变化的问题，正好整理一下 DHCP lease 生命周期以及变化流程。&lt;/p&gt;
&lt;h2 id=&quot;DH
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 执行 grub2-mkconfig 导致磁盘只读</title>
    <link href="https://zdyxry.github.io/2021/10/02/CentOS-%E6%89%A7%E8%A1%8C-grub2-mkconfig-%E5%AF%BC%E8%87%B4%E7%A3%81%E7%9B%98%E5%8F%AA%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2021/10/02/CentOS-执行-grub2-mkconfig-导致磁盘只读/</id>
    <published>2021-10-02T07:30:09.000Z</published>
    <updated>2022-06-26T03:30:00.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到了一个故障，在集群软件升级过程中，发现某一个磁盘分区变为只读，导致存储应用识别该磁盘不可用。调查发现集群升级过程中，会重新生成每个节点的 GRUB 配置文件，在执行 <code>grub2-mkconfig</code> 过程中导致的磁盘分区只读。记录下 <code>grub2-mkconfig</code> 命令执行到真正磁盘只读指令下发的流程。</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><h3 id="grub2-mkconfig"><a href="#grub2-mkconfig" class="headerlink" title="grub2-mkconfig"></a><code>grub2-mkconfig</code></h3><p>在执行 <code>grub2-mkconfig</code> 命令时，如果没有指定配置 <code>GRUB_DISABLE_OS_PROBER=true</code> 时，则 GRUB 会调用 os-prober （/etc/grub.d/30_os-prober）用于扫描其他操作系统进行后续配置。</p><h3 id="os-prober"><a href="#os-prober" class="headerlink" title="os-prober"></a>os-prober</h3><p>os-prober 是用来探测其他磁盘中存在操作系统的情况。通常由各个发行版本提供，源码地址：<a href="https://salsa.debian.org/installer-team/os-prober" target="_blank" rel="noopener">https://salsa.debian.org/installer-team/os-prober</a> 。</p><p>CentOS 默认包含的 os-prober 与源码版本并不相同，包含了一些额外的配置，通过 RPM changelog 可以查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Name        : os-prober</span><br><span class="line">Version     : 1.58</span><br><span class="line">Release     : 9.el7</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: Wed 18 Aug 2021 03:44:43 PM CST</span><br><span class="line">Group       : System Environment/Base</span><br><span class="line">Size        : 97946</span><br><span class="line">License     : GPLv2+ and GPL+</span><br><span class="line">Signature   : RSA/SHA256, Mon 21 Nov 2016 03:50:19 AM CST, Key ID 24c6a8a7f4a80eb5</span><br><span class="line">Source RPM  : os-prober-1.58-9.el7.src.rpm</span><br><span class="line">Build Date  : Sun 06 Nov 2016 11:30:02 AM CST</span><br><span class="line">Build Host  : worker1.bsys.centos.org</span><br><span class="line">Relocations : (not relocatable)</span><br><span class="line">Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;</span><br><span class="line">Vendor      : CentOS</span><br><span class="line">URL         : http://kitenet.net/~joey/code/os-prober/</span><br><span class="line">Summary     : Probes disks on the system for installed operating systems</span><br><span class="line">Description :</span><br><span class="line">This package detects other OSes available on a system and outputs the results</span><br><span class="line">in a generic machine-readable format. Support for new OSes and Linux</span><br><span class="line">distributions can be added easily.</span><br><span class="line">* Wed Sep 14 2016 rmarshall@redhat.com - 1.58-9</span><br><span class="line">- Fix regular expression that missed a corner case when detecting</span><br><span class="line">extended dos partitions.</span><br><span class="line">Resolves: rhbz#1322957</span><br><span class="line">        </span><br><span class="line">* Wed Jul 06 2016 rmarshall@redhat.com - 1.58-8</span><br><span class="line">- Resolve some coverity concerns with how the previous patch detected</span><br><span class="line">whether or not a partition was a device mapper device.</span><br><span class="line">Related: rhbz#1300262</span><br><span class="line">        </span><br><span class="line">* Tue Jul 05 2016 rmarshall@redhat.com - 1.58-7</span><br><span class="line">- Do not resolve device mapper links when generating stanzas</span><br><span class="line">for bootloader.</span><br><span class="line">Resolves: rhbz#1300262</span><br><span class="line">        </span><br><span class="line">* Wed May 04 2016 rmarshall@redhat.com - 1.58-6</span><br><span class="line">- Adding handling to skip probing extended dos partitions</span><br><span class="line">Resolves: rhbz#1322957</span><br><span class="line">- Improve Windows detection for dual boot and support Windows 10</span><br><span class="line">Resolves: rhbz#1322956</span><br><span class="line">- Suppress non-blocking dmraid sector size warning message</span><br><span class="line">Resolves: rhbz#1198918</span><br><span class="line">        </span><br><span class="line">* Fri Jan 24 2014 Daniel Mach &lt;dmach@redhat.com&gt; - 1.58-5</span><br><span class="line">- Mass rebuild 2014-01-24</span><br><span class="line">        </span><br><span class="line">* Mon Jan 20 2014 Peter Jones &lt;pjones@redhat.com&gt; - 1.58-4</span><br><span class="line">- Add man pages.</span><br><span class="line">Resolves: rhbz#948848</span><br></pre></td></tr></table></figure><p>通过下载 os-prober 的 source RPM 可以查看具体改动内容，查看 os-prober.spec 文件，查看额外的 Patch 列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Name:           os-prober</span><br><span class="line">Version:        1.58</span><br><span class="line">Release:        9%&#123;?dist&#125;</span><br><span class="line">Summary:        Probes disks on the system for installed operating systems</span><br><span class="line">            </span><br><span class="line">Group:          System Environment/Base</span><br><span class="line"># For more information about licensing, see copyright file.</span><br><span class="line">License:        GPLv2+ and GPL+</span><br><span class="line">URL:            http://kitenet.net/~joey/code/os-prober/</span><br><span class="line">Source0:        http://ftp.de.debian.org/debian/pool/main/o/os-prober/%&#123;name&#125;_%&#123;version&#125;.tar.gz</span><br><span class="line"># move newns binary outside of os-prober subdirectory, so that debuginfo</span><br><span class="line"># can be automatically generated for it</span><br><span class="line">Patch0001: 0001-Change-filepath-to-newns.patch</span><br><span class="line">Patch0002: 0002-Don-t-count-dummy-mach_kernel-as-MacOS-X-811412.patch</span><br><span class="line">Patch0003: 0003-Detect-OS-installed-to-mdraid-partition-752402.patch</span><br><span class="line">Patch0004: 0004-Yaboot-allows-spaces-in-append-825041.patch</span><br><span class="line">Patch0005: 0005-Detect-ld.so-after-usr-move-826754.patch</span><br><span class="line">Patch0006: 0006-Use-shell-processing-instead-of-basename-875356.patch</span><br><span class="line">Patch0007: 0007-Add-option-for-less-logging-893997.patch</span><br><span class="line">Patch0008: 0008-Improve-btrfs-detection-support-888341.patch</span><br><span class="line">Patch0009: 0009-Support-detection-on-btrfs-software-raid-906847.patch</span><br><span class="line">Patch0010: 0010-Name-lvm-boot-partitions-by-fstab-entry-893472.patch</span><br><span class="line">Patch0011: 0011-Set-correct-boot-partition-906886.patch</span><br><span class="line">Patch0012: 0012-Factor-out-unnecessary-logger-calls-875356.patch</span><br><span class="line">Patch0013: 0013-Issue-with-EFI-detection-in-logger-873207.patch</span><br><span class="line">Patch0014: 0014-Man-pages-missing-948848.patch</span><br><span class="line">Patch0015: 0015-Properly-handle-extended-dos-partitions-1322957.patch</span><br><span class="line">Patch0016: 0016-Windows-detection-requires-binary-grep-1322956.patch</span><br><span class="line">Patch0017: 0017-Add-Windows-10-detection-support-1322956.patch</span><br><span class="line">Patch0018: 0018-Suppress-non-blocking-dmraid-error-info-1198918.patch</span><br><span class="line">Patch0019: 0019-Do-not-resolve-device-mapper-symlinks-1300262.patch</span><br><span class="line">Patch0020: 0020-Use-POSIX-shell-syntax-1300262.patch</span><br><span class="line">Patch0021: 0021-Fix-extended-dos-partition-regex-1322957.patch</span><br></pre></td></tr></table></figure><p>单独查看每一个 Patch 很麻烦，直接看操作系统上已经安装的 os-prober 相关文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$rpm -ql os-prober</span><br><span class="line">/usr/bin/linux-boot-prober</span><br><span class="line">/usr/bin/os-prober</span><br><span class="line">/usr/libexec/linux-boot-probes</span><br><span class="line">/usr/libexec/linux-boot-probes/50mounted-tests</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/40grub</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/40grub2</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/50lilo</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/90fallback</span><br><span class="line">/usr/libexec/newns</span><br><span class="line">/usr/libexec/os-probes</span><br><span class="line">/usr/libexec/os-probes/50mounted-tests</span><br><span class="line">/usr/libexec/os-probes/init</span><br><span class="line">/usr/libexec/os-probes/init/10filesystems</span><br><span class="line">/usr/libexec/os-probes/mounted</span><br><span class="line">/usr/libexec/os-probes/mounted/05efi</span><br><span class="line">/usr/libexec/os-probes/mounted/10freedos</span><br><span class="line">/usr/libexec/os-probes/mounted/10qnx</span><br><span class="line">/usr/libexec/os-probes/mounted/20macosx</span><br><span class="line">/usr/libexec/os-probes/mounted/20microsoft</span><br><span class="line">/usr/libexec/os-probes/mounted/30utility</span><br><span class="line">/usr/libexec/os-probes/mounted/40lsb</span><br><span class="line">/usr/libexec/os-probes/mounted/70hurd</span><br><span class="line">/usr/libexec/os-probes/mounted/80minix</span><br><span class="line">/usr/libexec/os-probes/mounted/83haiku</span><br><span class="line">/usr/libexec/os-probes/mounted/90linux-distro</span><br><span class="line">/usr/libexec/os-probes/mounted/90solaris</span><br><span class="line">/usr/libexec/os-probes/mounted/efi</span><br><span class="line">/usr/libexec/os-probes/mounted/efi/10elilo</span><br><span class="line">/usr/libexec/os-probes/mounted/efi/20microsoft</span><br><span class="line">/usr/share/doc/os-prober-1.58</span><br><span class="line">/usr/share/doc/os-prober-1.58/README</span><br><span class="line">/usr/share/doc/os-prober-1.58/TODO</span><br><span class="line">/usr/share/doc/os-prober-1.58/changelog</span><br><span class="line">/usr/share/doc/os-prober-1.58/copyright</span><br><span class="line">/usr/share/man/man1/linux-boot-prober.1.gz</span><br><span class="line">/usr/share/man/man1/os-prober.1.gz</span><br><span class="line">/usr/share/os-prober</span><br><span class="line">/usr/share/os-prober/common.sh</span><br><span class="line">/var/lib/os-prober</span><br></pre></td></tr></table></figure><h3 id="grub2-mkconfig-调用-os-prober-流程"><a href="#grub2-mkconfig-调用-os-prober-流程" class="headerlink" title="grub2-mkconfig 调用 os-prober 流程"></a>grub2-mkconfig 调用 os-prober 流程</h3><p><code>grub2-mkconfig</code> 最终目的是生成 grub.cfg ，在执行过程中，会通过调用 <code>/etc/grub.d/</code> 路径下的配置脚本来依次执行，在 CentOS 存在 <code>/etc/grub.d/30_os-prober</code> 配置脚本。</p><p>执行 <code>os-prober</code> 的具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OSPROBED=&quot;`os-prober | tr &apos; &apos; &apos;^&apos; | paste -s -d &apos; &apos;`&quot;</span><br><span class="line">if [ -z &quot;$&#123;OSPROBED&#125;&quot; ] ; then</span><br><span class="line">  # empty os-prober output, nothing doing</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="CentOS-os-prober-执行流程"><a href="#CentOS-os-prober-执行流程" class="headerlink" title="CentOS os-prober 执行流程"></a>CentOS os-prober 执行流程</h3><ul><li>创建新的 namespace，在调试 os-prober 过程中建议注释掉该行为</li><li>确保所有的文件系统类型是支持的，执行 <code>/usr/libexec/os-prober/init/*</code></li><li>获取节点处于已挂载分区信息、swap 分区信息、RAID 设备分区信息</li><li><p>获取节点所有 partition 信息</p><ul><li>如果 partition 已经存在于swap 分区信息或 RAID 设备分区信息中，则跳过</li><li><p>通过 <code>blkid -o value -S type $path</code> 获取文件系统信息作为 type，比如：<br>  -</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$blkid -o value -s TYPE /dev/vdb1</span><br><span class="line">xfs_external_log</span><br></pre></td></tr></table></figure></code></pre><ul><li>如果 type == btrfs，则判断是否为 btrfs volume，如果是则过滤；如果不是，则使用 <code>/usr/libexec/os-probes/50mounted-tests</code> 针对该分区进行探测</li><li>如果分区不在已挂载分区信息中，则使用 <code>/usr/libexec/os-probes/50mounted-tests</code> 路径下的所有方式进行探测，遍历执行</li><li>如果分区处于已挂载分区信息中，则使用 <code>/usr/libexec/os-probes/50mounted-tests</code> 路径下的所有方式进行探测，遍历执行</li></ul></li></ul></li><li>探测结束</li></ul><h3 id="CentOS-usr-libexec-os-probes-50mounted-tests-探测流程"><a href="#CentOS-usr-libexec-os-probes-50mounted-tests-探测流程" class="headerlink" title="CentOS /usr/libexec/os-probes/50mounted-tests 探测流程"></a>CentOS <code>/usr/libexec/os-probes/50mounted-tests</code> 探测流程</h3><ul><li>参数校验，获取 partition 的 fs type 属性<ul><li>如果 type 处于未探测、空、LVM、swap、ctypto、ntfs则直接退出</li></ul></li><li>如果 type == btrfs ，则针对 subvolume 进行探测流程</li><li>如果节点存在 grub-mount ，存在 grub2-probe 则判断 partition 是否被GRUB 挂载</li><li>如果上述分支都没有进入，则将分区置为只读<ul><li>blockdev –setro $partition</li><li>并通过 trap 设置信号处理函数，当接收到 EXIT,HUP,INT,QUIT,TERM 信号时，则将partition 重新置为可读可写</li></ul></li><li>将分区根据当前 type 类型挂载到临时挂载点下，试用 <code>/usr/libexec/os-probes/mounted/</code> 路径下的探测方式进行探测，遍历执行</li><li>探测结束</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的节点上存在处于未被挂载，且文件系统类型不为空的情况，那么建议通过设置 GRUB 配置：<code>GRUB_DISABLE_OS_PROBER=true</code> 来禁用 os-prober 的执行，防止磁盘分区变为只读。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://tracker.ceph.com/issues/11298" target="_blank" rel="noopener">https://tracker.ceph.com/issues/11298</a></li><li><a href="https://www.thegeekdiary.com/how-to-disable-os-prober-in-centos-rhel-7/" target="_blank" rel="noopener">https://www.thegeekdiary.com/how-to-disable-os-prober-in-centos-rhel-7/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近遇到了一个故障，在集群软件升级过程中，发现某一个磁盘分区变为只读，导致存储应用识别该磁盘不可用。调查发现集群升级过程中，会重新生成每个节
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux audit buffer 配置</title>
    <link href="https://zdyxry.github.io/2021/08/15/Linux-audit-buffer-%E9%85%8D%E7%BD%AE/"/>
    <id>https://zdyxry.github.io/2021/08/15/Linux-audit-buffer-配置/</id>
    <published>2021-08-15T08:49:59.000Z</published>
    <updated>2022-06-26T03:30:00.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到了一个 case，一台主机处于挂起状态，当时主机的 IPMI console 显示日志 ： <code>audit: backlog limit exceeded</code> ，由于一些原因，导致没有及时的发送 NMI 信号触发 kernel core dump，所以只能根据已有信息进行排查，记录下 audit buffer 相关配置的学习。</p><h2 id="Audit"><a href="#Audit" class="headerlink" title="Audit"></a>Audit</h2><p>Linux kernel 在 2.6 引入 audit，为了能够更好的记录系统中的各种安全事件，比如文件修改事件和系统调用事件。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p><code>/etc/audit</code> 目录下</p><ul><li>控制规则：设置 audit 系统的一些行为以及修改其默认设置</li><li>文件系统规则：审计文件，记录特殊文件或目录的访问情况</li><li>系统调用规则：记录一些特殊应用程序的系统调用行为</li></ul><h3 id="buffer-配置"><a href="#buffer-配置" class="headerlink" title="buffer 配置"></a>buffer 配置</h3><ul><li><p>当事件无法被正确记录时，会打印一些异常日志：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">audit: audit_backlog=321 &gt; audit_backlog_limit=320</span><br><span class="line">audit: audit_lost=44395 audit_rate_limit=0 audit_backlog_limit=320</span><br><span class="line">audit: backlog limit exceeded</span><br></pre></td></tr></table></figure></code></pre></li><li><p>根据 audit 的flag 配置决定，当 flag ==1 时，打印提示日志；当 flag ==2 时，kernel panic。 默认flag = 1 。</p></li><li><p>在审计系统中，使用 socket buffer queue 来保存事件，每当接收到一条新的事件时，都会记录并准备添加到这个 queue 中，有以下几个参数来控制该行为：</p><ul><li>backlog_limit<ul><li>queue 最大长度，当记录了一个事件导致queue 长度超过限制，那么就会发生failure</li></ul></li><li>raid_limit<ul><li>速率，一秒钟内事件数量超过限定值时，则不会添加到 queue 中并会发生 failure</li></ul></li></ul></li></ul><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><ul><li><p>如果无法记录事件，那么会发生故障，根据 flag 设置来决定处理行为</p><ul><li>0，silent，静默处理</li><li><p>1， printk(默认行为)，打印到系统日志中，具体打印限制根据 kernel 参数决定：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sysctl -a | grep kernel.printk_rate</span><br><span class="line">kernel.printk_ratelimit = 5</span><br><span class="line">kernel.printk_ratelimit_burst = 10</span><br></pre></td></tr></table></figure></code></pre></li><li><p>2， panic，kernel panic</p></li></ul></li></ul><h3 id="buffer-资源计算"><a href="#buffer-资源计算" class="headerlink" title="buffer 资源计算"></a>buffer 资源计算</h3><ul><li>queue 在内存中，需要设置一个合理的 backlog_limit 数值来防止占用过多内存资源，每条事件在 9000 bytes 左右，如果设置为 320，那么占用内存资源为 320 * 9000 = 2.7 MiB 左右。</li></ul><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ul><li><p><code>audit: backlog limit exceeded</code></p><ul><li><p>IPMI console 打印以上日志，表示事件未被正确的记录，事件当前数量超过 backlog_limit 限制，可能会导致系统 hang 或者无响应</p><blockquote><p>An audit buffer queue at or exceeding capacity might also cause the instance to hang or remain in an unresponsive state.</p></blockquote></li><li><p>推荐根据实际情况调整 backlog_limit 大小，比如 8192.</p></li><li>可能产生的原因：<ul><li>审计系统设置参数设置不合理</li><li>冻结文件系统（通常由于系统快照）  </li></ul></li><li><p>audit 版本为 2.4.1-5 ，其中的配置为：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@dogfood-idc-elf-65 audit]# rpm -qa |grep audit</span><br><span class="line">audit-2.4.1-5.el7.x86_64</span><br><span class="line">audit-libs-2.4.1-5.el7.x86_64</span><br><span class="line">[root@dogfood-idc-elf-65 audit]# auditctl -s</span><br><span class="line">enabled 1</span><br><span class="line">flag 1</span><br><span class="line">pid 1093</span><br><span class="line">rate_limit 0</span><br><span class="line">backlog_limit 320</span><br><span class="line">lost 0</span><br><span class="line">backlog 0</span><br><span class="line">loginuid_immutable 0 unlocked</span><br></pre></td></tr></table></figure></code></pre></li><li><p>audit 版本为2.7.6-3，其中的配置为：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 14:16:09 ~]$rpm -q audit</span><br><span class="line">audit-2.7.6-3.el7.x86_64</span><br><span class="line">[root@node90 14:16:13 ~]$auditctl -s</span><br><span class="line">enabled 1</span><br><span class="line">failure 1</span><br><span class="line">pid 1133</span><br><span class="line">rate_limit 0</span><br><span class="line">backlog_limit 8192</span><br><span class="line">lost 0</span><br><span class="line">backlog 0</span><br><span class="line">loginuid_immutable 0 unlocked</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul><li>auditd 禁止 restart 操作（RefuseManualStop = yes），所以无法使用 [[systemctl]] 控制服务启停，可以使用 <code>service</code> 代替<ul><li><code>service auditd restart</code></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redhat 推荐在线上服务器上合理配置 audit 相关参数，避免因为参数不合理产生一些意外情况，CentOS7 系列的 audit 最新版本 backlog_limit 已经是 8192 。但是对于 audit 出现异常所产生的影响，不是很明确，在 AWS 的 KB 中是这么说的：</p><blockquote><p>An audit buffer queue at or exceeding capacity might also cause the instance to hang or remain in an unresponsive state.</p></blockquote><p>但是在 Redhat 的相关 KB 中关于具体可能产生怎样的影响并没有详细说明，还需要后续调查。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>buffer 的单位是什么？ <a href="https://serverfault.com/questions/701335/auditctl-buffer-setting-how-large-is-this" target="_blank" rel="noopener">https://serverfault.com/questions/701335/auditctl-buffer-setting-how-large-is-this</a></li><li>关于 buffer 参数的解释： <a href="https://blog.siphos.be/2015/05/audit-buffering-and-rate-limiting" target="_blank" rel="noopener">https://blog.siphos.be/2015/05/audit-buffering-and-rate-limiting</a></li><li>AWS 关于 <code>audit: backlog limit exceeded</code> 的KB： <a href="https://aws.amazon.com/cn/premiumsupport/knowledge-center/troubleshoot-audit-backlog-errors-ec2/?nc1=h_ls" target="_blank" rel="noopener">https://aws.amazon.com/cn/premiumsupport/knowledge-center/troubleshoot-audit-backlog-errors-ec2/?nc1=h_ls</a></li><li>RedHat 关于 <code>audit: backlog limit exceeded</code> 的 KB，其中提到了部分可能的原因和根本原因： <a href="https://access.redhat.com/solutions/19327" target="_blank" rel="noopener">https://access.redhat.com/solutions/19327</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近遇到了一个 case，一台主机处于挂起状态，当时主机的 IPMI console 显示日志 ： &lt;code&gt;audit: backlog
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Container Optimized OS(COS) 简单对比</title>
    <link href="https://zdyxry.github.io/2021/07/30/Container-Optimized-OS-COS-%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>https://zdyxry.github.io/2021/07/30/Container-Optimized-OS-COS-简单对比/</id>
    <published>2021-07-30T21:39:04.000Z</published>
    <updated>2022-06-26T03:30:00.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前简单调研过一些 Container Optimized OS，进行了一些简单的对比，最近又被同事问到了，整理一下发出来。</p><h2 id="COS"><a href="#COS" class="headerlink" title="COS"></a>COS</h2><img src="/2021/07/30/Container-Optimized-OS-COS-简单对比/cos.png" title="COS"><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果让我来选择一个 COS 作为 BaseOS 来进行定制，那我会根据以下几个条件来进行选择：</p><ul><li>是否支持 OSTree</li><li>是否有明星公司做背后支持，如 RedHat、VMware</li><li>社区活跃度</li></ul><p>根据以上几个条件，如果是我自己使用的话，我会选择 Fedora CoreOS，或者 VMware Photo（OSTree） 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前简单调研过一些 Container Optimized OS，进行了一些简单的对比，最近又被同事问到了，整理一下发出来。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>Gunicorn 信号处理</title>
    <link href="https://zdyxry.github.io/2021/06/27/Gunicorn-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    <id>https://zdyxry.github.io/2021/06/27/Gunicorn-信号处理/</id>
    <published>2021-06-27T18:55:41.000Z</published>
    <updated>2022-06-26T03:30:00.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在项目中使用到了 Gunicorn 的 Graceful Shutdown 功能，阅读代码学习一下 Gunicorn 的信号处理。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Gunicorn 启动入口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WSGIApplication(&quot;%(prog)s [OPTIONS] [APP_MODULE]&quot;).run()</span><br><span class="line">    BaseApplication().run()</span><br><span class="line">        Arbiter(self).run()</span><br></pre></td></tr></table></figure><p>Master 主要控制逻辑实现在 <code>Arbiter</code> 中，包括信号处理和主循环逻辑。在调用 <code>Arbiter().run()</code> 会最终调用到 <code>Arbiter.init_signals()</code> ，在该函数中会将 Master 中定义的需要处理的信号函数进行相应的注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arbiter().run():</span><br><span class="line">    Arbiter().start() </span><br><span class="line">        Arbiter().init_signals() # 初始化 Master 信号处理</span><br><span class="line">            # initialize all signals</span><br><span class="line">            for s in self.SIGNALS: # &quot;HUP QUIT INT TERM TTIN TTOU USR1 USR2 WINCH&quot;</span><br><span class="line">                signal.signal(s, self.signal)</span><br><span class="line">            signal.signal(signal.SIGCHLD, self.handle_chld)</span><br></pre></td></tr></table></figure><p>所有定义的信号处理函数都是 <code>Aribiter().signal()</code> ，该函数将接收到的信号存放在 <code>Arbiter.SIG_QUEUE</code> 中，最多保留 5 个信号，然后触发 <code>Arbiter().wakeup()</code> ，在 <code>Arbiter().wakeup()</code> 中，向 <code>Arbiter.PIPE</code> 管道写入数据，主要作用是唤醒 Master loop。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def signal(self, sig, frame):</span><br><span class="line">    if len(self.SIG_QUEUE) &lt; 5:</span><br><span class="line">        self.SIG_QUEUE.append(sig)</span><br><span class="line">        self.wakeup()</span><br><span class="line"></span><br><span class="line">def wakeup(self):</span><br><span class="line">    &quot;&quot;&quot;\</span><br><span class="line">    Wake up the arbiter by writing to the PIPE</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        os.write(self.PIPE[1], b&apos;.&apos;)</span><br><span class="line">    except IOError as e:</span><br><span class="line">        if e.errno not in [errno.EAGAIN, errno.EINTR]:</span><br><span class="line">            raise</span><br></pre></td></tr></table></figure><p>在 Arbiter 类中会实现相应的信号函数处理逻辑，针对 TERM 和 INT 信号处理的主要差异为是否会先执行 <code>Arbiter().stop(False)</code> ，最后都会 <code>raise StopIteration</code> 。对于 <code>HUP</code> 信号是执行自身的 <code>Arbiter().reload()</code> 逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def handle_hup(self):</span><br><span class="line">    &quot;&quot;&quot;\</span><br><span class="line">    HUP handling.</span><br><span class="line">    - Reload configuration</span><br><span class="line">    - Start the new worker processes with a new configuration</span><br><span class="line">    - Gracefully shutdown the old worker processes</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.log.info(&quot;Hang up: %s&quot;, self.master_name)</span><br><span class="line">    self.reload()</span><br><span class="line"></span><br><span class="line">def handle_term(self):</span><br><span class="line">    &quot;SIGTERM handling&quot;</span><br><span class="line">    raise StopIteration</span><br><span class="line"></span><br><span class="line">def handle_int(self):</span><br><span class="line">    &quot;SIGINT handling&quot;</span><br><span class="line">    self.stop(False)</span><br><span class="line">    raise StopIteration</span><br><span class="line"></span><br><span class="line">def handle_quit(self):</span><br><span class="line">    &quot;SIGQUIT handling&quot;</span><br><span class="line">    self.stop(False)</span><br><span class="line">    raise StopIteration</span><br><span class="line"></span><br><span class="line">def handle_ttin(self):</span><br><span class="line">    &quot;&quot;&quot;\</span><br><span class="line">    SIGTTIN handling.</span><br><span class="line">    Increases the number of workers by one.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.num_workers += 1</span><br><span class="line">    self.manage_workers()</span><br></pre></td></tr></table></figure><p>在 Master 进行信号处理初始化动作后，进入到 Master loop 阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    self.manage_workers()           # 启动 Worker，如果 Worker 数量不足则启动；如果数量超过预期则 kill。</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        self.maybe_promote_master()</span><br><span class="line"></span><br><span class="line">        sig = self.SIG_QUEUE.pop(0) if self.SIG_QUEUE else None</span><br><span class="line">        if sig is None:</span><br><span class="line">            self.sleep() # 如果 Master 没有接收到信号，则进入到 `Arbiter().sleep()` ，该函数从 `Arbiter.PIPE` 读取数据（阻塞），直到 `Arbiter.PIPE` 有数据后才返回</span><br><span class="line">            self.murder_workers() # 如果在当前循环中，接收到信号，则进行 worker 处理，清理无用 Worker</span><br><span class="line">            self.manage_workers() # 重新进入创建、清理 Worker 逻辑</span><br><span class="line">            continue # 进入下一循环，在下一次循环中，sig 为刚刚唤醒 Master 的信号</span><br><span class="line"></span><br><span class="line">        if sig not in self.SIG_NAMES:  # 如果接收到的信号不需要处理，则忽略</span><br><span class="line">            self.log.info(&quot;Ignoring unknown signal: %s&quot;, sig)</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        signame = self.SIG_NAMES.get(sig) # 获取信号名称</span><br><span class="line">        handler = getattr(self, &quot;handle_%s&quot; % signame, None) # 获取 Master 针对该信号的处理函数</span><br><span class="line">        if not handler:</span><br><span class="line">            self.log.error(&quot;Unhandled signal: %s&quot;, signame)</span><br><span class="line">            continue</span><br><span class="line">        self.log.info(&quot;Handling signal: %s&quot;, signame)</span><br><span class="line">        handler() # 执行信号处理</span><br><span class="line">        self.wakeup() </span><br><span class="line">except (StopIteration, KeyboardInterrupt): # 如果信号为 TERM 或 INT，则会触发 Exception，进入到 `Arbiter().halt()` 逻辑，清理配置并退出进程</span><br><span class="line">    self.halt()</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Master 创建 Worker 时，先执行 <code>worker.init_process()</code> 用来初始化进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.init_signals()</span><br><span class="line">...</span><br><span class="line"># Enter main run loop</span><br><span class="line">self.booted = True</span><br><span class="line">self.run()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def init_signals(self):</span><br><span class="line">    # reset signaling</span><br><span class="line">    for s in self.SIGNALS:</span><br><span class="line">        signal.signal(s, signal.SIG_DFL)</span><br><span class="line"></span><br><span class="line">    # init new signaling </span><br><span class="line">    signal.signal(signal.SIGQUIT, self.handle_quit)</span><br><span class="line">    signal.signal(signal.SIGTERM, self.handle_exit)</span><br><span class="line">    signal.signal(signal.SIGINT, self.handle_quit)</span><br><span class="line">    signal.signal(signal.SIGWINCH, self.handle_winch)</span><br><span class="line">    signal.signal(signal.SIGUSR1, self.handle_usr1)</span><br><span class="line">    signal.signal(signal.SIGABRT, self.handle_abort)</span><br><span class="line"></span><br><span class="line">    # Don&apos;t let SIGTERM and SIGUSR1 disturb active requests</span><br><span class="line">    # by interrupting system calls</span><br><span class="line">    signal.siginterrupt(signal.SIGTERM, False)</span><br><span class="line">    signal.siginterrupt(signal.SIGUSR1, False)</span><br><span class="line"></span><br><span class="line">    if hasattr(signal, &apos;set_wakeup_fd&apos;):</span><br><span class="line">        signal.set_wakeup_fd(self.PIPE[1])</span><br></pre></td></tr></table></figure><p>在 Worker 中，所有的信号处理函数都是直接触发，没有采用 Master 的 <code>SIG_QUEUE</code> 形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def handle_usr1(self, sig, frame):</span><br><span class="line">    self.log.reopen_files()</span><br><span class="line"></span><br><span class="line">def handle_exit(self, sig, frame):</span><br><span class="line">    self.alive = False</span><br><span class="line"></span><br><span class="line">def handle_quit(self, sig, frame):</span><br><span class="line">    self.alive = False</span><br><span class="line">    # worker_int callback</span><br><span class="line">    self.cfg.worker_int(self)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    sys.exit(0)</span><br><span class="line"></span><br><span class="line">def handle_abort(self, sig, frame):</span><br><span class="line">    self.alive = False</span><br><span class="line">    self.cfg.worker_abort(self)</span><br><span class="line">    sys.exit(1)</span><br></pre></td></tr></table></figure><p>在 Worker 的 loop 逻辑中，优先检查 <code>self.alive</code> 是否为 True，如果为 True ，则进入请求处理逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def run_for_one(self, timeout):</span><br><span class="line">    listener = self.sockets[0]</span><br><span class="line">    while self.alive:</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line">        # Accept a connection. If we get an error telling us</span><br><span class="line">        # that no connection is waiting we fall down to the</span><br><span class="line">        # select which is where we&apos;ll wait for a bit for new</span><br><span class="line">        # workers to come give us some love.</span><br><span class="line">        try:</span><br><span class="line">            self.accept(listener)</span><br><span class="line">            # Keep processing clients until no one is waiting. This</span><br><span class="line">            # prevents the need to select() for every client that we</span><br><span class="line">            # process.</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        except EnvironmentError as e:</span><br><span class="line">            if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,</span><br><span class="line">                               errno.EWOULDBLOCK):</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">        if not self.is_parent_alive():</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.wait(timeout)</span><br><span class="line">        except StopWaiting:</span><br><span class="line">            return</span><br></pre></td></tr></table></figure><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>以 HUP 信号为例，在 Gunicorn 文档中，HUP 可以优雅的重启 Worker 进程：</p><blockquote><p>HUP: Reload the configuration, start the new worker processes with a new configuration and gracefully shutdown older workers. If the application is not preloaded (using the preload_app option), Gunicorn will also load the new version of it.</p></blockquote><p>当 Master 进程收到 HUP 信号后：</p><ul><li>Master loop 唤醒，进入 <code>murder_workers</code> 和 <code>manage_workers</code> 处理</li><li>Master loop 进入下一循环，获取到 HUP 信号处理函数</li><li>执行 <code>Arbiter().handle_hup()</code> </li><li>执行 <code>Arbiter().reload()</code> 重新加载配置，重新加载 WSGI app，并按照 Worker 配置启动新 Worker ，启动完成后，执行 <code>manage_workers</code> 进行原有 Worker 处理，因为此时 Worker 数量为预期的一倍，因此会进入停掉原有 Worker 处理逻辑，执行 <code>Arbiter().kill_worker()</code> 逻辑，执行 <code>os.kill</code> ，传递信号为 TERM</li><li>此时 Master 信号处理完成，执行 <code>Arbiter().wakeup()</code> 使其重新进入 loop 阻塞逻辑。</li></ul><p>当 Worker 进程收到 TERM 信号后：</p><ul><li>执行 <code>Worker().handle_exit()</code> 逻辑，将 <code>self.alive</code> 置为 False</li><li>在 Worker 的 loop 逻辑中，优先检查 <code>self.alive</code> 是否为 True，如果不为True，则处理完成当前逻辑后，下一次循环退出，以此来实现 graceful shutdown</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://flaneur2020.github.io/2020/01/12/note-about-graceful-shutdown/" target="_blank" rel="noopener">http://flaneur2020.github.io/2020/01/12/note-about-graceful-shutdown/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在项目中使用到了 Gunicorn 的 Graceful Shutdown 功能，阅读代码学习一下 Gunicorn 的信号处理。&lt;/p
      
    
    </summary>
    
    
      <category term="Python" scheme="https://zdyxry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OSTree 背景介绍</title>
    <link href="https://zdyxry.github.io/2021/05/22/OSTree-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zdyxry.github.io/2021/05/22/OSTree-背景介绍/</id>
    <published>2021-05-22T09:00:15.000Z</published>
    <updated>2022-06-26T03:30:00.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间对 OSTree 做了一些简单的了解，进行了内部分享，好久没更新博客，把 PPT 整理出来水一篇。</p><p>仓库地址： <a href="https://github.com/zdyxry/ostree-share/" target="_blank" rel="noopener">https://github.com/zdyxry/ostree-share/</a><br>PPT： <a href="https://github.com/zdyxry/ostree-share/blob/master/ostree-intro.md" target="_blank" rel="noopener">https://github.com/zdyxry/ostree-share/blob/master/ostree-intro.md</a></p><p>（Marp 真的好用，用 Markdown 写草稿，然后短时间就可以转换成 PPT </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间对 OSTree 做了一些简单的了解，进行了内部分享，好久没更新博客，把 PPT 整理出来水一篇。&lt;/p&gt;
&lt;p&gt;仓库地址： &lt;a 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《现代操作系统：原理与实现》读书笔记</title>
    <link href="https://zdyxry.github.io/2021/01/17/%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zdyxry.github.io/2021/01/17/《现代操作系统：原理与实现》读书笔记/</id>
    <published>2021-01-17T10:42:48.000Z</published>
    <updated>2022-06-26T03:30:00.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-操作系统概述"><a href="#第1章-操作系统概述" class="headerlink" title="第1章　操作系统概述"></a>第1章　操作系统概述</h2><p>操作系统有两个职责：对硬件进行管理和抽象，为应用提供服务并进行管理。<br>从硬件的角度来看，操作系统核心功能是将优先的，离散的资源高效的抽象为无限的、连续的资源。<br>从应用的角度来看，操作系统提供了不同层次，不同功能的接口，还提供了不同类型的访问控制。还负责对应用生命周期的管理，包括应用的加载、启动、切换、调度、销毁等。  </p><p>API vs ABI<br>API 是指应用编程接口，它定义了两层软件之间的源码层面的交互接口。<br>ABI 是指应用二进制接口，即在某个特定体系结构下两层软件之间二进制层面的交互接口，包括如何定义二进制文件格式、应用之间的调用约定、数据模式等。</p><h2 id="第2章-硬件结构"><a href="#第2章-硬件结构" class="headerlink" title="第2章　硬件结构"></a>第2章　硬件结构</h2><p>冯诺依曼结构包括三个主要部分：</p><ul><li>中央处理单元（CPU）：主要负责运算和逻辑控制，按照程序中的指令进行计算，并且根据条件执行程序中的不同部分</li><li>存储器（memory unit）：负责存储程序指令和数据，以及保存程序执行的中间结果和最终结构。在现代计算机中，存储器通常包括寄存器、cpu 缓存、内存等存储层次。</li><li>输入输出（I/O）：负责与外界进行交互，从外界获得输入，将结果向外界输出。</li></ul><p>指令集架构（ISA）是 CPU 和软件之间的桥梁。ISA 包含指令集、特权级、寄存器、执行模式、安全扩展、性能加速扩展等方面。</p><p>指令集是 ISA 的重要组成部分，通常包含一系列不同功能的指令，用于数据搬移、计算、内存访问、过程调用等。 </p><p>AArch64 属于精简指令集计算机（RISC）。AArch64 每跳指令的长度固定为 4 字节，指令类型包括：</p><ul><li>数据搬移指定（mov）；</li><li>寄存器计算指令（add，sub）；</li><li>内存读写指令（ldr，str）；</li><li>跳转指令（b）；</li><li>过程调用指令（bl，ret）；</li><li>特权指令（msr，mrs）。</li></ul><p>特权级也是 ISA 的重要组成部分。AArch64 中的特权级被称为异常级别（Exception Level，EL），共有四种特权级：</p><ul><li>EL0：最低的特权级，应用程序通常运行在该特权级，也成为用户态</li><li>EL1：操作系统通常运行在该特权级，也成为内核态</li><li>EL2：在虚拟化场景下需要，虚拟机监控器（VMM，也称为 Hypervisor）通常运行在该特权级</li><li>EL3：和安全特性 TrustZone 相关，负责普通世界（normal word）和安全世界（secure world）之间的切换</li></ul><p>一般来说，EL0 切换到 EL1 的可能场景有三种：</p><ol><li>应用程序需要调用操作系统提供的系统调用，此时应用程序会通过执行 svc（特权调用 supervisor call）指令将 CPU 特权级从 EL0 切换到 EL1</li><li>应用程序执行了一条指令，而该指令触发了异常（exception），该异常导致 CPU 特权级从 EL0 切换到了 EL1。例如，应用在执行一条访存指令时，触发了缺页异常（page fault），从而切换到操作系统内核进行处理</li><li>应用程序在执行的过程中，CPU 收到了一个来自外设的中断（interrupt），该中断也会导致 CPU 特权级从 EL0 切换到 EL1<br>前两种成为同步的 CPU 特权级切换，因为都是由于 CPU 正在执行的指令所导致的，第三种 CPU 发生的切换并不是由于指令导致的，属于异步的 CPU 特权级切换。</li></ol><p>在发生特权级切换时，CPU 负责保存当前执行状态，以便操作系统内核在处理异常是使用并在处理结束后能够恢复应用程序的执行，CPU 保存的主要状态包括：</p><ul><li>触发异常的指令地址（即当前的程序计数器（Program Counter,PC）），保存在 ELR_EL1（异常链接寄存器）中；</li><li>异常原因（即异常是由于执行 svc 指令还是由于访存缺页导致的），保存在 ESR_EL1（异常症状寄存器）中；</li><li>CPU 将栈指针（SP）从 SP_EL0 切换到 SP_EL1 ；</li><li>CPU 还会保存一些其他状态，例如将 CPU 的相关状态保存在 SPSR_EL1（以保存的程序状态寄存器）中，将引发缺页异常的地址保存在 FAR_EL1 （错误地址寄存器）中。</li></ul><p>寄存器是 ISA 的另一个重要组成部分，在 aarch64 中，有 31 个 64 位通用寄存器，被命名为 X0~X30，其中 X29 用作帧指针（FP）寄存器，按照惯例，一般用于保存函数调用过程中栈顶的地址；X30 用作链接指针（LP）寄存器，因为 CPU 在执行函数调用指令 b1 时会自动把返回地址保存在其中。</p><p>在 EL1 特权级下由两个“页表基地址寄存器（TTBR）“，即 TTBR0_EL1 和 TTBR1_EL1 ，它们负责翻译虚拟地址空间中不同的地址段，负责的地址范围由另一个控制寄存器 TCR_EL1（翻译控制寄存器）决定。操作系统中一种常见的配置是 TTBR0_EL1 负责[0，2^48）的地址映射（作为用户地址空间），TTBR1_EL1 负责[2^48 ,2^64）地址映射（作为操作系统内核地址空间）。</p><p>CPU 使用物理内存的方式：通过总线向物理内存发送一个读写请求，其中包括目标地址，物理内存在收到请求后进行读写操作。因此从 CPU 的角度，可以把物理内存看做由字节组成的大数组：其中每一个字节拥有一个地址（物理地址），CPU 可以在这个数组中存取数据。 </p><p>内存访问速度太慢，引入缓存（cache）。<br>CPU 缓存是由若干个缓存行（cache line）组成的。每个缓存行包括：<br>一个有效位，用户表示其是否有效；<br>一个标记地址，用于标识其对应的物理地址；<br>一些其他的状态信息。  </p><p>内存映射输入输出（MMIO）是一种常见的 CPU 控制和访问设备的方式。MMIO 的原理是：把输入输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配对应的地址。</p><p>CPU 通过访问 MMIO 配置的地址可以获取输入，但是 CPU 如何才能知道有输入事件发生了？   </p><p>一种方法是轮询。但是轮询会使 CPU 长时间处于等待输入的状态，造成 CPU 浪费，一种更高效的做法是：让设备在获得输入后主动告知 CPU，然后 CPU 再去获取输入。</p><p>中断，设备通过向 CPU 发出中断来打断 CPU 的执行，使得 CPU 去处理这个中断。操作系统可以为不同的设备中断配置不同的中断函数。</p><p>中断机制除了使得设备能够主动通知 CPU 之外，还包括让一个 CPU 核心去通知另一个 CPU 核心等用途。</p><p>MMIO 使得 CPU 可以主动访问设备，中断使得设备能够主动通知 CPU。<br>从应用程序的视角来看，异常和中断的区别是什么？ </p><p>在发生特权级切换时，如果不保存程序计数器和栈指针，会出现什么问题？</p><h2 id="第3章-操作系统结构"><a href="#第3章-操作系统结构" class="headerlink" title="第3章　操作系统结构"></a>第3章　操作系统结构</h2><p>策略表示要”做什么，机制表示该“如何做”。 </p><p>对于操作系统的调度系统而言，策略包括先到先得（FCFS），时间片轮转（RR）等，机制包括调度队列的设计，调度实体（线程）的表示与调度的中断处理等。</p><p>模块化划分要充分考虑“高内聚”和“低耦合”。</p><p>分层 vs 层级  </p><p>分层和层级这两个概念有点像，简而言之，分层是指不同类模块之间的层级，而层级则是指同类模块之间的分层。</p><h2 id="第4章-内存管理"><a href="#第4章-内存管理" class="headerlink" title="第4章　内存管理"></a>第4章　内存管理</h2><p>应用程序能够既高效又安全的功能使用物理内存资源的方案：虚拟内存。</p><p>虚拟内存的设计有如下三个方面的目标：</p><ul><li>高效性，一方面，虚拟内存抽象不能在应用程序运行过程中造成明显的性能开销；另一方面，虚拟内存抽象不能占用过多的物理内存资源</li><li>安全性，虚拟内存抽象需要使不同的应用程序的内存互相隔离，即一个应用程序只能访问属于自己的物理内存区域</li><li>透明性，虚拟内存抽象需要考虑对应用程序的透明性，使得应用程序开发者在编程时无需考虑虚拟内存抽象</li></ul><p>应用程序使用虚拟地址访问存储在内存中的数据和代码，在程序执行过程中，CPU 会把虚拟地址转换为物理地址，然后通过后者访问物理内存，虚拟地址转换成物理地址的过程，通常称为地址翻译。</p><p>内存管理单元（MMU），负责虚拟地址到物理地址的转换。程序在 CPU 核心上运行期间，它使用的虚拟地址都会由 MMU 进行翻译，当需要访问物理内存设备的时候，MMU 翻译出的物理地址将会通过总线传到相应的物理内存设备，从而完成相应的物理内存读写请求。为了加速地址翻译的过程，现代 CPU 引入了转址旁路缓存（TLB），TLB 是 MMU 内部的单元。</p><p>MMU 将虚拟地址翻译为物理地址的主要机制有两种：分段机制和分页机制。   </p><p>分段：应用程序的虚拟地址空间由若干个不同大小的段组成，比如代码段、数据段等。<br>分页：将应用程序的虚拟地址空间划分成连续的、等长的物理页（显著区分于分段机制下不同长度的段），同时物理内存也被划分成连续的、等长的物理页。虚拟也和物理页的页长固定且想等，从而使得操作系统能够很方便的为每个应用构造页表，即虚拟页到物理页的映射关系表。   </p><p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，可有效避免分段机制中外部碎片的问题。</p><p>为什么需要多级页表？<br>因为如果是单级页表，那么页表所占用的空间很大，为了压缩页表大小，引入了多级结构的页表。多级页表允许在整个页表结构中出现空洞，而单级页表需要每一项都实际存在。</p><p>为什么单级页表中每一项都需要存在？<br>单级页表可以看成以虚拟地址的虚拟页号作为索引的数组，整个数组的起始地址（物理地址）存储在页表基地址寄存器中。翻译某个虚拟地址即根据其虚拟页号找到对应的数组项，因此整个页表必须在物理内存中连续，其中没有被用到的数组项也需要预留（不能出现空洞）。</p><p>在 4 级页表结构中允许页表内存在“空洞”，假设整个应用程序的内存地址空间中只有两个虚拟页被使用，分别对应最低和最高的两个虚拟地址。在使用 4 级页表后，整个页表实际上只需要 1 个 0 级页表，2 个 1 级页表，2 个 2 级页表，2 个 3 级页表，合计 7 个页表页，仅仅占用 28KB 的物理内存空间，远小于单级页表。</p><p>多级页表会导致地址翻译实践增加，一次地址翻译可能会导致多次物理内存访问。为了减少地址翻译的访存次数，MMU 引入了转址旁路缓存（TLB）部件来加速地址翻译的过程。TLB 缓存了虚拟页号到物理页号的映射关系，若找到则可直接获得对应的物理页号而无须查询页表。</p><p>为什么硬件仅仅采用简单的 TLB 管理方式，就能在大多数情况下获得较高的 TLB 命中率？<br>因为局部性起了重要作用，应用程序在运行过程中访问内存的模式具有时间局部性和空间局部性，TLB 中的一条缓存项对应着一个内存页，由于内存访问的时空局部性，TLB 缓存项在将来很可能被多次查询。</p><p>如何保证 TLB 中的内容与当前页表内容的一致性？<br>由于TLB 是使用虚拟地址进行查询的，所以操作系统在进行页表切换（应用程序切换）的时候，需要主动刷新 TLB。若操作系统在切换应用的过程中刷新 TLB，那么应用程序开始执行（被切换到）的时候总会发生 TLB 未命中的情况，进而不可避免的造成性能损失。那么是否能够避免应用程序切换过程中 TLB 刷新的开销呢？<br>一种为 TLB 缓存打上“标签”的设计正是为了避免这样的开销。AArch64 体系结构为例，它提供了 ASID 功能（x86 64 上对应的功能为 PCID），具体来说，操作系统可以为不同的应用程序分配不同的 ASID 作为应用程序的标签，再将这个标签写入应用程序的页表基地址寄存器的空闲位，同时 TLB 中的缓存项也会包含 ASID 这个标签，从而使得 TLB 中属于不同应用程序的缓存项可以被区分开。因此，在切换页表的过程中，操作系统不再需要清空 TLB 缓存项。 </p><p>ASID 最多有 16 位，即同时最多可以有 65536 个标签，操作系统需要合理的为应用程序分配标签。</p><p>当一个虚拟页处于未分配状态或者已分配但未映射至物理内存状态的时候，应用程序访问虚拟页都会触发缺页异常，操作系统时如何区分的呢？操作系统时如何记录虚拟页分配状态的呢？<br>Linux 实现方法：由于应用程序通常使用虚拟地址空间的一些区域（比如数据和代码，栈，堆分别对应于三个互不连续的虚拟内存区域），所以在 linux 中，应用程序的虚拟地址空间被实现成由多个虚拟内存区域（VMA）组成的数据结构，每个 VMA 中包含该区域的起始虚拟地址，结束虚拟地址，访问权限等信息，当发生缺页异常时，操作系统判断该虚拟页是否属于该应用程序的某 VMA 来区分该页所处的分配状态。<br>页替换策略：</p><ul><li>MIN/OPT 策略</li><li>FIFO 策略</li><li>Second Chance 策略</li><li>LRU 策略</li><li>MRU 策略</li><li>时钟算法策略</li></ul><p>虚拟内存的功能</p><ul><li>共享内存，允许同一个物理页在不同的应用程序间共享，共享内存到的一个基本用途是可以让不同的应用程序之间互相通信、传递数据。基于共享内存的思想，操作系统又从中衍生出诸如写时拷贝、内存去重等功能</li><li>写时拷贝，页表中每个页表项除了记录物理页号，还记录了其他信息（属性位），用于标识虚拟页的权限（该页是否可写，可执行）的权限位，写时拷贝正式利用标识“是否可写”的权限位来实现的。写时拷贝允许应用 A 和应用 B 以只读的方式共享同一段物理内存，一单某个应用对该内存区域进行修改，就会触发缺页异常（这是由于违反权限导致的，不同于之前所说的换页机制下的未映射导致的）。在触发了缺页异常后，CPU 同样会将控制流传递给操作系统预先设置的缺页异常处理函数，在该函数中，操作系统会发现当前的缺页异常是由于应用程序写了只读内存，而且相应的内存区域又是被操作系统标记成写时拷贝的，于是操作系统会在物理内存中将缺页异常对应的物理页重新拷贝一份，并且将新拷贝的物理页以可读可写的方式重新映射给触发异常的应用程序，此后再恢复应用程序的执行。</li><li>内存去重，操作系统定期扫描具有相同内容的物理页，并找到映射到这些物理页的虚拟页，然后只保留其中一个物理页，将具有相同内容的其他虚拟页都用写时拷贝的方式映射到这个物理页，释放其他的物理页。Linux 中的 KSM 实现该功能。但是该功能会对性能产生影响。</li><li>内存压缩，当内存资源不足时，操作系统选择一些“最近不太会使用”的内存页，压缩其中的数据，从而释放更多空闲内存。如 Linux zswap。</li></ul><h2 id="第5章-进程与线程"><a href="#第5章-进程与线程" class="headerlink" title="第5章　进程与线程"></a>第5章　进程与线程</h2><p>进程的状态</p><ul><li>新生状态（new）：该状态表示一个进程刚刚被创建出来，还未完成初始化，不能被调度执行。在经过初始化过程之后，进程迁移至预备状态</li><li>预备状态（ready）：该状态表示进程可以被调度执行，但还未被调度器选择。由于 CPU 数量可能少于进程数量，在某一时刻只有部分进程能被调度到 CPU 上执行。此时，系统中其他的可被调度的进程都处于预备状态。在被调度器选择执行后，进程迁移至运行状态</li><li>运行状态（running）：该状态表示进程正在 CPU 上运行。当一个进程执行一段时间后，调度器可以选择中断它的执行并重新将其放回调度队列，它就迁移至预备状态。当进程运行结束，它会迁移至终止状态。如果一个进程需要等待某些外部事件，它可以放弃 CPU 并迁移至阻塞状态</li><li>阻塞状态（blocked）：该状态表示进程需要等待外部事件（如某个 I/O 请求的完成），暂时无法被调度。当进程等待的外部事件完成后，它会迁移至预备状态</li><li>终止状态（terminated）：该状态表示进程已经完成了执行，且不会再被调度</li></ul><p>进程的（虚拟内存）空间布局</p><ul><li>用户栈：栈保存了进程需要使用的各种临时数据（如临时变量的值）。栈是一种可以伸缩的数据结构，其扩展方向是自顶向下，栈底在高地址上，栈顶在低地址上。当临时数据被压入栈内时，栈顶会像低地址扩展。</li><li>代码库：进程的执行有时需要依赖共享的代码库（比如 libc），这些代码库会被映射到用户栈下方的虚拟地址处，并标记为只读。</li><li>用户堆：堆管理的是进程动态分配的内存。与栈相反，堆的扩展方向是自底向上，堆顶在高地址上，当进程需要更多内存时，堆顶会向高地址扩展。</li><li>数据与代码段：处于较低地址的是数据段与代码段，它们原本都保存在进程需要执行的二进制文件中，在进程执行前，操作系统会将它们载入虚拟地址空间。其中，数据段保存的是全局变量的值，代码段保存的是进程执行所需的代码。</li><li>内核部分：处于进程地址空间最顶端的是内核内存。每个进程的虚拟地址空间里都映射了相同的内核内存。当进程在用户态运行时，内核内存对其不可见；只有当进程进入内核态时，才能访问内核内存。与用户态相似，内核部分也有内核需要的代码和数据段，当进程由于中断或系统调用进入内核后，会使用内核的栈。</li></ul><p>每个进程都通过一个数据结构来保存它的相关状态，如进程标识符（PID）、进程状态、虚拟内存状态、打开的文件等。这个数据结构成为进程控制块（PCB）。在进行上下文切换时，会将前一个进程的寄存器状态保存到 PCB 中，然后将下一个进程先前保存的状态写入寄存器，从而切换到该进程执行。</p><p>进程的创建：fork，进程的执行：exec。 </p><p>进程间监控：wait，wait 可以用来等待子进程，来回收已经运行结束的子进程和释放资源。如果父进程没有调用 wait 操作，或者还没来得及调用 wait 操作，就算子进程已经终止了，它所占用的资源也不会完全释放，这种进程成为“僵尸进程”。内核会为僵尸进程保留其进程描述符 PID 和终止时的信息，以便父进程在调用 wait 时可以监控子进程的状态。由于管理 PID 也需要一定的内存开销，内核会设定最大可用 PID 的限制，如果一个进程创建了大量子进程却不调用 wait，那么僵尸进程会迅速占据可用 PID，使得后续的 fork 因为内核资源不足而失败。不过如果父进程退出了，那么子进程的信息就不再会被父进程使用，也就没有必要继续保留它们了。这时，所有父进程创建的僵尸进程都会被内核的第一个进程 init 通过 wait 的方式回收。</p><p>进程组是进程的集合，进程组的一大作用体现在对信号的处理，应用程序可以调用 killpg 向一个进程组发送信号，这个信号会被发送给这个进程组的每个进程。</p><p>会话是进程组的集合，可以由一个或多个进程组构成。会话将进程组根据执行状态分为前台进程组和后台进程组，控制终端进程是会话与外界进行交互的“窗口”，它负责接收从用户发来的输入。</p><p>fork 的优点：<br>简洁，fork 和 exec 的组合可以认为是将进程的创建过程进一步的解耦：fork 为进程搭建了“骨架”，而 exec 则为进程添加了“血肉”，两者的分工非常清晰，由于 fork 和 exec 的解耦，程序可以在 fork 调用后，exec 调用前，对子进程进行各种设定，比如对文件进行重定向。另外，fork 还强调了进程与进程之间的联系，由于 fork 具有创建原有进程的拷贝的语义，原进程与 fork 创建的进程之间存在较强的联系（父进程与子进程），这种联系为进程的管理提供了便利，比如在 Shell 中，虽然同一个 shell 创建的进程的功能不同，但是它们都来自同一个用户，因此可以共享很多状态。又如，web 服务场景中，服务器为每个请求单独创建一个进程，由于这些进程的逻辑相似，因此可以通过 fork 一次创建多个进程来应对用户的请求。</p><p>fork 的局限性：</p><ul><li>fork 过于复杂，由于 fork 到的默认语义是构造与父进程一样的拷贝，因此它会使得子进程与父进程共享大量状态，可能会使进程表现出看似违反直觉的行为。每当操作系统为进程的结构添加功能时，就必须考虑到对 fork 的实现和修改，fork 在实现过程中需要考虑的特殊情况越来越多，代码越来越复杂。另外由于 fork 的实现与进程、内存管理等模块的耦合程度越高，因此不利于内核的代码维护。</li><li>fork 的性能太差，由于 fork需要创建出原进程的一份拷贝，原进程的状态越多，fork 的性能就越差。尽管写时拷贝已经大大减少了内存拷贝，但对于这类应用来说，就连建立内存映射都需要耗费大量时间，fork 的效率已经满足不了它们的需要。</li><li>fork 存在潜在的安全漏洞，fork 建立的父进程与子进程之间的联系可能会成为攻击者的重要切入点。 </li></ul><p>除了以上三点，还有扩展性差、与异质硬件不兼容、线程不安全等。</p><p>Linux 针对 fork 提出了多种替代方案：</p><ul><li>posix_spawn：灵活度不如fork &amp; exec，但是性能要好于 fork&amp;exec</li><li>vfork：vfork 是 fork 的裁剪版，从父进程中创建出子进程，但是不会为子进程单独创建地址空间，只适合用在进程创建后立即使用 exec 的场景，vfork &amp; exec 相比 fork&amp;exec 省去了一次地址空间的拷贝。</li><li>rfork/clone：fork 的精密控制版本，允许应用程序通过参数对创建过程进行更多的控制</li></ul><p>进程抽象过于笨重：</p><ol><li>创建进程的开销较大，需要完成创建独立的地址空间、载入数据和代码段、初始化堆等步骤，即使使用 fork 接口创建进程，也需要对父进程的状态进行大量拷贝</li><li>由于进程拥有独立的虚拟地址空间，在进程间进行数据共享和同步比较麻烦，一般只能基于共享虚拟内存页（粒度较粗）或者基于进程间通信（开销较高）。</li></ol><p>因此提出在进程内部添加可独立执行的单元，它们共享进程的地址空间，但又各自保存运行时所需的状态（上下文），这就是线程。线程取代进程成为操作系统调度和管理程序的最小单位。</p><p>多线程的地址空间主要有两个重要特征：</p><ul><li>分离的内核栈和用户栈：由于每个线程的执行相对独立，进程为每个线程都准备了不同的栈，供它们存放临时数据。在内核中，每个线程也有对应的内核栈，当线程切换到内核中执行时，它的栈指针会切换到对应的内核栈</li><li>共享的其他区域：进程除栈以外的其他区域由该进程的所有线程共享，包括堆、数据段、代码段等。当一个进程的多个线程需要动态分配更多的内存时（在 C 语言中可通过调用 malloc 函数实现），它们的内存分配操作都是在同一个堆上完成的。因此 malloc 的实现需要使用“同步原语”，使每个线程能正确的获取可用的内存空间</li></ul><p>线程分为：用户态线程和内核态线程。有三种多线程模型：</p><ul><li>多对一模型</li><li>一对一模型（Linux &amp; Windows 默认）</li><li>多对多模型（macOS 和 iOS）  </li></ul><p>与进程类似，线程也有自己的线程控制块（TCB），用于保存与自身相关的信息。在目前主流的一对一线程模型中，内核态线程和用户态线程都会各自保存自己的 TCB。内核态 TCB 结构与 PCB 相似，会存储现成的运行状态、内存映射、标识符等信息。用户态 TCB 的结构则主要由线程库决定，对于 Linux 平台上使用 pthread 线程库的应用来说，pthread 结构体就是用户态的 TCB。用户态的 TCB 可以认为是内核态的扩展，可以用来存储更多与用户态相关的信息，其中一项重要的功能就是线程本地存储（TLS）。</p><p>sleep vs yield ：   </p><p>sleep 操作与 yield 有相似之处，他们都会让当前线程放弃 CPU 资源，交给其他线程执行。它们最重要的区别是调用后线程的状态。当线程调用 yield 后，它会处于预备状态，并可能很快就会被调度；在某些极端情况下，如果没有其他可调度线程，该线程甚至会继续执行。而当调用 sleep 之后，它会进入阻塞状态，只有满足条件后才会重新恢复到预备状态。可以把 yield 看做类似于 sleep（0），即挂起时间无限趋近于 0 的调用。</p><p>线程的上下文是上下文切换的基础，在实际硬件中，上下文主要指的是当前处理器中大部分寄存器的值，这其中包括：</p><ul><li>程序计数器（PC）存储 CPU 当前所执行指令的地址；</li><li>通用寄存器，存储 CPU 当前正在处理的一些数据；</li><li>特殊寄存器，存储 CPU 当前的一些硬件状态和配置，如页表地址等。</li></ul><h2 id="第6章-操作系统调度"><a href="#第6章-操作系统调度" class="headerlink" title="第6章　操作系统调度"></a>第6章　操作系统调度</h2><p>一般来说，一个系统会同时处理多个请求，但是其资源是优先的，调度就是用来协调每个请求对资源的使用的方法。调度中存在：优先级，时间片，截止时间等概念。</p><p>任务调度（task scheduling 也称 CPU 调度）负责调度可执行的任务对 CPU 的使用；I/O 调度负责对应该以何种顺序想存储设备发起 I/O 请求进行调度；内存管理也是一种调度，内存管理将虚拟内存映射到物理内存，物理内存是有限的资源，当需要使用的虚拟内存超过物理内存容量时，换页机制就是在对哪部分物理内页的内容可以留在内存中进行调度，并将剩余物理页上到的内容写回磁盘，进而复用那些剩余的物理页。</p><p>一般调度器会通过维护运行队列（run queue）的方式来管理任务，Linux 调度器会用红黑树来实现运行队列，任务在执行时若触发一定条件，则会停止执行，这些条件可以是：</p><ul><li>该任务执行了指定的时间片后，应让其他任务在当前 CPU 核心上执行</li><li>该任务发起了 I/O 请求，在 I/O 返回前，它不会继续执行</li><li>该任务主动停止执行或进入睡眠</li><li>该任务被系统中断打断，系统优先处理中断而暂缓该任务的执行</li></ul><p>调度器主要作用是做出调度决策，整个系统通过该决策进而决定如何调度，这些调度决策包括：</p><ul><li>从运行队列中选择下一个运行任务</li><li>决定执行该任务的 CPU 核心</li><li>决定该任务被允许执行的时间，即时间片</li></ul><p>调度器的设计问题主要可以归纳为两类：</p><ul><li>调度器应该做出什么样的调度决策（what）？</li><li>调度器应该如何做出符合预期的调度决策（how）？</li></ul><p>常用的调度指标包括：</p><ul><li>性能 <ul><li>吞吐量、周转时间、响应时间、调度开销 </li></ul></li><li>非性能 <ul><li>公平性、资源利用率 </li></ul></li><li>特殊 <ul><li>实时性、能耗 </li></ul></li></ul><p>调度器面临的挑战：</p><ul><li>调度指标多样性</li><li>调度可参考的信息有限</li><li>任务间的复杂交互</li><li>许多方便存在权衡</li></ul><p>调度器权衡包括但不限于一下几点：</p><ul><li>调度开销与调度效果</li><li>优先级与公平性</li><li>性能与能耗</li></ul><p>在任务调度中，长期、中期和短期调度相互协作，分别以不同的目标对进程进行调度。<br>长期任务的触发间隔较长，它粗粒度的决定是否应该将一个新的进程纳入调度管理，负责增加系统中可被调度的进程的数量；<br>中期调度的触发相对频繁，它辅助换页机制，负责限制系统中可被调度的进程的数量；<br>短期调度的触发最为频发，它负责细粒度的调度进程的执行，做出相应的调度决策。  </p><p>调度流程：</p><ol><li>在传统操作系统中，批处理任务被发起后，其信息会被存入磁盘中的批处理队列，等待被长期调度允许进入系统；</li><li>长期调度负责从批处理队列中选取下一个可被调度的批处理任务，为其创建对应的进程，将进程设为预备状态并放入运行队列；</li><li>由于交互任务和实时任务一般都有比较高的时延要求，需要在一定时间内返回结果。所以这两类任务一般不会被长期调度管理。系统会直接为他们创建对应的进程，将进程设为预备状态并放入运行队列；</li><li>通过短期调度的决策，运行队列中的进程会被调度到 CPU 上执行，此时进程为运行状态；</li><li>当进程运行完一个时间片后，短期调度会将其重新置为预备状态，并放回运行队列；</li><li>当运行中的进程发起 I/O 请求，等待用户输入或进入睡眠，因而需要被阻塞时，会被放入阻塞队列，短期调度会选择其他进程进行调度；</li><li>当进程等待的事件被触发后，操作系统直接将对应的进程移出阻塞队列，并将其置为预备状态，重新放入运行队列；</li><li>如果系统中的内存使用量偏大，就会触发换页机制，中期调度会挂起处于预备状态、阻塞状态的进程，将其置为挂起预备状态/挂起阻塞状态并放入挂起运行队列/挂起阻塞队列中；</li><li>处于挂起阻塞状态的进程，如果其等待的时间被处罚，会被置为挂起预备状态并被放入挂起运行队列中；</li><li>当系统的内存使用不再紧张时，中期调度会激活挂起运行队列/挂起阻塞队列中的进程，将其置为预备状态/阻塞状态并放回运行队列/阻塞队列中；</li><li>当进程结束后，会进入终止状态并最终被回收<h3 id="单核调度策略"><a href="#单核调度策略" class="headerlink" title="单核调度策略"></a>单核调度策略</h3><h4 id="经典调度"><a href="#经典调度" class="headerlink" title="经典调度"></a>经典调度</h4>先到先得（FCFS），<br>弊端：</li></ol><ul><li>在长短任务混合的场景下对短任务不友好</li><li>对 I/O 密集型任务不友好</li></ul><p>最短任务优先（SJF）</p><p>弊端：  </p><ul><li>必须预知任务的运行时间</li><li>其表现严重依赖与任务到达时间点</li><li>最短完成时间任务优先（STCF），SJF 的抢占式版本</li></ul><p>弊端：</p><ul><li>必须预知任务的运行时间</li><li>长任务饥饿</li></ul><p>时间片轮转（RR）</p><p>对于 RR 策略，一个关键点是它的时间片该如何选取。</p><p>弊端：</p><ul><li>在任务运行时间相似的场景下平均周转时间高，RR 一定程度上保证了每个任务之间的公平性，同时也可获得良好的响应时间，但是在特定场景下，任务的平均周转时间可能较差。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>多级队列（MLQ），每个任务会被分配预先设置好的优先级，每个优先级对应一个队列，任务会被存储在对应的优先级队列中。如果优先级不同的任务同时处于预备状态，那么调度器应该倾向于调度优先级较高的任务，因此一个任务必须等到所有优先级比它高的任务调度完成才可以被调度。处于相同优先级队列的任务，它们内部的调度方式没有统一标准，可以针对性的为不同队列采用不同的调度策略，如 FCFS 或 RR。</p><p>在设置 MLQ 策略的任务优先级时，需要注意将 I/O 密集型任务的优先级提高，保证 I/O 资源利用率。</p><p>弊端：</p><ul><li>低优先级任务饥饿，如果调度器需要保证一定的公平性，需要引入额外的机制监控任务等待时间，为等待时间过长（如超过一定的阈值）的任务提升优先级</li><li>优先级反转，在程序执行时，多个任务可能会对同一份数据产生竞争，因此任务会使用锁来保护共享数据。假设存在 3 个任务A，B，C，他们的优先级是 ABC，任务 C 在运行时持有一把锁，然后被高优先级的 A 抢占了，A 也想申请任务 C 持有的锁，但是申请失败，因此进入阻塞状态等待 C 释放锁，此时 BC 都处于可以运行状态，B 优先级高，因此 B 先运行，观察该情况，会发现 B 的优先级好像高于 A，这一问题称为优先级反转。一个可行的解决方案是优先级继承。</li></ul><p>多级反馈队列（MLFQ），在 MLQ 基础上，增加了动态设置任务优先级的策略，MLFQ 策略也会维护多个优先级队列，处于相同优先级的任务则采用 RR 策略执行，优先级的动态设置策略如下：</p><ul><li>短任务拥有更高的优先级，好处：1. 可以有更好的平均周转时间；2. I/O 密集型任务一般在 CPU 中执行的时间很短，给短任务提高优先级也相当于提高 I/O 密集型任务的优先级，提高系统的 I/O 资源利用率；3. 交互式任务一般是短任务，降低响应时间。根据每个任务（多次）执行时间来判断是短任务还是长任务。当任务进入系统中，假设任务是短任务，MLFQ 会为每个任务队列设置任务的最大运行时间，如果超过了最大时间，就会将该任务的优先级减一。</li><li>低优先级的任务采用更长的时间片，为了减少任务的调度次数，优先级月底的任务，其时间片越长，由于 MLFQ 策略支持抢占式调度，无须担心低优先级的任务阻塞新进入系统的任务。</li><li>定时将所有任务的优先级提升至最高，避免出现低优先级任务饥饿。</li></ul><p>公平共享调度</p><ul><li>“公平”是指任务对资源的使用符合用户预期</li></ul><p>公平共享调度会量化任务对系统资源的占有比例，从而实现对资源的公平调度。用份额（share）来量化每个任务对 CPU 时间的使用。份额支持曾计划的分配方式，可以将任务分组，以组为单位分配份额，任务组会在组内进一步分摊该组所拥有的份额。</p><p>优先级和份额都表示了任务在系统中的重要程度，但是目的是不同的。优先级调度是为了优化任务的周转时间、响应时间和资源利用率而设计的。不同任务的优先级只能用于相互比较，表明任务执行的先后。而基于份额的公平共享调度是为了让每个任务都能使用它应该获得的系统资源。分隔的值明确对应了任务应使用的系统资源比例。</p><p>彩票调度，彩票转让，彩票货币，彩票通胀。<br>弊端：</p><ul><li>随机数所带来的问题，彩票调度通过使用随机的方式实现了一个简单并且近似于公平共享的调度器，然而，随机数会导致某一任务占用 CPU 时间的比例，需要在该任务经历多次调度后，才能趋近于该任务的份额在所有任务总份额的比例。只有调度次数足够多，彩票调度效果才接近公平。<br>步幅调度，采用确定性的方式调度任务，核心概念是步幅。引入虚拟时间的概念。为了让虚拟时间短的任务能够“追赶”虚拟时间长的任务，使用虚拟时间的调度策略一般会选择调度所有任务中虚拟时间最少的任务。步幅调度通过设置虚拟时间的方式，让任务在每次调度时增加一定的虚拟时间，即步幅。经历虚拟时间相同的任务，它们使用的 CPU 时间之比就是步幅的倒数之比，换句话说，任务的份额之比正对应了任务的步幅的倒数之比。在真实的系统中，由于任务可能在任意时间进入系统，因此任务经历的虚拟时间不能为 0，而应该设置为当前所有任务的最小虚拟时间值，放置新进入的任务长时间占有 CPU。</li></ul><p>实时调度</p><p>根据任务超过截止时间所造成的后果分类：</p><ul><li>硬实时任务，该类任务必须在截止时间前完成</li><li>软实时任务，该类任务可以偶尔超过截止时间完成</li></ul><p>根据被触发的时间分类：</p><ul><li>周期任务，指到达系统时间遵循一定周期的任务</li><li>偶发任务，指不会周期性的到达系统的任务，且还要满足连续两个相同偶发任务到达系统的时间间隔有最小值，即系统不会在同一时刻处理两个相同的偶发任务。偶发任务通常是硬实时任务。</li><li>非周期性任务，指到达系统时间随机的任务，通常是软实时任务。</li></ul><h3 id="多核调度策略"><a href="#多核调度策略" class="headerlink" title="多核调度策略"></a>多核调度策略</h3><p>在多核上进行调度时，需要回答以下三个问题：</p><ul><li>当前应该调度哪个/哪些任务？</li><li>每个调度的任务应该在哪个 CPU 核心上执行？</li><li>每个调度的任务应该执行多久？</li></ul><p>负载分担</p><p>设想多核共享一个全局运行队列，当一个 CPU 核心需要调度任务时，根据给定的调度策略，决定全局运行队列中下一个由它执行的任务。给定的调度策略可以是任一一种单核调度策略，这种方法称为负载分担，因为系统的负载是被所有的 CPU 核心分担的。</p><p>优点：</p><ul><li>设计实现简单，通过使用负载分担，可以将多核调度问题规约为单核调度问题，使用已有的单核调度策略和单核调度器，就可以实现一个多核的全局调度器</li><li>每个 CPU 核心都会分担系统的负载，不会出现 CPU 资源浪费的情况，一个 CPU 核心执行完当前任务后，它会从全局任务队列中再选取一个任务执行，只要当前系统还有可以执行的任务，每个 CPU 核心都能获取到任务执行</li></ul><p>问题：</p><ul><li>多核共享一个全局运行队列的同步开销</li><li>任务在多个 CPU 核心间来回切换的开销，包括重新载入缓存，TLB 刷新等</li></ul><p>协同调度</p><p>为了满足对蚁族任务进行调度的需求，协同调度的概念应运而生。协同调度的目的是尽可能让一组任务并行执行，避免调度器同时调度有依赖关系的两组任务，同时避免关联任务执行效率降低的问题。</p><p>协同调度的经典策略是群组调度。</p><p>两级调度</p><p>为了减少任务在不同 CPU 核心上切换执行的开销，每个任务应尽可能只在一个 CPU 核心上进行调度。因此，新的调度策略改为每个 CPU 核心都引入一个本地调度器，并用它管理对应核心上执行的任务。这种调度策略使用全局调度器和本地调度器，构成了层级化结构，一般称为两级调度。</p><p>当一个任务进入系统时，全局调度器根据系统的当前信息，诸如每个 CPU 核心的负载情况，决定该任务应该被哪个 CPU 核心执行，当一个任务被分配给定的核心时，它将一直被该核心的本地调度器管理，不会迁移到其他 CPU 核心上执行。同时，每个本地调度器可以使用任意单核调度策略来调度任务。在避免线程在 CPU 核心间来回切换，提高了缓存局部性，较少了数据竞争的冲突的同时，这种曾计划的设计将设计单核调度策略与支持多核调度进行了解耦，使得调度器的设计实现更加灵活。以 Linux 为代表的一系列操作系统会为每个 CPU 核心分配一个本地运行队列，即可理解为每个 CPU 核心有一个本地调度器。</p><p>负载追踪与负载均衡</p><p>两级调度策略避免了任务在多核间切换，但是由于在任务开始时就指定了它在哪个 CPU 上运行，且没有任务在 CPU 核心间切换的机制，可能会导致多核间的负载不均衡，为了解决这个问题，引入了负载均衡的策略，负载均衡的思想是：通过追踪每个 CPU 核心当前的负载情况，将处于高负载的 CPU 核心管理的任务迁移至低负载的 CPU 核心上，尽可能的保证每个核心的负载大致相同。</p><p>负载均衡面临的挑战是：如何确定当前任务的负载情况，一个任务的执行负载是动态变化的，因此系统必须动态追踪当前的负载情况，这会造成一定的性能开销，如何保持低开销的同时对负载进行精确追踪是调度器设计实现的一大挑战，Linux 目前使用的是调度实体粒度负载追踪（PELT）。</p><p>运行队列粒度的负载追踪，在 Linux 3.8 以前，内核以每个 CPU 核心的运行队列为粒度计算负载，认为运行队列长的负载就高，导致负载追踪不够精确。</p><p>调度实体粒度的负载追踪，在 Linux 3.8 以后，Linux 使用了以调度实体（单个任务）为粒度的负载计算方式，做到了更细粒度的负载追踪。PELT通过记录每个任务的历史执行状况来表示任务的当前负载。具体的，调度器会以 1024 微妙作为一个周期，记录任务处于可运行状态（包括正在运行的以及等待被运行的）的时间，记为 x 微妙。该任务在第 i 个周期内对当前 CPU 的利用率为 x/1024，而对应的负载 Li 为 scale_cpu_capacity <em> x/1024 ，其中 scale_cpu_capacity 是 CPU 容量，可以理解为对应 CPU 核心的处理能力。在手机到任务每个周期内的负载后，PELT 需要计算一段时间内任务所有周期的累计负载，随着距离当前时间越远，数据参考意义越小，采用衰减系数 y 来计算：<br>L = L0 + L0 </em> y + L1 <em> y^2 + L2 </em> y ^3…. 通过计算每个任务的负载 L，PELT 就可以进而统计出每个运行队列的负载，便于调度器做出有效的迁移决策。</p><p>随着 CPU 核心数量越来越多，系统架构越来越复杂，负载均衡策略应该让任务尽量在迁移开销较小的 CPU核心间迁移，以 NUMA 架构为例，当任务从一个 NUMA 节点迁移到另一个 NUMA 节点，会严重影响任务的执行效率，又以超线程为例，一个物理核会被逻辑上分为两个逻辑核，任务在同属于一个五里河的两个逻辑核间切换的开销，会比在不同五里河的两个逻辑核间的开销小很多。</p><p>Linux 为了解决上述问题，采用层级化的方法，引入两个数据结构：调度与是有用相同特性的 CPU 核心的集合，这些核心间可以进行负载均衡。一个调度与保存一个或多个调度组，调度组是一个调度与内进行负载均衡的整体单位。通过自下而上的方式层级式的进行负载均衡，并且为了设计简单，只允许触发负载均衡的 CPU 核心拉取其他 CPU 核心的任务到本地。如果当前 CPU 核心触发负载均衡逻辑，首先在最底层调度域内的调度组间进行均衡，然后依次进入更高一级的调度域，并对其管理的调度组进行负载均衡。由于越高层级的调度域间进行负载均衡的开销越大，所以 Linux 为不同层级的调度域设置了不同的负载均衡触发频率与阈值。</p><p>对于非实时任务，Linux 使用 CFS 调度器进行调度，CFS 采用了累死公平共享调度的策略，因此其主要关心每个任务占用 CPU 时间的份额。sched_nice 为[-20,19] 的 Niceness ，越不友善的任务越倾向于使用更多的资源或抢占其他友善的任务。</p><p>Linux 调度器设计</p><p>O(n) 调度器</p><p>在 Linux 2.4 版本以前，Linux 调度器是一个机遇 RR 策略的运行队列，没有考虑很多因素（诸如任务的实时性要求）。从 Linux 2.4 版本开始，采用 O(n) 调度器，O(n) 调度器指定调度决策的时间复杂度是 O(n) ，n 代表的是调度器运行队列中的任务数量。</p><p>O(n) 调度器采用了负载分担的思想，所有任务被存储于一个全局运行队列中，被选择调度的任务会从运行队列中移除，当该任务执行完并且需要再次被调度时，会被重新放入运行队列的队尾。当调度器选择下一个被调度的任务时，需要遍历运行队列中的所有任务，并重新计算他们的动态优先级，然后选取动态优先级最高的任务。</p><p>存在问题：</p><ul><li>调度开销过大</li><li>多核扩展性差</li></ul><p>O(1) 调度器</p><p>由于O(n) 调度器存在上述问题，Linux 在 2.6.0 版本使用心得 O(1) 调度器替换 O(n) 调度器。 O(1) 调度器采用了两级调度的思想，每个 CPU 核心单独维护一个本地运行队列，让任务仅在同一个核心上调度。每个本地运行队列实际上是由两个多级队列：激活队列和过期队列组成的，分别用于管理仍有时间片剩余的任务和时间片耗尽的任务。当一个任务的时间片耗尽后，它会被加入到过期队列中。如果当前激活队列中没没有可调度的任务， O(1) 调度器会将两个队列的角色互换，开始新一轮调度。<br>每个多级队列都有 140 个优先级，其中高优先级 [0,100) 对应于实时任务，剩下的优先级 [100, 140) 对应于不同 Niceness 的非实时任务。每个多级队列都维护了一个位图，位图中的比特位用于判断对应的优先级队列是否有任务等待调度，在制定调度决策时， O(1) 调度器会根据位图找到激活队列中第一个不为空的队列，并调度该队列的第一个任务，其时间复杂度是 O(1) ，与运行队列中的任务数量无关。</p><p>用户可能不希望交互式任务在时间片用完后就需要等待所有其他任务的时间片用完才能再次执行，因此该类任务在时间片用完后，仍然会被加入激活队列中。同时，为了防止交互式任务过于激进而导致当前过期队列中的任务无法执行，当过期队列中的任务等待过长时间后， O(1) 调度器会把交互式任务加入过期多列中。</p><p>存在问题：</p><ul><li>交互式任务的判定算法过于复杂</li><li>静态时间片带来的问题， O(1) 调度器的非实时任务的运行时间片是根据其 Niceness 静态确定的，问题是，随着系统中任务数量的上升，任务的调度时延也会上升，对应的，响应时间也会受到影响。</li></ul><p>完全公平调度器</p><p>为了解决 O(1)调度器的问题，Linux 从 2.6.23 版本开始使用完全公平调度器。公平共享调度策略保证每个任务可以根据自己所占的份额共享 CPU 时间，这是 CFS 调度器的基本思想，O(1)调度器需要繁琐的通过启发式方法确定交互式任务，再给与交互式任务更多的执行机会。而 CFS 调度器只关心非实时任务对 CPU 时间的公平共享，避免了复杂的调度算法实现与调参。同时通过动态的设定任务时间片，确保了任务的调度时延不会过高。</p><p>CFS 调度器所使用的调度策略类似于步幅调度，vruntime 代表人物经过的虚拟时间，在调度是 CFS 会调度 vruntime 值最低的任务，Linux 静态的设置了 Niceness 与任务权重的对应关系，Niceness 越低则任务的权重越高，可被分配的 CPU 时间越多。</p><p>CFS 调度器的动态时间片，为了避免静态设置任务时间片所带来的问题，CFS 调度使用了调度周期的概念，并保证每经过一个调度周期，运行队列中所有任务都会被调度一次。因而在最坏的情况下，任务的调度时延即为一个调度周期。同时间片一样，调度周期会带来权衡问题。如果调度周期过长，则一系列任务必须在很长时间的运行后才能体现公平性，且任务的调度时延可能过长；如果调度周期过短，则调度开销会变大。</p><p>确定了 CFS 的调度周期后，调度器就可以开始计算在当前运行队列中，第 i 个任务的动态时间片 time_slice_i = sched_period * weight_i / weight_rq ，其中 weight_i 是第 i 个任务的权重，weight_rq 代表当前运行队列中的任务权重之和。</p><p>由于每个任务的动态时间片是不同的，都根据任务权重进行了缩放，所以任务每次执行后对 vruntime 的更新也要进行对应的缩放：<br>vruntime_i = vruntime_i + weight_nice0 / weight_i * real_runtime ，其中 weight_nice0 表示一个 Niceness 为 0 的任务的权重，该权重与 weight_i 的比值是一个系数，用于将任务的实际运行时间映射为虚拟时间。通过该系数，CFS 保证了不同动态时间片的任务执行完自己的时间片后，他们虚拟时间的增幅是一致的。</p><h2 id="第7章-进程间通信"><a href="#第7章-进程间通信" class="headerlink" title="第7章　进程间通信"></a>第7章　进程间通信</h2><p>共享内存 vs 基于共享内存的消息传递：基于共享内存的消息传递以共享内存为媒介进行消息的传输，其核心的通信抽象仍然是消息。共享内存的另一种使用方法是，直接在两个（多个）进程间建立共享区域，然后再共享区域上建立数据结构。进程可以直接使用该共享区域上的数据，而不存在”消息“的抽象。</p><p>宏内核下的典型的进程间通信机制：管道，消息队列，信号量，共享内存，信号，套接字。</p><h2 id="第8章-同步原语"><a href="#第8章-同步原语" class="headerlink" title="第8章　同步原语"></a>第8章　同步原语</h2><p>实际应用程序中有很多需要同步的场景，为了正确，搞笑的解决这些同步问题，抽象出了一系列同步原语。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当程序的正确性依赖于特定执行顺序的情况时，被称为竞争冒险。避免竞争冒险最直接的办法就是：确保同一时刻只有生产者中的一个能够对共享缓冲区进行操作。任意时刻只允许至多一个线程访问的方式被称为互斥访问，而保证互斥访问共享资源的代码区域被称为临界区。</p><p>需要满足以下条件：</p><ul><li>互斥访问：在同一时刻，最多只能有一个线程可以执行临界区</li><li>有限等待：当一个线程申请进入临界区后，必须在有限的时间内获得许可并进入临界区，不能无限等待</li><li>空闲让进：当没有线程在执行临界区代码时，必须在申请进入临界区的线程中选择一个线程，允许其执行临界区代码，保证程序执行的进展。</li></ul><p>硬件实现：关闭中断。   </p><p>关闭中断可以防止执行临界区的线程被抢占，避免多个线程同时执行临界区，保证了互斥访问。而有限等待依赖于内核的调度器，如果能保证有限时间内调度到该线程，则该线程可以再有限时间内进入临界区，达成有限等待的要求。最后，每个线程离开临界区时都开启了中断，允许调度器调度其他线程执行，达成了空闲让进的要求。但是多核环境中，即使关闭了所有核心的中断，也不能阻塞其他核心上正在运行的线程继续执行。</p><p>软件实现：皮特森算法<a href="https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95。" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95。</a></p><p>软硬件协同：使用原子操作实现互斥锁。原子操作指的是不可被打断的一个或一系列操作。即要么这一系列指令都执行完成，要么都没有执行，最常见的是比较与置换 （CAS）拿取并累加（FAA）。</p><p>互斥锁的实现种类多，不同的互斥锁被用于不同的场景，比如利用原子 CAS 实现的自旋锁，利用原子 FAA 实现的排号自旋锁。</p><p>自旋锁：利用一个变量 lock 表示锁的状态，lock 为 1 表示已经有人拿锁，为 0 表示空闲。在加锁时，线程会通过 CAS 判断 lock 是否为空闲，如果空闲则上锁，否则将一遍一遍重试。放锁时，直接将 lock 设置为 0 表示其空闲。自旋锁不能保证有限等待，即不具有公平性。自旋锁并非按照申请的顺序决定下一个获取锁的竞争者，而是让所有的竞争者均同时尝试完成原子操作。</p><p>排号自旋锁：排号自旋锁按照锁竞争者申请锁的顺序传递锁，锁的竞争者组成了一个 FIFO 的等待队列。排号锁的结构体有两个成员，owner 表示当前锁持有者序号，next 表示下一个需要分发的序号。获取排号所需要先通过原子的 FAA 操作拿到最新的序号并同时增加锁的分发序号，来避免其他竞争者拿到相同的序号。拿到序号后，竞争者通过判断 owner 的值，等待排到自己的序号，一旦两者想等，竞争者拥有该锁并被允许进入临界区。释放锁时，持有者更新 owner 的值将锁传递给下一个竞争者，保证了公平性。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>使用条件变量提供的借口，一个线程可以停止使用 CPU 并将自己挂起，当等待的条件满足时，其他的线程会唤醒该挂起的线程让其继续执行，使用条件变量能够有效的避免无谓的循环等待。</p><p>互斥锁 vs 条件变量：   </p><p>互斥锁与条件变量解决的不是同一个问题，互斥锁用于解决临界区的问题，保证互斥访问共享资源。而条件变量通过提供挂起/唤醒机制来避免循环等待，节省 CPU 资源。条件变量需要和互斥锁搭配使用。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量在不同的线程之间充当信号灯，根据剩余资源数量控制不同线程的执行或等待。信号量又被成为 PV 原语，P 为校验，V 为自增。</p><p>互斥锁 vs 信号量：<br>互斥锁与信号量有相似之处。当信号量的初始值为 1，且只允许其值在 0 和 1 之间变化时，wait 和 signal 操作分别于互斥锁的 lock 和 unlock 操作类似，称这种信号量为二院信号量。二元信号量与互斥锁的差别在于：互斥锁有拥有者概念，二元信号量没有。互斥锁往往由同一个线程加锁和放锁，信号量允许不同线程执行 wait 与 signal 操作。互斥锁与计数信号量（非二元信号量）区别较大，计数信号量允许多个线程通过，其数量等于剩余可用资源数量；而互斥锁同一时刻只允许一个线程获取。互斥锁用于保证多个线程对一个共享资源的互斥访问，而信号量用于协调多个线程对一系列共享资源的有序操作。</p><p>条件变量 vs 信号量：<br>信号量是由条件变量、互斥锁以及计数器实现的。而这个计数器就是信号量的核心，用于表示当前可用资源的数量。可以理解为：信号量利用条件变量实现了更高层级的抽象。</p><p>同步带来的问题</p><p>死锁</p><p>死锁产生的必要条件： </p><ul><li>互斥访问</li><li>持有并等待</li><li>资源非抢占</li><li>循环等待</li></ul><p>优先级反转：由于同步导致线程执行顺序违反预设优先级的问题。</p><p>解决方法：</p><ul><li>不可抢占临界区协议，核心时避免线程在临界区中被抢占，当线程获取锁，编不允许任何其他线程抢占。</li><li>优先级继承协议，在高优先级线程等待锁时，会使锁的持有者继承其优先级，从而避免该锁的临界区被低优先级的任务打断。</li><li>优先级置顶协议，将获取锁的线程的优先级置为可能竞争该锁的最高优先级。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第1章-操作系统概述&quot;&gt;&lt;a href=&quot;#第1章-操作系统概述&quot; class=&quot;headerlink&quot; title=&quot;第1章　操作系统概述&quot;&gt;&lt;/a&gt;第1章　操作系统概述&lt;/h2&gt;&lt;p&gt;操作系统有两个职责：对硬件进行管理和抽象，为应用提供服务并进行管理。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>Podman(Docker) Compose 学习记录</title>
    <link href="https://zdyxry.github.io/2021/01/09/Podman-Docker-Compose-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2021/01/09/Podman-Docker-Compose-学习记录/</id>
    <published>2021-01-09T18:56:30.000Z</published>
    <updated>2022-06-26T03:30:00.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>最近因为一些需求可能需要用到 Compose，看了看 Podman Compose 和 Docker Compose，记录一下。</p><p>Compose 主要功能：</p><ul><li>环境隔离(docker)</li><li>一组服务的起停控制</li><li>服务之间的依赖管理</li></ul><h2 id="Podman-compose"><a href="#Podman-compose" class="headerlink" title="Podman compose"></a>Podman compose</h2><p>项目地址：<a href="https://github.com/containers/podman-compose" target="_blank" rel="noopener">https://github.com/containers/podman-compose</a></p><p>用爱发电的项目，所有的实现都在 <code>podman_compose.py</code> 中，由于 Podman 没有一个好用的 client ，所以 compose 中所有的 Podman 相关的交互都是通过命令行来完成的，目前处于一个非常早期的状态，最基本的服务依赖都没有实现，不建议使用。</p><h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cli/            # 命令行解析</span><br><span class="line">config/         # 配置文件格式、校验方式、辅助函数</span><br><span class="line">const.py        # constants</span><br><span class="line">container.py    # 使用 docker client 对 container 命令及属性进行封装</span><br><span class="line">errors.py       # error code</span><br><span class="line">network.py      # 网络相关配置</span><br><span class="line">parallel.py     # 并发操作封装</span><br><span class="line">progress_stream.py # stream 相关</span><br><span class="line">project.py      # project，project 与 service 是一对多的关系</span><br><span class="line">service.py      # service，service 与 container 是一对一或一对多的关系</span><br><span class="line">timeparse.py    # 时间转换</span><br><span class="line">utils.py        # utils function</span><br><span class="line">volume.py       # volume 相关封装</span><br></pre></td></tr></table></figure><p>Docker 官方提供，所有的 container 都通过 docker python client 进行。service 之间的依赖管理通过拓扑排序实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def sort_service_dicts(services):</span><br><span class="line">    # Topological sort (Cormen/Tarjan algorithm).</span><br><span class="line">    unmarked = services[:]</span><br><span class="line">    temporary_marked = set()</span><br><span class="line">    sorted_services = []</span><br><span class="line"></span><br><span class="line">    def visit(n):</span><br><span class="line">        if n[&apos;name&apos;] in temporary_marked:</span><br><span class="line">            if n[&apos;name&apos;] in get_service_names(n.get(&apos;links&apos;, [])):</span><br><span class="line">                raise DependencyError(&apos;A service can not link to itself: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            if n[&apos;name&apos;] in n.get(&apos;volumes_from&apos;, []):</span><br><span class="line">                raise DependencyError(&apos;A service can not mount itself as volume: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            if n[&apos;name&apos;] in n.get(&apos;depends_on&apos;, []):</span><br><span class="line">                raise DependencyError(&apos;A service can not depend on itself: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            raise DependencyError(&apos;Circular dependency between %s&apos; % &apos; and &apos;.join(temporary_marked))</span><br><span class="line"></span><br><span class="line">        if n in unmarked:</span><br><span class="line">            temporary_marked.add(n[&apos;name&apos;])</span><br><span class="line">            for m in get_service_dependents(n, services):</span><br><span class="line">                visit(m)</span><br><span class="line">            temporary_marked.remove(n[&apos;name&apos;])</span><br><span class="line">            unmarked.remove(n)</span><br><span class="line">            sorted_services.insert(0, n)</span><br><span class="line"></span><br><span class="line">    while unmarked:</span><br><span class="line">        visit(unmarked[-1])</span><br><span class="line"></span><br><span class="line">    return sorted_services</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.project.up()</span><br><span class="line">    project:initialize()</span><br><span class="line">        self.networks.initialize()</span><br><span class="line">        self.volumes.initialize()</span><br><span class="line">    self.get_services_without_duplicate()</span><br><span class="line">    svc.ensure_image_exists()</span><br><span class="line">    self._get_convergence_plans()</span><br><span class="line">    parallel.parallel_execute()</span><br><span class="line">        service.execute_convergence_plan()</span><br><span class="line">        self._execute_convergence_create()</span><br><span class="line">            parallel_execute()</span><br><span class="line">                create_and_start()</span><br><span class="line">                    service.create_container()</span><br><span class="line">                    self.start_container()</span><br><span class="line">log_printer.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose&quot;&gt;&lt;a href=&quot;#Compose&quot; class=&quot;headerlink&quot; title=&quot;Compose&quot;&gt;&lt;/a&gt;Compose&lt;/h2&gt;&lt;p&gt;最近因为一些需求可能需要用到 Compose，看了看 Podman Compose 和 Docker
      
    
    </summary>
    
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>cgroups notification API demo</title>
    <link href="https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/"/>
    <id>https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/</id>
    <published>2021-01-01T18:28:00.000Z</published>
    <updated>2022-06-26T03:30:00.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cgroups-notification-API-demo"><a href="#cgroups-notification-API-demo" class="headerlink" title="cgroups notification API demo"></a>cgroups notification API demo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"flag"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"io/ioutil"</span></span><br><span class="line">        <span class="string">"os"</span></span><br><span class="line">        <span class="string">"path/filepath"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"golang.org/x/sys/unix"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cgName := flag.String(<span class="string">"cgName"</span>, <span class="string">"yiran"</span>, <span class="string">"cgroup path"</span>)</span><br><span class="line">        flag.Parse()</span><br><span class="line">        level := <span class="string">"critical"</span></span><br><span class="line">        cgDir := filepath.Join(<span class="string">"/sys/fs/cgroup/memory/"</span>, *cgName)</span><br><span class="line">        evName := <span class="string">"memory.pressure_level"</span></span><br><span class="line">        fmt.Printf(<span class="string">"cgroup name is: %s\n"</span>, *cgName)</span><br><span class="line">        fmt.Printf(<span class="string">"cgroup path is: %s\n"</span>, cgDir)</span><br><span class="line">        fmt.Printf(<span class="string">"cgroup event name is: %s\n"</span>, evName)</span><br><span class="line"></span><br><span class="line">        evFile, err := os.Open(filepath.Join(cgDir, evName))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fd, err := unix.Eventfd(<span class="number">0</span>, unix.EFD_CLOEXEC)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                evFile.Close()</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eventfd := os.NewFile(<span class="keyword">uintptr</span>(fd), <span class="string">"eventfd"</span>)</span><br><span class="line"></span><br><span class="line">        eventControlPath := filepath.Join(cgDir, <span class="string">"cgroup.event_control"</span>)</span><br><span class="line">        data := fmt.Sprintf(<span class="string">"%d %d %s"</span>, eventfd.Fd(), evFile.Fd(), level)</span><br><span class="line">        <span class="keyword">if</span> err := ioutil.WriteFile(eventControlPath, []<span class="keyword">byte</span>(data), <span class="number">0700</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                eventfd.Close()</span><br><span class="line">                evFile.Close()</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                eventfd.Close()</span><br><span class="line">                evFile.Close()</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"start..."</span>)</span><br><span class="line">                <span class="keyword">if</span> _, err := eventfd.Read(buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="built_in">panic</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> _, err := os.Lstat(eventControlPath); os.IsNotExist(err) &#123;</span><br><span class="line">                        <span class="built_in">panic</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">                fmt.Println(<span class="string">"test success ..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备 memory cgroup 配置，并限制内存上限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go build /tmp/demo.go</span><br><span class="line">mkdir /sys/fs/cgroup/memory/yiran/</span><br><span class="line"><span class="built_in">echo</span> 10M &gt;  /sys/fs/cgroup/memory/yiran/memory.limit_in_bytes</span><br><span class="line"><span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/memory/yiran/tasks</span><br><span class="line">nohup /tmp/demo -cgName=yiran &amp; </span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero | <span class="built_in">read</span> x</span><br></pre></td></tr></table></figure><p><code>tailf /tmp/nohup.out</code> 查看输出结果。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cgroups-notification-API-demo&quot;&gt;&lt;a href=&quot;#cgroups-notification-API-demo&quot; class=&quot;headerlink&quot; title=&quot;cgroups notification API demo&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
      <category term="cgroups" scheme="https://zdyxry.github.io/tags/cgroups/"/>
    
  </entry>
  
  <entry>
    <title>2020 年终总结</title>
    <link href="https://zdyxry.github.io/2020/12/31/2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://zdyxry.github.io/2020/12/31/2020-年终总结/</id>
    <published>2020-12-31T08:42:51.000Z</published>
    <updated>2022-06-26T03:30:00.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>减重 70 斤，身体达到近 10 年最健康的状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2020&quot;&gt;&lt;a href=&quot;#2020&quot; class=&quot;headerlink&quot; title=&quot;2020&quot;&gt;&lt;/a&gt;2020&lt;/h2&gt;&lt;p&gt;减重 70 斤，身体达到近 10 年最健康的状态。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020年读书记录</title>
    <link href="https://zdyxry.github.io/2020/12/28/2020%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/12/28/2020年读书记录/</id>
    <published>2020-12-28T09:03:03.000Z</published>
    <updated>2022-06-26T03:30:00.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><ul><li><a href="https://zdyxry.github.io/2016/12/31/2016%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2016</a><ul><li>计划读 5 本，实际读 13 本。</li></ul></li><li><a href="https://zdyxry.github.io/2017/12/31/2017%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2017</a><ul><li>计划 32 本，实际读完 23 本。</li></ul></li><li><a href="https://zdyxry.github.io/2018/12/30/2018%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2018</a><ul><li>计划 30 本，实际25本。</li></ul></li><li><a href="https://zdyxry.github.io/2019/12/09/2019%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2019</a><ul><li>计划 30 本，实际 43 本。</li></ul></li><li>2020<ul><li>计划 30 本，实际 40 本。</li></ul></li></ul><h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ol><li>《时间的秩序》</li><li>《肠子的小心思》</li><li>《饮食的迷思》</li><li>《认知天性》</li><li>《Linux/UNIX系统编程手册》</li><li>《码农翻身》</li><li>《庆余年》</li><li>《凤凰项目》</li><li>《编程珠玑》</li><li>《了不起的我》</li><li>《见识》</li><li>《重来》</li><li>《重来2》</li><li>《Unix/Linux编程实践教程》</li><li>《漫画数据库》</li><li>《程序员修炼之道》</li><li>《Flask Web开发：基于Python的Web应用开发实战》</li><li>《HTTP权威指南》</li><li>《计算机网络（第7版）》</li><li>《程序员的数学》</li><li>《把时间当作朋友》</li><li>《KVM Virtualization Cookbook》</li><li>《Go语言学习笔记》</li><li>《UNIX网络编程》</li><li>《现代操作系统（原书第4版）》</li><li>《基本无害》</li><li>《宇宙尽头的餐馆》</li><li>《生命，宇宙以及一切》</li><li>《再会，谢谢所有的鱼》</li><li>《畅游日本（第3版）》</li><li>《基本穿搭》</li><li>《囚徒健身》</li><li>《蛤蟆先生去看心理医生》</li><li>《天生有罪》</li><li>《数据密集型应用系统设计》</li><li>《高效能人士的七个习惯》</li><li>《咖啡咖啡》</li><li>《TCP/IP网络编程》</li><li>《献给阿尔吉侬的花束》</li><li>《囚徒增肌》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zdyxry.github.io/2016/12/31/2016%E5%B9%
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>2020 第39周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/26/2020-%E7%AC%AC39%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/26/2020-第39周-LeetCode-记录/</id>
    <published>2020-09-26T17:08:07.000Z</published>
    <updated>2022-06-26T03:30:00.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1588-Sum-of-All-Odd-Length-Subarrays"><a href="#1588-Sum-of-All-Odd-Length-Subarrays" class="headerlink" title="1588. Sum of All Odd Length Subarrays"></a>1588. Sum of All Odd Length Subarrays</h3><p>处理当长度为 1 时特殊情况，其他都遍历长度为奇数情况然后求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                    res += sum(arr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> j + i &lt;= len(arr):</span><br><span class="line">                        res += sum(arr[j:j+i])</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1592-Rearrange-Spaces-Between-Words"><a href="#1592-Rearrange-Spaces-Between-Words" class="headerlink" title="1592. Rearrange Spaces Between Words"></a>1592. Rearrange Spaces Between Words</h3><p>统计空格出现的次数，然后求出平均空格数进行字符串拼接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderSpaces</span><span class="params">(self, text: str)</span> -&gt; str:</span></span><br><span class="line">        cnt=text.count(<span class="string">" "</span>)</span><br><span class="line">        n = text.split()</span><br><span class="line">        <span class="keyword">if</span> len(n)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> text.strip()+cnt*<span class="string">" "</span></span><br><span class="line">        space,last = divmod(cnt,len(n)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">" "</span>*space).join(n)+<span class="string">" "</span>*last</span><br></pre></td></tr></table></figure><h3 id="1593-Split-a-String-Into-the-Max-Number-of-Unique-Substrings"><a href="#1593-Split-a-String-Into-the-Max-Number-of-Unique-Substrings" class="headerlink" title="1593. Split a String Into the Max Number of Unique Substrings"></a>1593. Split a String Into the Max Number of Unique Substrings</h3><p>回溯法，使用集合记录出现过的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxUniqueSplit</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        d = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(num, sub)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> sub:</span><br><span class="line">                self.ans = max(num, self.ans)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">in</span> d: <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sub) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> sub[:i] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d.add(sub[:i])</span><br><span class="line">                    helper(num + <span class="number">1</span>, sub[i:])</span><br><span class="line">                    d.remove(sub[:i]) </span><br><span class="line">                    </span><br><span class="line">        helper(<span class="number">0</span>, s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><h3 id="814-Binary-Tree-Pruning"><a href="#814-Binary-Tree-Pruning" class="headerlink" title="814. Binary Tree Pruning"></a>814. Binary Tree Pruning</h3><p>如果叶子节点的左子树和右子树为空且当前值为 0，则将其置为空，递归剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left = self.pruneTree(root.left)</span><br><span class="line">        root.right = self.pruneTree(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a>1008. Construct Binary Search Tree from Preorder Traversal</h3><p>提供先序遍历，构造二叉树，先序遍历的第一个元素是 root 节点，分别遍历之后元素，如果元素比 root 小，则记录到root 左子树中，反之记录到 root 右子树中，递归构造。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstFromPreorder</span><span class="params">(self, preorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        leftList = []</span><br><span class="line">        rightList = []</span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> preorder[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> num &lt; preorder[<span class="number">0</span>]:</span><br><span class="line">                leftList.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &gt; preorder[<span class="number">0</span>]:</span><br><span class="line">                rightList.append(num)</span><br><span class="line">        root.left = self.bstFromPreorder(leftList)</span><br><span class="line">        root.right = self.bstFromPreorder(rightList)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1588-Sum-of-All-Odd-Length-Subarrays&quot;&gt;&lt;a href=&quot;#1588-Sum-of-All-Odd-Length-Subarrays&quot; class=&quot;headerlink&quot; title=&quot;1588. Sum of All Odd
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第38周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/20/2020-%E7%AC%AC38%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/20/2020-第38周-LeetCode-记录/</id>
    <published>2020-09-20T07:45:55.000Z</published>
    <updated>2022-06-26T03:30:00.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1582-Special-Positions-in-a-Binary-Matrix"><a href="#1582-Special-Positions-in-a-Binary-Matrix" class="headerlink" title="1582. Special Positions in a Binary Matrix"></a>1582. Special Positions in a Binary Matrix</h3><p>直接遍历二维数组之后，如果某个位置是 1，再去统计每行的和和每列的和是否为 1 时间复杂度太高，可以先统计每行每列的和，然后再遍历二维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecial</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n, ans = len(mat), len(mat[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">        row, col = [<span class="number">0</span>] * m, [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]:</span><br><span class="line">                    row[i] += <span class="number">1</span></span><br><span class="line">                    col[j] += <span class="number">1</span></span><br><span class="line">        pool = [j <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> col[j] == <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> row[i] != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> pool:</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1025-Divisor-Game"><a href="#1025-Divisor-Game" class="headerlink" title="1025. Divisor Game"></a>1025. Divisor Game</h3><blockquote><p>如果N是奇数，因为奇数的所有因数都是奇数，因此 N 进行一次 N-x 的操作结果一定是偶数，所以如果 a 拿到了一个奇数，那么轮到 b 的时候，b拿到的肯定是偶数，这个时候 b 只要进行 -1， 还给 a 一个奇数，那么这样子b就会一直拿到偶数，到最后b一定会拿到最小偶数2，a就输了。</p><p>所以如果游戏开始时Alice拿到N为奇数，那么她必输，也就是false。如果拿到N为偶数，她只用 -1，让bob 拿到奇数，最后bob必输，结果就是true。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> N%<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="1583-Count-Unhappy-Friends"><a href="#1583-Count-Unhappy-Friends" class="headerlink" title="1583. Count Unhappy Friends"></a>1583. Count Unhappy Friends</h3><p>题目有些绕，python 可以直接用 <code>index</code> 方法来切片，golang 只能自己实现了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unhappyFriends</span><span class="params">(self, n: int, preferences: List[List[int]], pairs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        dd = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> pairs:</span><br><span class="line">            dd[i] = preferences[i][:preferences[i].index(x)]</span><br><span class="line">            dd[x] = preferences[x][:preferences[x].index(i)]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        print(dd)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dd:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> dd[i]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dd[x]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1282-Group-the-People-Given-the-Group-Size-They-Belong-To"><a href="#1282-Group-the-People-Given-the-Group-Size-They-Belong-To" class="headerlink" title="1282. Group the People Given the Group Size They Belong To"></a>1282. Group the People Given the Group Size They Belong To</h3><p>对分组进行统计，组人数作为 key，在该人数的用户索引列表作为 value，然后遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupThePeople</span><span class="params">(self, groupSizes: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        groups = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, _id <span class="keyword">in</span> enumerate(groupSizes):</span><br><span class="line">            groups[_id].append(i)</span><br><span class="line">        </span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> gsize, users <span class="keyword">in</span> groups.items():</span><br><span class="line">            <span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">0</span>, len(users), gsize):</span><br><span class="line">                ans.append(users[it : it + gsize])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1305-All-Elements-in-Two-Binary-Search-Trees"><a href="#1305-All-Elements-in-Two-Binary-Search-Trees" class="headerlink" title="1305. All Elements in Two Binary Search Trees"></a>1305. All Elements in Two Binary Search Trees</h3><p>如果只是单纯的用列表存储所有值，然后进行排序是最简单的实现方式，但是这道题考察的应该是归并排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAllElements</span><span class="params">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, v)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.left, v)</span><br><span class="line">            v.append(node.val)</span><br><span class="line">            dfs(node.right, v)</span><br><span class="line">        </span><br><span class="line">        v1, v2 = list(), list()</span><br><span class="line">        dfs(root1, v1)</span><br><span class="line">        dfs(root2, v2)</span><br><span class="line">        ans, i, j = list(), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(v1) <span class="keyword">or</span> j &lt; len(v2):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(v1) <span class="keyword">and</span> (j == len(v2) <span class="keyword">or</span> v1[i] &lt;= v2[j]):</span><br><span class="line">                ans.append(v1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(v2[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1582-Special-Positions-in-a-Binary-Matrix&quot;&gt;&lt;a href=&quot;#1582-Special-Positions-in-a-Binary-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1582. Spec
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
