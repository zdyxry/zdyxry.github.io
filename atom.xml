<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2021-05-22T01:05:51.007Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSTree 背景介绍</title>
    <link href="https://zdyxry.github.io/2021/05/22/OSTree-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zdyxry.github.io/2021/05/22/OSTree-背景介绍/</id>
    <published>2021-05-22T09:00:15.000Z</published>
    <updated>2021-05-22T01:05:51.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间对 OSTree 做了一些简单的了解，进行了内部分享，好久没更新博客，把 PPT 整理出来水一篇。</p><p>仓库地址： <a href="https://github.com/zdyxry/ostree-share/" target="_blank" rel="noopener">https://github.com/zdyxry/ostree-share/</a><br>PPT： <a href="https://github.com/zdyxry/ostree-share/blob/master/ostree-intro.md" target="_blank" rel="noopener">https://github.com/zdyxry/ostree-share/blob/master/ostree-intro.md</a></p><p>（Marp 真的好用，用 Markdown 写草稿，然后短时间就可以转换成 PPT </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间对 OSTree 做了一些简单的了解，进行了内部分享，好久没更新博客，把 PPT 整理出来水一篇。&lt;/p&gt;
&lt;p&gt;仓库地址： &lt;a 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《现代操作系统：原理与实现》读书笔记</title>
    <link href="https://zdyxry.github.io/2021/01/17/%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zdyxry.github.io/2021/01/17/《现代操作系统：原理与实现》读书笔记/</id>
    <published>2021-01-17T10:42:48.000Z</published>
    <updated>2021-05-22T01:05:51.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-操作系统概述"><a href="#第1章-操作系统概述" class="headerlink" title="第1章　操作系统概述"></a>第1章　操作系统概述</h2><p>操作系统有两个职责：对硬件进行管理和抽象，为应用提供服务并进行管理。<br>从硬件的角度来看，操作系统核心功能是将优先的，离散的资源高效的抽象为无限的、连续的资源。<br>从应用的角度来看，操作系统提供了不同层次，不同功能的接口，还提供了不同类型的访问控制。还负责对应用生命周期的管理，包括应用的加载、启动、切换、调度、销毁等。  </p><p>API vs ABI<br>API 是指应用编程接口，它定义了两层软件之间的源码层面的交互接口。<br>ABI 是指应用二进制接口，即在某个特定体系结构下两层软件之间二进制层面的交互接口，包括如何定义二进制文件格式、应用之间的调用约定、数据模式等。</p><h2 id="第2章-硬件结构"><a href="#第2章-硬件结构" class="headerlink" title="第2章　硬件结构"></a>第2章　硬件结构</h2><p>冯诺依曼结构包括三个主要部分：</p><ul><li>中央处理单元（CPU）：主要负责运算和逻辑控制，按照程序中的指令进行计算，并且根据条件执行程序中的不同部分</li><li>存储器（memory unit）：负责存储程序指令和数据，以及保存程序执行的中间结果和最终结构。在现代计算机中，存储器通常包括寄存器、cpu 缓存、内存等存储层次。</li><li>输入输出（I/O）：负责与外界进行交互，从外界获得输入，将结果向外界输出。</li></ul><p>指令集架构（ISA）是 CPU 和软件之间的桥梁。ISA 包含指令集、特权级、寄存器、执行模式、安全扩展、性能加速扩展等方面。</p><p>指令集是 ISA 的重要组成部分，通常包含一系列不同功能的指令，用于数据搬移、计算、内存访问、过程调用等。 </p><p>AArch64 属于精简指令集计算机（RISC）。AArch64 没跳指令的长度固定为 4 字节，指令类型包括：</p><ul><li>数据搬移指定（mov）；</li><li>寄存器计算指令（add，sub）；</li><li>内存读写指令（ldr，str）；</li><li>跳转指令（b）；</li><li>过程调用指令（bl，ret）；</li><li>特权指令（msr，mrs）。</li></ul><p>特权级也是 ISA 的重要组成部分。AArch64 中的特权级被称为异常级别（Exception Level，EL），共有四种特权级：</p><ul><li>EL0：最低的特权级，应用程序通常运行在该特权级，也成为用户态</li><li>EL1：操作系统通常运行在该特权级，也成为内核态</li><li>EL2：在虚拟化场景下需要，虚拟机监控器（VMM，也称为 Hypervisor）通常运行在该特权级</li><li>EL3：和安全特性 TrustZone 相关，负责普通世界（normal word）和安全世界（secure world）之间的切换</li></ul><p>一般来说，EL0 切换到 EL1 的可能场景有三种：</p><ol><li>应用程序需要调用操作系统提供的系统调用此时应用程序会通过执行 svc（特权调用 supervisor call）指令将 CPU 特权级从 EL0 切换到 EL1</li><li>应用程序执行了一条指令，而该指令触发了异常（exception），该异常导致 CPU 特权级从 EL0 切换到了 EL1。例如，应用在执行一条访存指令时，触发了缺页异常（page fault），从而切换到操作系统内核进行处理</li><li>应用程序在执行的过程中，CPU 收到了一个来自外设的中断（interrupt），该中断也会导致 CPU 特权级从 EL0 切换到 EL1<br>前两种成为同步的 CPU 特权级切换，因为都是由于 CPU 正在执行的指令所导致的，第三种 CPU 发生的切换并不是由于指令导致的，属于异步的 CPU 特权级切换。</li></ol><p>在发生特权级切换时，CPU 负责保存当前执行状态，以便操作系统内核在处理异常是使用并在处理结束后能够恢复应用程序的执行，CPU 保存的主要状态包括：</p><ul><li>触发异常的指令地址（即当前的程序计数器（Program Counter,PC）），保存在 ELR_EL1（异常链接寄存器）中；</li><li>异常原因（即异常是由于执行 svc 指令还是由于访存缺页导致的），保存在 ESR_EL1（异常症状寄存器）中；</li><li>CPU 将栈指针（SP）从 SP_EL0 切换到 SP_EL1 ；</li><li>CPU 还会保存一些其他状态，例如将 CPU 的相关状态保存在 SPSR_EL1（以保存的程序状态寄存器）中，将引发缺页异常的地址保存在 FAR_EL1 （错误地址寄存器）中。</li></ul><p>寄存器是 ISA 的另一个重要组成部分，在 aarch64 中，有 31 个 64 位通用寄存器，被命名为 X0~X30，其中 X29 用作帧指针（FP）寄存器，按照惯例，一般用于保存函数调用过程中栈顶的地址；X30 用作链接指针（LP）寄存器，因为 CPU 在执行函数调用指令 b1 时会自动把返回地址保存在其中。</p><p>在 EL1 特权级下由两个“页表基地址寄存器（TTBR）“，即 TTBR0_EL1 和 TTBR1_EL1 ，它们负责翻译虚拟地址空间中不同的地址段，负责的地址范围由另一个控制寄存器 TCR_EL1（翻译控制寄存器）决定。操作系统中一种常见的配置是 TTBR0_EL1 负责[0，2^48）的地址映射（作为用户地址空间），TTBR1_EL1 负责[2^48 ,2^64）地址映射（作为操作系统内核地址空间）。</p><p>CPU 使用物理内存的方式：通过总线向物理内存发送一个读写请求，其中包括目标地址，物理内存在收到请求后进行读写操作。因此从 CPU 的角度，可以把物理内存看做由字节组成的大数组：其中每一个字节拥有一个地址（物理地址），CPU 可以再这个数组中存取数据。 </p><p>内存访问速度太慢，引入缓存（cache）。<br>CPU 缓存是由若干个缓存行（cache line）组成的。每个缓存行包括：<br>一个有效位，用户表示其是否有效；<br>一个标记地址，用于标识其对应的物理地址；<br>一些其他的状态信息。</p><p>内存映射输入输出（MMIO）是一种常见的 CPU 控制和访问设备的方式。MMIO 的原理是：把输入输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配对应的地址。</p><p>CPU 通过访问 MMIO 配置的地址可以获取输入，但是 CPU 如何才能知道有输入事件发生了？   </p><p>一种方法是轮询。但是轮询会使 CPU 长时间处于等待输入的状态，造成 CPU 浪费，一种更高效的做法是：让设备在获得输入后主动告知 CPU，然后 CPU 再去获取输入。</p><p>中断，设备通过向 CPU 发出中断来打断 CPU 的执行，使得 CPU 去处理这个中断。操作系统可以为不同的设备中断配置不同的中断函数。</p><p>中断机制除了使得设备能够主动通知 CPU 之外，还包括让一个 CPU 核心去通知另一个 CPU 核心等用途。</p><p>MMIO 使得 CPU 可以主动访问设备，中断使得设备能够主动通知 CPU。<br>从应用程序的视角来看，异常和中断的区别是什么？ </p><p>在发生特权级切换时，如果不保存程序计数器和栈指针，会出现什么问题？</p><h2 id="第3章-操作系统结构"><a href="#第3章-操作系统结构" class="headerlink" title="第3章　操作系统结构"></a>第3章　操作系统结构</h2><p>策略表示要”做什么，机制表示该“如何做”。 </p><p>对于操作系统的调度系统而言，策略包括先到先得（FCFS），时间片轮转（RR）等，机制包括调度队列的设计，调度实体（线程）的表示与调度的中断处理等。</p><p>模块化划分要充分考虑“高内聚”和“低耦合”。</p><p>分层 vs 层级  </p><p>分层和层级这两个概念有点像，简而言之，分层是指不同类模块之间的层级，而层级则是指同类模块之间的分层。</p><h2 id="第4章-内存管理"><a href="#第4章-内存管理" class="headerlink" title="第4章　内存管理"></a>第4章　内存管理</h2><p>应用程序能够既高效又安全的功能使用物理内存资源的方案：虚拟内存。<br>虚拟内存的设计有如下三个方面的目标：</p><ul><li>高效性，一方面，虚拟内存抽象不能在应用程序运行过程中造成明显的性能开销；另一方面，虚拟内存抽象不能占用过多的物理内存资源</li><li>安全性，虚拟内存抽象需要使不同的应用程序的内存互相隔离，即一个应用程序只能访问属于自己的物理内存区域</li><li>透明性，虚拟内存抽象需要考虑对应用程序的透明性，使得应用程序开发者在编程时无需考虑虚拟内存抽象</li></ul><p>应用程序使用虚拟地址访问存储在内存中的数据和代码，在程序执行过程中，CPU 会把虚拟地址转换为物理地址，然后通过后者访问物理内存，虚拟地址转换成物理地址的过程，通常称为地址翻译。</p><p>内存管理单元（MMU），负责虚拟地址到物理地址的转换。程序在 CPU 核心上运行期间，它使用的虚拟地址都会由 MMU 进行翻译，当需要访问物理内存设备的时候，MMU 翻译出的物理地址将会通过总线传到相应的物理内存设备，从而完成相应的物理内存读写请求。为了加速地址翻译的过程，现代 CPU 引入了转址旁路缓存（TLB），TLB 是 MMU 内部的单元。</p><p>MMU 将虚拟地址翻译为物理地址的主要机制有两种：分段机制和分页机制。<br>分段：应用程序的虚拟地址空间由若干个不同大小的段组成，比如代码段、数据段等。<br>分页：将应用程序的虚拟地址空间划分成连续的、等长的物理页（显著区分于分段机制下不同长度的段），同时物理内存也被划分成连续的、等长的物理页。虚拟也和物理页的页长固定且想等，从而使得操作系统能够很方便的为每个应用构造页表，即虚拟页到物理页的映射关系表。   </p><p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，可有效避免分段机制中外部碎片的问题。</p><p>为什么需要多级页表？<br>因为如果是单级页表，那么页表所占用的空间很大，为了压缩页表大小，引入了多级结构的页表。多级页表允许在整个页表结构中出现空洞，而单级页表需要每一项都实际存在。</p><p>为什么单级页表中每一项都需要存在？<br>单级页表可以看成以虚拟地址的虚拟页号作为索引的数组，整个数组的起始地址（物理地址）存储在页表基地址寄存器中。翻译某个虚拟地址即根据其虚拟页号找到对应的数组项，因此整个页表必须在物理内存中连续，其中没有被用到的数组项也需要预留着（不能出现空洞）。</p><p>在 4 级页表结构中允许页表内存在“空洞”，假设整个应用程序的内存地址空间中只有两个虚拟页被使用，分别对应最低和最高的两个虚拟地址。在使用 4 级页表后，整个页表实际上只需要 1 个 0 级页表，2 个 1 级页表，2 个 2 级页表，2 个 3 级页表，合计 7 个页表页，仅仅占用 28KB 的物理内存空间，远小于单级页表。</p><p>多级页表会导致地址翻译实践增加，一次地址翻译可能会导致多次物理内存访问。为了减少地址翻译的访存次数，MMU 引入了转址旁路缓存（TLB）部件来加速地址翻译的过程。TLB 缓存了虚拟页号到物理页号的映射关系，若找到泽科直接获得对应的物理页号而无须查询页表。</p><p>为什么硬件仅仅采用简单的 TLB 管理方式，就能在大多数情况下获得较高的 TLB 命中率？<br>因为局部性起了重要作用，应用程序在运行过程中访问内存的模式具有时间局部性和空间局部性，TLB 中的一条缓存项对应着一个内存也，由于内存访问的时空局部性，TLB 缓存项在将来很可能被多次查询。</p><p>如何保证 TLB 中的内容与当前页表内容的一致性？<br>由于TLB 是使用虚拟地址进行查询的，所以操作系统在进行页表切换（应用程序切换）的时候，需要主动刷新 TLB。若操作系统在切换应用的过程中刷新 TLB，那么应用程序开始执行（被切换到）的时候总会发生 TLB 未命中的情况，进而不可避免的造成性能损失。那么是否能够避免应用程序切换过程中 TLB 刷新的开销呢？<br>一种为 TLB 缓存打上“标签”的设计正是为了避免这样的开销。AArch64 体系结构为例，它提供了 ASID 功能（x86 64 上对应的功能为 PCID），具体来说，操作系统可以为不同的应用程序分配不同的 ASID 作为应用程序的标签，再将这个标签写入应用程序的页表基地址寄存器的空闲位，同时 TLB 中的缓存项也会包含 ASID 这个标签，从而使得 TLB 中属于不同应用程序的缓存项可以被区分开。因此，在切换页表的过程中，操作系统不再需要清空 TLB 缓存项。 </p><p>ASID 最多有 16 位，即同时最多可以有 65536 个标签，操作系统需要合理的为应用程序分配标签。</p><p>当一个虚拟页处于未分配状态或者已分配但未映射至物理内存状态的时候，应用程序访问虚拟页都会触发缺页异常，操作系统时如何区分的呢？操作系统时如何记录虚拟页分配状态的呢？<br>Linux 实现方法：由于应用程序通常使用虚拟地址空间的一些区域（比如数据和代码，栈，堆分别对应于三个互不连续的虚拟内存区域），所以在 linux 中，应用程序的虚拟地址空间被实现成由多个虚拟内存区域（VMA）组成的数据结构，每个 VMA 中包含该区域的起始虚拟地址，结束虚拟地址，访问权限等信息，当发生缺页异常是，操作系统判断该虚拟页是否属于该应用程序的某VMA 来区分该页所处的分配状态。<br>页替换策略：</p><ul><li>MIN/OPT 策略</li><li>FIFO 策略</li><li>Second Chance 策略</li><li>LRU 策略</li><li>MRU 策略</li><li>时钟算法策略</li></ul><p>虚拟内存的功能</p><ul><li>共享内存，允许同一个物理页在不同的应用程序间共享，共享内存到的一个基本用途是可以让不同的应用程序之间互相通信、传递数据。基于共享内存的思想，操作系统又从中衍生出诸如写时拷贝、内存去重等功能</li><li>写时拷贝，页表中每个页表项除了记录物理页号，还记录了其他信息（属性位），用于标识虚拟页的权限（该页是否可写，可执行）的权限位，写时拷贝正式利用标识“是否可写”的权限位来实现的。写时拷贝允许应用 A 和应用 B 以只读的方式共享同一段物理内存，一单某个应用对该内存区域进行修改，就会触发缺页异常（这是由于违反权限导致的，不同于之前所说的换页机制下的未映射导致的）。在触发了缺页异常后，CPU 同样会将控制流传递给操作系统预先设置的缺页异常处理函数，在该函数中，操作系统会发现当前的缺页异常是由于应用程序写了只读内存，而且相应的内存区域又是被操作系统标记成写时拷贝的，于是操作系统会在物理内存中将缺页异常对应的物理页重新拷贝一份，并且将新拷贝的物理页以可读可写的方式重新映射给触发异常的应用程序，此后再恢复应用程序的执行。</li><li>内存去重，操作系统定期扫描具有相同内容的物理页，并找到映射到这些物理页的虚拟页，然后只保留其中一个物理页，将具有相同内容的其他虚拟页都用写时拷贝的方式映射到这个物理页，释放其他的物理页。Linux 中的 KSM 实现该功能。但是该功能会对性能产生影响。</li><li>内存压缩，当内存资源不足时，操作系统选择一些“最近不太会使用”的内存页，压缩其中的数据，从而释放更多空闲内存。如 Linux zswap。<h2 id="第5章-进程与线程"><a href="#第5章-进程与线程" class="headerlink" title="第5章　进程与线程"></a>第5章　进程与线程</h2>进程的状态</li><li>新生状态（new）：该状态表示一个进程刚刚被创建出来，还未完成初始化，不能被调度执行。在经过初始化过程之后，进程迁移至预备状态</li><li>预备状态（ready）：该状态表示进程可以被调度执行，但还未被调度器选择。由于 CPU 数量可能少于进程数量，在某一时刻只有部分进程能被调度到 CPU 上执行。此时，系统中其他的可被调度的进程都处于预备状态。在被调度器选择执行后，进程迁移至运行状态</li><li>运行状态（running）：该状态表示进程正在 CPU 上运行。当一个进程执行一段时间后，调度器可以选择中断它的执行并重新将其放回调度队列，它就迁移至预备状态。当进程运行结束，它会迁移至终止状态。如果一个进程需要等待某些外部时间，它可以放弃 CPU 并迁移至阻塞状态</li><li>阻塞状态（blocked）：该状态表示进程需要等待外部时间（如某个 I/O 请求的完成），暂时无法被调度。当进程等待的外部事件完成后，它会迁移至预备状态</li><li>终止状态（terminated）：该状态表示进程已经完成了执行，且不会再被调度</li></ul><p>进程的（虚拟内存）空间布局</p><ul><li>用户栈：栈保存了进程需要使用的各种临时数据（如临时变量的值）。栈是一种可以伸缩的数据结构，其扩展方向是自顶向下，栈底在高地址上，栈顶在低地址上。当临时数据被压入栈内时，栈顶会像低地址扩展。</li><li>代码库：进程的执行有时需要依赖共享的代码库（比如 libc），这些代码库会被映射到用户栈下方的虚拟地址处，并标记为只读。</li><li>用户堆：堆管理的是进程动态分配的内存。与栈相反，堆的扩展方向是自底向上，堆顶在高地址上，当进程需要更多内存时，堆顶会向高地址扩展。</li><li>数据与代码段：处于较低地址的是数据段与代码段，它们原本都保存在进程需要执行的二进制文件中，在进程执行前，操作系统会将它们载入虚拟地址空间。其中，数据段保存的是全局变量的值，代码段保存的是进程执行所需的代码。</li><li>内核部分：处于进程地址空间最顶端的是内核内存。每个进程的虚拟地址空间里都映射了相同的内核内存。当进程在用户态运行时，内核内存对其不可见；只有当进程进入内核态时，才能访问内核内存。与用户态相似，内核部分也有内核需要的代码和数据段，当进程由于中断或系统调用进入内核后，会使用内核的栈。</li></ul><p>每个进程都通过一个数据结构来保存它的相关状态，如进程标识符（PID）、进程状态、虚拟内存状态、打开的文件等。这个数据结构成为进程控制块（PCB）。在进行上下文切换时，会将前一个进程的寄存器状态保存到 PCB 中，然后将下一个进程先前保存的状态写入寄存器，从而切换到该进程执行。</p><p>进程的创建：fork，进程的执行：exec。 </p><p>进程间监控：wait，wait 可以用来等待子进程，来回收已经运行结束的子进程和释放资源。如果父进程没有调用 wait 操作，那或者还没来得及调用 wait 操作，就算子进程已经终止了，它所占用的资源也不会完全释放，这种进程成为“僵尸进程”。内核会为僵尸进程保留其进程描述符 PID 和终止时的信息，以便父进程在调用 wait 时可以监控子进程的状态。由于管理 PID 也需要一定的内存开销，内核会设定最大可用 PID 的限制，如果一个进程创建了大量子进程却不调用 wait，那么僵尸进程会迅速占据可用 PID，使得后续的 fork 因为内核资源不足而失败。不过如果父进程退出了，那么子进程的信息就不再会被父进程使用，也就没有必要继续保留它们了。这时，所有父进程创建的僵尸进程都会被内核的第一个进程 init 通过 wait 的方式回收。</p><p>进程组是进程的集合，进程组的一大作用体现在对信号的处理，应用程序可以调用 killpg 向一个进程组发送信号，这个信号会被发送给这个进程组的每个进程。</p><p>会话是进程组的集合，可以由一个或多个进程组构成。会话将进程组根据执行状态分为前台进程组和后台进程组，控制终端进程是会话与外界进行交互的“窗口”，它负责接收从用户发来的输入。</p><p>fork 的优点：<br>简洁，fork 和 exec 的组合可以认为是将进程的创建过程进一步的解耦：fork 为进程搭建了“骨架”，而 exec 则为进程添加了“血肉”，亮着的分工非常清晰，由于 fork 和 exec 的解耦，程序可以再 fork 调用后，exec 调用前，对子进程进行各种设定，比如对文件进行重定向。另外，fork 还强调了进程与进程之间的联系，由于 fork 具有创建原有进程的拷贝的语义，原进程与 fork 创建的进程之间存在较强的联系（父进程与子进程），这种联系为进程的管理提供了遍历，比如在 Shell 中，虽然同一个 shell 创建的进程的功能不同，但是它们都来自同一个用户，因此可以共享很多状态。又如，web 服务场景中，服务器为每个请求单独创建一个进程，由于这些进程的罗技相似，因此可以通过 fork 一次创建多个进程来应对用户的请求。</p><p>fork 的局限性：</p><ul><li>fork 过于复杂，由于 fork 到的默认语义是构造与父进程一样的拷贝，因此它会使得子进程与父进程共享大量状态，可能会使进程表现出看似违反直觉的行为。每当操作系统为进程的结构添加功能时，就必须考虑到对 fork 的实现和修改，fork 在实现过程中需要考虑的特殊情况越来越多，代码越来越复杂。另外由于 fork 的实现与进程、内存管理等模块的耦合程度越高，因此不利于内核的代码维护。</li><li>fork 的性能太差，由于 fork需要创建出原进程的一份拷贝，原进程的状态越多，fork 的性能就越差。尽管写时拷贝已经大大减少了内存拷贝，但对于这类应用来说，就连建立内存映射都需要耗费大量时间，fork 的效率已经满足不了它们的需要。</li><li>fork 存在潜在的安全漏洞，fork 建立的父进程与子进程之间的联系可能会成为攻击者的重要切入点。 </li></ul><p>除了以上三点，还有扩展性差、与异质硬件不兼容、线程不安全等。</p><p>Linux 针对 fork 提出了多种替代方案：</p><ul><li>posix_spawn：灵活度不如fork &amp; exec，但是性能要好于 fork&amp;exec</li><li>vfork：vfork 是 fork 的裁剪版，从父进程中创建出子进程，但是不会为子进程单独创建地址空间，只适合用在进程创建后立即使用 exec 的场景，vfork &amp; exec 相比 fork&amp;exec 省去了一次地址空间的拷贝。</li><li>rfork/clone：fork 的精密控制版本，允许应用程序通过参数对创建过程进行更多的控制</li></ul><p>进程抽象过于笨重：</p><ol><li>创建进程的开销较大，需要完成创建独立的地址空间、载入数据和代码段、初始化堆等步骤，即使使用 fork 接口创建进程，也需要对父进程的状态进行大量拷贝</li><li>由于进程拥有独立的虚拟地址空间，在进程间进行数据共享和同步比较麻烦，一般只能基于共享虚拟内存页（粒度较粗）或者基于进程间通信（开销较高）。</li></ol><p>因此提出在进程内部添加可独立执行的单元，它们共享进程的地址空间，但又各自保存运行时所需的状态（上下文），这就是线程。线程取代进程成为操作系统调度和管理程序的最小单位。</p><p>多线程的地址空间主要有两个重要特征：</p><ul><li>分离的内核栈和用户栈：由于每个线程的执行相对独立，进程为每个线程都准备了不同的栈，供它们存放临时数据。在内核中，每个线程也有对应的内核栈，当线程切换到内核中执行时，它的栈指针会切换到对应的内核栈</li><li>共享的其他区域：进程除栈以外的其他区域由该进程的所有线程共享，包括堆、数据段、代码段等。当一个进程的多个线程需要动态分配更多的内存时（在 C 语言中可通过调用 malloc 函数实现），它们的内存分配操作都是在同一个堆上完成的。因此 malloc 的实现需要使用“同步原语”，使每个线程能正确的获取可用的内存空间</li></ul><p>线程分为：用户态线程和内核态线程。有三种多线程模型：</p><ul><li>多对一模型</li><li>一对一模型（Linux &amp; Windows 默认）</li><li>多对多模型（macOS 和 iOS）  </li></ul><p>与进程类似，线程也有自己的线程控制块（TCB），用于保存与自身相关的信息。在目前主流的一对一线程模型中，内核态线程和用户态线程都会各自保存自己的 TCB。内核态 TCB 结构与 PCB 相似，会存储现成的运行状态、内存映射、标识符等信息。用户态 TCB 的结构则主要由线程库决定，对于 Linux 平台上使用 pthread 线程库的应用来说，pthread 结构体就是用户态的 TCB。用户态的 TCB 可以认为是内核态的扩展，可以用来存储更多与用户态相关的信息，其中一项重要的功能就是线程本地存储（TLS）。</p><p>sleep vs yield ：   </p><p>sleep 操作与 yield 有相似之处，他们都会让当前线程放弃 CPU 资源，交给其他线程执行。它们最重要的区别是调用后线程的状态。当线程调用 yield 后，它会处于预备状态，并可能很快就会被调度；在某些极端情况下，如果没有其他可调度线程，该线程甚至会继续执行。而当调用 sleep 之后，它会进入阻塞状态，只有满足条件后才会重新恢复到预备状态。可以把 yield 看做类似于 sleep（0），即挂起时间无限趋近于 0 的调用。</p><p>线程的上下文是上下文切换的基础，在实际硬件中，上下文主要指的是当前处理器中大部分寄存器的值，这其中包括：</p><ul><li>程序计数器（PC）存储 CPU 当前所执行指令的地址；</li><li>通用寄存器，存储 CPU 当前正在处理的一些数据；</li><li>特殊寄存器，存储 CPU 当前的一些硬件状态和配置，如页表地址等。</li></ul><h2 id="第6章-操作系统调度"><a href="#第6章-操作系统调度" class="headerlink" title="第6章　操作系统调度"></a>第6章　操作系统调度</h2><p>一般来说，一个系统会同时处理多个请求，但是其资源是优先的，调度就是用来协调每个请求对资源的使用的方法。调度中存在：优先级，时间片，截止时间等概念。</p><p>任务调度（task scheduling 也称 CPU 调度）负责调度可执行的任务对 CPU 的使用；I/O 调度负责对应该以何种顺序想存储设备发起 I/O 请求进行调度；内存管理也是一种调度，内存管理将虚拟内存映射到物理内存，物理内存是有限的资源，当需要使用的虚拟内存超过物理内存容量时，换页机制就是在对哪部分物理内页的内容可以留在内存中进行调度，并将剩余物理页上到的内容写回磁盘，进而复用那些剩余的物理页。</p><p>一般调度器会通过维护运行队列（run queue）的方式来管理任务，Linux 调度器会用红黑树来实现运行队列，任务在执行时若触发一定条件，则会停止执行，这些条件可以是：</p><ul><li>该任务执行了指定的时间片后，应让其他任务在当前 CPU 核心上执行</li><li>该任务发起了 I/O 请求，在 I/O 返回前，它不会继续执行</li><li>该任务主动停止执行或进入睡眠</li><li>该任务被系统中断打断，系统优先处理中断而暂缓该任务的执行</li></ul><p>调度器主要作用是做出调度决策，整个系统通过该决策进而决定如何调度，这些调度决策包括：</p><ul><li>从运行队列中选择下一个运行任务</li><li>决定执行该任务的 CPU 核心</li><li>决定该任务被允许执行的时间，即时间片</li></ul><p>调度器的设计问题主要可以归纳为两类：</p><ul><li>调度器应该做出什么样的调度决策（what）？</li><li>调度器应该如何做出符合预期的调度决策（how）？</li></ul><p>常用的调度指标包括：</p><ul><li>性能 <ul><li>吞吐量、周转时间、响应时间、调度开销 </li></ul></li><li>非性能 <ul><li>公平性、资源利用率 </li></ul></li><li>特殊 <ul><li>实时性、能耗 </li></ul></li></ul><p>调度器面临的挑战：</p><ul><li>调度指标多样性</li><li>调度可参考的信息有限</li><li>任务间的复杂交互</li><li>许多方便存在权衡</li></ul><p>调度器权衡包括但不限于一下几点：</p><ul><li>调度开销与调度效果</li><li>优先级与公平性</li><li>性能与能耗</li></ul><p>在任务调度中，长期、中期和短期调度相互协作，分别以不同的目标对进程进行调度。<br>长期任务的触发间隔较长，它粗粒度的决定是否应该将一个新的进程纳入调度管理，负责增加系统中可被调度的进程的数量；<br>中期调度的触发相对频繁，它辅助换页机制，负责限制系统中可被调度的进程的数量；<br>短期调度的触发最为频发，它负责细粒度的调度进程的执行，做出相应的调度决策。  </p><p>调度流程：</p><ol><li>在传统操作系统中，批处理任务被发起后，其信息会被存入磁盘中的批处理队列，等待被长期调度允许进入系统；</li><li>长期调度负责从批处理队列中选取下一个可被调度的批处理任务，为其创建对应的进程，将进程设为预备状态并放入运行队列；</li><li>由于交互任务和实时任务一般都有比较高的时延要求，需要在一定时间内返回结果。所以这两类任务一般不会被长期调度管理。系统会直接为他们创建对应的进程，将进程设为预备状态并放入运行队列；</li><li>通过短期调度的决策，运行队列中的进程会被调度到 CPU 上执行，此时进程为运行状态；</li><li>当进程运行完一个时间片后，短期调度会将其重新置为预备状态，并放回运行队列；</li><li>当运行中的进程发起 I/O 请求，等待用户输入或进入睡眠，因而需要被阻塞时，会被放入阻塞队列，短期调度会选择其他进程进行调度；</li><li>当进程等待的事件被触发后，操作系统直接将对应的进程移出阻塞队列，并将其置为预备状态，重新放入运行队列；</li><li>如果系统中的内存使用量偏大，就会触发换页机制，中期调度会挂起处于预备状态、阻塞状态的进程，将其置为挂起预备状态/挂起阻塞状态并放入挂起运行队列/挂起阻塞队列中；</li><li>处于挂起阻塞状态的进程，如果其等待的时间被处罚，会被置为挂起预备状态并被放入挂起运行队列中；</li><li>当系统的内存使用不再紧张时，中期调度会激活挂起运行队列/挂起阻塞队列中的进程，将其置为预备状态/阻塞状态并放回运行队列/阻塞队列中；</li><li>当进程结束后，会进入终止状态并最终被回收<h3 id="单核调度策略"><a href="#单核调度策略" class="headerlink" title="单核调度策略"></a>单核调度策略</h3><h4 id="经典调度"><a href="#经典调度" class="headerlink" title="经典调度"></a>经典调度</h4>先到先得（FCFS），<br>弊端：</li></ol><ul><li>在长短任务混合的场景下对短任务不友好</li><li>对 I/O 密集型任务不友好</li></ul><p>最短任务优先（SJF）</p><p>弊端：  </p><ul><li>必须预知任务的运行时间</li><li>其表现严重依赖与任务到达时间点</li><li>最短完成时间任务优先（STCF），SJF 的抢占式版本</li></ul><p>弊端：</p><ul><li>必须预知任务的运行时间</li><li>长任务饥饿</li></ul><p>时间片轮转（RR）</p><p>对于 RR 策略，一个关键点是它的时间片该如何选取。</p><p>弊端：</p><ul><li>在任务运行时间相似的场景下平均周转时间高，RR 一定程度上保证了每个任务之间的公平性，同时也可获得良好的响应时间，但是在特定场景下，任务的平均周转时间可能较差。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>多级队列（MLQ），每个任务会被分配预先设置好的优先级，每个优先级对应一个队列，任务会被存储在对应的优先级队列中。如果优先级不同的任务同时处于预备状态，那么调度器应该倾向于调度优先级较高的任务，因此一个任务必须等到所有优先级比它高的任务调度完成才可以被调度。处于相同优先级队列的任务，它们内部的调度方式没有统一标准，可以针对性的为不同队列采用不同的调度策略，如 FCFS 或 RR。</p><p>在设置 MLQ 策略的任务优先级时，需要注意将 I/O 密集型任务的优先级提高，保证 I/O 资源利用率。</p><p>弊端：</p><ul><li>低优先级任务饥饿，如果调度器需要保证一定的公平性，需要引入额外的机制监控任务等待时间，为等待时间过长（如超过一定的阈值）的任务提升优先级</li><li>优先级反转，在程序执行时，多个任务可能会对同一份数据产生竞争，因此任务会使用锁来保护共享数据。假设存在 3 个任务A，B，C，他们的优先级是 ABC，任务 C 在运行时持有一把锁，然后被高优先级的 A 抢占了，A 也想申请任务 C 持有的锁，但是申请失败，因此进入阻塞状态等待 C 释放锁，此时 BC 都处于可以运行状态，B 优先级高，因此 B 先运行，观察该情况，会发现 B 的优先级好像高于 A，这一问题称为优先级反转。一个可行的解决方案是优先级继承。</li></ul><p>多级反馈队列（MLFQ），在 MLQ 基础上，增加了动态设置任务优先级的策略，MLFQ 策略也会维护多个优先级队列，处于相同优先级的任务则采用 RR 策略执行，优先级的动态设置策略如下：</p><ul><li>短任务拥有更高的优先级，好处：1. 可以有更好的平均周转时间；2. I/O 密集型任务一般在 CPU 中执行的时间很短，给短任务提高优先级也相当于提高 I/O 密集型任务的优先级，提高系统的 I/O 资源利用率；3. 交互式任务一般是短任务，降低响应时间。根据每个任务（多次）执行时间来判断是短任务还是长任务。当任务进入系统中，假设任务是短任务，MLFQ 会为每个任务队列设置任务的最大运行时间，如果超过了最大时间，就会将该任务的优先级减一。</li><li>低优先级的任务采用更长的时间片，为了减少任务的调度次数，优先级月底的任务，其时间片越长，由于 MLFQ 策略支持抢占式调度，无须担心低优先级的任务阻塞新进入系统的任务。</li><li>定时将所有任务的优先级提升至最高，避免出现低优先级任务饥饿。</li></ul><p>公平共享调度</p><ul><li>“公平”是指任务对资源的使用符合用户预期</li></ul><p>公平共享调度会量化任务对系统资源的占有比例，从而实现对资源的公平调度。用份额（share）来量化每个任务对 CPU 时间的使用。份额支持曾计划的分配方式，可以将任务分组，以组为单位分配份额，任务组会在组内进一步分摊该组所拥有的份额。</p><p>优先级和份额都表示了任务在系统中的重要程度，但是目的是不同的。优先级调度是为了优化任务的周转时间、响应时间和资源利用率而设计的。不同任务的优先级只能用于相互比较，表明任务执行的先后。而基于份额的公平共享调度是为了让每个任务都能使用它应该获得的系统资源。分隔的值明确对应了任务应使用的系统资源比例。</p><p>彩票调度，彩票转让，彩票货币，彩票通胀。<br>弊端：</p><ul><li>随机数所带来的问题，彩票调度通过使用随机的方式实现了一个简单并且近似于公平共享的调度器，然而，随机数会导致某一任务占用 CPU 时间的比例，需要在该任务经历多次调度后，才能趋近于该任务的份额在所有任务总份额的比例。只有调度次数足够多，彩票调度效果才接近公平。<br>步幅调度，采用确定性的方式调度任务，核心概念是步幅。引入虚拟时间的概念。为了让虚拟时间短的任务能够“追赶”虚拟时间长的任务，使用虚拟时间的调度策略一般会选择调度所有任务中虚拟时间最少的任务。步幅调度通过设置虚拟时间的方式，让任务在每次调度时增加一定的虚拟时间，即步幅。经历虚拟时间相同的任务，它们使用的 CPU 时间之比就是步幅的倒数之比，换句话说，任务的份额之比正对应了任务的步幅的倒数之比。在真实的系统中，由于任务可能在任意时间进入系统，因此任务经历的虚拟时间不能为 0，而应该设置为当前所有任务的最小虚拟时间值，放置新进入的任务长时间占有 CPU。</li></ul><p>实时调度</p><p>根据任务超过截止时间所造成的后果分类：</p><ul><li>硬实时任务，该类任务必须在截止时间前完成</li><li>软实时任务，该类任务可以偶尔超过截止时间完成</li></ul><p>根据被触发的时间分类：</p><ul><li>周期任务，指到达系统时间遵循一定周期的任务</li><li>偶发任务，指不会周期性的到达系统的任务，且还要满足连续两个相同偶发任务到达系统的时间间隔有最小值，即系统不会在同一时刻处理两个相同的偶发任务。偶发任务通常是硬实时任务。</li><li>非周期性任务，指到达系统时间随机的任务，通常是软实时任务。</li></ul><h3 id="多核调度策略"><a href="#多核调度策略" class="headerlink" title="多核调度策略"></a>多核调度策略</h3><p>在多核上进行调度时，需要回答以下三个问题：</p><ul><li>当前应该调度哪个/哪些任务？</li><li>每个调度的任务应该在哪个 CPU 核心上执行？</li><li>每个调度的任务应该执行多久？</li></ul><p>负载分担</p><p>设想多核共享一个全局运行队列，当一个 CPU 核心需要调度任务时，根据给定的调度策略，决定全局运行队列中下一个由它执行的任务。给定的调度策略可以是任一一种单核调度策略，这种方法称为负载分担，因为系统的负载是被所有的 CPU 核心分担的。</p><p>优点：</p><ul><li>设计实现简单，通过使用负载分担，可以将多核调度问题规约为单核调度问题，使用已有的单核调度策略和单核调度器，就可以实现一个多核的全局调度器</li><li>每个 CPU 核心都会分担系统的负载，不会出现 CPU 资源浪费的情况，一个 CPU 核心执行完当前任务后，它会从全局任务队列中再选取一个任务执行，只要当前系统还有可以执行的任务，每个 CPU 核心都能获取到任务执行</li></ul><p>问题：</p><ul><li>多核共享一个全局运行队列的同步开销</li><li>任务在多个 CPU 核心间来回切换的开销，包括重新载入缓存，TLB 刷新等</li></ul><p>协同调度</p><p>为了满足对蚁族任务进行调度的需求，协同调度的概念应运而生。协同调度的目的是尽可能让一组任务并行执行，避免调度器同时调度有依赖关系的两组任务，同时避免关联任务执行效率降低的问题。</p><p>协同调度的经典策略是群组调度。</p><p>两级调度</p><p>为了减少任务在不同 CPU 核心上切换执行的开销，每个任务应尽可能只在一个 CPU 核心上进行调度。因此，新的调度策略改为每个 CPU 核心都引入一个本地调度器，并用它管理对应核心上执行的任务。这种调度策略使用全局调度器和本地调度器，构成了层级化结构，一般称为两级调度。</p><p>当一个任务进入系统时，全局调度器根据系统的当前信息，诸如每个 CPU 核心的负载情况，决定该任务应该被哪个 CPU 核心执行，当一个任务被分配给定的核心时，它将一直被该核心的本地调度器管理，不会迁移到其他 CPU 核心上执行。同时，每个本地调度器可以使用任意单核调度策略来调度任务。在避免线程在 CPU 核心间来回切换，提高了缓存局部性，较少了数据竞争的冲突的同时，这种曾计划的设计将设计单核调度策略与支持多核调度进行了解耦，使得调度器的设计实现更加灵活。以 Linux 为代表的一系列操作系统会为每个 CPU 核心分配一个本地运行队列，即可理解为每个 CPU 核心有一个本地调度器。</p><p>负载追踪与负载均衡</p><p>两级调度策略避免了任务在多核间切换，但是由于在任务开始时就指定了它在哪个 CPU 上运行，且没有任务在 CPU 核心间切换的机制，可能会导致多核间的负载不均衡，为了解决这个问题，引入了负载均衡的策略，负载均衡的思想是：通过追踪每个 CPU 核心当前的负载情况，将处于高负载的 CPU 核心管理的任务迁移至低负载的 CPU 核心上，尽可能的保证每个核心的负载大致相同。</p><p>负载均衡面临的挑战是：如何确定当前任务的负载情况，一个任务的执行负载是动态变化的，因此系统必须动态追踪当前的负载情况，这会造成一定的性能开销，如何保持低开销的同时对负载进行精确追踪是调度器设计实现的一大挑战，Linux 目前使用的是调度实体粒度负载追踪（PELT）。</p><p>运行队列粒度的负载追踪，在 Linux 3.8 以前，内核以每个 CPU 核心的运行队列为粒度计算负载，认为运行队列长的负载就高，导致负载追踪不够精确。</p><p>调度实体粒度的负载追踪，在 Linux 3.8 以后，Linux 使用了以调度实体（单个任务）为粒度的负载计算方式，做到了更细粒度的负载追踪。PELT通过记录每个任务的历史执行状况来表示任务的当前负载。具体的，调度器会以 1024 微妙作为一个周期，记录任务处于可运行状态（包括正在运行的以及等待被运行的）的时间，记为 x 微妙。该任务在第 i 个周期内对当前 CPU 的利用率为 x/1024，而对应的负载 Li 为 scale_cpu_capacity <em> x/1024 ，其中 scale_cpu_capacity 是 CPU 容量，可以理解为对应 CPU 核心的处理能力。在手机到任务每个周期内的负载后，PELT 需要计算一段时间内任务所有周期的累计负载，随着距离当前时间越远，数据参考意义越小，采用衰减系数 y 来计算：<br>L = L0 + L0 </em> y + L1 <em> y^2 + L2 </em> y ^3…. 通过计算每个任务的负载 L，PELT 就可以进而统计出每个运行队列的负载，便于调度器做出有效的迁移决策。</p><p>随着 CPU 核心数量越来越多，系统架构越来越复杂，负载均衡策略应该让任务尽量在迁移开销较小的 CPU核心间迁移，以 NUMA 架构为例，当任务从一个 NUMA 节点迁移到另一个 NUMA 节点，会严重影响任务的执行效率，又以超线程为例，一个物理核会被逻辑上分为两个逻辑核，任务在同属于一个五里河的两个逻辑核间切换的开销，会比在不同五里河的两个逻辑核间的开销小很多。</p><p>Linux 为了解决上述问题，采用层级化的方法，引入两个数据结构：调度与是有用相同特性的 CPU 核心的集合，这些核心间可以进行负载均衡。一个调度与保存一个或多个调度组，调度组是一个调度与内进行负载均衡的整体单位。通过自下而上的方式层级式的进行负载均衡，并且为了设计简单，只允许触发负载均衡的 CPU 核心拉取其他 CPU 核心的任务到本地。如果当前 CPU 核心触发负载均衡逻辑，首先在最底层调度域内的调度组间进行均衡，然后依次进入更高一级的调度域，并对其管理的调度组进行负载均衡。由于越高层级的调度域间进行负载均衡的开销越大，所以 Linux 为不同层级的调度域设置了不同的负载均衡触发频率与阈值。</p><p>对于非实时任务，Linux 使用 CFS 调度器进行调度，CFS 采用了累死公平共享调度的策略，因此其主要关心每个任务占用 CPU 时间的份额。sched_nice 为[-20,19] 的 Niceness ，越不友善的任务越倾向于使用更多的资源或抢占其他友善的任务。</p><p>Linux 调度器设计</p><p>O(n) 调度器</p><p>在 Linux 2.4 版本以前，Linux 调度器是一个机遇 RR 策略的运行队列，没有考虑很多因素（诸如任务的实时性要求）。从 Linux 2.4 版本开始，采用 O(n) 调度器，O(n) 调度器指定调度决策的时间复杂度是 O(n) ，n 代表的是调度器运行队列中的任务数量。</p><p>O(n) 调度器采用了负载分担的思想，所有任务被存储于一个全局运行队列中，被选择调度的任务会从运行队列中移除，当该任务执行完并且需要再次被调度时，会被重新放入运行队列的队尾。当调度器选择下一个被调度的任务时，需要遍历运行队列中的所有任务，并重新计算他们的动态优先级，然后选取动态优先级最高的任务。</p><p>存在问题：</p><ul><li>调度开销过大</li><li>多核扩展性差</li></ul><p>O(1) 调度器</p><p>由于O(n) 调度器存在上述问题，Linux 在 2.6.0 版本使用心得 O(1) 调度器替换 O(n) 调度器。 O(1) 调度器采用了两级调度的思想，每个 CPU 核心单独维护一个本地运行队列，让任务仅在同一个核心上调度。每个本地运行队列实际上是由两个多级队列：激活队列和过期队列组成的，分别用于管理仍有时间片剩余的任务和时间片耗尽的任务。当一个任务的时间片耗尽后，它会被加入到过期队列中。如果当前激活队列中没没有可调度的任务， O(1) 调度器会将两个队列的角色互换，开始新一轮调度。<br>每个多级队列都有 140 个优先级，其中高优先级 [0,100) 对应于实时任务，剩下的优先级 [100, 140) 对应于不同 Niceness 的非实时任务。每个多级队列都维护了一个位图，位图中的比特位用于判断对应的优先级队列是否有任务等待调度，在制定调度决策时， O(1) 调度器会根据位图找到激活队列中第一个不为空的队列，并调度该队列的第一个任务，其时间复杂度是 O(1) ，与运行队列中的任务数量无关。</p><p>用户可能不希望交互式任务在时间片用完后就需要等待所有其他任务的时间片用完才能再次执行，因此该类任务在时间片用完后，仍然会被加入激活队列中。同时，为了防止交互式任务过于激进而导致当前过期队列中的任务无法执行，当过期队列中的任务等待过长时间后， O(1) 调度器会把交互式任务加入过期多列中。</p><p>存在问题：</p><ul><li>交互式任务的判定算法过于复杂</li><li>静态时间片带来的问题， O(1) 调度器的非实时任务的运行时间片是根据其 Niceness 静态确定的，问题是，随着系统中任务数量的上升，任务的调度时延也会上升，对应的，响应时间也会受到影响。</li></ul><p>完全公平调度器</p><p>为了解决 O(1)调度器的问题，Linux 从 2.6.23 版本开始使用完全公平调度器。公平共享调度策略保证每个任务可以根据自己所占的份额共享 CPU 时间，这是 CFS 调度器的基本思想，O(1)调度器需要繁琐的通过启发式方法确定交互式任务，再给与交互式任务更多的执行机会。而 CFS 调度器只关心非实时任务对 CPU 时间的公平共享，避免了复杂的调度算法实现与调参。同时通过动态的设定任务时间片，确保了任务的调度时延不会过高。</p><p>CFS 调度器所使用的调度策略类似于步幅调度，vruntime 代表人物经过的虚拟时间，在调度是 CFS 会调度 vruntime 值最低的任务，Linux 静态的设置了 Niceness 与任务权重的对应关系，Niceness 越低则任务的权重越高，可被分配的 CPU 时间越多。</p><p>CFS 调度器的动态时间片，为了避免静态设置任务时间片所带来的问题，CFS 调度使用了调度周期的概念，并保证每经过一个调度周期，运行队列中所有任务都会被调度一次。因而在最坏的情况下，任务的调度时延即为一个调度周期。同时间片一样，调度周期会带来权衡问题。如果调度周期过长，则一系列任务必须在很长时间的运行后才能体现公平性，且任务的调度时延可能过长；如果调度周期过短，则调度开销会变大。</p><p>确定了 CFS 的调度周期后，调度器就可以开始计算在当前运行队列中，第 i 个任务的动态时间片 time_slice_i = sched_period * weight_i / weight_rq ，其中 weight_i 是第 i 个任务的权重，weight_rq 代表当前运行队列中的任务权重之和。</p><p>由于每个任务的动态时间片是不同的，都根据任务权重进行了缩放，所以任务每次执行后对 vruntime 的更新也要进行对应的缩放：<br>vruntime_i = vruntime_i + weight_nice0 / weight_i * real_runtime ，其中 weight_nice0 表示一个 Niceness 为 0 的任务的权重，该权重与 weight_i 的比值是一个系数，用于将任务的实际运行时间映射为虚拟时间。通过该系数，CFS 保证了不同动态时间片的任务执行完自己的时间片后，他们虚拟时间的增幅是一致的。</p><h2 id="第7章-进程间通信"><a href="#第7章-进程间通信" class="headerlink" title="第7章　进程间通信"></a>第7章　进程间通信</h2><p>共享内存 vs 基于共享内存的消息传递：基于共享内存的消息传递以共享内存为媒介进行消息的传输，其核心的通信抽象仍然是消息。共享内存的另一种使用方法是，直接在两个（多个）进程间建立共享区域，然后再共享区域上建立数据结构。进程可以直接使用该共享区域上的数据，而不存在”消息“的抽象。</p><p>宏内核下的典型的进程间通信机制：管道，消息队列，信号量，共享内存，信号，套接字。</p><h2 id="第8章-同步原语"><a href="#第8章-同步原语" class="headerlink" title="第8章　同步原语"></a>第8章　同步原语</h2><p>实际应用程序中有很多需要同步的场景，为了正确，搞笑的解决这些同步问题，抽象出了一系列同步原语。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当程序的正确性依赖于特定执行顺序的情况时，被称为竞争冒险。避免竞争冒险最直接的办法就是：确保同一时刻只有生产者中的一个能够对共享缓冲区进行操作。任意时刻只允许至多一个线程访问的方式被称为互斥访问，而保证互斥访问共享资源的代码区域被称为临界区。</p><p>需要满足以下条件：</p><ul><li>互斥访问：在同一时刻，最多只能有一个线程可以执行临界区</li><li>有限等待：当一个线程申请进入临界区后，必须在有限的时间内获得许可并进入临界区，不能无限等待</li><li>空闲让进：当没有线程在执行临界区代码时，必须在申请进入临界区的线程中选择一个线程，允许其执行临界区代码，保证程序执行的进展。</li></ul><p>硬件实现：关闭中断。   </p><p>关闭中断可以防止执行临界区的线程被抢占，避免多个线程同时执行临界区，保证了互斥访问。而有限等待依赖于内核的调度器，如果能保证有限时间内调度到该线程，则该线程可以再有限时间内进入临界区，达成有限等待的要求。最后，每个线程离开临界区时都开启了中断，允许调度器调度其他线程执行，达成了空闲让进的要求。但是多核环境中，即使关闭了所有核心的中断，也不能阻塞其他核心上正在运行的线程继续执行。</p><p>软件实现：皮特森算法<a href="https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95。" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95。</a></p><p>软硬件协同：使用原子操作实现互斥锁。原子操作指的是不可被打断的一个或一系列操作。即要么这一系列指令都执行完成，要么都没有执行，最常见的是比较与置换 （CAS）拿取并累加（FAA）。</p><p>互斥锁的实现种类多，不同的互斥锁被用于不同的场景，比如利用原子 CAS 实现的自旋锁，利用原子 FAA 实现的排号自旋锁。</p><p>自旋锁：利用一个变量 lock 表示锁的状态，lock 为 1 表示已经有人拿锁，为 0 表示空闲。在加锁时，线程会通过 CAS 判断 lock 是否为空闲，如果空闲则上锁，否则将一遍一遍重试。放锁时，直接将 lock 设置为 0 表示其空闲。自旋锁不能保证有限等待，即不具有公平性。自旋锁并非按照申请的顺序决定下一个获取锁的竞争者，而是让所有的竞争者均同时尝试完成原子操作。</p><p>排号自旋锁：排号自旋锁按照锁竞争者申请锁的顺序传递锁，锁的竞争者组成了一个 FIFO 的等待队列。排号锁的结构体有两个成员，owner 表示当前锁持有者序号，next 表示下一个需要分发的序号。获取排号所需要先通过原子的 FAA 操作拿到最新的序号并同时增加锁的分发序号，来避免其他竞争者拿到相同的序号。拿到序号后，竞争者通过判断 owner 的值，等待排到自己的序号，一旦两者想等，竞争者拥有该锁并被允许进入临界区。释放锁时，持有者更新 owner 的值将锁传递给下一个竞争者，保证了公平性。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>使用条件变量提供的借口，一个线程可以停止使用 CPU 并将自己挂起，当等待的条件满足时，其他的线程会唤醒该挂起的线程让其继续执行，使用条件变量能够有效的避免无谓的循环等待。</p><p>互斥锁 vs 条件变量：   </p><p>互斥锁与条件变量解决的不是同一个问题，互斥锁用于解决临界区的问题，保证互斥访问共享资源。而条件变量通过提供挂起/唤醒机制来避免循环等待，节省 CPU 资源。条件变量需要和互斥锁搭配使用。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量在不同的线程之间充当信号灯，根据剩余资源数量控制不同线程的执行或等待。信号量又被成为 PV 原语，P 为校验，V 为自增。</p><p>互斥锁 vs 信号量：<br>互斥锁与信号量有相似之处。当信号量的初始值为 1，且只允许其值在 0 和 1 之间变化时，wait 和 signal 操作分别于互斥锁的 lock 和 unlock 操作类似，称这种信号量为二院信号量。二元信号量与互斥锁的差别在于：互斥锁有拥有者概念，二元信号量没有。互斥锁往往由同一个线程加锁和放锁，信号量允许不同线程执行 wait 与 signal 操作。互斥锁与计数信号量（非二元信号量）区别较大，计数信号量允许多个线程通过，其数量等于剩余可用资源数量；而互斥锁同一时刻只允许一个线程获取。互斥锁用于保证多个线程对一个共享资源的互斥访问，而信号量用于协调多个线程对一系列共享资源的有序操作。</p><p>条件变量 vs 信号量：<br>信号量是由条件变量、互斥锁以及计数器实现的。而这个计数器就是信号量的核心，用于表示当前可用资源的数量。可以理解为：信号量利用条件变量实现了更高层级的抽象。</p><p>同步带来的问题</p><p>死锁</p><p>死锁产生的必要条件： </p><ul><li>互斥访问</li><li>持有并等待</li><li>资源非抢占</li><li>循环等待</li></ul><p>优先级反转：由于同步导致线程执行顺序违反预设优先级的问题。</p><p>解决方法：</p><ul><li>不可抢占临界区协议，核心时避免线程在临界区中被抢占，当线程获取锁，编不允许任何其他线程抢占。</li><li>优先级继承协议，在高优先级线程等待锁时，会使锁的持有者继承其优先级，从而避免该锁的临界区被低优先级的任务打断。</li><li>优先级置顶协议，将获取锁的线程的优先级置为可能竞争该锁的最高优先级。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第1章-操作系统概述&quot;&gt;&lt;a href=&quot;#第1章-操作系统概述&quot; class=&quot;headerlink&quot; title=&quot;第1章　操作系统概述&quot;&gt;&lt;/a&gt;第1章　操作系统概述&lt;/h2&gt;&lt;p&gt;操作系统有两个职责：对硬件进行管理和抽象，为应用提供服务并进行管理。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>Podman(Docker) Compose 学习记录</title>
    <link href="https://zdyxry.github.io/2021/01/09/Podman-Docker-Compose-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2021/01/09/Podman-Docker-Compose-学习记录/</id>
    <published>2021-01-09T18:56:30.000Z</published>
    <updated>2021-05-22T01:05:51.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>最近因为一些需求可能需要用到 Compose，看了看 Podman Compose 和 Docker Compose，记录一下。</p><p>Compose 主要功能：</p><ul><li>环境隔离(docker)</li><li>一组服务的起停控制</li><li>服务之间的依赖管理</li></ul><h2 id="Podman-compose"><a href="#Podman-compose" class="headerlink" title="Podman compose"></a>Podman compose</h2><p>项目地址：<a href="https://github.com/containers/podman-compose" target="_blank" rel="noopener">https://github.com/containers/podman-compose</a></p><p>用爱发电的项目，所有的实现都在 <code>podman_compose.py</code> 中，由于 Podman 没有一个好用的 client ，所以 compose 中所有的 Podman 相关的交互都是通过命令行来完成的，目前处于一个非常早期的状态，最基本的服务依赖都没有实现，不建议使用。</p><h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cli/            # 命令行解析</span><br><span class="line">config/         # 配置文件格式、校验方式、辅助函数</span><br><span class="line">const.py        # constants</span><br><span class="line">container.py    # 使用 docker client 对 container 命令及属性进行封装</span><br><span class="line">errors.py       # error code</span><br><span class="line">network.py      # 网络相关配置</span><br><span class="line">parallel.py     # 并发操作封装</span><br><span class="line">progress_stream.py # stream 相关</span><br><span class="line">project.py      # project，project 与 service 是一对多的关系</span><br><span class="line">service.py      # service，service 与 container 是一对一或一对多的关系</span><br><span class="line">timeparse.py    # 时间转换</span><br><span class="line">utils.py        # utils function</span><br><span class="line">volume.py       # volume 相关封装</span><br></pre></td></tr></table></figure><p>Docker 官方提供，所有的 container 都通过 docker python client 进行。service 之间的依赖管理通过拓扑排序实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def sort_service_dicts(services):</span><br><span class="line">    # Topological sort (Cormen/Tarjan algorithm).</span><br><span class="line">    unmarked = services[:]</span><br><span class="line">    temporary_marked = set()</span><br><span class="line">    sorted_services = []</span><br><span class="line"></span><br><span class="line">    def visit(n):</span><br><span class="line">        if n[&apos;name&apos;] in temporary_marked:</span><br><span class="line">            if n[&apos;name&apos;] in get_service_names(n.get(&apos;links&apos;, [])):</span><br><span class="line">                raise DependencyError(&apos;A service can not link to itself: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            if n[&apos;name&apos;] in n.get(&apos;volumes_from&apos;, []):</span><br><span class="line">                raise DependencyError(&apos;A service can not mount itself as volume: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            if n[&apos;name&apos;] in n.get(&apos;depends_on&apos;, []):</span><br><span class="line">                raise DependencyError(&apos;A service can not depend on itself: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            raise DependencyError(&apos;Circular dependency between %s&apos; % &apos; and &apos;.join(temporary_marked))</span><br><span class="line"></span><br><span class="line">        if n in unmarked:</span><br><span class="line">            temporary_marked.add(n[&apos;name&apos;])</span><br><span class="line">            for m in get_service_dependents(n, services):</span><br><span class="line">                visit(m)</span><br><span class="line">            temporary_marked.remove(n[&apos;name&apos;])</span><br><span class="line">            unmarked.remove(n)</span><br><span class="line">            sorted_services.insert(0, n)</span><br><span class="line"></span><br><span class="line">    while unmarked:</span><br><span class="line">        visit(unmarked[-1])</span><br><span class="line"></span><br><span class="line">    return sorted_services</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.project.up()</span><br><span class="line">    project:initialize()</span><br><span class="line">        self.networks.initialize()</span><br><span class="line">        self.volumes.initialize()</span><br><span class="line">    self.get_services_without_duplicate()</span><br><span class="line">    svc.ensure_image_exists()</span><br><span class="line">    self._get_convergence_plans()</span><br><span class="line">    parallel.parallel_execute()</span><br><span class="line">        service.execute_convergence_plan()</span><br><span class="line">        self._execute_convergence_create()</span><br><span class="line">            parallel_execute()</span><br><span class="line">                create_and_start()</span><br><span class="line">                    service.create_container()</span><br><span class="line">                    self.start_container()</span><br><span class="line">log_printer.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose&quot;&gt;&lt;a href=&quot;#Compose&quot; class=&quot;headerlink&quot; title=&quot;Compose&quot;&gt;&lt;/a&gt;Compose&lt;/h2&gt;&lt;p&gt;最近因为一些需求可能需要用到 Compose，看了看 Podman Compose 和 Docker
      
    
    </summary>
    
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>cgroups notification API demo</title>
    <link href="https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/"/>
    <id>https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/</id>
    <published>2021-01-01T18:28:00.000Z</published>
    <updated>2021-05-22T01:05:51.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cgroups-notification-API-demo"><a href="#cgroups-notification-API-demo" class="headerlink" title="cgroups notification API demo"></a>cgroups notification API demo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"flag"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"io/ioutil"</span></span><br><span class="line">        <span class="string">"os"</span></span><br><span class="line">        <span class="string">"path/filepath"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"golang.org/x/sys/unix"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cgName := flag.String(<span class="string">"cgName"</span>, <span class="string">"yiran"</span>, <span class="string">"cgroup path"</span>)</span><br><span class="line">        flag.Parse()</span><br><span class="line">        level := <span class="string">"critical"</span></span><br><span class="line">        cgDir := filepath.Join(<span class="string">"/sys/fs/cgroup/memory/"</span>, *cgName)</span><br><span class="line">        evName := <span class="string">"memory.pressure_level"</span></span><br><span class="line">        fmt.Printf(<span class="string">"cgroup name is: %s\n"</span>, *cgName)</span><br><span class="line">        fmt.Printf(<span class="string">"cgroup path is: %s\n"</span>, cgDir)</span><br><span class="line">        fmt.Printf(<span class="string">"cgroup event name is: %s\n"</span>, evName)</span><br><span class="line"></span><br><span class="line">        evFile, err := os.Open(filepath.Join(cgDir, evName))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fd, err := unix.Eventfd(<span class="number">0</span>, unix.EFD_CLOEXEC)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                evFile.Close()</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eventfd := os.NewFile(<span class="keyword">uintptr</span>(fd), <span class="string">"eventfd"</span>)</span><br><span class="line"></span><br><span class="line">        eventControlPath := filepath.Join(cgDir, <span class="string">"cgroup.event_control"</span>)</span><br><span class="line">        data := fmt.Sprintf(<span class="string">"%d %d %s"</span>, eventfd.Fd(), evFile.Fd(), level)</span><br><span class="line">        <span class="keyword">if</span> err := ioutil.WriteFile(eventControlPath, []<span class="keyword">byte</span>(data), <span class="number">0700</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                eventfd.Close()</span><br><span class="line">                evFile.Close()</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                eventfd.Close()</span><br><span class="line">                evFile.Close()</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"start..."</span>)</span><br><span class="line">                <span class="keyword">if</span> _, err := eventfd.Read(buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="built_in">panic</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> _, err := os.Lstat(eventControlPath); os.IsNotExist(err) &#123;</span><br><span class="line">                        <span class="built_in">panic</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">                fmt.Println(<span class="string">"test success ..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备 memory cgroup 配置，并限制内存上限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go build /tmp/demo.go</span><br><span class="line">mkdir /sys/fs/cgroup/memory/yiran/</span><br><span class="line"><span class="built_in">echo</span> 10M &gt;  /sys/fs/cgroup/memory/yiran/memory.limit_in_bytes</span><br><span class="line"><span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/memory/yiran/tasks</span><br><span class="line">nohup /tmp/demo -cgName=yiran &amp; </span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero | <span class="built_in">read</span> x</span><br></pre></td></tr></table></figure><p><code>tailf /tmp/nohup.out</code> 查看输出结果。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cgroups-notification-API-demo&quot;&gt;&lt;a href=&quot;#cgroups-notification-API-demo&quot; class=&quot;headerlink&quot; title=&quot;cgroups notification API demo&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
      <category term="cgroups" scheme="https://zdyxry.github.io/tags/cgroups/"/>
    
  </entry>
  
  <entry>
    <title>2020 年终总结</title>
    <link href="https://zdyxry.github.io/2020/12/31/2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://zdyxry.github.io/2020/12/31/2020-年终总结/</id>
    <published>2020-12-31T08:42:51.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>减重 70 斤，身体达到近 10 年最健康的状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2020&quot;&gt;&lt;a href=&quot;#2020&quot; class=&quot;headerlink&quot; title=&quot;2020&quot;&gt;&lt;/a&gt;2020&lt;/h2&gt;&lt;p&gt;减重 70 斤，身体达到近 10 年最健康的状态。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020年读书记录</title>
    <link href="https://zdyxry.github.io/2020/12/28/2020%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/12/28/2020年读书记录/</id>
    <published>2020-12-28T09:03:03.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><ul><li><a href="https://zdyxry.github.io/2016/12/31/2016%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2016</a><ul><li>计划读 5 本，实际读 13 本。</li></ul></li><li><a href="https://zdyxry.github.io/2017/12/31/2017%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2017</a><ul><li>计划 32 本，实际读完 23 本。</li></ul></li><li><a href="https://zdyxry.github.io/2018/12/30/2018%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2018</a><ul><li>计划 30 本，实际25本。</li></ul></li><li><a href="https://zdyxry.github.io/2019/12/09/2019%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2019</a><ul><li>计划 30 本，实际 43 本。</li></ul></li><li>2020<ul><li>计划 30 本，实际 40 本。</li></ul></li></ul><h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ol><li>《时间的秩序》</li><li>《肠子的小心思》</li><li>《饮食的迷思》</li><li>《认知天性》</li><li>《Linux/UNIX系统编程手册》</li><li>《码农翻身》</li><li>《庆余年》</li><li>《凤凰项目》</li><li>《编程珠玑》</li><li>《了不起的我》</li><li>《见识》</li><li>《重来》</li><li>《重来2》</li><li>《Unix/Linux编程实践教程》</li><li>《漫画数据库》</li><li>《程序员修炼之道》</li><li>《Flask Web开发：基于Python的Web应用开发实战》</li><li>《HTTP权威指南》</li><li>《计算机网络（第7版）》</li><li>《程序员的数学》</li><li>《把时间当作朋友》</li><li>《KVM Virtualization Cookbook》</li><li>《Go语言学习笔记》</li><li>《UNIX网络编程》</li><li>《现代操作系统（原书第4版）》</li><li>《基本无害》</li><li>《宇宙尽头的餐馆》</li><li>《生命，宇宙以及一切》</li><li>《再会，谢谢所有的鱼》</li><li>《畅游日本（第3版）》</li><li>《基本穿搭》</li><li>《囚徒健身》</li><li>《蛤蟆先生去看心理医生》</li><li>《天生有罪》</li><li>《数据密集型应用系统设计》</li><li>《高效能人士的七个习惯》</li><li>《咖啡咖啡》</li><li>《TCP/IP网络编程》</li><li>《献给阿尔吉侬的花束》</li><li>《囚徒增肌》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zdyxry.github.io/2016/12/31/2016%E5%B9%
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>2020 第39周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/26/2020-%E7%AC%AC39%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/26/2020-第39周-LeetCode-记录/</id>
    <published>2020-09-26T17:08:07.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1588-Sum-of-All-Odd-Length-Subarrays"><a href="#1588-Sum-of-All-Odd-Length-Subarrays" class="headerlink" title="1588. Sum of All Odd Length Subarrays"></a>1588. Sum of All Odd Length Subarrays</h3><p>处理当长度为 1 时特殊情况，其他都遍历长度为奇数情况然后求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                    res += sum(arr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> j + i &lt;= len(arr):</span><br><span class="line">                        res += sum(arr[j:j+i])</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1592-Rearrange-Spaces-Between-Words"><a href="#1592-Rearrange-Spaces-Between-Words" class="headerlink" title="1592. Rearrange Spaces Between Words"></a>1592. Rearrange Spaces Between Words</h3><p>统计空格出现的次数，然后求出平均空格数进行字符串拼接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderSpaces</span><span class="params">(self, text: str)</span> -&gt; str:</span></span><br><span class="line">        cnt=text.count(<span class="string">" "</span>)</span><br><span class="line">        n = text.split()</span><br><span class="line">        <span class="keyword">if</span> len(n)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> text.strip()+cnt*<span class="string">" "</span></span><br><span class="line">        space,last = divmod(cnt,len(n)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">" "</span>*space).join(n)+<span class="string">" "</span>*last</span><br></pre></td></tr></table></figure><h3 id="1593-Split-a-String-Into-the-Max-Number-of-Unique-Substrings"><a href="#1593-Split-a-String-Into-the-Max-Number-of-Unique-Substrings" class="headerlink" title="1593. Split a String Into the Max Number of Unique Substrings"></a>1593. Split a String Into the Max Number of Unique Substrings</h3><p>回溯法，使用集合记录出现过的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxUniqueSplit</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        d = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(num, sub)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> sub:</span><br><span class="line">                self.ans = max(num, self.ans)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">in</span> d: <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sub) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> sub[:i] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d.add(sub[:i])</span><br><span class="line">                    helper(num + <span class="number">1</span>, sub[i:])</span><br><span class="line">                    d.remove(sub[:i]) </span><br><span class="line">                    </span><br><span class="line">        helper(<span class="number">0</span>, s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><h3 id="814-Binary-Tree-Pruning"><a href="#814-Binary-Tree-Pruning" class="headerlink" title="814. Binary Tree Pruning"></a>814. Binary Tree Pruning</h3><p>如果叶子节点的左子树和右子树为空且当前值为 0，则将其置为空，递归剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left = self.pruneTree(root.left)</span><br><span class="line">        root.right = self.pruneTree(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a>1008. Construct Binary Search Tree from Preorder Traversal</h3><p>提供先序遍历，构造二叉树，先序遍历的第一个元素是 root 节点，分别遍历之后元素，如果元素比 root 小，则记录到root 左子树中，反之记录到 root 右子树中，递归构造。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstFromPreorder</span><span class="params">(self, preorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        leftList = []</span><br><span class="line">        rightList = []</span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> preorder[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> num &lt; preorder[<span class="number">0</span>]:</span><br><span class="line">                leftList.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &gt; preorder[<span class="number">0</span>]:</span><br><span class="line">                rightList.append(num)</span><br><span class="line">        root.left = self.bstFromPreorder(leftList)</span><br><span class="line">        root.right = self.bstFromPreorder(rightList)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1588-Sum-of-All-Odd-Length-Subarrays&quot;&gt;&lt;a href=&quot;#1588-Sum-of-All-Odd-Length-Subarrays&quot; class=&quot;headerlink&quot; title=&quot;1588. Sum of All Odd
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第38周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/20/2020-%E7%AC%AC38%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/20/2020-第38周-LeetCode-记录/</id>
    <published>2020-09-20T07:45:55.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1582-Special-Positions-in-a-Binary-Matrix"><a href="#1582-Special-Positions-in-a-Binary-Matrix" class="headerlink" title="1582. Special Positions in a Binary Matrix"></a>1582. Special Positions in a Binary Matrix</h3><p>直接遍历二维数组之后，如果某个位置是 1，再去统计每行的和和每列的和是否为 1 时间复杂度太高，可以先统计每行每列的和，然后再遍历二维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecial</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n, ans = len(mat), len(mat[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">        row, col = [<span class="number">0</span>] * m, [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]:</span><br><span class="line">                    row[i] += <span class="number">1</span></span><br><span class="line">                    col[j] += <span class="number">1</span></span><br><span class="line">        pool = [j <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> col[j] == <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> row[i] != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> pool:</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1025-Divisor-Game"><a href="#1025-Divisor-Game" class="headerlink" title="1025. Divisor Game"></a>1025. Divisor Game</h3><blockquote><p>如果N是奇数，因为奇数的所有因数都是奇数，因此 N 进行一次 N-x 的操作结果一定是偶数，所以如果 a 拿到了一个奇数，那么轮到 b 的时候，b拿到的肯定是偶数，这个时候 b 只要进行 -1， 还给 a 一个奇数，那么这样子b就会一直拿到偶数，到最后b一定会拿到最小偶数2，a就输了。</p><p>所以如果游戏开始时Alice拿到N为奇数，那么她必输，也就是false。如果拿到N为偶数，她只用 -1，让bob 拿到奇数，最后bob必输，结果就是true。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> N%<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="1583-Count-Unhappy-Friends"><a href="#1583-Count-Unhappy-Friends" class="headerlink" title="1583. Count Unhappy Friends"></a>1583. Count Unhappy Friends</h3><p>题目有些绕，python 可以直接用 <code>index</code> 方法来切片，golang 只能自己实现了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unhappyFriends</span><span class="params">(self, n: int, preferences: List[List[int]], pairs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        dd = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> pairs:</span><br><span class="line">            dd[i] = preferences[i][:preferences[i].index(x)]</span><br><span class="line">            dd[x] = preferences[x][:preferences[x].index(i)]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        print(dd)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dd:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> dd[i]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dd[x]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1282-Group-the-People-Given-the-Group-Size-They-Belong-To"><a href="#1282-Group-the-People-Given-the-Group-Size-They-Belong-To" class="headerlink" title="1282. Group the People Given the Group Size They Belong To"></a>1282. Group the People Given the Group Size They Belong To</h3><p>对分组进行统计，组人数作为 key，在该人数的用户索引列表作为 value，然后遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupThePeople</span><span class="params">(self, groupSizes: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        groups = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, _id <span class="keyword">in</span> enumerate(groupSizes):</span><br><span class="line">            groups[_id].append(i)</span><br><span class="line">        </span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> gsize, users <span class="keyword">in</span> groups.items():</span><br><span class="line">            <span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">0</span>, len(users), gsize):</span><br><span class="line">                ans.append(users[it : it + gsize])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1305-All-Elements-in-Two-Binary-Search-Trees"><a href="#1305-All-Elements-in-Two-Binary-Search-Trees" class="headerlink" title="1305. All Elements in Two Binary Search Trees"></a>1305. All Elements in Two Binary Search Trees</h3><p>如果只是单纯的用列表存储所有值，然后进行排序是最简单的实现方式，但是这道题考察的应该是归并排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAllElements</span><span class="params">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, v)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.left, v)</span><br><span class="line">            v.append(node.val)</span><br><span class="line">            dfs(node.right, v)</span><br><span class="line">        </span><br><span class="line">        v1, v2 = list(), list()</span><br><span class="line">        dfs(root1, v1)</span><br><span class="line">        dfs(root2, v2)</span><br><span class="line">        ans, i, j = list(), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(v1) <span class="keyword">or</span> j &lt; len(v2):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(v1) <span class="keyword">and</span> (j == len(v2) <span class="keyword">or</span> v1[i] &lt;= v2[j]):</span><br><span class="line">                ans.append(v1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(v2[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1582-Special-Positions-in-a-Binary-Matrix&quot;&gt;&lt;a href=&quot;#1582-Special-Positions-in-a-Binary-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1582. Spec
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第37周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/13/2020-%E7%AC%AC37%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/13/2020-第37周-LeetCode-记录/</id>
    <published>2020-09-13T10:51:05.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1572-Matrix-Diagonal-Sum"><a href="#1572-Matrix-Diagonal-Sum" class="headerlink" title="1572. Matrix Diagonal Sum"></a>1572. Matrix Diagonal Sum</h3><p>对角线之和，需要注意当行为奇数和偶数时候的去重处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diagonalSum</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(mat)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != n<span class="number">-1</span>-i:</span><br><span class="line">                ans += mat[i][i]</span><br><span class="line">                ans += mat[i][n<span class="number">-1</span>-i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += mat[i][i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1576-Replace-All-’s-to-Avoid-Consecutive-Repeating-Characters"><a href="#1576-Replace-All-’s-to-Avoid-Consecutive-Repeating-Characters" class="headerlink" title="1576. Replace All ?’s to Avoid Consecutive Repeating Characters"></a>1576. Replace All ?’s to Avoid Consecutive Repeating Characters</h3><p>题目中说的是不能出现连续相同的字符，整个字符串中是可以出现重复字符的，只需要遍历字符串，然后判断前后是否相同替换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modifyString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        l = list(s)</span><br><span class="line">        alphabet = list(string.ascii_lowercase)</span><br><span class="line">        <span class="keyword">for</span> i, _ <span class="keyword">in</span> enumerate(l):</span><br><span class="line">            <span class="keyword">if</span> l[i] == <span class="string">"?"</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> alphabet:</span><br><span class="line">                    <span class="keyword">if</span> i == len(l) - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> l[i<span class="number">-1</span>] != j:</span><br><span class="line">                            l[i] = j</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> l[i<span class="number">-1</span>] != j <span class="keyword">and</span> l[i+<span class="number">1</span>] != j:</span><br><span class="line">                        l[i] = j</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(l)</span><br></pre></td></tr></table></figure><h3 id="1578-Minimum-Deletion-Cost-to-Avoid-Repeating-Letters"><a href="#1578-Minimum-Deletion-Cost-to-Avoid-Repeating-Letters" class="headerlink" title="1578. Minimum Deletion Cost to Avoid Repeating Letters"></a>1578. Minimum Deletion Cost to Avoid Repeating Letters</h3><p>给一个字符串 s 和一个整数数组 cost ，其中 cost[i] 是从 s 中删除字符 i 的代价。返回使字符串任意相邻两个字母不相同的最小删除成本。如果当前字符与前一个字符相同，那么比较当前字符的价格与前一个字符的价格对比，取小；当前一个字符的价格比当前价格大时，那么此时更新 pre 为当前字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, s: str, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[idx] == s[pre]:</span><br><span class="line">                res += min(cost[idx], cost[pre])</span><br><span class="line">            <span class="keyword">if</span> s[idx] != s[pre] <span class="keyword">or</span> cost[pre] &lt; cost[idx]:</span><br><span class="line">                pre = idx</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="763-Partition-Labels"><a href="#763-Partition-Labels" class="headerlink" title="763. Partition Labels"></a>763. Partition Labels</h3><p>字符串 S 由小写字母组成。要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。定义数组 last[char] 来表示字符 char 最后一次出现的下标。定义 anchor 和 j 来表示当前区间的首尾。如果遇到的字符最后一次出现的位置下标大于 j， 就让 j=last[c] 来拓展当前的区间。当遍历到了当前区间的末尾时(即 i==j )，把当前区间加入答案，同时将 start 设为 i+1 去找下一个区间。</p><blockquote><p><a href="https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line">        last = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(S)&#125;</span><br><span class="line">        j = anchor = <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            j = max(j, last[c])</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                ans.append(i - anchor + <span class="number">1</span>)</span><br><span class="line">                anchor = i + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1252-Cells-with-Odd-Values-in-a-Matrix"><a href="#1252-Cells-with-Odd-Values-in-a-Matrix" class="headerlink" title="1252. Cells with Odd Values in a Matrix"></a>1252. Cells with Odd Values in a Matrix</h3><p>如果从正向方式求解会出现遍历二维数组 * 遍历 indices 的情况，可以先构造一个二维数组，然后遍历 indices 模拟数组，最终判断数组中的奇数个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddCells</span><span class="params">(self, n: int, m: int, indices: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        rows = [<span class="number">0</span>] * n</span><br><span class="line">        cols = [<span class="number">0</span>] * m</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> indices:</span><br><span class="line">            rows[x] += <span class="number">1</span></span><br><span class="line">            cols[y] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum((rows[x] + cols[y]) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(n) <span class="keyword">for</span> y <span class="keyword">in</span> range(m))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1572-Matrix-Diagonal-Sum&quot;&gt;&lt;a href=&quot;#1572-Matrix-Diagonal-Sum&quot; class=&quot;headerlink&quot; title=&quot;1572. Matrix Diagonal Sum&quot;&gt;&lt;/a&gt;1572. Matrix 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第36周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/06/2020-%E7%AC%AC36%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/06/2020-第36周-LeetCode-记录/</id>
    <published>2020-09-06T15:04:19.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times"><a href="#1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times" class="headerlink" title="1566. Detect Pattern of Length M Repeated K or More Times"></a>1566. Detect Pattern of Length M Repeated K or More Times</h3><p>判断数组中是否存在连续长度为 m 且重复次数为 k 的字符串，直接对 arr 进行切片判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsPattern</span><span class="params">(self, arr: List[int], m: int, k: int)</span> -&gt; bool:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(arr):</span><br><span class="line">            p = arr[i:i+m]</span><br><span class="line">            <span class="keyword">if</span> p * k == arr[i:i+m*k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1567-Maximum-Length-of-Subarray-With-Positive-Product"><a href="#1567-Maximum-Length-of-Subarray-With-Positive-Product" class="headerlink" title="1567. Maximum Length of Subarray With Positive Product"></a>1567. Maximum Length of Subarray With Positive Product</h3><p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。使用数组记录数值为负数的索引值，当数字为 0 时则重置数组，当负数数量为偶数时，则更新最大值，最大值为当前索引减去第一个非 0 数字索引，如果负数数量为奇数时，则最大值为当前索引减去第一个负数索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxLen</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        pre=<span class="number">-1</span></span><br><span class="line">        l=[]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num&lt;<span class="number">0</span>:</span><br><span class="line">                l.append(i)</span><br><span class="line">            <span class="keyword">elif</span> num==<span class="number">0</span>:</span><br><span class="line">                l,pre = [],i</span><br><span class="line">            <span class="keyword">if</span> len(l)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                res=max(res,i-pre)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = max(res,i-l[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1161-Maximum-Level-Sum-of-a-Binary-Tree"><a href="#1161-Maximum-Level-Sum-of-a-Binary-Tree" class="headerlink" title="1161. Maximum Level Sum of a Binary Tree"></a>1161. Maximum Level Sum of a Binary Tree</h3><p>给一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推，找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。BFS 直接找，只是在找的过程中要记录层号以及该层的和，我直接用一个数组记录每层的和，然后数组的索引就是层级号，求最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxLevelSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result, current = [], [root]</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            next_level, vals = [], []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> current:</span><br><span class="line">                vals.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    next_level.append(node.right)</span><br><span class="line">            current = next_level</span><br><span class="line">            result.append(vals)</span><br><span class="line"></span><br><span class="line">        result = [sum(i) <span class="keyword">for</span> i <span class="keyword">in</span> result]</span><br><span class="line">        print(result)</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> enumerate(result):</span><br><span class="line">            <span class="keyword">if</span> v == max(result):</span><br><span class="line">                <span class="keyword">return</span> idx+<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="1219-Path-with-Maximum-Gold"><a href="#1219-Path-with-Maximum-Gold" class="headerlink" title="1219. Path with Maximum Gold"></a>1219. Path with Maximum Gold</h3><p>回溯法，每次递归计算下一个数值时，将当前数值置为 0，递归结束后重置该值，找到最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, grid, pos, m, n, count)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt; m <span class="keyword">and</span> y &gt;= <span class="number">0</span> <span class="keyword">and</span> y &lt; n <span class="keyword">and</span> grid[x][y] != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(pos)</span></span><br><span class="line">            count += grid[x][y]</span><br><span class="line">            temp = grid[x][y]</span><br><span class="line">            grid[x][y] = <span class="number">0</span></span><br><span class="line">            self.helper(grid, (x<span class="number">-1</span>, y), m, n, count)</span><br><span class="line">            self.helper(grid, (x+<span class="number">1</span>, y), m, n, count)</span><br><span class="line">            self.helper(grid, (x, y<span class="number">-1</span>), m, n, count)</span><br><span class="line">            self.helper(grid, (x, y+<span class="number">1</span>), m, n, count)</span><br><span class="line">            grid[x][y] = temp</span><br><span class="line">        self.res.append(count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaximumGold</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                self.helper(grid, (i, j), m, n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(self.res)</span><br></pre></td></tr></table></figure><h3 id="728-Self-Dividing-Numbers"><a href="#728-Self-Dividing-Numbers" class="headerlink" title="728. Self Dividing Numbers"></a>728. Self Dividing Numbers</h3><p>python 可以直接将数字转换为字符串，继而转换为数组直接判断，不然的话就通过每次对 10 取余数，判断完后除 10。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isDividingNumbers</span><span class="params">(i <span class="keyword">int</span>)</span><span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> i&lt;<span class="number">10</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">v:=i</span><br><span class="line"><span class="keyword">for</span> i!=<span class="number">0</span>&#123;</span><br><span class="line">r :=i%<span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> r==<span class="number">0</span>||v%r!=<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">i =i/<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selfDividingNumbers</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">     <span class="keyword">for</span> i:=left;i&lt;=right;i++&#123;</span><br><span class="line"> <span class="keyword">if</span> isDividingNumbers(i)&#123;</span><br><span class="line"> res = <span class="built_in">append</span>(res,i)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times&quot;&gt;&lt;a href=&quot;#1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times&quot; class=
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第35周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/29/2020-%E7%AC%AC35%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/29/2020-第35周-LeetCode-记录/</id>
    <published>2020-08-29T18:42:34.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1560-Most-Visited-Sector-in-a-Circular-Track"><a href="#1560-Most-Visited-Sector-in-a-Circular-Track" class="headerlink" title="1560. Most Visited Sector in a Circular Track"></a>1560. Most Visited Sector in a Circular Track</h3><p>在中间走过多少圈，对于各个扇区来说是相同的，只需要考虑起点和终点的位置关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostVisited</span><span class="params">(self, n: int, rounds: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        s, d = rounds[<span class="number">0</span>], rounds[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> s &lt;= d:</span><br><span class="line">            <span class="keyword">return</span> list(range(s, d+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> list(range(<span class="number">1</span>, d+<span class="number">1</span>)) + list(range(s, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes"><a href="#1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes" class="headerlink" title="1557. Minimum Number of Vertices to Reach All Nodes"></a>1557. Minimum Number of Vertices to Reach All Nodes</h3><p>如果某个节点出现在到达节点，那么这个节点一定不在结果中，相反则一定在结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSmallestSetOfVertices</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> list(set(range(n)) - set(e[<span class="number">1</span>] <span class="keyword">for</span> e <span class="keyword">in</span> edges))</span><br></pre></td></tr></table></figure><h3 id="1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array"><a href="#1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array" class="headerlink" title="1558. Minimum Numbers of Function Calls to Make Target Array"></a>1558. Minimum Numbers of Function Calls to Make Target Array</h3><p>一共有两种操作：1. 将某个索引位置的数值 +1； 2. 将所有数值 * 2 。<br>从结果上来说肯定是操作 2 效率更高，因为我们要求最小次数，所以我们想调用最多的操作 2。首先将判断数组中数字是否为奇数，如果是奇数的话就-1 并将结果 +1。执行完成后数组中所有数字都是偶数后，整体将数组中所有数字 /2 ，并将结果 +1。直到数组中所有数字都为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> any(nums):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] % <span class="number">2</span>:</span><br><span class="line">                    nums[i] -= <span class="number">1</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> any(nums):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    nums[i] //= <span class="number">2</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1561-Maximum-Number-of-Coins-You-Can-Get"><a href="#1561-Maximum-Number-of-Coins-You-Can-Get" class="headerlink" title="1561. Maximum Number of Coins You Can Get"></a>1561. Maximum Number of Coins You Can Get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。</span><br><span class="line">Alice 将会取走硬币数量最多的那一堆。</span><br><span class="line">你将会取走硬币数量第二多的那一堆。</span><br><span class="line">Bob 将会取走最后一堆。</span><br><span class="line">重复这个过程，直到没有更多硬币。</span><br></pre></td></tr></table></figure><p>虽然不可以选择最多的硬币，但是可以选择第二多的，所以可以先将数组排序，然后每次选择第二大的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, piles: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1,2,2,4,7,8 =&gt; 7,2</span></span><br><span class="line">        <span class="comment"># 1,2,3,4,5,6,7,8,9 =&gt; 8,6,4</span></span><br><span class="line">        piles.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(piles):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i += <span class="number">1</span>    </span><br><span class="line">            res.append(piles[i])</span><br><span class="line">            <span class="keyword">if</span> len(res) == len(piles) /<span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> sum(res)</span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure><h3 id="1079-Letter-Tile-Possibilities"><a href="#1079-Letter-Tile-Possibilities" class="headerlink" title="1079. Letter Tile Possibilities"></a>1079. Letter Tile Possibilities</h3><p>使用 DFS + 回溯，先统计字母出现的次数，分别遍历 26 个字母，如果字母出现的次数不为 0 ，那么将字母出现的次数 -1 ，并进行 dfs，在深度搜索后再将字母次数 +1，避免影响最终结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTilePossibilities</span><span class="params">(self, tiles: str)</span> -&gt; int:</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> tile <span class="keyword">in</span> tiles: record[ord(tile)-ord(<span class="string">'A'</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(record)</span>:</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> record[i]: <span class="keyword">continue</span></span><br><span class="line">                record[i] -= <span class="number">1</span></span><br><span class="line">                s += dfs(record) + <span class="number">1</span> </span><br><span class="line">                record[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> dfs(record)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1560-Most-Visited-Sector-in-a-Circular-Track&quot;&gt;&lt;a href=&quot;#1560-Most-Visited-Sector-in-a-Circular-Track&quot; class=&quot;headerlink&quot; title=&quot;1560
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第34周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/23/2020-%E7%AC%AC34%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/23/2020-第34周-LeetCode-记录/</id>
    <published>2020-08-23T16:37:12.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1550-Three-Consecutive-Odds"><a href="#1550-Three-Consecutive-Odds" class="headerlink" title="1550. Three Consecutive Odds"></a>1550. Three Consecutive Odds</h3><p>判断数组是否存在连续 3 个奇数的情况存在，直接遍历判断，使用变量记录当前奇数个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeConsecutiveOdds</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1551-Minimum-Operations-to-Make-Array-Equal"><a href="#1551-Minimum-Operations-to-Make-Array-Equal" class="headerlink" title="1551. Minimum Operations to Make Array Equal"></a>1551. Minimum Operations to Make Array Equal</h3><p>一道数学题，等差数列求和公式变形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=3 最小操作数是 2</span><br><span class="line">n=4 最小操作数是 1 + 3</span><br><span class="line">n=5 最小操作数是 2 + 4</span><br><span class="line">n=6 最小操作数是 1 + 3 + 5</span><br><span class="line">n=7 最小操作数是 2 + 4 + 6</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> n*n // <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a>410. Split Array Largest Sum</h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>求最大值最小一般采用二分法来做，数值最终在 max(nums) &lt; result &lt; sum(nums) 区间中，假设当前数值符合条件，然后检查是否符合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums: List[int], m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(x: int)</span> -&gt; bool:</span></span><br><span class="line">            total, cnt = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> total + num &gt; x:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    total = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    total += num</span><br><span class="line">            <span class="keyword">return</span> cnt &lt;= m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        left = max(nums)</span><br><span class="line">        right = sum(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="1552-Magnetic-Force-Between-Two-Balls"><a href="#1552-Magnetic-Force-Between-Two-Balls" class="headerlink" title="1552. Magnetic Force Between Two Balls"></a>1552. Magnetic Force Between Two Balls</h3><p>与 410 类似，也是求最大化最小值，相同的解法，二分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDistance(self, position: List[int], m: int) -&gt; int:</span><br><span class="line">        position.sort()</span><br><span class="line">        </span><br><span class="line">        def check(x):</span><br><span class="line">            cnt = 1</span><br><span class="line">            t = position[0]</span><br><span class="line">            for i in range(1, len(position)):</span><br><span class="line">                if position[i]-t &gt; x:</span><br><span class="line">                    cnt += 1</span><br><span class="line">                    t = position[i]</span><br><span class="line">            return cnt &gt;= m</span><br><span class="line">        </span><br><span class="line">        l, r = 0, position[-1]</span><br><span class="line">        while l &lt; r:</span><br><span class="line">            mid = l + (r-l)//2</span><br><span class="line">            if check(mid):</span><br><span class="line">                l = mid+1</span><br><span class="line">            else:</span><br><span class="line">                r = mid</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure><h3 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a>406. Queue Reconstruction by Height</h3><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p><blockquote><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序：</span><br><span class="line">按高度降序排列。</span><br><span class="line">在同一高度的人中，按 k 值的升序排列。</span><br><span class="line">逐个地把它们放在输出队列中，索引等于它们的 k 值。</span><br><span class="line">返回输出队列</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            output.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="1249-Minimum-Remove-to-Make-Valid-Parentheses"><a href="#1249-Minimum-Remove-to-Make-Valid-Parentheses" class="headerlink" title="1249. Minimum Remove to Make Valid Parentheses"></a>1249. Minimum Remove to Make Valid Parentheses</h3><p>给你一个字符串，其中字符串包含一些括号，但是括号不是成对出现的，需要你删除其中不平衡的括号使其达到平衡。<br>自己做的时候使用了两个栈来分别记录括号和括号所在的索引，如果出现平衡的括号，那么两个栈同时出栈，最终将保存索引的栈中对应的字母删除，返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx, i <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> [<span class="string">'('</span>, <span class="string">')'</span>]:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                    res.append(idx)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        res.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack.append(i)</span><br><span class="line">                        res.append(idx)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> idx, i <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(tmp)</span><br></pre></td></tr></table></figure><p>虽然也能通过但是复杂度很高，可以直接遍历字符串，使用一个栈记录 <code>(</code> ，如果字符串为 <code>(</code> 那么入栈，如果字符串为 <code>)</code> 并且栈长度不为 0，那么出栈，否则将字符串对应索引字母置为空，此时结果中所有多余的 <code>)</code> 都已经处理完了，接下来处理栈中存在的多余的 <code>(</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        indices, ans = [], list(s)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> indices:</span><br><span class="line">                    indices.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans[i] = <span class="string">''</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'('</span>:</span><br><span class="line">                indices.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> indices:</span><br><span class="line">            ans[i] = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1550-Three-Consecutive-Odds&quot;&gt;&lt;a href=&quot;#1550-Three-Consecutive-Odds&quot; class=&quot;headerlink&quot; title=&quot;1550. Three Consecutive Odds&quot;&gt;&lt;/a&gt;1550
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>ARM 服务器？能用。</title>
    <link href="https://zdyxry.github.io/2020/08/22/ARM-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E8%83%BD%E7%94%A8%E3%80%82/"/>
    <id>https://zdyxry.github.io/2020/08/22/ARM-服务器？能用。/</id>
    <published>2020-08-22T15:09:04.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上一次写 <a href="https://zdyxry.github.io/2019/11/01/ARM-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E8%83%BD%E7%94%A8%EF%BC%9F/">ARM 服务器</a>相关的是在大半年以前了，当时适配工作做得神烦，最近在折腾 ARM 上 KVM 虚拟化相关的事情，目标是虚拟化功能最小代码改动同时兼容 x86 和 ARM，记录一下目前的一点经验总结。</p><p>硬件配置：  </p><ul><li>华为泰山服务器</li><li>Kunpeng 920</li></ul><p>软件配置：  </p><ul><li>CentOS 7.6</li><li>kernel-4.18.0-193.1.2.el7.aarch64</li><li>libvirt-4.5.0</li><li>qemu-2.12.0</li></ul><h2 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h2><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>如果产品之前都是 x86 架构下的，在适配 ARM 时往往需要进行架构判断，此时可以通过 <code>arch</code> 来获取，在 ARM 架构显示 <code>aarch64</code> ，在 x86 架构下显示 <code>x86_64</code> 。</p><p><code>aarch64</code> 等价于 <code>arm64</code>。</p><blockquote><p>AArch64 or ARM64 is the 64-bit extension of the ARM architecture.</p></blockquote><h3 id="KVM-module"><a href="#KVM-module" class="headerlink" title="KVM module"></a>KVM module</h3><p>在 x86 上我们可以直接通过 <code>lsmod |grep kvm</code> 查看到 KVM module 情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:24:30 ~]$lsmod |grep kvm</span><br><span class="line">kvm_intel             188644  82 </span><br><span class="line">kvm                   621480  1 kvm_intel</span><br></pre></td></tr></table></figure><p>但是在 arm 上是没有加载 KVM module 的，此时想要知道 KVM 配置是否正确，可以通过 <code>dmesg</code> 中查看 KVM 相关日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: IPA Size Limit: 48bits</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: GICv4 support disabled</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: vgic-v2@9b020000</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: GIC system register CPU interface enabled</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: vgic interrupt IRQ1</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: VHE mode initialized successfully</span><br></pre></td></tr></table></figure><p>如果看到 <code>VHE mode initialized successfully</code> ，那么 KVM 正常。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>在 CentOS 中通常使用 cpuinfo 来获取 CPU 相关信息，但是发现集群中某个节点无法获取主频相关信息，通过 lscpu 也无法正确显示，开始以为是 <code>util-linux</code> 相关软件的版本不兼容导致，后续排查发现不是这个问题，于是考虑通过其他方式获取主频。</p><p>正常 cpuinfo 输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hz Advertised: 2.6000 GHz</span><br><span class="line">Hz Actual: 2.6000 GHz</span><br><span class="line">Hz Advertised Raw: (2600000000, 0)</span><br><span class="line">Hz Actual Raw: (2600000000, 0)</span><br><span class="line">Arch: ARM_8</span><br></pre></td></tr></table></figure><p>如果作为他信息统计的话我们往往使用的是 <code>Hz Advertised Raw</code> 字段，我们可以通过 <code>dmidecode</code> 获取，<code>dmidecode</code> 输出结果示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:33:47 ~]$dmidecode -t 4 </span><br><span class="line">        ...</span><br><span class="line">        Max Speed: 4000 MHz</span><br><span class="line">        Current Speed: 2600 MHz</span><br><span class="line">        Status: Populated, Enabled</span><br><span class="line">        Upgrade: Socket LGA2011</span><br><span class="line">        L1 Cache Handle: 0x0009</span><br><span class="line">        L2 Cache Handle: 0x000A</span><br><span class="line">        L3 Cache Handle: 0x000B</span><br></pre></td></tr></table></figure><p>这里需要进行区分， <code>dmidecode</code> 获取到的是主板信息，比如 <code>Max Speed</code> 指的是主板支持最大主频，如果我们想获取当前 CPU 标称主频，需要使用 <code>Current Speed</code> 字段数值。</p><h2 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h2><h3 id="Machine-Type"><a href="#Machine-Type" class="headerlink" title="Machine Type"></a>Machine Type</h3><p>在 x86 架构下，支持两种 Machine Type，分别为 q35 和 i440fx(pc)，我们使用的是 i440fx，这两种类型我理解最主要的区别在于 PCI 和 PCIE 的支持，通俗描述就是 <code>兼容性</code> 更好。目前 x86 架构下的 Machine Type 我们使用的是 i440fx(pc)。但是在 ARM 架构下只支持一种 Machine Type，就是 mach-virt(virt) ，而这种架构下的大部分行为与 q35 相同，所以我们在创建虚拟机时所指定的基本参数就需要进行相应的调整。</p><h3 id="Boot-Options"><a href="#Boot-Options" class="headerlink" title="Boot Options"></a>Boot Options</h3><p>ARM 架构下虚拟机不支持 BIOS 引导，只支持 UEFI，在设置 UEFI  bootloader 时，需要使用 aarch64 版本的 edk2(EFI Development Kit II)，虽然 edk2 的 x86 下使用的是 noarch 版本，但是这里的 noarch 是假象，还是需要指定 aarch64 版本才可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node26 19:58:59 ~]$rpm -ql edk2.git-aarch64-0-20200515.1405.g9af1064995.noarch</span><br><span class="line">/usr/share/edk2.git</span><br><span class="line">/usr/share/edk2.git/aarch64</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_EFI.fd</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_VARS.fd</span><br><span class="line">/usr/share/edk2.git/aarch64/vars-template-pflash.raw</span><br><span class="line">/usr/share/qemu/firmware/80-uefi-a64-git.json</span><br></pre></td></tr></table></figure><p>在 libvirt qemu 配置文件中指定 nvram 文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node26 19:59:23 ~]$cat /etc/libvirt/qemu.conf </span><br><span class="line">nvram = [&quot;/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw:/usr/share/edk2.git/aarch64/vars-template-pflash.raw&quot;]</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>虚拟机配置中，一个比较重要的地方是 Controller 配置，在 q35 Machine Type 中：不支持 PCI Controller，仅支持 PCI-E Controller，因此需要特殊注意；同时 USB Controller 支持 XHCI Controller，XHCI 可以同时支持 USB 1.1，2.0，3.0 设备。</p><h4 id="PCI-E-Controller"><a href="#PCI-E-Controller" class="headerlink" title="PCI-E Controller"></a>PCI-E Controller</h4><p>默认的 PCI 拓扑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;controller type=&apos;pci&apos; index=&apos;0&apos; model=&apos;pcie-root&apos;/&gt;</span><br><span class="line">&lt;controller type=&apos;pci&apos; index=&apos;1&apos; model=&apos;pcie-root-port&apos;&gt;</span><br><span class="line">  &lt;model name=&apos;pcie-root-port&apos;/&gt;</span><br><span class="line">  &lt;target chassis=&apos;1&apos; port=&apos;0x10&apos;/&gt;</span><br><span class="line">  &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x01&apos; function=&apos;0x0&apos;/&gt;</span><br><span class="line">&lt;/controller&gt;</span><br></pre></td></tr></table></figure><p><code>pcie-root</code> 不支持设备的热插拔，因此需要将设备添加到 <code>pcie-root-port</code> 上，但是 <code>pcie-root-port</code> 自身也不支持热插拔，所以需要在虚拟机创建时预先分配好一定数量的 <code>pcie-root-port</code> Controller 用于后续其他设备的热插拔。</p><p>文档中提到 q35 支持 <code>pcie-to-pci-bridge</code> 控制器用于连接一些传统的 PCI 设备，但是实际测试中发现没有作用，不知道是不是我的姿势有问题。</p><p>上面提到要在虚拟机创建时预先分配 <code>pcie-root-port</code> Controller，我们需要知道 <code>pcie-root</code> 所支持的 <code>pcie-root-port</code> 数量上限是多少，没有找到相关文档，于是我去看了看 virt-manager 中是否有特殊处理，代码中没找到 <code>pcie-root-port</code> 关键字，在测试的 XML 文件中，发现最多添加了 8 个 <code>pcie-root-port</code> Controller。virt-manager 没找到，那么就去 OpenStack Nova 中找。</p><p>在 nova/virt/libvirt/driver.py 中，看到了添加 <code>pcie-root-port</code> Controller 的相关逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_guest_add_pcie_root_ports</span><span class="params">(self, guest)</span>:</span></span><br><span class="line">    <span class="string">"""Add PCI Express root ports.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    PCI Express machine can have as many PCIe devices as it has</span></span><br><span class="line"><span class="string">    pcie-root-port controllers (slots in virtual motherboard).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we want to have more PCIe slots for hotplug then we need to create</span></span><br><span class="line"><span class="string">    whole PCIe structure (libvirt limitation).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    pcieroot = vconfig.LibvirtConfigGuestPCIeRootController()</span><br><span class="line">    guest.add_device(pcieroot)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, CONF.libvirt.num_pcie_ports):</span><br><span class="line">        pcierootport = vconfig.LibvirtConfigGuestPCIeRootPortController()</span><br><span class="line">        guest.add_device(pcierootport)</span><br></pre></td></tr></table></figure><p>nova 在创建虚拟机时，直接预先分配了所有的 <code>pcie-root-port</code> ，达到了 libvirt 的上限，在 nova 中时一个常量 28，并且给出了 qemu 关于 PCI-E 相关的文档说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    cfg.IntOpt(&apos;num_pcie_ports&apos;,</span><br><span class="line">               default=0,</span><br><span class="line">               min=0,</span><br><span class="line">               max=28,</span><br><span class="line">               help= &quot;&quot;&quot;</span><br><span class="line">The number of PCIe ports an instance will get.</span><br><span class="line"></span><br><span class="line">Libvirt allows a custom number of PCIe ports (pcie-root-port controllers) a</span><br><span class="line">target instance will get. Some will be used by default, rest will be available</span><br><span class="line">for hotplug use.</span><br><span class="line"></span><br><span class="line">By default we have just 1-2 free ports which limits hotplug.</span><br><span class="line"></span><br><span class="line">More info: https://github.com/qemu/qemu/blob/master/docs/pcie.txt</span><br><span class="line"></span><br><span class="line">Due to QEMU limitations for aarch64/virt maximum value is set to &apos;28&apos;.</span><br><span class="line"></span><br><span class="line">Default value &apos;0&apos; moves calculating amount of ports to libvirt.</span><br><span class="line">&quot;&quot;&quot;),</span><br></pre></td></tr></table></figure><p>于是我在创建虚拟机的时候指定了 28个 <code>pcie-root-port</code> Controller，但是发现虚拟机无法成功引导，简单的二分最终确认在当前环境配置下，虚拟机最多支持 15 个 <code>pcie-root-port</code> ，猜测可能根当前使用的版本有关。</p><h4 id="USB-Controller"><a href="#USB-Controller" class="headerlink" title="USB Controller"></a>USB Controller</h4><p>USB Controller model 选择 <code>qemu-xhci</code> ，添加一个即可，涉及到的设备有 mouse, keyboard, tablet ，都需要将 bus 设置未 usb 。</p><p>在 Controller 确认完成后，我们可以得出当前虚拟机支持设备上限：最多可以连接 15 个 Device/Controller，其中 USB Controller 和 Virtio Video 占用 2个 port，剩余 13 个 port，可以最多插入 13 个 Virtio Device ，也可插入 13 个 Controller，1 个 SCSI Controller 可以插入 7 个 SCSI Disk。</p><h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><p>q35 仅支持 <code>virtio</code> 类型的 Video 设备，cirrus, vga, qxl 都不支持。</p><h3 id="CDROM"><a href="#CDROM" class="headerlink" title="CDROM"></a>CDROM</h3><p>不支持 IDE 磁盘，因此需要将 CDROM 的 bus 总线设置为 SCSI。</p><h3 id="CPU-Model"><a href="#CPU-Model" class="headerlink" title="CPU Model"></a>CPU Model</h3><p>通常我们为了虚拟机兼容性考虑，都会将虚拟机的 CPU Model 设置的略微低一些，避免当一个集群中存在节点 CPU 代数不一致时导致虚拟机无法热迁移，通常我们在 x86 下可以通过 <code>virsh domcapabilities</code> 获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;mode name=&apos;custom&apos; supported=&apos;yes&apos;&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;qemu64&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;qemu32&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;phenom&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;IvyBridge&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;IvyBridge-IBRS&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-noTSX&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-noTSX-IBRS&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-IBRS&lt;/model&gt;</span><br><span class="line">&lt;/mode&gt;</span><br></pre></td></tr></table></figure><p>可以通过 <code>usable</code> 属性来判断是否可以配置，但是在 ARM 下所有的 <code>usable</code> 属性都是 unknown，强行设置后，虚拟机无法启动，在当前版本下时无法进行 CPU Model 设置的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mode name=&apos;host-passthrough&apos; supported=&apos;yes&apos;/&gt;</span><br><span class="line">&lt;mode name=&apos;host-model&apos; supported=&apos;no&apos;/&gt;</span><br><span class="line">&lt;mode name=&apos;custom&apos; supported=&apos;yes&apos;&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a53&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a57&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;max&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a15&lt;/model&gt;</span><br><span class="line">&lt;/mode&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一番折腾，终于可以在 ARM 服务器上进行虚拟化功能的使用了，实际使用感受还不错，没啥问题。</p><p>例行吐槽：</p><ul><li>尽量使用华为官方文档中提到的建议版本，否则就有坑</li><li>华为鲲鹏论坛的活跃度不高，而且遇到了问题基本上没啥回复，全得靠自己</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.huaweicloud.com/kunpeng/" target="_blank" rel="noopener">https://www.huaweicloud.com/kunpeng/</a></li><li><a href="https://stackoverflow.com/questions/31851611/differences-between-arm64-and-aarch64" target="_blank" rel="noopener">https://stackoverflow.com/questions/31851611/differences-between-arm64-and-aarch64</a></li><li><a href="https://libvirt.org/pci-hotplug.html#aarch64-virt" target="_blank" rel="noopener">https://libvirt.org/pci-hotplug.html#aarch64-virt</a></li><li><a href="https://sourcegraph.com/github.com/openstack/nova/-/blob/nova/conf/libvirt.py" target="_blank" rel="noopener">https://sourcegraph.com/github.com/openstack/nova/-/blob/nova/conf/libvirt.py</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上一次写 &lt;a href=&quot;https://zdyxry.github.io/2019/11/01/ARM-%E6%9C%8D%E5%8A%
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第33周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/16/2020-第33周-LeetCode-记录/</id>
    <published>2020-08-16T10:27:06.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1544-Make-The-String-Great"><a href="#1544-Make-The-String-Great" class="headerlink" title="1544. Make The String Great"></a>1544. Make The String Great</h3><p>使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeGood</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> ((ord(stack[<span class="number">-1</span>])<span class="number">-32</span>) == ord(i) <span class="keyword">or</span> (ord(stack[<span class="number">-1</span>])+<span class="number">32</span>) == ord(i)):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure><h3 id="1545-Find-Kth-Bit-in-Nth-Binary-String"><a href="#1545-Find-Kth-Bit-in-Nth-Binary-String" class="headerlink" title="1545. Find Kth Bit in Nth Binary String"></a>1545. Find Kth Bit in Nth Binary String</h3><p>找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        l = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">        mid = (l &gt;&gt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == mid:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">elif</span> k &lt; mid:</span><br><span class="line">            <span class="keyword">return</span> self.findKthBit(n - <span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = l + <span class="number">1</span> -k</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span> <span class="keyword">if</span> self.findKthBit(n - <span class="number">1</span>, k) == <span class="string">'0'</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        s = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + <span class="string">'1'</span> + self.reverse(s[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> s[n][k<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                res.append(<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target"><a href="#1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target" class="headerlink" title="1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target"></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</h3><p>这是一道告诉你方法就会立刻做出来的题目，前缀和，因为要求不重叠，因此在遍历过的结果中找到 target，那么就需要将 set 重置，cur_sum 清零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNonOverlapping</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += num</span><br><span class="line">            <span class="keyword">if</span> cur_sum - target <span class="keyword">in</span> s:</span><br><span class="line">                s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">                cur_sum = <span class="number">0</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(cur_sum)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1541-Minimum-Insertions-to-Balance-a-Parentheses-String"><a href="#1541-Minimum-Insertions-to-Balance-a-Parentheses-String" class="headerlink" title="1541. Minimum Insertions to Balance a Parentheses String"></a>1541. Minimum Insertions to Balance a Parentheses String</h3><p>看完题目第一想法是用栈来做，但是写了半天发现题目理解错了，这题跟 #1544 不同的是，它不会因为栈中某个时刻符合平衡括号的条件就全部出栈，比如 <code>&quot;(()))(()))()())))&quot;</code> 这个用例，如果自己计算理解了这个用例这道题也就做出来了。</p><p>使用栈记录当前遍历字符为 <code>(</code> 的情况，如果为 <code>(</code> 那么直接入栈，如果为 <code>)</code> ，那么此时有两种情况：</p><ul><li>如果栈不存在，意味着左边缺少 <code>(</code> ，那么就至少需要补充一个 <code>(</code> ，此时判断当前字符的右侧是否为 <code>)</code> ，如果是，那么只需要添加一个 <code>(</code> ，如果不是 <code>)</code> ，那么就需要添加一个 <code>(</code> 和一个 <code>)</code>；</li><li>如果栈存在，意味着左侧存在 <code>(</code> ，此时判断当前字符右侧是否为 <code>)</code> ，如果是，那么将左侧字符出栈，此时已经满足了平衡括号情况，无须添加，如果不是 <code>)</code> ，那么需要添加一个 <code>)</code> 满足平衡。</li></ul><p>最终判断 stack 是否还存在，如果存在，则每个 <code>(</code> 需要添加两个 <code>)</code> 满足条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># use stack</span></span><br><span class="line">        stack = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># when facing empty stack</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">if</span> i+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        count += <span class="number">1</span>  <span class="comment"># add one "("</span></span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">2</span>   <span class="comment"># add one "("  and one ")"</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># check two positions</span></span><br><span class="line">                    <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">1</span>   <span class="comment"># add one ")"</span></span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        rest = len(stack)*<span class="number">2</span>  <span class="comment"># still have "(" on the stack. one "(" pairs with two ")"</span></span><br><span class="line">        <span class="keyword">return</span> count + rest</span><br></pre></td></tr></table></figure><h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h3><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/solution/da-lao-de-dai-ma-kan-ming-bai-hou-ji-ge-bi-ji-yong/" target="_blank" rel="noopener">leetcode-cn</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:                            </span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy=ListNode(float(-inf))             <span class="comment">#首项负无穷保证插的数据不在最前头</span></span><br><span class="line">        dummy.next=head                         <span class="comment">#用于返回答案</span></span><br><span class="line">        pre=head                                    </span><br><span class="line">        nxt=head.next</span><br><span class="line">        <span class="keyword">while</span> nxt:                              <span class="comment">#最后一项为None结束循环</span></span><br><span class="line">            <span class="keyword">if</span> nxt.val&gt;pre.val:                 <span class="comment">#从头开始，如果后一项大于前一项不改变节点</span></span><br><span class="line">               pre=nxt                          <span class="comment">#这两行移动指针（往后挪一格）</span></span><br><span class="line">               nxt=nxt.next</span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment">#如果后项小需要把后项nxt的节点插到正确位置</span></span><br><span class="line">                pre.next=nxt.next               <span class="comment">#把nxt指向的节点拿出来</span></span><br><span class="line">                cp1=dummy                       <span class="comment">#这两个指针负责从头开始比较nxt的位置</span></span><br><span class="line">                cp2=dummy.next                  <span class="comment">#使用dummy的原因见11行注释</span></span><br><span class="line">                <span class="keyword">while</span> nxt.val&gt;cp2.val:          <span class="comment">#因为前面是排好序的循环结束nxt正好在cp1和cp2中间</span></span><br><span class="line">                    cp1=cp2                     <span class="comment">#</span></span><br><span class="line">                    cp2=cp2.next                <span class="comment">#</span></span><br><span class="line">                nxt.next=cp2                    <span class="comment">#这两行负责插</span></span><br><span class="line">                cp1.next=nxt                    <span class="comment">#把nxt指向的节点查到cp1和cp2中间</span></span><br><span class="line">                nxt=pre.next                    <span class="comment">#指针从哪来回哪去 准备下一个循环</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1544-Make-The-String-Great&quot;&gt;&lt;a href=&quot;#1544-Make-The-String-Great&quot; class=&quot;headerlink&quot; title=&quot;1544. Make The String Great&quot;&gt;&lt;/a&gt;1544. M
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第32周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/08/2020-%E7%AC%AC32%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/08/2020-第32周-LeetCode-记录/</id>
    <published>2020-08-08T16:17:20.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1534-Count-Good-Triplets"><a href="#1534-Count-Good-Triplets" class="headerlink" title="1534. Count Good Triplets"></a>1534. Count Good Triplets</h3><p>数据规模很小，暴力循环解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countGoodTriplets</span><span class="params">(self, arr: List[int], a: int, b: int, c: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(arr)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, len(arr)):</span><br><span class="line">                    <span class="keyword">if</span> abs(arr[i] - arr[j]) &lt;= a <span class="keyword">and</span> abs(arr[j] - arr[k]) &lt;= b <span class="keyword">and</span> abs(arr[i] - arr[k]) &lt;= c:</span><br><span class="line">                        ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1535-Find-the-Winner-of-an-Array-Game"><a href="#1535-Find-the-Winner-of-an-Array-Game" class="headerlink" title="1535. Find the Winner of an Array Game"></a>1535. Find the Winner of an Array Game</h3><p>每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。</p><p>假设第一个数字为所求数字，从下一个数字开始遍历，如果当前数字比所求数字大，那么更新所求数字为当前数字并重置胜利变量为1，否则 += 1，如果胜利次数等于 k，那么直接返回当前最大的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWinner</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        a,n=arr[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i&gt;a:</span><br><span class="line">                a,n=i,<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> n==k:</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h3 id="1536-Minimum-Swaps-to-Arrange-a-Binary-Grid"><a href="#1536-Minimum-Swaps-to-Arrange-a-Binary-Grid" class="headerlink" title="1536. Minimum Swaps to Arrange a Binary Grid"></a>1536. Minimum Swaps to Arrange a Binary Grid</h3><p>最终需要将二维数组变为 grid[i] 的 grid[i][i+1:] 均为0，遍历 grid，找到满足当前 grid[i][i+1:] 需求，如果找到了，那么就需要一次次的交换，因为每次只能交换相邻两行，所以交换的次数等于 j -i 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwaps</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        need = <span class="number">0</span></span><br><span class="line">        l = len(grid)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, l):</span><br><span class="line">                <span class="keyword">if</span> sum(grid[j][i+<span class="number">1</span>:]) == <span class="number">0</span>:</span><br><span class="line">                    need += j-i</span><br><span class="line">                    grid[i:j+<span class="number">1</span>] = grid[j:j+<span class="number">1</span>]+grid[i:j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> need</span><br></pre></td></tr></table></figure><h3 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h3><p>每 k 组链表进行反转，使用递归做比较清晰易懂，<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/" target="_blank" rel="noopener">官方题解</a>感觉需要自己实际画画方便理解。</p><p>这道题的基础就是反转链表，通常的反转链表的操作是定义一个 pre，然后遍历整个链表，进行链表连接的断开以及反转，这里需要判断每 k 次，如果不足 k，那么直接返回当前的 head ，如果大于 k，那么就开始反转 k 个链表，注意需要记录反转前的 head，因为进行 k 次反转后，head 就是当前链表的尾端，然后递归反转后续链表，并赋值 head.next 保证链表的连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr: <span class="keyword">return</span> head</span><br><span class="line">            curr = curr.next</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reverse the group (basic way to reverse linked list)</span></span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nxt = curr.next</span><br><span class="line">            curr.next = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = nxt</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># After reverse, we know that `head` is the tail of the group.</span></span><br><span class="line"><span class="comment"># And `curr` is the next pointer in original linked list order</span></span><br><span class="line">        head.next = self.reverseKGroup(curr, k)</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h3 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h3><p>合并 k 个链表，题目没有要求原地合并，直接遍历记录所有链表的数值，然后进行排序，最后再重新定义链表连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists <span class="keyword">or</span> len(lists) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        all_vals = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l:</span><br><span class="line">                all_vals.append(l.val)</span><br><span class="line">                l = l.next</span><br><span class="line">        all_vals.sort()</span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> all_vals:</span><br><span class="line">            temp_node = ListNode(i)</span><br><span class="line">            cur.next = temp_node</span><br><span class="line">            cur = temp_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1534-Count-Good-Triplets&quot;&gt;&lt;a href=&quot;#1534-Count-Good-Triplets&quot; class=&quot;headerlink&quot; title=&quot;1534. Count Good Triplets&quot;&gt;&lt;/a&gt;1534. Count G
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>通过 grub 修复系统无法正确引导问题</title>
    <link href="https://zdyxry.github.io/2020/08/02/%E9%80%9A%E8%BF%87-grub-%E4%BF%AE%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%BC%95%E5%AF%BC%E9%97%AE%E9%A2%98/"/>
    <id>https://zdyxry.github.io/2020/08/02/通过-grub-修复系统无法正确引导问题/</id>
    <published>2020-08-02T09:10:39.000Z</published>
    <updated>2021-05-22T01:05:51.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在将一个节点的 kernel 从 4.18 版本降级到 4.14 后，发现系统无法启动，直接进入到了 GRUB 提示符界面，记录下修复过程。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>因为 kernel 4.18 版本和 4.14 的 打包方式发生了比较大的变化，4.18 版本多出了 kernel-core 和 kernel-modules 两个 rpm：</p><blockquote><p>4.14</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@sh-workstation Packages]# ls |grep ^kernel</span><br><span class="line">kernel-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-headers-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-tools-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-tools-libs-4.14.0-115.el7a.0.1.aarch64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>4.18</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-core-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-modules-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-tools-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-tools-libs-4.18.0-147.8.1.el7.aarch64.rpm</span><br></pre></td></tr></table></figure><p>在没有官方 yum repo 的情况下，降级就比较麻烦，我直接尝试 <code>rpm -Uvh kernel-4.14*.rpm</code> ，然后将 4.18 的 kernel-core 和 kernel-modules 卸载掉，然后重启后，发现系统直接进入到了 GRUB 提示符界面，无法正常启动，只能寻求修复办法。</p><h2 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h2><p>当时系统启动后，显示的是 <code>grub&gt;</code> 提示符，说明此时已经加载了 grub 程序，但是没有找到 grub.cfg 配置文件中的指定kernel 和 initramfs。</p><p>此时有两种修复思路：一种是在现有环境基础上，手动指定 grub 参数，先启动进入系统，然后再修复 grub 配置；一种是关机，在服务器上挂载一个 LiveCD OS，进入到 LiveCD 中，chroot 进行修复。</p><p>因为当时没有 LiveCD，所以选择第一种方式修复。</p><p>此时排查思路如下：</p><ol><li>需要找到 <code>/boot/</code> 分区所在磁盘，可以通过 <code>ls</code> 命令显示此时所有的磁盘分区情况，可以通过 <code>ls (hd0,msdos1)/</code> 方式查看磁盘分区下的文件，如果是 <code>/boot/</code> 分区，会看到 vmlinuz 和 initramfs 文件</li><li>根据 <code>/boot</code> 分区文件系统类型，执行 <code>insmod</code> 命令加载对应的 module，比如 <code>insmod xfs</code></li><li>找到 <code>/boot/</code> 分区所在磁盘后，设置 <code>root</code> 变量，<code>root</code> 变量是指定的我们当前交互的根分区，指定我们找到的磁盘分区，<code>set root=(hd0,msdos1)</code> </li><li>加载 linux kernel，并指定系统根分区 <code>root</code>，这个 <code>root</code> 变量并不是我们在上一步所指定的，而是作为加载 kernel 的参数传递的，如果使用 lvm 配置，那么默认是 <code>/dev/mapper/centos-root</code> ，最终命令如 <code>linux /vmlinuz-4.14.0-115.el7a.0.1.aarch64 root=/dev/mapper/centos-root</code> </li><li>加载 initramfs，如 <code>initrd initramfs-4.14.0-115.el7a.0.1.aarch64.img</code> </li><li>此时所有引导的必要参数已经设置完成，输入 <code>boot</code> 命令即可正确引导</li><li>系统引导后，检查 grub.cfg 配置，执行 <code>grub2-mkconfig -o</code> 重新生成 grub 配置。</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>在 kernel 升级的动作中，grub 会被自动更新，但是如果通过非常规方式进行 kernel 降级，就需要注意 grub 配置了，修复 grub 不是什么好的体验，慎重。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.gnu.org/software/grub/manual/grub/grub.html" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/grub/grub.html</a></li><li><a href="https://help.ubuntu.com/community/Grub2/Troubleshooting" target="_blank" rel="noopener">https://help.ubuntu.com/community/Grub2/Troubleshooting</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在将一个节点的 kernel 从 4.18 版本降级到 4.14 后，发现系统无法启动，直接进入到了 GRUB 提示符界面，记录下修复过
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第31周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/01/2020-%E7%AC%AC31%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/01/2020-第31周-LeetCode-记录/</id>
    <published>2020-08-01T07:26:24.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1523-Count-Odd-Numbers-in-an-Interval-Range"><a href="#1523-Count-Odd-Numbers-in-an-Interval-Range" class="headerlink" title="1523. Count Odd Numbers in an Interval Range"></a>1523. Count Odd Numbers in an Interval Range</h3><p>数学题，数据范围是10^9，O(n) 会超时，统计 high 中有多少个奇数，减去 low-1 中的奇数个数，需要考虑边界条件：low/high 自身为奇数情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countOdds</span><span class="params">(self, low: int, high: int)</span> -&gt; int:</span></span><br><span class="line">        res = high // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> high % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> low - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            res -= (low - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (low - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1528-Shuffle-String"><a href="#1528-Shuffle-String" class="headerlink" title="1528. Shuffle String"></a>1528. Shuffle String</h3><p>按照指定顺序调整字符串，直接定义一个新的长度为 len(s)字符串，然后按照 indices 的索引顺序进行对应调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreString</span><span class="params">(self, s: str, indices: List[int])</span> -&gt; str:</span></span><br><span class="line">        _s = [<span class="string">'0'</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            _s[indices[idx]] = val</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(_s)</span><br></pre></td></tr></table></figure><h3 id="1524-Number-of-Sub-arrays-With-Odd-Sum"><a href="#1524-Number-of-Sub-arrays-With-Odd-Sum" class="headerlink" title="1524. Number of Sub-arrays With Odd Sum"></a>1524. Number of Sub-arrays With Odd Sum</h3><blockquote><p><a href="https://www.youtube.com/watch?v=vGTm8rjlDTQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=vGTm8rjlDTQ</a></p></blockquote><p>用两个变量分别记录奇数和偶数的个数，遍历数组，如果当前数字是奇数，那么 odd 等于偶数个数 +1，1为当前数字，even 等于奇数个数，因为奇数个数加上当前数字（奇数）为偶数；如果当前数字是偶数，那么 odd 等于 odd，偶数个数等于 even + 1，1为当前数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numOfSubarrays</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    odd, even := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">if</span> v % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            odd, even = even + <span class="number">1</span>, odd</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            odd, even = odd, even + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        res += odd</span><br><span class="line">        res %= mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1525-Number-of-Good-Ways-to-Split-a-String"><a href="#1525-Number-of-Good-Ways-to-Split-a-String" class="headerlink" title="1525. Number of Good Ways to Split a String"></a>1525. Number of Good Ways to Split a String</h3><p>使用 Counter 统计当前字符串中的字符出现的次数，left 表示切割索引左侧字符出现的次数，right 表示切割索引右侧字符出现的次数，遍历字符，如果 right[x] == 0，那么表示右侧已经没有字符 x，那么需要将对应的 key(x) 从 right 中删除，比较 left 中的 key 数量与 right 中是否相同，如果相同，则记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSplits</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = Counter()</span><br><span class="line">        right = Counter(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            left[s[i]] += <span class="number">1</span></span><br><span class="line">            right[s[i]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right[s[i]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> right[s[i]]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> len(left) == len(right):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1529-Bulb-Switcher-IV"><a href="#1529-Bulb-Switcher-IV" class="headerlink" title="1529. Bulb Switcher IV"></a>1529. Bulb Switcher IV</h3><p>统计需要翻转开关的次数，就是统计最终状态中 0，1 切换的次数，比如<code>001011101</code> ，0，1 切换分别在 <code>001</code> , <code>10</code>, <code>0111</code>, <code>1110</code>, <code>01</code> 这五个位置出现了切换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minFlips</span><span class="params">(target <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">target = <span class="string">"0"</span> + target</span><br><span class="line">flag := target[<span class="built_in">len</span>(target)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(target) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> target[i] != flag &#123;</span><br><span class="line">count++</span><br><span class="line">flag = target[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1523-Count-Odd-Numbers-in-an-Interval-Range&quot;&gt;&lt;a href=&quot;#1523-Count-Odd-Numbers-in-an-Interval-Range&quot; class=&quot;headerlink&quot; title=&quot;1523. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第30周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/26/2020-%E7%AC%AC30%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/26/2020-第30周-LeetCode-记录/</id>
    <published>2020-07-26T09:36:03.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1518-Water-Bottles"><a href="#1518-Water-Bottles" class="headerlink" title="1518. Water Bottles"></a>1518. Water Bottles</h3><p>小学数学题，用几个空瓶子可以换一瓶新的，问最后能喝到几瓶，在小学场景下可以先借再喝，在这道题没有这种场景，所以正常计算就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWaterBottles</span><span class="params">(self, numBottles: int, numExchange: int)</span> -&gt; int:</span></span><br><span class="line">        res = numBottles</span><br><span class="line">        <span class="keyword">while</span> numBottles &gt;= numExchange:</span><br><span class="line">            cnt = numBottles // numExchange</span><br><span class="line">            res += cnt</span><br><span class="line">            numBottles = numBottles - (cnt * numExchange)</span><br><span class="line">            numBottles += cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108. Defanging an IP Address"></a>1108. Defanging an IP Address</h3><p>将 IPv4 地址 “1.1.1.1” 转换为 “1[.]1[.]1[.]1” ，不知道这道题的意义在哪里。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">'.'</span>, <span class="string">'[.]'</span>)</span><br></pre></td></tr></table></figure><h3 id="1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><a href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label" class="headerlink" title="1519. Number of Nodes in the Sub-Tree With the Same Label"></a>1519. Number of Nodes in the Sub-Tree With the Same Label</h3><p>题目很绕，最好自己根据给的 edges 和 labels 构建出对应的树，了解是如何构建的，最终要求的 ans 中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数，记录所有节点的相邻节点，从 0 节点开始 dfs，如果节点已经访问过，则跳过对应节点，最终汇总 ans[i] 中的数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">        edge_map = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            edge_map[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            edge_map[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            visited.add(i)</span><br><span class="line">            <span class="comment"># 字符数字典</span></span><br><span class="line">            data = Counter(&#123;labels[i]: <span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> edge_map[i]:</span><br><span class="line">                <span class="keyword">if</span> nxt <span class="keyword">in</span> visited: <span class="keyword">continue</span> <span class="comment"># 去重</span></span><br><span class="line">                <span class="comment"># 整合子树的字符数</span></span><br><span class="line">                data += _dfs(nxt)</span><br><span class="line">            <span class="comment"># 设置当前节点的结果字符数</span></span><br><span class="line">            ans[i] = data[labels[i]]</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        ans = [<span class="number">1</span>] * n</span><br><span class="line">        _dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1189-Maximum-Number-of-Balloons"><a href="#1189-Maximum-Number-of-Balloons" class="headerlink" title="1189. Maximum Number of Balloons"></a>1189. Maximum Number of Balloons</h3><p>给一个字符串 text，使用 text 中的字母来拼凑尽可能多的单词 “balloon”，每个字母最多只能被使用一次。返回最多可以拼凑出多少个单词 “balloon”，分别统计每个字母出现的次数，然后判断满足ballon 所有字母出现次数最小的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfBalloons</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        d = collections.Counter(text)</span><br><span class="line">        <span class="keyword">return</span> min(d[<span class="string">'b'</span>], d[<span class="string">'a'</span>], d[<span class="string">'l'</span>] // <span class="number">2</span>, d[<span class="string">'o'</span>] // <span class="number">2</span>, d[<span class="string">'n'</span>])</span><br></pre></td></tr></table></figure><h3 id="1304-Find-N-Unique-Integers-Sum-up-to-Zero"><a href="#1304-Find-N-Unique-Integers-Sum-up-to-Zero" class="headerlink" title="1304. Find N Unique Integers Sum up to Zero"></a>1304. Find N Unique Integers Sum up to Zero</h3><p>给一个整数 n，返回任意一个由 n 个 各不相同的整数组成的数组，并且这 n 个数相加和为 0 ，题目很开放，如果n 为奇数，则补充一个数字 <code>0</code>，如果为 偶数，那么补充对应的 n/2 个数字的正负值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            res.append(i)</span><br><span class="line">            res.append(-i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1518-Water-Bottles&quot;&gt;&lt;a href=&quot;#1518-Water-Bottles&quot; class=&quot;headerlink&quot; title=&quot;1518. Water Bottles&quot;&gt;&lt;/a&gt;1518. Water Bottles&lt;/h3&gt;&lt;p&gt;小学数学
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第29周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/19/2020-第29周-LeetCode-记录/</id>
    <published>2020-07-19T11:19:38.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves"><a href="#1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves" class="headerlink" title="1509. Minimum Difference Between Largest and Smallest Value in Three Moves"></a>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</h3><p>要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> min(b - a <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(nums[:<span class="number">4</span>], nums[<span class="number">-4</span>:]))</span><br></pre></td></tr></table></figure><h3 id="1512-Number-of-Good-Pairs"><a href="#1512-Number-of-Good-Pairs" class="headerlink" title="1512. Number of Good Pairs"></a>1512. Number of Good Pairs</h3><p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 ，返回好数对的数目。<br>只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIdenticalPairs</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(k * (k - <span class="number">1</span>) / <span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> collections.Counter(A).values())</span><br></pre></td></tr></table></figure><h3 id="1513-Number-of-Substrings-With-Only-1s"><a href="#1513-Number-of-Substrings-With-Only-1s" class="headerlink" title="1513. Number of Substrings With Only 1s"></a>1513. Number of Substrings With Only 1s</h3><p>判断连续 1 的个数，每当遇到 1 时计数 +1， 遇到 0 时对现有计数进行求和公式，并加到最终结果中，重置计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += cnt * (cnt +<span class="number">1</span>) /<span class="number">2</span></span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            res += cnt * (cnt + <span class="number">1</span>)/ <span class="number">2</span></span><br><span class="line">        res %= <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><h3 id="1114-Print-in-Order"><a href="#1114-Print-in-Order" class="headerlink" title="1114. Print in Order"></a>1114. Print in Order</h3><p>将各个线程按照顺序执行，有很多实现方式，挑一种方式实现就可以了，这里直接使用 <code>threading.Event</code> 。</p><p><code>threading.Event</code> 定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b1 = threading.Event()</span><br><span class="line">        self.b2 = threading.Event()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.b1.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b1.wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.b2.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b2.wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure><h3 id="1209-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#1209-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="1209. Remove All Adjacent Duplicates in String II"></a>1209. Remove All Adjacent Duplicates in String II</h3><p>这题描述有点别扭，给一个字符串，如果字符串中包含 k 个相邻且相等的字母，那么就原地删除，然后继续检测是否满足条件，重复执行操作。使用栈来记录最终结果，遍历字符串，如果当前自负和栈顶相同，且长度等于 k，那么就出栈，最终将栈中记录拼接为字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">if</span> len(stack) == <span class="number">0</span> <span class="keyword">or</span> stack[<span class="number">-1</span>][<span class="number">0</span>] != i:</span><br><span class="line">                stack.append([i, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[<span class="number">-1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">        ret = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> stack:</span><br><span class="line">            ret += t[<span class="number">0</span>] * t[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves&quot;&gt;&lt;a href=&quot;#1509-Minimum-Difference-Between-Largest-and-Sma
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第28周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/11/2020-%E7%AC%AC28%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/11/2020-第28周-LeetCode-记录/</id>
    <published>2020-07-11T21:50:54.000Z</published>
    <updated>2021-05-22T01:05:50.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1502-Can-Make-Arithmetic-Progression-From-Sequence"><a href="#1502-Can-Make-Arithmetic-Progression-From-Sequence" class="headerlink" title="1502. Can Make Arithmetic Progression From Sequence"></a>1502. Can Make Arithmetic Progression From Sequence</h3><p>判断是否可以组成等差数列，将数组排序后，比较两两数字差是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        arr.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        diff = arr[<span class="number">0</span>] - arr[<span class="number">1</span>]</span><br><span class="line">        pre = arr[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> pre - i != diff:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            pre = i</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank"><a href="#1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank" class="headerlink" title="1503. Last Moment Before All Ants Fall Out of a Plank"></a>1503. Last Moment Before All Ants Fall Out of a Plank</h3><p>标签是“脑筋急转弯”，蚂蚁只要在一个点碰到，那么就会调换方向，但是蚂蚁始终是蚂蚁，因此可以忽略掉这个条件，直接找到最大值就可以了。</p><p>再次怀疑自己智商。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastMoment</span><span class="params">(self, n: int, left: List[int], right: List[int])</span> -&gt; int:</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            time = max(time, max(left))</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            time = max(time, n - min(right))</span><br><span class="line">        <span class="keyword">return</span> time</span><br></pre></td></tr></table></figure><h3 id="939-Minimum-Area-Rectangle"><a href="#939-Minimum-Area-Rectangle" class="headerlink" title="939. Minimum Area Rectangle"></a>939. Minimum Area Rectangle</h3><p>一般会选择完整本周周赛题目，然后去做其他的题，但是 1504 做不出，就找了到也是矩形相关的补一补 - - 。</p><p>找出最小矩形面积，需要先找到组成矩形的四个点，遍历所有点，将其记录下来，并遍历已记录的点，此时拿到了两个点，直接暴力判断这两个点的对称点是否存在，如果存在，则计算面积并更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAreaRect</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        mem = set()</span><br><span class="line">        <span class="keyword">for</span> x1,y1 <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">for</span> x2,y2 <span class="keyword">in</span> mem:</span><br><span class="line">                <span class="keyword">if</span> (x2,y1) <span class="keyword">in</span> mem <span class="keyword">and</span> (x1,y2) <span class="keyword">in</span> mem:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> area:</span><br><span class="line">                        area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> abs(x2-x1)*abs(y2-y1) &lt; area:</span><br><span class="line">                            area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">            mem.add((x1,y1))</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure><h3 id="1160-Find-Words-That-Can-Be-Formed-by-Characters"><a href="#1160-Find-Words-That-Can-Be-Formed-by-Characters" class="headerlink" title="1160. Find Words That Can Be Formed by Characters"></a>1160. Find Words That Can Be Formed by Characters</h3><p>使用 Counter 统计词汇表中的字母，遍历单词，如果单词中的每个字母数量小于词汇表中的字母数量，那么满足条件，否则跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCharacters</span><span class="params">(self, words: List[str], chars: str)</span> -&gt; int:</span></span><br><span class="line">        chars_cnt = collections.Counter(chars)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_cnt = collections.Counter(word)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word_cnt:</span><br><span class="line">                <span class="keyword">if</span> chars_cnt[c] &lt; word_cnt[c]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += len(word)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a>1048. Longest String Chain</h3><p>先对所有单词进行排序，使用哈希表记录当前单词所能组成的最长字符串链的长度。当遍历到某个单词是，通过字符串切片，判断其所有可能的情况，如果记录中存在，那么与当前最大值进行比较更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        words.sort(key=len)</span><br><span class="line">        note=&#123;&#125;</span><br><span class="line">        maxChain=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> note:</span><br><span class="line">                note[word]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(word)):</span><br><span class="line">                newWord=word[:i]+word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> (newWord) <span class="keyword">in</span> note:</span><br><span class="line">                    note[word]=max(note[word],note[newWord]+<span class="number">1</span>)</span><br><span class="line">            maxChain=max(maxChain,note[word])</span><br><span class="line">        <span class="keyword">return</span> maxChain</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1502-Can-Make-Arithmetic-Progression-From-Sequence&quot;&gt;&lt;a href=&quot;#1502-Can-Make-Arithmetic-Progression-From-Sequence&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
