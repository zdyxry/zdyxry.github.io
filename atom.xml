<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2020-08-29T10:43:27.714Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 第35周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/29/2020-%E7%AC%AC35%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/29/2020-第35周-LeetCode-记录/</id>
    <published>2020-08-29T18:42:34.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1560-Most-Visited-Sector-in-a-Circular-Track"><a href="#1560-Most-Visited-Sector-in-a-Circular-Track" class="headerlink" title="1560. Most Visited Sector in a Circular Track"></a>1560. Most Visited Sector in a Circular Track</h3><p>在中间走过多少圈，对于各个扇区来说是相同的，只需要考虑起点和终点的位置关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostVisited</span><span class="params">(self, n: int, rounds: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        s, d = rounds[<span class="number">0</span>], rounds[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> s &lt;= d:</span><br><span class="line">            <span class="keyword">return</span> list(range(s, d+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> list(range(<span class="number">1</span>, d+<span class="number">1</span>)) + list(range(s, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes"><a href="#1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes" class="headerlink" title="1557. Minimum Number of Vertices to Reach All Nodes"></a>1557. Minimum Number of Vertices to Reach All Nodes</h3><p>如果某个节点出现在到达节点，那么这个节点一定不在结果中，相反则一定在结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSmallestSetOfVertices</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> list(set(range(n)) - set(e[<span class="number">1</span>] <span class="keyword">for</span> e <span class="keyword">in</span> edges))</span><br></pre></td></tr></table></figure><h3 id="1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array"><a href="#1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array" class="headerlink" title="1558. Minimum Numbers of Function Calls to Make Target Array"></a>1558. Minimum Numbers of Function Calls to Make Target Array</h3><p>一共有两种操作：1. 将某个索引位置的数值 +1； 2. 将所有数值 * 2 。<br>从结果上来说肯定是操作 2 效率更高，因为我们要求最小次数，所以我们想调用最多的操作 2。首先将判断数组中数字是否为奇数，如果是奇数的话就-1 并将结果 +1。执行完成后数组中所有数字都是偶数后，整体将数组中所有数字 /2 ，并将结果 +1。直到数组中所有数字都为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> any(nums):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] % <span class="number">2</span>:</span><br><span class="line">                    nums[i] -= <span class="number">1</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> any(nums):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    nums[i] //= <span class="number">2</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1561-Maximum-Number-of-Coins-You-Can-Get"><a href="#1561-Maximum-Number-of-Coins-You-Can-Get" class="headerlink" title="1561. Maximum Number of Coins You Can Get"></a>1561. Maximum Number of Coins You Can Get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。</span><br><span class="line">Alice 将会取走硬币数量最多的那一堆。</span><br><span class="line">你将会取走硬币数量第二多的那一堆。</span><br><span class="line">Bob 将会取走最后一堆。</span><br><span class="line">重复这个过程，直到没有更多硬币。</span><br></pre></td></tr></table></figure><p>虽然不可以选择最多的硬币，但是可以选择第二多的，所以可以先将数组排序，然后每次选择第二大的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, piles: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1,2,2,4,7,8 =&gt; 7,2</span></span><br><span class="line">        <span class="comment"># 1,2,3,4,5,6,7,8,9 =&gt; 8,6,4</span></span><br><span class="line">        piles.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(piles):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i += <span class="number">1</span>    </span><br><span class="line">            res.append(piles[i])</span><br><span class="line">            <span class="keyword">if</span> len(res) == len(piles) /<span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> sum(res)</span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure><h3 id="1079-Letter-Tile-Possibilities"><a href="#1079-Letter-Tile-Possibilities" class="headerlink" title="1079. Letter Tile Possibilities"></a>1079. Letter Tile Possibilities</h3><p>使用 DFS + 回溯，先统计字母出现的次数，分别遍历 26 个字母，如果字母出现的次数不为 0 ，那么将字母出现的次数 -1 ，并进行 dfs，在深度搜索后再将字母次数 +1，避免影响最终结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTilePossibilities</span><span class="params">(self, tiles: str)</span> -&gt; int:</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> tile <span class="keyword">in</span> tiles: record[ord(tile)-ord(<span class="string">'A'</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(record)</span>:</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> record[i]: <span class="keyword">continue</span></span><br><span class="line">                record[i] -= <span class="number">1</span></span><br><span class="line">                s += dfs(record) + <span class="number">1</span> </span><br><span class="line">                record[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> dfs(record)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1560-Most-Visited-Sector-in-a-Circular-Track&quot;&gt;&lt;a href=&quot;#1560-Most-Visited-Sector-in-a-Circular-Track&quot; class=&quot;headerlink&quot; title=&quot;1560
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第34周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/23/2020-%E7%AC%AC34%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/23/2020-第34周-LeetCode-记录/</id>
    <published>2020-08-23T16:37:12.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1550-Three-Consecutive-Odds"><a href="#1550-Three-Consecutive-Odds" class="headerlink" title="1550. Three Consecutive Odds"></a>1550. Three Consecutive Odds</h3><p>判断数组是否存在连续 3 个奇数的情况存在，直接遍历判断，使用变量记录当前奇数个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeConsecutiveOdds</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1551-Minimum-Operations-to-Make-Array-Equal"><a href="#1551-Minimum-Operations-to-Make-Array-Equal" class="headerlink" title="1551. Minimum Operations to Make Array Equal"></a>1551. Minimum Operations to Make Array Equal</h3><p>一道数学题，等差数列求和公式变形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=3 最小操作数是 2</span><br><span class="line">n=4 最小操作数是 1 + 3</span><br><span class="line">n=5 最小操作数是 2 + 4</span><br><span class="line">n=6 最小操作数是 1 + 3 + 5</span><br><span class="line">n=7 最小操作数是 2 + 4 + 6</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> n*n // <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a>410. Split Array Largest Sum</h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>求最大值最小一般采用二分法来做，数值最终在 max(nums) &lt; result &lt; sum(nums) 区间中，假设当前数值符合条件，然后检查是否符合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums: List[int], m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(x: int)</span> -&gt; bool:</span></span><br><span class="line">            total, cnt = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> total + num &gt; x:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    total = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    total += num</span><br><span class="line">            <span class="keyword">return</span> cnt &lt;= m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        left = max(nums)</span><br><span class="line">        right = sum(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="1552-Magnetic-Force-Between-Two-Balls"><a href="#1552-Magnetic-Force-Between-Two-Balls" class="headerlink" title="1552. Magnetic Force Between Two Balls"></a>1552. Magnetic Force Between Two Balls</h3><p>与 410 类似，也是求最大化最小值，相同的解法，二分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDistance(self, position: List[int], m: int) -&gt; int:</span><br><span class="line">        position.sort()</span><br><span class="line">        </span><br><span class="line">        def check(x):</span><br><span class="line">            cnt = 1</span><br><span class="line">            t = position[0]</span><br><span class="line">            for i in range(1, len(position)):</span><br><span class="line">                if position[i]-t &gt; x:</span><br><span class="line">                    cnt += 1</span><br><span class="line">                    t = position[i]</span><br><span class="line">            return cnt &gt;= m</span><br><span class="line">        </span><br><span class="line">        l, r = 0, position[-1]</span><br><span class="line">        while l &lt; r:</span><br><span class="line">            mid = l + (r-l)//2</span><br><span class="line">            if check(mid):</span><br><span class="line">                l = mid+1</span><br><span class="line">            else:</span><br><span class="line">                r = mid</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure><h3 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a>406. Queue Reconstruction by Height</h3><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p><blockquote><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序：</span><br><span class="line">按高度降序排列。</span><br><span class="line">在同一高度的人中，按 k 值的升序排列。</span><br><span class="line">逐个地把它们放在输出队列中，索引等于它们的 k 值。</span><br><span class="line">返回输出队列</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            output.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="1249-Minimum-Remove-to-Make-Valid-Parentheses"><a href="#1249-Minimum-Remove-to-Make-Valid-Parentheses" class="headerlink" title="1249. Minimum Remove to Make Valid Parentheses"></a>1249. Minimum Remove to Make Valid Parentheses</h3><p>给你一个字符串，其中字符串包含一些括号，但是括号不是成对出现的，需要你删除其中不平衡的括号使其达到平衡。<br>自己做的时候使用了两个栈来分别记录括号和括号所在的索引，如果出现平衡的括号，那么两个栈同时出栈，最终将保存索引的栈中对应的字母删除，返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx, i <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> [<span class="string">'('</span>, <span class="string">')'</span>]:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                    res.append(idx)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        res.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack.append(i)</span><br><span class="line">                        res.append(idx)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> idx, i <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(tmp)</span><br></pre></td></tr></table></figure><p>虽然也能通过但是复杂度很高，可以直接遍历字符串，使用一个栈记录 <code>(</code> ，如果字符串为 <code>(</code> 那么入栈，如果字符串为 <code>)</code> 并且栈长度不为 0，那么出栈，否则将字符串对应索引字母置为空，此时结果中所有多余的 <code>)</code> 都已经处理完了，接下来处理栈中存在的多余的 <code>(</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        indices, ans = [], list(s)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> indices:</span><br><span class="line">                    indices.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans[i] = <span class="string">''</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'('</span>:</span><br><span class="line">                indices.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> indices:</span><br><span class="line">            ans[i] = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1550-Three-Consecutive-Odds&quot;&gt;&lt;a href=&quot;#1550-Three-Consecutive-Odds&quot; class=&quot;headerlink&quot; title=&quot;1550. Three Consecutive Odds&quot;&gt;&lt;/a&gt;1550
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>ARM 服务器？能用。</title>
    <link href="https://zdyxry.github.io/2020/08/22/ARM-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E8%83%BD%E7%94%A8%E3%80%82/"/>
    <id>https://zdyxry.github.io/2020/08/22/ARM-服务器？能用。/</id>
    <published>2020-08-22T15:09:04.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上一次写 <a href="https://zdyxry.github.io/2019/11/01/ARM-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E8%83%BD%E7%94%A8%EF%BC%9F/">ARM 服务器</a>相关的是在大半年以前了，当时适配工作做得神烦，最近在折腾 ARM 上 KVM 虚拟化相关的事情，目标是虚拟化功能最小代码改动同时兼容 x86 和 ARM，记录一下目前的一点经验总结。</p><p>硬件配置：  </p><ul><li>华为泰山服务器</li><li>Kunpeng 920</li></ul><p>软件配置：  </p><ul><li>CentOS 7.6</li><li>kernel-4.18.0-193.1.2.el7.aarch64</li><li>libvirt-4.5.0</li><li>qemu-2.12.0</li></ul><h2 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h2><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>如果产品之前都是 x86 架构下的，在适配 ARM 时往往需要进行架构判断，此时可以通过 <code>arch</code> 来获取，在 ARM 架构显示 <code>aarch64</code> ，在 x86 架构下显示 <code>x86_64</code> 。</p><p><code>aarch64</code> 等价于 <code>arm64</code>。</p><blockquote><p>AArch64 or ARM64 is the 64-bit extension of the ARM architecture.</p></blockquote><h3 id="KVM-module"><a href="#KVM-module" class="headerlink" title="KVM module"></a>KVM module</h3><p>在 x86 上我们可以直接通过 <code>lsmod |grep kvm</code> 查看到 KVM module 情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:24:30 ~]$lsmod |grep kvm</span><br><span class="line">kvm_intel             188644  82 </span><br><span class="line">kvm                   621480  1 kvm_intel</span><br></pre></td></tr></table></figure><p>但是在 arm 上是没有加载 KVM module 的，此时想要知道 KVM 配置是否正确，可以通过 <code>dmesg</code> 中查看 KVM 相关日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: IPA Size Limit: 48bits</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: GICv4 support disabled</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: vgic-v2@9b020000</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: GIC system register CPU interface enabled</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: vgic interrupt IRQ1</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: VHE mode initialized successfully</span><br></pre></td></tr></table></figure><p>如果看到 <code>VHE mode initialized successfully</code> ，那么 KVM 正常。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>在 CentOS 中通常使用 cpuinfo 来获取 CPU 相关信息，但是发现集群中某个节点无法获取主频相关信息，通过 lscpu 也无法正确显示，开始以为是 <code>util-linux</code> 相关软件的版本不兼容导致，后续排查发现不是这个问题，于是考虑通过其他方式获取主频。</p><p>正常 cpuinfo 输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hz Advertised: 2.6000 GHz</span><br><span class="line">Hz Actual: 2.6000 GHz</span><br><span class="line">Hz Advertised Raw: (2600000000, 0)</span><br><span class="line">Hz Actual Raw: (2600000000, 0)</span><br><span class="line">Arch: ARM_8</span><br></pre></td></tr></table></figure><p>如果作为他信息统计的话我们往往使用的是 <code>Hz Advertised Raw</code> 字段，我们可以通过 <code>dmidecode</code> 获取，<code>dmidecode</code> 输出结果示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:33:47 ~]$dmidecode -t 4 </span><br><span class="line">        ...</span><br><span class="line">        Max Speed: 4000 MHz</span><br><span class="line">        Current Speed: 2600 MHz</span><br><span class="line">        Status: Populated, Enabled</span><br><span class="line">        Upgrade: Socket LGA2011</span><br><span class="line">        L1 Cache Handle: 0x0009</span><br><span class="line">        L2 Cache Handle: 0x000A</span><br><span class="line">        L3 Cache Handle: 0x000B</span><br></pre></td></tr></table></figure><p>这里需要进行区分， <code>dmidecode</code> 获取到的是主板信息，比如 <code>Max Speed</code> 指的是主板支持最大主频，如果我们想获取当前 CPU 标称主频，需要使用 <code>Current Speed</code> 字段数值。</p><h2 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h2><h3 id="Machine-Type"><a href="#Machine-Type" class="headerlink" title="Machine Type"></a>Machine Type</h3><p>在 x86 架构下，支持两种 Machine Type，分别为 q35 和 i440fx(pc)，我们使用的是 i440fx，这两种类型我理解最主要的区别在于 PCI 和 PCIE 的支持，通俗描述就是 <code>兼容性</code> 更好。目前 x86 架构下的 Machine Type 我们使用的是 i440fx(pc)。但是在 ARM 架构下只支持一种 Machine Type，就是 mach-virt(virt) ，而这种架构下的大部分行为与 q35 相同，所以我们在创建虚拟机时所指定的基本参数就需要进行相应的调整。</p><h3 id="Boot-Options"><a href="#Boot-Options" class="headerlink" title="Boot Options"></a>Boot Options</h3><p>ARM 架构下虚拟机不支持 BIOS 引导，只支持 UEFI，在设置 UEFI  bootloader 时，需要使用 aarch64 版本的 edk2(EFI Development Kit II)，虽然 edk2 的 x86 下使用的是 noarch 版本，但是这里的 noarch 是假象，还是需要指定 aarch64 版本才可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node26 19:58:59 ~]$rpm -ql edk2.git-aarch64-0-20200515.1405.g9af1064995.noarch</span><br><span class="line">/usr/share/edk2.git</span><br><span class="line">/usr/share/edk2.git/aarch64</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_EFI.fd</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_VARS.fd</span><br><span class="line">/usr/share/edk2.git/aarch64/vars-template-pflash.raw</span><br><span class="line">/usr/share/qemu/firmware/80-uefi-a64-git.json</span><br></pre></td></tr></table></figure><p>在 libvirt qemu 配置文件中指定 nvram 文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node26 19:59:23 ~]$cat /etc/libvirt/qemu.conf </span><br><span class="line">nvram = [&quot;/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw:/usr/share/edk2.git/aarch64/vars-template-pflash.raw&quot;]</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>虚拟机配置中，一个比较重要的地方是 Controller 配置，在 q35 Machine Type 中：不支持 PCI Controller，仅支持 PCI-E Controller，因此需要特殊注意；同时 USB Controller 支持 XHCI Controller，XHCI 可以同时支持 USB 1.1，2.0，3.0 设备。</p><h4 id="PCI-E-Controller"><a href="#PCI-E-Controller" class="headerlink" title="PCI-E Controller"></a>PCI-E Controller</h4><p>默认的 PCI 拓扑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;controller type=&apos;pci&apos; index=&apos;0&apos; model=&apos;pcie-root&apos;/&gt;</span><br><span class="line">&lt;controller type=&apos;pci&apos; index=&apos;1&apos; model=&apos;pcie-root-port&apos;&gt;</span><br><span class="line">  &lt;model name=&apos;pcie-root-port&apos;/&gt;</span><br><span class="line">  &lt;target chassis=&apos;1&apos; port=&apos;0x10&apos;/&gt;</span><br><span class="line">  &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x01&apos; function=&apos;0x0&apos;/&gt;</span><br><span class="line">&lt;/controller&gt;</span><br></pre></td></tr></table></figure><p><code>pcie-root</code> 不支持设备的热插拔，因此需要将设备添加到 <code>pcie-root-port</code> 上，但是 <code>pcie-root-port</code> 自身也不支持热插拔，所以需要在虚拟机创建时预先分配好一定数量的 <code>pcie-root-port</code> Controller 用于后续其他设备的热插拔。</p><p>文档中提到 q35 支持 <code>pcie-to-pci-bridge</code> 控制器用于连接一些传统的 PCI 设备，但是实际测试中发现没有作用，不知道是不是我的姿势有问题。</p><p>上面提到要在虚拟机创建时预先分配 <code>pcie-root-port</code> Controller，我们需要知道 <code>pcie-root</code> 所支持的 <code>pcie-root-port</code> 数量上限是多少，没有找到相关文档，于是我去看了看 virt-manager 中是否有特殊处理，代码中没找到 <code>pcie-root-port</code> 关键字，在测试的 XML 文件中，发现最多添加了 8 个 <code>pcie-root-port</code> Controller。virt-manager 没找到，那么就去 OpenStack Nova 中找。</p><p>在 nova/virt/libvirt/driver.py 中，看到了添加 <code>pcie-root-port</code> Controller 的相关逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_guest_add_pcie_root_ports</span><span class="params">(self, guest)</span>:</span></span><br><span class="line">    <span class="string">"""Add PCI Express root ports.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    PCI Express machine can have as many PCIe devices as it has</span></span><br><span class="line"><span class="string">    pcie-root-port controllers (slots in virtual motherboard).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we want to have more PCIe slots for hotplug then we need to create</span></span><br><span class="line"><span class="string">    whole PCIe structure (libvirt limitation).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    pcieroot = vconfig.LibvirtConfigGuestPCIeRootController()</span><br><span class="line">    guest.add_device(pcieroot)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, CONF.libvirt.num_pcie_ports):</span><br><span class="line">        pcierootport = vconfig.LibvirtConfigGuestPCIeRootPortController()</span><br><span class="line">        guest.add_device(pcierootport)</span><br></pre></td></tr></table></figure><p>nova 在创建虚拟机时，直接预先分配了所有的 <code>pcie-root-port</code> ，达到了 libvirt 的上限，在 nova 中时一个常量 28，并且给出了 qemu 关于 PCI-E 相关的文档说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    cfg.IntOpt(&apos;num_pcie_ports&apos;,</span><br><span class="line">               default=0,</span><br><span class="line">               min=0,</span><br><span class="line">               max=28,</span><br><span class="line">               help= &quot;&quot;&quot;</span><br><span class="line">The number of PCIe ports an instance will get.</span><br><span class="line"></span><br><span class="line">Libvirt allows a custom number of PCIe ports (pcie-root-port controllers) a</span><br><span class="line">target instance will get. Some will be used by default, rest will be available</span><br><span class="line">for hotplug use.</span><br><span class="line"></span><br><span class="line">By default we have just 1-2 free ports which limits hotplug.</span><br><span class="line"></span><br><span class="line">More info: https://github.com/qemu/qemu/blob/master/docs/pcie.txt</span><br><span class="line"></span><br><span class="line">Due to QEMU limitations for aarch64/virt maximum value is set to &apos;28&apos;.</span><br><span class="line"></span><br><span class="line">Default value &apos;0&apos; moves calculating amount of ports to libvirt.</span><br><span class="line">&quot;&quot;&quot;),</span><br></pre></td></tr></table></figure><p>于是我在创建虚拟机的时候指定了 28个 <code>pcie-root-port</code> Controller，但是发现虚拟机无法成功引导，简单的二分最终确认在当前环境配置下，虚拟机最多支持 15 个 <code>pcie-root-port</code> ，猜测可能根当前使用的版本有关。</p><h4 id="USB-Controller"><a href="#USB-Controller" class="headerlink" title="USB Controller"></a>USB Controller</h4><p>USB Controller model 选择 <code>qemu-xhci</code> ，添加一个即可，涉及到的设备有 mouse, keyboard, tablet ，都需要将 bus 设置未 usb 。</p><p>在 Controller 确认完成后，我们可以得出当前虚拟机支持设备上限：最多可以连接 15 个 Device/Controller，其中 USB Controller 和 Virtio Video 占用 2个 port，剩余 13 个 port，可以最多插入 13 个 Virtio Device ，也可插入 13 个 Controller，1 个 SCSI Controller 可以插入 7 个 SCSI Disk。</p><h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><p>q35 仅支持 <code>virtio</code> 类型的 Video 设备，cirrus, vga, qxl 都不支持。</p><h3 id="CDROM"><a href="#CDROM" class="headerlink" title="CDROM"></a>CDROM</h3><p>不支持 IDE 磁盘，因此需要将 CDROM 的 bus 总线设置为 SCSI。</p><h3 id="CPU-Model"><a href="#CPU-Model" class="headerlink" title="CPU Model"></a>CPU Model</h3><p>通常我们为了虚拟机兼容性考虑，都会将虚拟机的 CPU Model 设置的略微低一些，避免当一个集群中存在节点 CPU 代数不一致时导致虚拟机无法热迁移，通常我们在 x86 下可以通过 <code>virsh domcapabilities</code> 获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;mode name=&apos;custom&apos; supported=&apos;yes&apos;&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;qemu64&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;qemu32&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;phenom&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;IvyBridge&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;IvyBridge-IBRS&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-noTSX&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-noTSX-IBRS&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-IBRS&lt;/model&gt;</span><br><span class="line">&lt;/mode&gt;</span><br></pre></td></tr></table></figure><p>可以通过 <code>usable</code> 属性来判断是否可以配置，但是在 ARM 下所有的 <code>usable</code> 属性都是 unknown，强行设置后，虚拟机无法启动，在当前版本下时无法进行 CPU Model 设置的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mode name=&apos;host-passthrough&apos; supported=&apos;yes&apos;/&gt;</span><br><span class="line">&lt;mode name=&apos;host-model&apos; supported=&apos;no&apos;/&gt;</span><br><span class="line">&lt;mode name=&apos;custom&apos; supported=&apos;yes&apos;&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a53&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a57&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;max&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a15&lt;/model&gt;</span><br><span class="line">&lt;/mode&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一番折腾，终于可以在 ARM 服务器上进行虚拟化功能的使用了，实际使用感受还不错，没啥问题。</p><p>例行吐槽：</p><ul><li>尽量使用华为官方文档中提到的建议版本，否则就有坑</li><li>华为鲲鹏论坛的活跃度不高，而且遇到了问题基本上没啥回复，全得靠自己</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.huaweicloud.com/kunpeng/" target="_blank" rel="noopener">https://www.huaweicloud.com/kunpeng/</a></li><li><a href="https://stackoverflow.com/questions/31851611/differences-between-arm64-and-aarch64" target="_blank" rel="noopener">https://stackoverflow.com/questions/31851611/differences-between-arm64-and-aarch64</a></li><li><a href="https://libvirt.org/pci-hotplug.html#aarch64-virt" target="_blank" rel="noopener">https://libvirt.org/pci-hotplug.html#aarch64-virt</a></li><li><a href="https://sourcegraph.com/github.com/openstack/nova/-/blob/nova/conf/libvirt.py" target="_blank" rel="noopener">https://sourcegraph.com/github.com/openstack/nova/-/blob/nova/conf/libvirt.py</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上一次写 &lt;a href=&quot;https://zdyxry.github.io/2019/11/01/ARM-%E6%9C%8D%E5%8A%
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第33周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/16/2020-第33周-LeetCode-记录/</id>
    <published>2020-08-16T10:27:06.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1544-Make-The-String-Great"><a href="#1544-Make-The-String-Great" class="headerlink" title="1544. Make The String Great"></a>1544. Make The String Great</h3><p>使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeGood</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> ((ord(stack[<span class="number">-1</span>])<span class="number">-32</span>) == ord(i) <span class="keyword">or</span> (ord(stack[<span class="number">-1</span>])+<span class="number">32</span>) == ord(i)):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure><h3 id="1545-Find-Kth-Bit-in-Nth-Binary-String"><a href="#1545-Find-Kth-Bit-in-Nth-Binary-String" class="headerlink" title="1545. Find Kth Bit in Nth Binary String"></a>1545. Find Kth Bit in Nth Binary String</h3><p>找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        l = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">        mid = (l &gt;&gt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == mid:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">elif</span> k &lt; mid:</span><br><span class="line">            <span class="keyword">return</span> self.findKthBit(n - <span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = l + <span class="number">1</span> -k</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span> <span class="keyword">if</span> self.findKthBit(n - <span class="number">1</span>, k) == <span class="string">'0'</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        s = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + <span class="string">'1'</span> + self.reverse(s[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> s[n][k<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                res.append(<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target"><a href="#1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target" class="headerlink" title="1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target"></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</h3><p>这是一道告诉你方法就会立刻做出来的题目，前缀和，因为要求不重叠，因此在遍历过的结果中找到 target，那么就需要将 set 重置，cur_sum 清零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNonOverlapping</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += num</span><br><span class="line">            <span class="keyword">if</span> cur_sum - target <span class="keyword">in</span> s:</span><br><span class="line">                s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">                cur_sum = <span class="number">0</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(cur_sum)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1541-Minimum-Insertions-to-Balance-a-Parentheses-String"><a href="#1541-Minimum-Insertions-to-Balance-a-Parentheses-String" class="headerlink" title="1541. Minimum Insertions to Balance a Parentheses String"></a>1541. Minimum Insertions to Balance a Parentheses String</h3><p>看完题目第一想法是用栈来做，但是写了半天发现题目理解错了，这题跟 #1544 不同的是，它不会因为栈中某个时刻符合平衡括号的条件就全部出栈，比如 <code>&quot;(()))(()))()())))&quot;</code> 这个用例，如果自己计算理解了这个用例这道题也就做出来了。</p><p>使用栈记录当前遍历字符为 <code>(</code> 的情况，如果为 <code>(</code> 那么直接入栈，如果为 <code>)</code> ，那么此时有两种情况：</p><ul><li>如果栈不存在，意味着左边缺少 <code>(</code> ，那么就至少需要补充一个 <code>(</code> ，此时判断当前字符的右侧是否为 <code>)</code> ，如果是，那么只需要添加一个 <code>(</code> ，如果不是 <code>)</code> ，那么就需要添加一个 <code>(</code> 和一个 <code>)</code>；</li><li>如果栈存在，意味着左侧存在 <code>(</code> ，此时判断当前字符右侧是否为 <code>)</code> ，如果是，那么将左侧字符出栈，此时已经满足了平衡括号情况，无须添加，如果不是 <code>)</code> ，那么需要添加一个 <code>)</code> 满足平衡。</li></ul><p>最终判断 stack 是否还存在，如果存在，则每个 <code>(</code> 需要添加两个 <code>)</code> 满足条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># use stack</span></span><br><span class="line">        stack = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># when facing empty stack</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">if</span> i+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        count += <span class="number">1</span>  <span class="comment"># add one "("</span></span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">2</span>   <span class="comment"># add one "("  and one ")"</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># check two positions</span></span><br><span class="line">                    <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">1</span>   <span class="comment"># add one ")"</span></span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        rest = len(stack)*<span class="number">2</span>  <span class="comment"># still have "(" on the stack. one "(" pairs with two ")"</span></span><br><span class="line">        <span class="keyword">return</span> count + rest</span><br></pre></td></tr></table></figure><h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h3><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/solution/da-lao-de-dai-ma-kan-ming-bai-hou-ji-ge-bi-ji-yong/" target="_blank" rel="noopener">leetcode-cn</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:                            </span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy=ListNode(float(-inf))             <span class="comment">#首项负无穷保证插的数据不在最前头</span></span><br><span class="line">        dummy.next=head                         <span class="comment">#用于返回答案</span></span><br><span class="line">        pre=head                                    </span><br><span class="line">        nxt=head.next</span><br><span class="line">        <span class="keyword">while</span> nxt:                              <span class="comment">#最后一项为None结束循环</span></span><br><span class="line">            <span class="keyword">if</span> nxt.val&gt;pre.val:                 <span class="comment">#从头开始，如果后一项大于前一项不改变节点</span></span><br><span class="line">               pre=nxt                          <span class="comment">#这两行移动指针（往后挪一格）</span></span><br><span class="line">               nxt=nxt.next</span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment">#如果后项小需要把后项nxt的节点插到正确位置</span></span><br><span class="line">                pre.next=nxt.next               <span class="comment">#把nxt指向的节点拿出来</span></span><br><span class="line">                cp1=dummy                       <span class="comment">#这两个指针负责从头开始比较nxt的位置</span></span><br><span class="line">                cp2=dummy.next                  <span class="comment">#使用dummy的原因见11行注释</span></span><br><span class="line">                <span class="keyword">while</span> nxt.val&gt;cp2.val:          <span class="comment">#因为前面是排好序的循环结束nxt正好在cp1和cp2中间</span></span><br><span class="line">                    cp1=cp2                     <span class="comment">#</span></span><br><span class="line">                    cp2=cp2.next                <span class="comment">#</span></span><br><span class="line">                nxt.next=cp2                    <span class="comment">#这两行负责插</span></span><br><span class="line">                cp1.next=nxt                    <span class="comment">#把nxt指向的节点查到cp1和cp2中间</span></span><br><span class="line">                nxt=pre.next                    <span class="comment">#指针从哪来回哪去 准备下一个循环</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1544-Make-The-String-Great&quot;&gt;&lt;a href=&quot;#1544-Make-The-String-Great&quot; class=&quot;headerlink&quot; title=&quot;1544. Make The String Great&quot;&gt;&lt;/a&gt;1544. M
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第32周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/08/2020-%E7%AC%AC32%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/08/2020-第32周-LeetCode-记录/</id>
    <published>2020-08-08T16:17:20.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1534-Count-Good-Triplets"><a href="#1534-Count-Good-Triplets" class="headerlink" title="1534. Count Good Triplets"></a>1534. Count Good Triplets</h3><p>数据规模很小，暴力循环解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countGoodTriplets</span><span class="params">(self, arr: List[int], a: int, b: int, c: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(arr)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, len(arr)):</span><br><span class="line">                    <span class="keyword">if</span> abs(arr[i] - arr[j]) &lt;= a <span class="keyword">and</span> abs(arr[j] - arr[k]) &lt;= b <span class="keyword">and</span> abs(arr[i] - arr[k]) &lt;= c:</span><br><span class="line">                        ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1535-Find-the-Winner-of-an-Array-Game"><a href="#1535-Find-the-Winner-of-an-Array-Game" class="headerlink" title="1535. Find the Winner of an Array Game"></a>1535. Find the Winner of an Array Game</h3><p>每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。</p><p>假设第一个数字为所求数字，从下一个数字开始遍历，如果当前数字比所求数字大，那么更新所求数字为当前数字并重置胜利变量为1，否则 += 1，如果胜利次数等于 k，那么直接返回当前最大的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWinner</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        a,n=arr[<span class="number">0</span>],<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i&gt;a:</span><br><span class="line">                a,n=i,<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> n==k:</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h3 id="1536-Minimum-Swaps-to-Arrange-a-Binary-Grid"><a href="#1536-Minimum-Swaps-to-Arrange-a-Binary-Grid" class="headerlink" title="1536. Minimum Swaps to Arrange a Binary Grid"></a>1536. Minimum Swaps to Arrange a Binary Grid</h3><p>最终需要将二维数组变为 grid[i] 的 grid[i][i+1:] 均为0，遍历 grid，找到满足当前 grid[i][i+1:] 需求，如果找到了，那么就需要一次次的交换，因为每次只能交换相邻两行，所以交换的次数等于 j -i 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwaps</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        need = <span class="number">0</span></span><br><span class="line">        l = len(grid)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, l):</span><br><span class="line">                <span class="keyword">if</span> sum(grid[j][i+<span class="number">1</span>:]) == <span class="number">0</span>:</span><br><span class="line">                    need += j-i</span><br><span class="line">                    grid[i:j+<span class="number">1</span>] = grid[j:j+<span class="number">1</span>]+grid[i:j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> need</span><br></pre></td></tr></table></figure><h3 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h3><p>每 k 组链表进行反转，使用递归做比较清晰易懂，<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/k-ge-yi-zu-fan-zhuan-lian-biao-by-leetcode-solutio/" target="_blank" rel="noopener">官方题解</a>感觉需要自己实际画画方便理解。</p><p>这道题的基础就是反转链表，通常的反转链表的操作是定义一个 pre，然后遍历整个链表，进行链表连接的断开以及反转，这里需要判断每 k 次，如果不足 k，那么直接返回当前的 head ，如果大于 k，那么就开始反转 k 个链表，注意需要记录反转前的 head，因为进行 k 次反转后，head 就是当前链表的尾端，然后递归反转后续链表，并赋值 head.next 保证链表的连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr: <span class="keyword">return</span> head</span><br><span class="line">            curr = curr.next</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reverse the group (basic way to reverse linked list)</span></span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            nxt = curr.next</span><br><span class="line">            curr.next = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = nxt</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># After reverse, we know that `head` is the tail of the group.</span></span><br><span class="line"><span class="comment"># And `curr` is the next pointer in original linked list order</span></span><br><span class="line">        head.next = self.reverseKGroup(curr, k)</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h3 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h3><p>合并 k 个链表，题目没有要求原地合并，直接遍历记录所有链表的数值，然后进行排序，最后再重新定义链表连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists <span class="keyword">or</span> len(lists) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        all_vals = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l:</span><br><span class="line">                all_vals.append(l.val)</span><br><span class="line">                l = l.next</span><br><span class="line">        all_vals.sort()</span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> all_vals:</span><br><span class="line">            temp_node = ListNode(i)</span><br><span class="line">            cur.next = temp_node</span><br><span class="line">            cur = temp_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1534-Count-Good-Triplets&quot;&gt;&lt;a href=&quot;#1534-Count-Good-Triplets&quot; class=&quot;headerlink&quot; title=&quot;1534. Count Good Triplets&quot;&gt;&lt;/a&gt;1534. Count G
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>通过 grub 修复系统无法正确引导问题</title>
    <link href="https://zdyxry.github.io/2020/08/02/%E9%80%9A%E8%BF%87-grub-%E4%BF%AE%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%BC%95%E5%AF%BC%E9%97%AE%E9%A2%98/"/>
    <id>https://zdyxry.github.io/2020/08/02/通过-grub-修复系统无法正确引导问题/</id>
    <published>2020-08-02T09:10:39.000Z</published>
    <updated>2020-08-29T10:43:27.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在将一个节点的 kernel 从 4.18 版本降级到 4.14 后，发现系统无法启动，直接进入到了 GRUB 提示符界面，记录下修复过程。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>因为 kernel 4.18 版本和 4.14 的 打包方式发生了比较大的变化，4.18 版本多出了 kernel-core 和 kernel-modules 两个 rpm：</p><blockquote><p>4.14</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@sh-workstation Packages]# ls |grep ^kernel</span><br><span class="line">kernel-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-headers-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-tools-4.14.0-115.el7a.0.1.aarch64.rpm</span><br><span class="line">kernel-tools-libs-4.14.0-115.el7a.0.1.aarch64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>4.18</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-core-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-modules-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-tools-4.18.0-147.8.1.el7.aarch64.rpm</span><br><span class="line">kernel-tools-libs-4.18.0-147.8.1.el7.aarch64.rpm</span><br></pre></td></tr></table></figure><p>在没有官方 yum repo 的情况下，降级就比较麻烦，我直接尝试 <code>rpm -Uvh kernel-4.14*.rpm</code> ，然后将 4.18 的 kernel-core 和 kernel-modules 卸载掉，然后重启后，发现系统直接进入到了 GRUB 提示符界面，无法正常启动，只能寻求修复办法。</p><h2 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h2><p>当时系统启动后，显示的是 <code>grub&gt;</code> 提示符，说明此时已经加载了 grub 程序，但是没有找到 grub.cfg 配置文件中的指定kernel 和 initramfs。</p><p>此时有两种修复思路：一种是在现有环境基础上，手动指定 grub 参数，先启动进入系统，然后再修复 grub 配置；一种是关机，在服务器上挂载一个 LiveCD OS，进入到 LiveCD 中，chroot 进行修复。</p><p>因为当时没有 LiveCD，所以选择第一种方式修复。</p><p>此时排查思路如下：</p><ol><li>需要找到 <code>/boot/</code> 分区所在磁盘，可以通过 <code>ls</code> 命令显示此时所有的磁盘分区情况，可以通过 <code>ls (hd0,msdos1)/</code> 方式查看磁盘分区下的文件，如果是 <code>/boot/</code> 分区，会看到 vmlinuz 和 initramfs 文件</li><li>根据 <code>/boot</code> 分区文件系统类型，执行 <code>insmod</code> 命令加载对应的 module，比如 <code>insmod xfs</code></li><li>找到 <code>/boot/</code> 分区所在磁盘后，设置 <code>root</code> 变量，<code>root</code> 变量是指定的我们当前交互的根分区，指定我们找到的磁盘分区，<code>set root=(hd0,msdos1)</code> </li><li>加载 linux kernel，并指定系统根分区 <code>root</code>，这个 <code>root</code> 变量并不是我们在上一步所指定的，而是作为加载 kernel 的参数传递的，如果使用 lvm 配置，那么默认是 <code>/dev/mapper/centos-root</code> ，最终命令如 <code>linux /vmlinuz-4.14.0-115.el7a.0.1.aarch64 root=/dev/mapper/centos-root</code> </li><li>加载 initramfs，如 <code>initrd initramfs-4.14.0-115.el7a.0.1.aarch64.img</code> </li><li>此时所有引导的必要参数已经设置完成，输入 <code>boot</code> 命令即可正确引导</li><li>系统引导后，检查 grub.cfg 配置，执行 <code>grub2-mkconfig -o</code> 重新生成 grub 配置。</li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>在 kernel 升级的动作中，grub 会被自动更新，但是如果通过非常规方式进行 kernel 降级，就需要注意 grub 配置了，修复 grub 不是什么好的体验，慎重。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.gnu.org/software/grub/manual/grub/grub.html" target="_blank" rel="noopener">https://www.gnu.org/software/grub/manual/grub/grub.html</a></li><li><a href="https://help.ubuntu.com/community/Grub2/Troubleshooting" target="_blank" rel="noopener">https://help.ubuntu.com/community/Grub2/Troubleshooting</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在将一个节点的 kernel 从 4.18 版本降级到 4.14 后，发现系统无法启动，直接进入到了 GRUB 提示符界面，记录下修复过
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第31周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/01/2020-%E7%AC%AC31%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/01/2020-第31周-LeetCode-记录/</id>
    <published>2020-08-01T07:26:24.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1523-Count-Odd-Numbers-in-an-Interval-Range"><a href="#1523-Count-Odd-Numbers-in-an-Interval-Range" class="headerlink" title="1523. Count Odd Numbers in an Interval Range"></a>1523. Count Odd Numbers in an Interval Range</h3><p>数学题，数据范围是10^9，O(n) 会超时，统计 high 中有多少个奇数，减去 low-1 中的奇数个数，需要考虑边界条件：low/high 自身为奇数情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countOdds</span><span class="params">(self, low: int, high: int)</span> -&gt; int:</span></span><br><span class="line">        res = high // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> high % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> low - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            res -= (low - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (low - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1528-Shuffle-String"><a href="#1528-Shuffle-String" class="headerlink" title="1528. Shuffle String"></a>1528. Shuffle String</h3><p>按照指定顺序调整字符串，直接定义一个新的长度为 len(s)字符串，然后按照 indices 的索引顺序进行对应调整。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreString</span><span class="params">(self, s: str, indices: List[int])</span> -&gt; str:</span></span><br><span class="line">        _s = [<span class="string">'0'</span>] * len(s)</span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            _s[indices[idx]] = val</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(_s)</span><br></pre></td></tr></table></figure><h3 id="1524-Number-of-Sub-arrays-With-Odd-Sum"><a href="#1524-Number-of-Sub-arrays-With-Odd-Sum" class="headerlink" title="1524. Number of Sub-arrays With Odd Sum"></a>1524. Number of Sub-arrays With Odd Sum</h3><blockquote><p><a href="https://www.youtube.com/watch?v=vGTm8rjlDTQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=vGTm8rjlDTQ</a></p></blockquote><p>用两个变量分别记录奇数和偶数的个数，遍历数组，如果当前数字是奇数，那么 odd 等于偶数个数 +1，1为当前数字，even 等于奇数个数，因为奇数个数加上当前数字（奇数）为偶数；如果当前数字是偶数，那么 odd 等于 odd，偶数个数等于 even + 1，1为当前数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numOfSubarrays</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    odd, even := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">if</span> v % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            odd, even = even + <span class="number">1</span>, odd</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            odd, even = odd, even + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        res += odd</span><br><span class="line">        res %= mod</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1525-Number-of-Good-Ways-to-Split-a-String"><a href="#1525-Number-of-Good-Ways-to-Split-a-String" class="headerlink" title="1525. Number of Good Ways to Split a String"></a>1525. Number of Good Ways to Split a String</h3><p>使用 Counter 统计当前字符串中的字符出现的次数，left 表示切割索引左侧字符出现的次数，right 表示切割索引右侧字符出现的次数，遍历字符，如果 right[x] == 0，那么表示右侧已经没有字符 x，那么需要将对应的 key(x) 从 right 中删除，比较 left 中的 key 数量与 right 中是否相同，如果相同，则记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSplits</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        left = Counter()</span><br><span class="line">        right = Counter(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            left[s[i]] += <span class="number">1</span></span><br><span class="line">            right[s[i]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right[s[i]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> right[s[i]]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> len(left) == len(right):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1529-Bulb-Switcher-IV"><a href="#1529-Bulb-Switcher-IV" class="headerlink" title="1529. Bulb Switcher IV"></a>1529. Bulb Switcher IV</h3><p>统计需要翻转开关的次数，就是统计最终状态中 0，1 切换的次数，比如<code>001011101</code> ，0，1 切换分别在 <code>001</code> , <code>10</code>, <code>0111</code>, <code>1110</code>, <code>01</code> 这五个位置出现了切换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minFlips</span><span class="params">(target <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">target = <span class="string">"0"</span> + target</span><br><span class="line">flag := target[<span class="built_in">len</span>(target)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(target) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> target[i] != flag &#123;</span><br><span class="line">count++</span><br><span class="line">flag = target[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1523-Count-Odd-Numbers-in-an-Interval-Range&quot;&gt;&lt;a href=&quot;#1523-Count-Odd-Numbers-in-an-Interval-Range&quot; class=&quot;headerlink&quot; title=&quot;1523. 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第30周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/26/2020-%E7%AC%AC30%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/26/2020-第30周-LeetCode-记录/</id>
    <published>2020-07-26T09:36:03.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1518-Water-Bottles"><a href="#1518-Water-Bottles" class="headerlink" title="1518. Water Bottles"></a>1518. Water Bottles</h3><p>小学数学题，用几个空瓶子可以换一瓶新的，问最后能喝到几瓶，在小学场景下可以先借再喝，在这道题没有这种场景，所以正常计算就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWaterBottles</span><span class="params">(self, numBottles: int, numExchange: int)</span> -&gt; int:</span></span><br><span class="line">        res = numBottles</span><br><span class="line">        <span class="keyword">while</span> numBottles &gt;= numExchange:</span><br><span class="line">            cnt = numBottles // numExchange</span><br><span class="line">            res += cnt</span><br><span class="line">            numBottles = numBottles - (cnt * numExchange)</span><br><span class="line">            numBottles += cnt</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108. Defanging an IP Address"></a>1108. Defanging an IP Address</h3><p>将 IPv4 地址 “1.1.1.1” 转换为 “1[.]1[.]1[.]1” ，不知道这道题的意义在哪里。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">defangIPaddr</span><span class="params">(self, address: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">'.'</span>, <span class="string">'[.]'</span>)</span><br></pre></td></tr></table></figure><h3 id="1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label"><a href="#1519-Number-of-Nodes-in-the-Sub-Tree-With-the-Same-Label" class="headerlink" title="1519. Number of Nodes in the Sub-Tree With the Same Label"></a>1519. Number of Nodes in the Sub-Tree With the Same Label</h3><p>题目很绕，最好自己根据给的 edges 和 labels 构建出对应的树，了解是如何构建的，最终要求的 ans 中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数，记录所有节点的相邻节点，从 0 节点开始 dfs，如果节点已经访问过，则跳过对应节点，最终汇总 ans[i] 中的数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span><span class="params">(self, n: int, edges: List[List[int]], labels: str)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">        edge_map = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            edge_map[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            edge_map[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            visited.add(i)</span><br><span class="line">            <span class="comment"># 字符数字典</span></span><br><span class="line">            data = Counter(&#123;labels[i]: <span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> edge_map[i]:</span><br><span class="line">                <span class="keyword">if</span> nxt <span class="keyword">in</span> visited: <span class="keyword">continue</span> <span class="comment"># 去重</span></span><br><span class="line">                <span class="comment"># 整合子树的字符数</span></span><br><span class="line">                data += _dfs(nxt)</span><br><span class="line">            <span class="comment"># 设置当前节点的结果字符数</span></span><br><span class="line">            ans[i] = data[labels[i]]</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        ans = [<span class="number">1</span>] * n</span><br><span class="line">        _dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1189-Maximum-Number-of-Balloons"><a href="#1189-Maximum-Number-of-Balloons" class="headerlink" title="1189. Maximum Number of Balloons"></a>1189. Maximum Number of Balloons</h3><p>给一个字符串 text，使用 text 中的字母来拼凑尽可能多的单词 “balloon”，每个字母最多只能被使用一次。返回最多可以拼凑出多少个单词 “balloon”，分别统计每个字母出现的次数，然后判断满足ballon 所有字母出现次数最小的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumberOfBalloons</span><span class="params">(self, text: str)</span> -&gt; int:</span></span><br><span class="line">        d = collections.Counter(text)</span><br><span class="line">        <span class="keyword">return</span> min(d[<span class="string">'b'</span>], d[<span class="string">'a'</span>], d[<span class="string">'l'</span>] // <span class="number">2</span>, d[<span class="string">'o'</span>] // <span class="number">2</span>, d[<span class="string">'n'</span>])</span><br></pre></td></tr></table></figure><h3 id="1304-Find-N-Unique-Integers-Sum-up-to-Zero"><a href="#1304-Find-N-Unique-Integers-Sum-up-to-Zero" class="headerlink" title="1304. Find N Unique Integers Sum up to Zero"></a>1304. Find N Unique Integers Sum up to Zero</h3><p>给一个整数 n，返回任意一个由 n 个 各不相同的整数组成的数组，并且这 n 个数相加和为 0 ，题目很开放，如果n 为奇数，则补充一个数字 <code>0</code>，如果为 偶数，那么补充对应的 n/2 个数字的正负值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumZero</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            res.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            res.append(i)</span><br><span class="line">            res.append(-i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1518-Water-Bottles&quot;&gt;&lt;a href=&quot;#1518-Water-Bottles&quot; class=&quot;headerlink&quot; title=&quot;1518. Water Bottles&quot;&gt;&lt;/a&gt;1518. Water Bottles&lt;/h3&gt;&lt;p&gt;小学数学
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第29周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/19/2020-%E7%AC%AC29%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/19/2020-第29周-LeetCode-记录/</id>
    <published>2020-07-19T11:19:38.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves"><a href="#1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves" class="headerlink" title="1509. Minimum Difference Between Largest and Smallest Value in Three Moves"></a>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</h3><p>要返回最大值与最小值之间的差最小，那么先对其进行排序，三次操作相当于删除三个数字，依次判断删除三个数字之后剩余的数字最大值最小值差最小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDifference</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> min(b - a <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(nums[:<span class="number">4</span>], nums[<span class="number">-4</span>:]))</span><br></pre></td></tr></table></figure><h3 id="1512-Number-of-Good-Pairs"><a href="#1512-Number-of-Good-Pairs" class="headerlink" title="1512. Number of Good Pairs"></a>1512. Number of Good Pairs</h3><p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 ，返回好数对的数目。<br>只要一个数字出现次数多余一次，那么这个数就可以凑成好数对，然后进行组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIdenticalPairs</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(k * (k - <span class="number">1</span>) / <span class="number">2</span> <span class="keyword">for</span> k <span class="keyword">in</span> collections.Counter(A).values())</span><br></pre></td></tr></table></figure><h3 id="1513-Number-of-Substrings-With-Only-1s"><a href="#1513-Number-of-Substrings-With-Only-1s" class="headerlink" title="1513. Number of Substrings With Only 1s"></a>1513. Number of Substrings With Only 1s</h3><p>判断连续 1 的个数，每当遇到 1 时计数 +1， 遇到 0 时对现有计数进行求和公式，并加到最终结果中，重置计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += cnt * (cnt +<span class="number">1</span>) /<span class="number">2</span></span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">            res += cnt * (cnt + <span class="number">1</span>)/ <span class="number">2</span></span><br><span class="line">        res %= <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure><h3 id="1114-Print-in-Order"><a href="#1114-Print-in-Order" class="headerlink" title="1114. Print in Order"></a>1114. Print in Order</h3><p>将各个线程按照顺序执行，有很多实现方式，挑一种方式实现就可以了，这里直接使用 <code>threading.Event</code> 。</p><p><code>threading.Event</code> 定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b1 = threading.Event()</span><br><span class="line">        self.b2 = threading.Event()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.b1.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b1.wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.b2.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.b2.wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure><h3 id="1209-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#1209-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="1209. Remove All Adjacent Duplicates in String II"></a>1209. Remove All Adjacent Duplicates in String II</h3><p>这题描述有点别扭，给一个字符串，如果字符串中包含 k 个相邻且相等的字母，那么就原地删除，然后继续检测是否满足条件，重复执行操作。使用栈来记录最终结果，遍历字符串，如果当前自负和栈顶相同，且长度等于 k，那么就出栈，最终将栈中记录拼接为字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">if</span> len(stack) == <span class="number">0</span> <span class="keyword">or</span> stack[<span class="number">-1</span>][<span class="number">0</span>] != i:</span><br><span class="line">                stack.append([i, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack[<span class="number">-1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> stack[<span class="number">-1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">        ret = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> stack:</span><br><span class="line">            ret += t[<span class="number">0</span>] * t[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1509-Minimum-Difference-Between-Largest-and-Smallest-Value-in-Three-Moves&quot;&gt;&lt;a href=&quot;#1509-Minimum-Difference-Between-Largest-and-Sma
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第28周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/11/2020-%E7%AC%AC28%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/11/2020-第28周-LeetCode-记录/</id>
    <published>2020-07-11T21:50:54.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1502-Can-Make-Arithmetic-Progression-From-Sequence"><a href="#1502-Can-Make-Arithmetic-Progression-From-Sequence" class="headerlink" title="1502. Can Make Arithmetic Progression From Sequence"></a>1502. Can Make Arithmetic Progression From Sequence</h3><p>判断是否可以组成等差数列，将数组排序后，比较两两数字差是否一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        arr.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        diff = arr[<span class="number">0</span>] - arr[<span class="number">1</span>]</span><br><span class="line">        pre = arr[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> pre - i != diff:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            pre = i</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank"><a href="#1503-Last-Moment-Before-All-Ants-Fall-Out-of-a-Plank" class="headerlink" title="1503. Last Moment Before All Ants Fall Out of a Plank"></a>1503. Last Moment Before All Ants Fall Out of a Plank</h3><p>标签是“脑筋急转弯”，蚂蚁只要在一个点碰到，那么就会调换方向，但是蚂蚁始终是蚂蚁，因此可以忽略掉这个条件，直接找到最大值就可以了。</p><p>再次怀疑自己智商。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLastMoment</span><span class="params">(self, n: int, left: List[int], right: List[int])</span> -&gt; int:</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            time = max(time, max(left))</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            time = max(time, n - min(right))</span><br><span class="line">        <span class="keyword">return</span> time</span><br></pre></td></tr></table></figure><h3 id="939-Minimum-Area-Rectangle"><a href="#939-Minimum-Area-Rectangle" class="headerlink" title="939. Minimum Area Rectangle"></a>939. Minimum Area Rectangle</h3><p>一般会选择完整本周周赛题目，然后去做其他的题，但是 1504 做不出，就找了到也是矩形相关的补一补 - - 。</p><p>找出最小矩形面积，需要先找到组成矩形的四个点，遍历所有点，将其记录下来，并遍历已记录的点，此时拿到了两个点，直接暴力判断这两个点的对称点是否存在，如果存在，则计算面积并更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAreaRect</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        mem = set()</span><br><span class="line">        <span class="keyword">for</span> x1,y1 <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">for</span> x2,y2 <span class="keyword">in</span> mem:</span><br><span class="line">                <span class="keyword">if</span> (x2,y1) <span class="keyword">in</span> mem <span class="keyword">and</span> (x1,y2) <span class="keyword">in</span> mem:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> area:</span><br><span class="line">                        area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> abs(x2-x1)*abs(y2-y1) &lt; area:</span><br><span class="line">                            area = abs(x2-x1)*abs(y2-y1)</span><br><span class="line">            mem.add((x1,y1))</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure><h3 id="1160-Find-Words-That-Can-Be-Formed-by-Characters"><a href="#1160-Find-Words-That-Can-Be-Formed-by-Characters" class="headerlink" title="1160. Find Words That Can Be Formed by Characters"></a>1160. Find Words That Can Be Formed by Characters</h3><p>使用 Counter 统计词汇表中的字母，遍历单词，如果单词中的每个字母数量小于词汇表中的字母数量，那么满足条件，否则跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCharacters</span><span class="params">(self, words: List[str], chars: str)</span> -&gt; int:</span></span><br><span class="line">        chars_cnt = collections.Counter(chars)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_cnt = collections.Counter(word)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word_cnt:</span><br><span class="line">                <span class="keyword">if</span> chars_cnt[c] &lt; word_cnt[c]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += len(word)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a>1048. Longest String Chain</h3><p>先对所有单词进行排序，使用哈希表记录当前单词所能组成的最长字符串链的长度。当遍历到某个单词是，通过字符串切片，判断其所有可能的情况，如果记录中存在，那么与当前最大值进行比较更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        words.sort(key=len)</span><br><span class="line">        note=&#123;&#125;</span><br><span class="line">        maxChain=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> note:</span><br><span class="line">                note[word]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(word)):</span><br><span class="line">                newWord=word[:i]+word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> (newWord) <span class="keyword">in</span> note:</span><br><span class="line">                    note[word]=max(note[word],note[newWord]+<span class="number">1</span>)</span><br><span class="line">            maxChain=max(maxChain,note[word])</span><br><span class="line">        <span class="keyword">return</span> maxChain</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1502-Can-Make-Arithmetic-Progression-From-Sequence&quot;&gt;&lt;a href=&quot;#1502-Can-Make-Arithmetic-Progression-From-Sequence&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第27周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/07/04/2020-%E7%AC%AC27%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/07/04/2020-第27周-LeetCode-记录/</id>
    <published>2020-07-04T09:17:15.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1492-The-kth-Factor-of-n"><a href="#1492-The-kth-Factor-of-n" class="headerlink" title="1492. The kth Factor of n"></a>1492. The kth Factor of n</h3><p>计算 n 的第 k 个因子，i 从 1 开始递增，如果 i 可以被 n 整除，则 k–，当 k == 0 时， i为所求值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthFactor</span><span class="params">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1493-Longest-Subarray-of-1’s-After-Deleting-One-Element"><a href="#1493-Longest-Subarray-of-1’s-After-Deleting-One-Element" class="headerlink" title="1493. Longest Subarray of 1’s After Deleting One Element"></a>1493. Longest Subarray of 1’s After Deleting One Element</h3><p>用 cnt1 记录删除一个元素之后当前最长全为 1 的数组长度，用 cnt2 记录当前最长全为 1 的数组长度。</p><p>遍历数组，当 num == 1 时，则 cnt1++, cnt2++，当 num != 1 时，cnt1 = cnt2，并将 cnt2 置 0。每次更新 cnt1 时，比较最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        cnt1, cnt2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line">                maxlen = max(maxlen, cnt1)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt1 = cnt2</span><br><span class="line">                cnt2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 == len(nums):</span><br><span class="line">            <span class="keyword">return</span> len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure><h3 id="1496-Path-Crossing"><a href="#1496-Path-Crossing" class="headerlink" title="1496. Path Crossing"></a>1496. Path Crossing</h3><p>起始点为 (0,0)，然后遍历 path，当为南北时，分别对 y 进行 +1，-1， 当为东西时，分别对 x 进行 +1，-1，每次走过一个路径，就判断当前所在节点是否已经在记录中，如果在直接返回 True，否则将其添加到记录中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPathCrossing</span><span class="params">(self, path: str)</span> -&gt; bool:</span></span><br><span class="line">        x = y = <span class="number">0</span></span><br><span class="line">        set = &#123;(<span class="number">0</span>, <span class="number">0</span>)&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'N'</span>:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'S'</span>:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'E'</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">in</span> set:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            set.add((x, y))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1497-Check-If-Array-Pairs-Are-Divisible-by-k"><a href="#1497-Check-If-Array-Pairs-Are-Divisible-by-k" class="headerlink" title="1497. Check If Array Pairs Are Divisible by k"></a>1497. Check If Array Pairs Are Divisible by k</h3><p>使用哈希表，分别将所有 arr 中的数字对 k 取余，然后遍历余数，如果余数不为0，且 k - 余数 在哈希表中并且 两个key 数值相同，则这两个数字所组成的数字对之和是可以被 k 整除的。如果余数为0，那么判断余数为0 的个数是否为偶数，如果为偶数，那么返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canArrange</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        mod = collections.Counter(num % k <span class="keyword">for</span> num <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="keyword">for</span> t, occ <span class="keyword">in</span> mod.items():</span><br><span class="line">            <span class="keyword">if</span> t &gt; <span class="number">0</span> <span class="keyword">and</span> (k - t <span class="keyword">not</span> <span class="keyword">in</span> mod <span class="keyword">or</span> mod[k - t] != occ):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> mod[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition"><a href="#1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition" class="headerlink" title="1498. Number of Subsequences That Satisfy the Given Sum Condition"></a>1498. Number of Subsequences That Satisfy the Given Sum Condition</h3><p>因为是非空子序列，因此不要求连续，只要满足条件的任意组合即可。</p><p>对数组进行排序，然后使用双指针，如果 nums[l] + nums[r] &gt; target，此时不符合条件，那么将 r–，如果符合，那么在结果中 l 到 r 这个距离中所有的组合都是满足条件的，2 ^ (r-l)，l++，结果相加后取模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubseq</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] &gt; target:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += pow(<span class="number">2</span>, r - l, mod)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res % mod</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1492-The-kth-Factor-of-n&quot;&gt;&lt;a href=&quot;#1492-The-kth-Factor-of-n&quot; class=&quot;headerlink&quot; title=&quot;1492. The kth Factor of n&quot;&gt;&lt;/a&gt;1492. The kth
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第26周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/28/2020-%E7%AC%AC26%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/28/2020-第26周-LeetCode-记录/</id>
    <published>2020-06-28T21:57:10.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1486-XOR-Operation-in-an-Array"><a href="#1486-XOR-Operation-in-an-Array" class="headerlink" title="1486. XOR Operation in an Array"></a>1486. XOR Operation in an Array</h3><p>遍历进行异或操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorOperation</span><span class="params">(self, n: int, start: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans ^= start + <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1487-Making-File-Names-Unique"><a href="#1487-Making-File-Names-Unique" class="headerlink" title="1487. Making File Names Unique"></a>1487. Making File Names Unique</h3><p>一道实际环境中会遇到的场景，使用哈希表记录已有的文件名，如果该文件已经存在在哈希表中，那么循环判断文件名 + <code>()</code> 数字是否也在哈希表中，如果还在，那么数字 + 1，直到数字不在。然后将结果记录到返回列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFolderNames</span><span class="params">(self, names: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        nameMap = &#123;&#125; <span class="comment"># baseName : largest k suffix</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> nameMap:</span><br><span class="line">                <span class="comment"># find k</span></span><br><span class="line">                k = nameMap[n] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> ( n + <span class="string">"("</span> + str(k) + <span class="string">")"</span> ) <span class="keyword">in</span> nameMap:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                nameMap[n] = k</span><br><span class="line">                n = n + <span class="string">"("</span> + str(k) + <span class="string">")"</span> <span class="comment"># with suffix is now considered a base name</span></span><br><span class="line">                </span><br><span class="line">            nameMap[n] = <span class="number">0</span> <span class="comment"># first time seeing this base name</span></span><br><span class="line">            res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a>701. Insert into a Binary Search Tree</h3><p>在二叉树中插入节点，如果 val &gt; node.val，插入到右子树，如果 val &lt; node.val，插入到左子树，最终返回 root 节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="comment"># insert into the right subtree</span></span><br><span class="line">            <span class="keyword">if</span> val &gt; node.val:</span><br><span class="line">                <span class="comment"># insert right now</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    node.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> root</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.right</span><br><span class="line">            <span class="comment"># insert into the left subtree</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># insert right now</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                    node.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> root</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.left</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br></pre></td></tr></table></figure><h3 id="1488-Avoid-Flood-in-The-City"><a href="#1488-Avoid-Flood-in-The-City" class="headerlink" title="1488. Avoid Flood in The City"></a>1488. Avoid Flood in The City</h3><p>遇到不下雨的时候先不去判断应该将哪个湖水抽干，而是等到某个湖下雨两次，再去从不下雨的天气里在湖两次下雨之间抽取第一个来抽干这个湖，防止洪水泛滥，如果找不到，则发生洪水。</p><blockquote><p><a href="https://www.youtube.com/watch?v=8sxeQyumrYc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8sxeQyumrYc</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avoidFlood</span><span class="params">(self, rains: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">1</span>] * len(rains)</span><br><span class="line">        left = []</span><br><span class="line">        record = dict()</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(rains):</span><br><span class="line">            <span class="keyword">if</span> val &gt; <span class="number">0</span>:</span><br><span class="line">                ans[i] = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">in</span> record:</span><br><span class="line">                    pos = bisect_left(left, record[val])</span><br><span class="line">                    <span class="keyword">if</span> pos &gt;= len(left):</span><br><span class="line">                        <span class="keyword">return</span> []</span><br><span class="line">                    ans[left.pop(pos)] = val</span><br><span class="line">                record[val] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a>1047. Remove All Adjacent Duplicates In String</h3><p>遍历字符串，使用列表作为栈记录结果，如果当前栈大于0 且当前字母与栈顶相同，则出栈，否则将其加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> len(res) &gt;= <span class="number">1</span> <span class="keyword">and</span> i == res[<span class="number">-1</span>]:</span><br><span class="line">                res.pop()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1486-XOR-Operation-in-an-Array&quot;&gt;&lt;a href=&quot;#1486-XOR-Operation-in-an-Array&quot; class=&quot;headerlink&quot; title=&quot;1486. XOR Operation in an Array&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第25周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/20/2020-%E7%AC%AC25%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/20/2020-第25周-LeetCode-记录/</id>
    <published>2020-06-20T06:53:40.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1476-Subrectangle-Queries"><a href="#1476-Subrectangle-Queries" class="headerlink" title="1476. Subrectangle Queries"></a>1476. Subrectangle Queries</h3><p>二维数组的更新与查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubrectangleQueries</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rectangle: List[List[int]])</span>:</span></span><br><span class="line">        self.rect = rectangle</span><br><span class="line">        self.rows, self.cols = len(self.rect), len(self.rect[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateSubrectangle</span><span class="params">(self, row1: int, col1: int, row2: int, col2: int, newValue: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row1, row2 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col1, col2 + <span class="number">1</span>):</span><br><span class="line">                self.rect[i][j] = newValue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self, row: int, col: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.rect[row][col]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your SubrectangleQueries object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = SubrectangleQueries(rectangle)</span></span><br><span class="line"><span class="comment"># obj.updateSubrectangle(row1,col1,row2,col2,newValue)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getValue(row,col)</span></span><br></pre></td></tr></table></figure><h3 id="1480-Running-Sum-of-1d-Array"><a href="#1480-Running-Sum-of-1d-Array" class="headerlink" title="1480. Running Sum of 1d Array"></a>1480. Running Sum of 1d Array</h3><p>统计动态和，始终用一个变量记录当前值，遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runningSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            sum += i</span><br><span class="line">            res.append(sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1481-Least-Number-of-Unique-Integers-after-K-Removals"><a href="#1481-Least-Number-of-Unique-Integers-after-K-Removals" class="headerlink" title="1481. Least Number of Unique Integers after K Removals"></a>1481. Least Number of Unique Integers after K Removals</h3><p>对 arr 中出现数字的次数进行统计，并按照升序进行排序，遍历排序后的结果，如果 sum + elem_v 小于等于 k，那么表示此时还可以继续删除数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        res = dict(Counter(arr))</span><br><span class="line">        res = sorted(res.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        len_elem = len(res)</span><br><span class="line">        <span class="keyword">for</span> (elem_k,elem_v) <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> sum + elem_v &lt;= k:</span><br><span class="line">                len_elem -=<span class="number">1</span></span><br><span class="line">                sum += elem_v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> len_elem</span><br></pre></td></tr></table></figure><h3 id="1482-Minimum-Number-of-Days-to-Make-m-Bouquets"><a href="#1482-Minimum-Number-of-Days-to-Make-m-Bouquets" class="headerlink" title="1482. Minimum Number of Days to Make m Bouquets"></a>1482. Minimum Number of Days to Make m Bouquets</h3><p>对所有天数进行排序，使用二分法判断是否满足，其中判断是否可以组成k 朵花需要注意判断是否连续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDays</span><span class="params">(self, bloomDay: List[int], m: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(bloomDay)</span><br><span class="line">        <span class="keyword">if</span> n &lt; m * k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(day: int)</span>:</span></span><br><span class="line">            num = sums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> num &gt;= m:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> bloomDay[i] &lt;= day:</span><br><span class="line">                    sums += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sums = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> sums == k:</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">                    sums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= m</span><br><span class="line">        days = sorted(set(bloomDay))</span><br><span class="line">        l, r = <span class="number">0</span>, len(days)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> count(days[mid]):</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> days[l]</span><br></pre></td></tr></table></figure><h3 id="1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><a href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree" class="headerlink" title="1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"></a>1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</h3><p>题目描述不清楚，我理解是 dfs ，只是传入的是两个 Tree，判断符合条件后直接返回另一个 Tree Node。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTargetCopy</span><span class="params">(self, original: TreeNode, cloned: TreeNode, target: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(original, cloned, target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> original <span class="keyword">or</span> <span class="keyword">not</span> cloned:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> original == target:</span><br><span class="line">                <span class="keyword">return</span> cloned</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> traverse(original.left, cloned.left, target) <span class="keyword">or</span> \</span><br><span class="line">                traverse(original.right, cloned.right, target)</span><br><span class="line">        <span class="keyword">return</span> traverse(original, cloned, target)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1476-Subrectangle-Queries&quot;&gt;&lt;a href=&quot;#1476-Subrectangle-Queries&quot; class=&quot;headerlink&quot; title=&quot;1476. Subrectangle Queries&quot;&gt;&lt;/a&gt;1476. Subr
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>从北京转到上海生活两周感受</title>
    <link href="https://zdyxry.github.io/2020/06/13/%E4%BB%8E%E5%8C%97%E4%BA%AC%E8%BD%AC%E5%88%B0%E4%B8%8A%E6%B5%B7%E7%94%9F%E6%B4%BB%E4%B8%A4%E5%91%A8%E6%84%9F%E5%8F%97/"/>
    <id>https://zdyxry.github.io/2020/06/13/从北京转到上海生活两周感受/</id>
    <published>2020-06-13T22:09:05.000Z</published>
    <updated>2020-08-29T10:43:27.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾，换个城市感受一下，正好公司在上海也有办公室，就直接转过来了，到今天已经工作了两周，写一下感受，扯一扯。</p><h2 id="租房"><a href="#租房" class="headerlink" title="租房"></a>租房</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>因为在5月份的时候疫情消停了一段时间，我就开始了远程看房的计划，因为有深圳同事也要转到上海，就计划一起合租，那么目标就是两居室。我们通过 Notion 协作写清楚需求（是的，还有猫的需求），然后各自开始了远程找房。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># yiran 的需求</span><br><span class="line">- 步行 30min 可到达公司</span><br><span class="line">- 民水民点</span><br><span class="line">- 厨房可用</span><br><span class="line">- 周围有商超</span><br><span class="line">- 不临街</span><br><span class="line"></span><br><span class="line">## 同事的需求</span><br><span class="line">- 希望是有电梯的(骑车穿锁鞋很难下楼)</span><br><span class="line">- 避免石膏墙</span><br><span class="line">- 询问一下居住证的问题</span><br><span class="line"></span><br><span class="line">## 猫的需求</span><br><span class="line">- 最好是有防盗网的窗户</span><br><span class="line">- 阳光</span><br><span class="line">- 够大</span><br><span class="line"></span><br><span class="line"># 避免</span><br><span class="line">- 窗户有树</span><br></pre></td></tr></table></figure><h3 id="了解中介"><a href="#了解中介" class="headerlink" title="了解中介"></a>了解中介</h3><p>如果个人在上海本地，那么还有可能通过豆瓣等平台找到房东直接签约没有中介费，但是像我这种时间紧任务重的，就放弃了这种方式选择中介。上海租房与北京租房最主要的不同就是中介费，北京是租客需要支付一个月的租金，而上海是租客与房东共支付一个月的租金作为中介费，所以租客只需要支付50% 的租金即可，这点比北京友好很多，所以我们开始也是倾向于通过中介与房东签约的房子。</p><p>中介主要是链家，我爱我家的房源很少，且质量不高，贝壳上还有些其他的小中介，因为担心有其他隐患，最后还是选择的链家。</p><h3 id="看房"><a href="#看房" class="headerlink" title="看房"></a>看房</h3><p>主要看了两天的时间，第一天看了很多公司周围的板楼，后来才知道这类房子叫“老公房”，房子质量很差，且隔音很是问题，无法接受，于是第二天开始看一些距离公司地铁20min 可达的房子，在看的时候发现我忽略了一个比较重要的点，就是猫，同事养了两只猫，但是我看房子时忽略了房东不让养宠物的可能，直到我看了一个各方面都符合要求的房子后，想要与房东签约，才想到这点，房东果断拒绝了，后续也看了几个房子各方面都很好，但是不让养宠物而错过的，也是没有办法。</p><h3 id="自如"><a href="#自如" class="headerlink" title="自如"></a>自如</h3><p>在看了两天之后，发现房子质量比较好的房东，都不同意租客养宠物，换位思考可以理解，因为时间比较紧张，把目光选择了自如，自如的收费与北京相同，没有差别，照片都是真实的，但是我还是线下去看了房子，确保没有问题，期间发现了一些在自如网站上无法发现的问题：</p><ol><li>隔音，部分房子隔音很差</li><li>周围环境，发现部分房子周围存在基建施工情况，看形式不是几天可以完工的</li><li>老旧小区改造，在北京吃过亏，租的房子是老房子，恰逢政府进行小区改造，两个月没有卫生间的日子还是太难过了</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如果当地有朋友，还是通过朋友那里了解到租房坑是最直接的方式</li><li>要确认好自己的需求，尤其是宠物这种可能会一票否决的事项更是要第一时间提出，否则白白浪费一个小时看房</li><li>找中介看房基本上不会按照自己的计划来安排时间的，每个中介都会拉着你去看几个类似的房子，所以做时间规划的时候最好要留有余地</li><li>实在没有选择就找自如吧，至少是有基本保证，但是要注意上海这边属于南方，宽带很可能没有联通选项</li></ol><p>附一张 Notion 的看房列表：</p><img src="/2020/06/13/从北京转到上海生活两周感受/2.png" title="Notion"><h2 id="搬家"><a href="#搬家" class="headerlink" title="搬家"></a>搬家</h2><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>因为我在去上海前没有租好房子，所以不能先把行李快递走，当时有两个计划，优先计划 2：</p><ol><li>先去上海租房，回北京快递行李，再去上海</li><li>出发前先打包好行李、去上海租房、找同事帮忙快递行李</li></ol><h3 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h3><p>在出发前我已经将自己的行李打包好了，在淘宝买了质量还可以的纸箱子，然后找了北京同事帮忙寄快递，选择的是德邦物流，之前也问过几个朋友，貌似是比较稳妥的方式了，当时物流费用是 448，我进行了保价，一共花费了 488，还是可以接受的，毕竟也是200kg+ 的行李。</p><p>但是事实证明别人的稳妥只有实际体验才知道，德邦在我的纸箱子外套了层编织袋，当我打开行李的时候，发现里面的纸箱子已经接近散架的状态，全靠编织袋才坚持到了上海，不知道其他人是不是也是这样，还好我没有什么贵重的大件物品，否则感觉要完。</p><p>同事搬家选择的顺丰，并且选择了带托盘的方式，行李在出发前是什么样子，到达时就是什么样子，全程行李没有离开托盘，所以行李也没有任何的破损，体验非常好，当然价格也很好，1k+ 的快递费。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果普通物品选择德邦还是可以的，但是我之后应该会选择顺丰。</p><h3 id="气候"><a href="#气候" class="headerlink" title="气候"></a>气候</h3><h3 id="梅雨期"><a href="#梅雨期" class="headerlink" title="梅雨期"></a>梅雨期</h3><p>在来上海前，好多朋友同事都说我作为东北人，会无法适应上海的气候，我觉得还是要感受一下才能知道是否真正适合，不试试是不知道的。</p><p>正好过来收拾的差不多就到了 6 月份，在上班的时候看到一个新闻： <code>气象局宣布，上海入梅了！上海昨天由此进入梅雨期，较常年提早9天。</code> ，这应该是整个夏天最闷最潮湿的时候了，我的感受是，北京我没有感觉到有多干燥，但是上海的潮湿是真的潮，洗完衣服晾干，我都怀疑我的感知能力，这衣服真的干了么？无论什么时间，走在室外都感觉随时会出汗，中午的时候甚至有一种水汽往脸上扑的感觉。因为我个人比较容易出汗，所以来到上海还是出汗，感受倒是没差，只是衣服不干比较愁人，也买了各种除湿袋，不知道是否真的有用，同时也在考虑除湿机。</p><h3 id="下雨"><a href="#下雨" class="headerlink" title="下雨"></a>下雨</h3><p>我自己的鞋子都是网或者布料的，所以如果下大雨鞋子肯定会湿，于是特意买了一双皮质的鞋子想着防雨，但是我低估了上海的大雨，鞋子很快就湿了，又因为是皮质的，所以干的还慢。问了同事才知道，这时候需要拖鞋，于是我在公司和家里都放了拖鞋，如果下大雨就还是穿拖鞋吧。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>目前来看，需要多准备几件衣服防止没有晾干，多准备几双鞋子防止鞋子湿了没有更换，同时备着拖鞋。</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="地下"><a href="#地下" class="headerlink" title="地下"></a>地下</h3><p>平时上班做地铁，之前在北京搭乘地铁我有一个不好的习惯：倚靠安全门，来上海的第一天就被说了两次。。现在好多了。</p><p>上海地铁有一点不好，就是没有屏幕实时展示当前地铁行进状态，虽然有小屏幕滚动，但是不够及时，在地铁上玩手机就需要留意广播重的信息，防止坐过站。</p><h3 id="地上"><a href="#地上" class="headerlink" title="地上"></a>地上</h3><p>公司到家的距离是 5 公里，体验了一下骑车回家，上海的自行车道感受很好，首先很宽，其次没有机动车抢占的情况，整体体验要比北京好很多。发现上海的交通管控也要比北京严格一些，经常能在路口看到交警在指挥交通，毕竟很少看到闯红绿灯的情况。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>目前在上海两周，还没有什么不适，感觉不错，目前还有待确定的：1. 没有暖气的冬天；2. 除湿机是否需要。之后如果有了感受再更新上来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近一个月除了每天还刷刷题之外，没有更新其他播客，因为搬家到了上海（借口）。从毕业开始就在北京工作，算下来也4年多的时间了，想着趁着还能折腾
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 第24周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/13/2020-%E7%AC%AC24%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/13/2020-第24周-LeetCode-记录/</id>
    <published>2020-06-13T07:38:57.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1470-Shuffle-the-Array"><a href="#1470-Shuffle-the-Array" class="headerlink" title="1470. Shuffle the Array"></a>1470. Shuffle the Array</h3><p>重新排列数组，使用 zip 对两个切分后的数组进行聚合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self, nums: List[int], n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(nums[<span class="number">0</span>:n],nums[n:]):</span><br><span class="line">            res+=[i,j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1471-The-k-Strongest-Values-in-an-Array"><a href="#1471-The-k-Strongest-Values-in-an-Array" class="headerlink" title="1471. The k Strongest Values in an Array"></a>1471. The k Strongest Values in an Array</h3><p>找到与“中位数”数值相差最大的 k 个数字，先将数组排序，找到“中位数”，分别从开头和结尾两边进行比较，找到最大的 k个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStrongest</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">        median = arr[(len(arr) - <span class="number">1</span>) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> len(arr) + i - j &lt;= k:</span><br><span class="line">            <span class="keyword">if</span> median - arr[i] &gt; arr[j] - median:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[:i] + arr[j + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><h3 id="1472-Design-Browser-History"><a href="#1472-Design-Browser-History" class="headerlink" title="1472. Design Browser History"></a>1472. Design Browser History</h3><p>用两个变量记录 homepage 和当前位置，处理几个场景：  </p><ol><li>从当前页跳转访问 url 对应的页面，需要将当前位置之后的所有历史列表清空</li><li>在浏览历史中后退 steps 步，需要与 0 比较，如果小于 0，则将其置为 0</li><li>在浏览历史中前进 steps 步，需要与当前历史记录长度比较，如果超过长度，则取历史记录中最后一个</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, homepage: str)</span>:</span></span><br><span class="line">        self.hist = [homepage]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, url: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        self.hist[self.pos:] = []</span><br><span class="line">        self.hist.append(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos -= steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &lt; <span class="number">0</span>:</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, steps: int)</span> -&gt; str:</span></span><br><span class="line">        self.pos += steps</span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.hist):</span><br><span class="line">            self.pos = len(self.hist) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.hist[self.pos]</span><br></pre></td></tr></table></figure><h3 id="754-Reach-a-Number"><a href="#754-Reach-a-Number" class="headerlink" title="754. Reach a Number"></a>754. Reach a Number</h3><blockquote><p><a href="https://www.bilibili.com/video/av31621072/" target="_blank" rel="noopener">https://www.bilibili.com/video/av31621072/</a></p></blockquote><blockquote><p><a href="https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reach-a-number/solution/pythonchao-ji-jian-ji-de-jie-fa-by-zhengkang/</a></p></blockquote><p>首先， 由于坐标轴是对称的，往左往右走的几率相等，因此可以只考虑右半轴。先递推一下可以知道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步数        能到达的位置</span><br><span class="line">1:          1</span><br><span class="line">2:          3, 1</span><br><span class="line">3:          6, 4, 2, 0</span><br><span class="line">4:          10, 8, 6, 4, 0</span><br><span class="line">5:          15, 13, 11, 9, 7, 5, 3, 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看出来，每一步能到达的最大位置是上一步最大位置加上步数，而每一步所能达到的位置之间间隔都为2。<br>记f(n)为第n步能到达的位置，那么有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(f(n)) = max(f(n-1)) + n</span><br><span class="line">f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]</span><br></pre></td></tr></table></figure><p>如果target可以在第n步达到，那么target一定小于等于max(f(n))且max(f(n))与taget同奇同偶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachNumber</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        target = abs(target)</span><br><span class="line">        p, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; target <span class="keyword">or</span> (p + target) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            p = p + i</span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree"></a>1038. Binary Search Tree to Greater Sum Tree</h3><p>与 538 题相同，使用 dfs 遍历，优先遍历右节点，然后root 节点，最后左节点，使用 currSum 记录比当前节点数值大的数字和，然后将自身与数字和想家，并更新数字和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        currSum = [<span class="number">0</span>]</span><br><span class="line">        self.recurse(root, currSum)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(self, root, currSum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.recurse(root.right, currSum)</span><br><span class="line">        root.val = root.val + currSum[<span class="number">0</span>]</span><br><span class="line">        currSum[<span class="number">0</span>] = root.val</span><br><span class="line">        self.recurse(root.left, currSum)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1470-Shuffle-the-Array&quot;&gt;&lt;a href=&quot;#1470-Shuffle-the-Array&quot; class=&quot;headerlink&quot; title=&quot;1470. Shuffle the Array&quot;&gt;&lt;/a&gt;1470. Shuffle the A
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第23周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/06/2020-%E7%AC%AC23%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/06/2020-第23周-LeetCode-记录/</id>
    <published>2020-06-06T13:25:41.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays"><a href="#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays" class="headerlink" title="1460. Make Two Arrays Equal by Reversing Sub-arrays"></a>1460. Make Two Arrays Equal by Reversing Sub-arrays</h3><p>比较两个列表是否可以通过翻转等价，统计列表中字母出现的次数判断，或者可以直接排序判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canBeEqual</span><span class="params">(self, target: List[int], arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        c = collections.Counter(target)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            c[a] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c[a] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1464-Maximum-Product-of-Two-Elements-in-an-Array"><a href="#1464-Maximum-Product-of-Two-Elements-in-an-Array" class="headerlink" title="1464. Maximum Product of Two Elements in an Array"></a>1464. Maximum Product of Two Elements in an Array</h3><p>找到数组中最大的两个数字，分别将其数值 -1 然后相乘返回。可以直接升序排序后取最后两个数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max:=<span class="number">0</span></span><br><span class="line">    secondMax:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        e:=nums[i]</span><br><span class="line">        <span class="keyword">if</span> e&gt;max&#123;</span><br><span class="line">            secondMax = max</span><br><span class="line">            max = e</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> e&gt;secondMax&#123;</span><br><span class="line">            secondMax = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (max<span class="number">-1</span>)*(secondMax<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K"><a href="#1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K" class="headerlink" title="1461. Check If a String Contains All Binary Codes of Size K"></a>1461. Check If a String Contains All Binary Codes of Size K</h3><p>s 字符串中只包含0或1，滑动窗口计算 s 所有长度为 k 的组合，使用 set 去重，与 K 个数字的二进制字符串数量相比较，是否相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAllCodes</span><span class="params">(self, s: str, k: int)</span> -&gt; bool:</span></span><br><span class="line">        m = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)-k+<span class="number">1</span>):</span><br><span class="line">            m.add(s[i:i+k])</span><br><span class="line">        <span class="keyword">return</span> len(m) == (<span class="number">1</span> &lt;&lt; k)</span><br></pre></td></tr></table></figure><h3 id="1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts"><a href="#1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts" class="headerlink" title="1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"></a>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</h3><p>分别对两个数组进行排序切割，找到两个元素之间间隔最大的数值，然后将其相乘为最终所求面积大小，对 <code>1e9 +7</code> 取余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(h <span class="keyword">int</span>, w <span class="keyword">int</span>, horizontalCuts []<span class="keyword">int</span>, verticalCuts []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxH, maxV := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">pre := <span class="number">0</span></span><br><span class="line">sort.Ints(horizontalCuts)</span><br><span class="line">sort.Ints(verticalCuts)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(horizontalCuts); i++ &#123;</span><br><span class="line">maxH = max(maxH, horizontalCuts[i] - pre)</span><br><span class="line">pre = horizontalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxH = max(maxH, h - pre)</span><br><span class="line">pre = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(verticalCuts); i++ &#123;</span><br><span class="line">maxV = max(maxV, verticalCuts[i] - pre)</span><br><span class="line">pre = verticalCuts[i]</span><br><span class="line">&#125;</span><br><span class="line">maxV = max(maxV, w - pre)</span><br><span class="line"><span class="keyword">return</span> (maxH * maxV) % <span class="number">1000000007</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h3><p>遍历 connections ，统计每个节点之间相邻的节点，使用 dfs 从 0 开始计算，当相邻节点已经访问过了，直接跳过，如果没有访问过，且相邻节点到当前节点方向不对，那么就将结果 +1，并将其添加到访问过的集合中，继续dfs 相邻节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span><span class="params">(self, n: int, connections: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        edges = &#123; (a,b) <span class="keyword">for</span> a, b <span class="keyword">in</span> connections &#125; <span class="comment"># instantly check if a-&gt;b</span></span><br><span class="line">        neighbors = &#123; i:[] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;     <span class="comment"># adjacent cities</span></span><br><span class="line">        visit = set()                             <span class="comment"># visit each city once</span></span><br><span class="line">        changes = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            neighbors[a].append(b)</span><br><span class="line">            neighbors[b].append(a)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs from City 0, count outgoing edges</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(city)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> edges, neighbors, visit, changes</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors[city]:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">in</span> visit:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># neighbor can't reach city</span></span><br><span class="line">                <span class="keyword">if</span> (neighbor, city) <span class="keyword">not</span> <span class="keyword">in</span> edges:</span><br><span class="line">                    changes += <span class="number">1</span></span><br><span class="line">                visit.add(neighbor)</span><br><span class="line">                dfs(neighbor)</span><br><span class="line">        </span><br><span class="line">        visit.add(<span class="number">0</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> changes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot;&gt;&lt;a href=&quot;#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第22周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/06/01/2020-%E7%AC%AC22%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/06/01/2020-第22周-LeetCode-记录/</id>
    <published>2020-06-01T05:44:57.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence"><a href="#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence" class="headerlink" title="1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence"></a>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</h3><p>切分句子然后遍历判断是否为前缀，需要返回索引 + 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, sentence: str, searchWord: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> idx, w <span class="keyword">in</span> enumerate(sentence.split(<span class="string">' '</span>)):</span><br><span class="line">            <span class="keyword">if</span> w.startswith(searchWord):</span><br><span class="line">                <span class="keyword">return</span> idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length"><a href="#1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length" class="headerlink" title="1456. Maximum Number of Vowels in a Substring of Given Length"></a>1456. Maximum Number of Vowels in a Substring of Given Length</h3><p>滑动窗口，使用字典统计每个元音出现的次数，每次更新最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxVowels</span><span class="params">(self, s: str, k: int)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'e'</span>: <span class="number">0</span>, <span class="string">'i'</span>: <span class="number">0</span>, <span class="string">'o'</span>: <span class="number">0</span>, <span class="string">'u'</span>: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[:k]:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> d:</span><br><span class="line">                d[c] += <span class="number">1</span></span><br><span class="line">        res = sum(d.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i-k] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i-k]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i]] += <span class="number">1</span></span><br><span class="line">            res = max(res, sum(d.values()))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1200-Minimum-Absolute-Difference"><a href="#1200-Minimum-Absolute-Difference" class="headerlink" title="1200. Minimum Absolute Difference"></a>1200. Minimum Absolute Difference</h3><p>遍历列表，记录前一个数值，每次计算绝对差值，更新最小值，如果差值等于最小值，则将其加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumAbsDifference</span><span class="params">(self, arr: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        m = float(<span class="string">'inf'</span>)</span><br><span class="line">        out = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">            prev = arr[i - <span class="number">1</span>]</span><br><span class="line">            curr = abs(prev - arr[i])</span><br><span class="line">            <span class="keyword">if</span> curr &lt; m:</span><br><span class="line">                out = [[prev, arr[i]]]</span><br><span class="line">                m = curr</span><br><span class="line">            <span class="keyword">elif</span> curr == m: out.append([prev, arr[i]])</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree"><a href="#1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree" class="headerlink" title="1457. Pseudo-Palindromic Paths in a Binary Tree"></a>1457. Pseudo-Palindromic Paths in a Binary Tree</h3><p>DFS 遍历二叉树，使用 set 记录已有数值，如果该数值已经存在，则删掉，如果不存在，则加入set。判断回文字符的依据是set 中剩余字母长度是否小于等于1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        s = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            res = dfs(root.left) + dfs(root.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res += len(s)&lt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.val <span class="keyword">in</span> s:</span><br><span class="line">                s.discard(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(root.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence&quot;&gt;&lt;a href=&quot;#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第21周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/22/2020-%E7%AC%AC21%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/22/2020-第21周-LeetCode-记录/</id>
    <published>2020-05-22T22:28:29.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1446-Consecutive-Characters"><a href="#1446-Consecutive-Characters" class="headerlink" title="1446. Consecutive Characters"></a>1446. Consecutive Characters</h3><p>判断最长连续相同字符的长度，记录下当前字母，然后比较与 flag 是否相同，如果相同则 +1，不相同则重置为 1。</p><p>也可以通过 itertools.groupby 来实现（新学习的。。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPower</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        tmp = s[<span class="number">0</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i == tmp:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = i</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            max_cnt = max(max_cnt, cnt)</span><br><span class="line">        <span class="keyword">return</span> max_cnt</span><br></pre></td></tr></table></figure><h3 id="1447-Simplified-Fractions"><a href="#1447-Simplified-Fractions" class="headerlink" title="1447. Simplified Fractions"></a>1447. Simplified Fractions</h3><p>遍历分子与分母，求最大公约数，如果最大公约数为1，则将结果保存下来。分母从 2 开始计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simplifiedFractions</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> gcd(i, j) == <span class="number">1</span> &#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, fmt.Sprintf(<span class="string">"%d/%d"</span>, j, i))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x%y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1448-Count-Good-Nodes-in-Binary-Tree"><a href="#1448-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="1448. Count Good Nodes in Binary Tree"></a>1448. Count Good Nodes in Binary Tree</h3><p>遍历所有节点，记录 root 节点到当前节点经过的最大值，当前节点数值与最大值进行比较，如果符合条件，则结果 +1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, curmax)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> node.val &gt;= curmax:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            curmax = max(curmax, node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                dfs(node.left, curmax)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                dfs(node.right, curmax)</span><br><span class="line">            </span><br><span class="line">        dfs(root, -float(<span class="string">'inf'</span>))</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h3><p>遍历开始时间和结束时间，判断查询时间是否在两者之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busyStudent</span><span class="params">(self, startTime: List[int], endTime: List[int], queryTime: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(a&lt;=queryTime&lt;=b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(startTime,endTime))</span><br></pre></td></tr></table></figure><h3 id="896-Monotonic-Array"><a href="#896-Monotonic-Array" class="headerlink" title="896. Monotonic Array"></a>896. Monotonic Array</h3><p>遍历数组，记录前一个数字与当前数字的差值，判断是否单调递增或递减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt_inc = <span class="number">0</span>; cnt_dec = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: prev = v; <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span>   v &gt; prev: cnt_inc += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v &lt; prev: cnt_dec += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt_inc <span class="keyword">and</span> cnt_dec: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            prev = v</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1446-Consecutive-Characters&quot;&gt;&lt;a href=&quot;#1446-Consecutive-Characters&quot; class=&quot;headerlink&quot; title=&quot;1446. Consecutive Characters&quot;&gt;&lt;/a&gt;1446
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第20周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/05/16/2020-%E7%AC%AC20%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/05/16/2020-第20周-LeetCode-记录/</id>
    <published>2020-05-16T10:17:49.000Z</published>
    <updated>2020-08-29T10:43:27.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1441-Build-an-Array-With-Stack-Operations"><a href="#1441-Build-an-Array-With-Stack-Operations" class="headerlink" title="1441. Build an Array With Stack Operations"></a>1441. Build an Array With Stack Operations</h3><p>遍历数组，比较当前值与目标值是否相同，如果相同，则在结果追加 <code>Push</code> ，如果不同，则追加 <code>Push</code>, <code>Pop</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildArray</span><span class="params">(self, target: List[int], n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        keep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(<span class="string">"Push"</span>)</span><br><span class="line">            keep += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> target:</span><br><span class="line">                res.append(<span class="string">"Pop"</span>)</span><br><span class="line">                keep -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> keep == len(target):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a>1442. Count Triplets That Can Form Two Arrays of Equal XOR</h3><p>求子数组中是否存在左侧部分异或值与右侧部分异或值相等的情况，a==b -&gt; a ^ b = 0，也就是是否存在子数组所有元素异或值为0 的情况，如果存在，那么子数组所有的元素都可以符合条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">                temp = temp^arr[j]</span><br><span class="line">                <span class="keyword">if</span> temp == <span class="number">0</span>:</span><br><span class="line">                    count += j-i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers"><a href="#1317-Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers" class="headerlink" title="1317. Convert Integer to the Sum of Two No-Zero Integers"></a>1317. Convert Integer to the Sum of Two No-Zero Integers</h3><p>从 1 开始遍历判断两个拆分数字是否包含 <code>0</code> ，判断对 10 取余是否为0 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNoZeroIntegers</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.check(i) <span class="keyword">and</span> self.check(n - i):</span><br><span class="line">                <span class="keyword">return</span> [i, n - i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            n //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree"></a>1443. Minimum Time to Collect All Apples in a Tree</h3><p>通过字典来保证每条路径只走一次，判断子节点是否有苹果，如果没有，则将子节点从字典中删除，最终字典中保存的是必须要经过的节点，要走 2 次，所以需要 * 2 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTime</span><span class="params">(self, n: int, edges: List[List[int]],</span></span></span><br><span class="line"><span class="function"><span class="params">                hasApple: List[bool])</span> -&gt; int:</span></span><br><span class="line">        maps = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            maps[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            selfOrChildHasApple = hasApple[i]</span><br><span class="line">            <span class="keyword">for</span> nex <span class="keyword">in</span> maps[i]:</span><br><span class="line">                selfOrChildHasApple |= dfs(nex)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> selfOrChildHasApple:</span><br><span class="line">                <span class="keyword">del</span> maps[i]</span><br><span class="line">            <span class="keyword">return</span> selfOrChildHasApple</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, <span class="number">2</span> * (len(maps) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="807-Max-Increase-to-Keep-City-Skyline"><a href="#807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="807. Max Increase to Keep City Skyline"></a>807. Max Increase to Keep City Skyline</h3><p>分别找出每行、每列的最大值，然后遍历判断当前值距离两个最大值中的最小值需要增加多少，累加计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        max_cols = [max(col) <span class="keyword">for</span> col <span class="keyword">in</span> zip(*grid)]</span><br><span class="line">        max_rows = [max(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid]</span><br><span class="line">        inc = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[i])):</span><br><span class="line">                inc += (min(max_cols[j], max_rows[i]) - grid[i][j])</span><br><span class="line">        <span class="keyword">return</span> inc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1441-Build-an-Array-With-Stack-Operations&quot;&gt;&lt;a href=&quot;#1441-Build-an-Array-With-Stack-Operations&quot; class=&quot;headerlink&quot; title=&quot;1441. Buil
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>PyInstaller 与 RPM 配合使用踩坑</title>
    <link href="https://zdyxry.github.io/2020/05/13/PyInstaller-%E4%B8%8E-RPM-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"/>
    <id>https://zdyxry.github.io/2020/05/13/PyInstaller-与-RPM-配合使用踩坑/</id>
    <published>2020-05-13T20:35:50.000Z</published>
    <updated>2020-08-29T10:43:27.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配置会有坑，然后搜索下来几乎没看到有人提到，可能用 pyinstaller 和用 rpm 的完全是两类人吧 - -。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先列一下官方默认例子的输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/demo</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> ls</span></span><br><span class="line">demo.py</span><br><span class="line">root@localhost:/tmp/demo</span><br><span class="line"><span class="meta"> $</span><span class="bash"> pyinstaller demo.py</span></span><br><span class="line">63 INFO: PyInstaller: 3.6</span><br><span class="line">63 INFO: Python: 3.6.8</span><br><span class="line">65 INFO: Platform: Linux-3.10.0-862.el7.x86_64-x86_64-with-centos-7.5.1804-Core</span><br><span class="line">65 INFO: wrote /tmp/demo/demo.spec</span><br><span class="line">67 INFO: UPX is not available.</span><br><span class="line">70 INFO: Extending PYTHONPATH with paths</span><br><span class="line">['/tmp/demo', '/tmp/demo']</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>来看一下生成文件的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── demo</span><br><span class="line">├── demo.py</span><br><span class="line">├── demo.spec</span><br><span class="line">├── dist</span><br><span class="line">│   └── demo</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── binascii.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _bisect.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _blake2.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">|       ├── ...</span><br><span class="line">│       ├── _codecs_kr.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _codecs_tw.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── _datetime.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── demo</span><br><span class="line">│       ├── libbz2.so.1</span><br><span class="line">│       ├── libcom_err.so.2</span><br><span class="line">│       ├── libcrypto.so.10</span><br><span class="line">│       ├── libexpat.so.1</span><br><span class="line">│       ├── libgssapi_krb5.so.2</span><br><span class="line">│       ├── libk5crypto.so.3</span><br><span class="line">│       ├── libkeyutils.so.1</span><br><span class="line">│       ├── libtinfo.so.5</span><br><span class="line">│       ├── libkrb5support.so.0</span><br><span class="line">│       ├── liblzma.so.5</span><br><span class="line">│       ├── libpcre.so.1</span><br><span class="line">│       ├── libpython3.6m.so.1.0</span><br><span class="line">│       ├── libreadline.so.6</span><br><span class="line">│       ├── libz.so.1</span><br><span class="line">└── __pycache__</span><br><span class="line">    └── demo.cpython-36.pyc</span><br></pre></td></tr></table></figure><p>看上去也没啥问题，编写一个 rpm spec，然后使用 rpmbuild 直接就可以生成一个 RPM出来，在 RedHat 系列的 OS上可以直接安装使用，具体的步骤可以参考之前的博客：<a href="https://zdyxry.github.io/2018/07/28/RPM-%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F/">《RPM 常用构建方式》</a>，目前来看一切都正常，但是坑来了。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在验证完基础的功能后，我想要将这个 RPM 放到 ISO 中发布，在验证过程中，发现这个 RPM 会破坏系统其他的依赖检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:00:20 tmp]$cat packaging.log |grep so |grep 'No such file'</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,490 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /bin/sh: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,491 INFO packaging: /sbin/install-info: error ...</span><br><span class="line">09:19:50,495 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /usr/bin/trust: error while loading shared libraries: libfreebl3.so: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,499 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,500 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">09:19:50,501 INFO packaging: /sbin/install-info: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>简单的过滤了一下，有这些包直接受到了影响，还有很多未知的，简单的说就是系统的一些核心依赖库缺失，没有安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 18:02:48 tmp]$cat packaging.log |grep 'scriptlet failed'</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(readline-6.2-10.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,490 INFO packaging: warning: %post(gawk-4.0.2-4.el7_3.1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(info-5.1-4.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,491 INFO packaging: warning: %post(qemu-kvm-aurora-0.3.3-1.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,495 INFO packaging: warning: %post(glib2-2.50.3-3.el7.x86_64) scriptlet failed, exit status 127</span><br><span class="line">09:19:50,499 INFO packaging: warning: %post(ca-certificates-2017.2.14-71.el7.noarch) scriptlet failed, exit status 127</span><br></pre></td></tr></table></figure><p>最初在排查是否是 anaconda 在检查 rpm 相互之间的依赖时出了 bug，但是最近版本没什么变化，理论上不会，又去瞧了瞧 anaconda 的代码，发现跟 rpm 相关的太多，一时也没看出什么头绪。</p><p>再来看一下相关的库， <code>libz.so.1</code> , <code>libtinfo.so.5</code> 有没有点眼熟，都是在 pyinstaller 生成的文件中的，但是有一点很奇怪，命令路径都不是系统路径，为什么在检查依赖的时候还是会检查到新加入的 rpm 上，而不是真正提供这些库的 RPM？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>今天的主角登场：Automatic Dependencies。</p><p>Automatic Dependencies 是 RPM 的一个特性，官方文档中是这么描述的：</p><blockquote><p>When a package is built by RPM, if any file in the package’s %files list is a shared library, the library’s soname is automatically added to the list of capabilities the package provides. The soname is the name used to determine compatibility between different versions of a library.</p></blockquote><blockquote><p>Note that this is not a filename. In fact, no aspect of RPM’s dependency processing is based on filenames. Many people new to RPM often make the assumption that a failed dependency represents a missing file. This is not the case.</p></blockquote><blockquote><p>Remember that RPM’s dependency processing is based on knowing what capabilities are provided by a package and what capabilities a package requires. We’ve seen how RPM automatically determines what shared library resources a package provides. But does it automatically determine what shared libraries a package requires?</p></blockquote><blockquote><p>Yes! RPM does this by running ldd on every executable program in a package’s %files list. Since ldd provides a list of the shared libraries each program requires, both halves of the equation are complete — that is, the packages that make shared libraries available, and the packages that require those shared libraries, are tracked by RPM. RPM can then take that information into account when packages are installed, upgraded, or erased.</p></blockquote><p>嗯，找到问题了，解决的方式也很简单，直接关掉就好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoReqProv: no</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说 pyinstaller 用的人不少，rpm 用的人也不少，这俩默认配置配合使用是一定会出问题的，但是没有找到相关的问题，可能真的不是一类人吧。</p><p>用同事的话作为结束语： <code>automatic 开头的东西，一个字都不要信</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司一个项目用到了 pyinstaller 打包 Python 环境，又因为公司内部发布的最小粒度是 rpm，发现这俩工具配合起来默认配
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
