<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiran&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zdyxry.github.io/"/>
  <updated>2022-01-10T10:49:33.428Z</updated>
  <id>https://zdyxry.github.io/</id>
  
  <author>
    <name>yiran</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 年读书记录</title>
    <link href="https://zdyxry.github.io/2021/12/31/2021-%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2021/12/31/2021-年读书记录/</id>
    <published>2021-12-31T09:01:41.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><ul><li><a href="https://zdyxry.github.io/2016/12/31/2016%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2016</a><ul><li>计划读 5 本，实际读 13 本。</li></ul></li><li><a href="https://zdyxry.github.io/2017/12/31/2017%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2017</a><ul><li>计划 32 本，实际读完 23 本。</li></ul></li><li><a href="https://zdyxry.github.io/2018/12/30/2018%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2018</a><ul><li>计划 30 本，实际25本。</li></ul></li><li><a href="https://zdyxry.github.io/2019/12/09/2019%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2019</a><ul><li>计划 30 本，实际 43 本。</li></ul></li><li><a href="https://zdyxry.github.io/2020/12/28/2020%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2020</a><ul><li>计划 30 本，实际 40 本。</li></ul></li><li>2021<ul><li>计划 50 本，实际 47 本。</li></ul></li></ul><h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ol><li>《Linux C编程一站式学习》</li><li>《现代操作系统：原理与实现》</li><li>《封锁》</li><li>《指数基金投资》</li><li>《指数基金投资指南》</li><li>《小狗钱钱》</li><li>《富爸爸穷爸爸》</li><li>《The Almanack of Naval Ravikant》</li><li>《让时间陪你慢慢变富》</li><li>《韭菜的自我修养》</li><li>《labuladong的算法小抄》</li><li>《人人都能用英语》</li><li>《仿制药的真相》</li><li>《Kubernetes源码剖析》</li><li>《如何高效学习》</li><li>《你的第一本保险指南》</li><li>《跑步圣经》</li><li>《当我谈跑步时我谈些什么》</li><li>《柴犬绅士》</li><li>《咖啡新规则》</li><li>《深度休息》</li><li>《爱上跑步的13周》</li><li>《金阁寺》</li><li>《UNIX传奇》</li><li>《间客》</li><li>《工薪族财务自由说明书》</li><li>《分布式缓存》</li><li>《剑指Offer》</li><li>《商业的本质和互联网》</li><li>《哈利·波特》</li><li>《Go语言编程》</li><li>《卡片笔记写作法》</li><li>《图解网络硬件》</li><li>《喜剧这回事》</li><li>《gRPC与云原生应用开发》</li><li>《HTTP/2 in Action 中文版》</li><li>《代码整洁之道》</li><li>《李诞脱口秀工作手册》</li><li>《娱乐至死》</li><li>《深入浅出 HTTPS：从原理到实战》</li><li>《骆驼祥子》</li><li>《沉默的大多数》</li><li>《智能时代》</li><li>《被看见的力量》</li><li>《拒看新聞的生活藝術》</li><li>《JavaScript DOM编程艺术 （第2版）》</li><li>《非暴力沟通》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zdyxry.github.io/2016/12/31/2016%E5%B9%
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>DHCP lease 生命周期</title>
    <link href="https://zdyxry.github.io/2021/12/18/DHCP-lease-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://zdyxry.github.io/2021/12/18/DHCP-lease-生命周期/</id>
    <published>2021-12-18T18:42:08.000Z</published>
    <updated>2022-01-10T10:49:33.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天配合一个同事排查虚拟机 IP 发生了变化的问题，正好整理一下 DHCP lease 生命周期以及变化流程。</p><h2 id="DHCP-lease-生命周期"><a href="#DHCP-lease-生命周期" class="headerlink" title="DHCP lease 生命周期"></a>DHCP lease 生命周期</h2><ul><li>Allocation：一个客户端开始时没有有效的租约，因此也没有 DHCP 分配的地址。它通过一个分配过程获得一个租约。</li><li>Reallocation：如果一个客户端已经有了一个来自现有租约的地址，那么当它重启或关闭后启动时，它将与授予它租约的 DHCP 服务器联系，以确认租约并获得操作参数。这有时被称为重新分配；它与完全分配过程相似，但时间更短。</li><li>Normal Operation：一旦租约被激活，客户端就会正常工作，在租约周期内使用其分配的IP地址和其他参数。客户端被称为与租约和地址绑定。</li><li>Renewal：在租约时间的某一部分过期后，客户端将试图联系最初授予租约的服务器，以更新租约，这样它就可以继续使用其 IP 地址。</li><li>Rebinding：如果与最初的租约服务器续约失败（例如，因为该服务器已经下线），那么客户端将尝试重新绑定到任何活跃的 DHCP 服务器，试图在任何允许它这样做的服务器上延长其当前租约。</li><li>Release：客户端可以在任何时候决定它不再希望使用它被分配的IP地址，并可以终止租约，释放 IP 地址。</li></ul><h2 id="Allocation-流程"><a href="#Allocation-流程" class="headerlink" title="Allocation 流程"></a>Allocation 流程</h2><pre><code>- 1.客户端创建 DHCPDISCOVER 消息  客户端开始处于INIT（初始化）状态。它没有IP地址，甚至不知道网络上是否有 DHCP 服务器或在哪里。为了找到一个，它创建了一个 DHCPDISCOVER 消息，包括以下信息。    - 在消息的 CHAddr 字段中包含自己的硬件地址，用来识别自身。    - 一个随机的交易标识符，放在 XID 字段中，这被用来识别以后的消息是同一事务的一部分。    - 另外，客户可以使用 `Requested IP Address` DHCP 选项请求一个特定的IP地址，使用IP地址 `Lease Time` 选项请求一个特定的租约长度，或通过在报文中加入`Parameter Request List`选项请求特定的配置参数。- 2.客户端发送 DHCPDISCOVER 消息  客户端在本地网络上广播 DHCPDISCOVER 消息。客户端过渡到 SELECTING 状态，在那里等待对其消息的回复。- 3.服务器接收并处理 DHCPDISCOVER 消息  本地网络上的每个 DHCP 服务器都会收到客户的 DHCPDISCOVER 消息并进行检查。服务器在其数据库中查找客户的硬件地址，并确定它是否能够为客户提供租约，以及租约的条款是什么。如果客户对一个特定的IP地址、租约长度或其他参数提出了要求，服务器将试图满足这些要求，但并不要求这样做。如果一个服务器没有被设定为为某一特定客户提供服务，它没有剩余的IP地址，或出于其他原因，它可以决定不向该客户提供租约。- 4.服务器创建 DHCPOFFER 消息  每个选择响应客户端的服务器都会创建一个包括以下信息的DHCPOFFER消息。    - 在 YIAddr 字段中包含要分配给客户的IP地址，如果服务器以前曾为该客户租用过，它将尝试重新使用上次使用的 IP 地址。如果没有，它将尝试使用客户要求的地址（如果存在）；否则，它将选择任何可用的地址。    - 所提供的租约长度。    - 客户端要求的任何特定于客户端的配置参数，或者在服务器返回给客户端的参数。    - 任何要返回给所有客户端或该客户端类别中的一般配置参数。    - DHCP 服务器标识符选项中的服务器标识符。    - 与 DHCPDISCOVER 消息中使用的交易ID（XID）相同。- 5. 服务器探测，保留提供的地址（可选）  DHCP标准规定，在向客户发送DHCPOFFER之前，服务器 &quot;应该 &quot;通过向该地址发送一个 ICMP Echo 消息来检查该IP地址是否已经被使用。如果探测到该地址正在使用，服务器当然不会将其提供给客户。这可以由管理员禁用。它被认为是DHCP服务器冲突检测功能的一个关键部分。  无论它是否探测所提供的地址，服务器也可以保留该地址，以便如果客户决定使用它，它将是可用的。这不是强制性的，因为正如我们将在下面看到的，协议会处理提供的租约被收回的情况。如果服务器保留地址，效率会更高，但如果IP地址非常短缺，这种保留可能并不实际。- 6. 服务器发送 DHCPOFFER 消息  每个服务器都会发送其 DHCPOFFER 消息。当然，它们不一定都是在完全相同的时间发送。如前所述，这些消息可以是单播的，也可以是广播的。- 7. 客户端收集和处理 DHCPOFFER 消息  客户端等待 DHCPOFFER 消息的到来，作为对其 DHCPDISCOVER 的回应。客户端在这里的确切行为是与实现有关的。为了方便起见，客户可能决定简单地接受它收到的第一个提议。或者它也可以选择通过等待一段时间来进行比较。然后它可以处理每一个 DHCPOFFER，并选择具有最有利条件的 DHCPOFFER--例如，具有最长租期的那一个。  如果没有收到 DHCPOFFER 消息，客户端将进入重传模式，并尝试在一段时间内再次发送DHCPDISCOVER。- 8. 客户端创建 DHCPREQUEST 消息  客户端为其选择的服务器 DHCPOFFER 创建一个 DHCPREQUEST 消息。这个消息有两个作用：它告诉客户接受其提议的服务器 &quot;是的，我接受你的提议，假设它仍然可用&quot;，同时也告诉其他服务器 &quot;对不起，你的提议被拒绝&quot;。在这个消息中，客户端包括以下信息。    - 在 DHCP 服务器标识符选项中，被选中的服务器的标识符。    - DHCP 服务器在 DHCPOFFER 消息中分配给客户的 IP 地址，客户在 `Requested IP Address` DHCP选项中把它作为确认地址    - 它在消息中的参数请求列表选项中想要的任何其他配置参数。- 9. 客户端发送 DHCPREQUEST 消息  客户端发送 DHCPREQUEST 消息。由于它不只是针对选定的 DHCP 服务器，而是针对所有的DHCP 服务器，所以它是广播的。这样做之后，客户端过渡到 REQUESTING 状态，在那里它等待来自所选服务器的回复。- 10. 服务器接收和处理 DHCPREQUEST 消息  每个服务器都接收并处理客户的请求信息。未被选中的服务器将把该消息视为拒绝。然而，请注意，客户可能会选择一个OFFER ，试图请求租约单没有成功完成。然后，客户可以通过发送包含不同服务器标识符的 DHCPREQUEST 来尝试其 &quot;第二选择 &quot;的 OFFER。这意味着，如果服务器A收到一个服务器标识符为服务器B的单一DHCPREQUEST，这并不一定意味着服务器A已经完成了。由于这个原因，&quot;被拒绝 &quot;的服务器在向另一个客户提供先前提供的租约之前会等待一段时间。- 11. 服务器发送 DHCPACK 或 DHCPNAK 消息  被选中的服务器将看到它的租约已被选中。如果它以前没有保留提供给客户的 IP 地址，它必须检查以确保它仍然可用。如果不是，服务器会发回一个 DHCPNAK（否定确认）消息。通常情况下，服务器仍然拥有该租约。它将为该客户创建一个绑定，并发回一个 DHCPACK（确认）消息，确认该租约并包含该客户端的所有相关配置参数。- 12. 客户端接收并处理 DHCPACK 或 DHCPNAK 消息  客户端收到对其请求的肯定或否定的确认。如果该消息是DHCPNAK，客户端过渡到 INIT 状态并重新开始：回到原点（步骤#1）。如果是DHCPACK，客户端从 YIAddr 字段中读取 IP 地址，并从各种消息字段和 DHCP 选项中记录租约长度和其他参数。  如果客户端没有收到任何消息，它可以将 DHCPREQUEST 消息重传一次或多次。如果它继续什么也没听到，那么它必须得出结论，服务器已经失效，并回到步骤#1。- 13. 客户端检查地址是否正在使用  客户端设备应该进行最后的检查，以确保新地址在结束租约过程之前没有被使用。这通常是通过在本地网络上生成一个 ARP 请求来完成的，看看是否有其他设备认为它已经拥有该客户端刚刚租赁的IP地址。如果有其他设备响应，客户端就向服务器发送一个 DHCPDECLINE 消息，然后，客户端回到步骤1，重新开始。- 14. 客户端最终完成租约分配  假设该地址还没有被使用，客户端最终确定租约并过渡到 BOUND 状态。它还设置了它的两个租赁计时器，T1 和T2。现在它已经准备好进行正常操作了。</code></pre><h2 id="Reallocation-流程"><a href="#Reallocation-流程" class="headerlink" title="Reallocation 流程"></a>Reallocation 流程</h2><pre><code>- 1. 客户端创建 DHCPREQUEST 消息  客户端以 INIT-REBOOT 状态而不是 INIT 状态开始。它创建了一个 DHCPREQUEST 消息，试图找到一个具有其当前租约信息的服务器。注意，这可能不是最初授予租约的服务器；理论上，负责租约的服务器可能在客户端获得租约后发生变化。因此，与分配过程中第8步的 DHCPREQUEST 消息不同，客户端不包括DHCP 服务器标识符选项。它确实包括以下信息。    - 在消息的 CHAddr 字段中包含它自己的硬件地址，以识别自己。    - 在 `Requested IP Address` DHCP选项中包含其现有租约的IP地址，这个地址没有被放到CIAddr 字段中。    - 一个随机的交易标识符，放在XID字段中。这被用来识别以后的信息是同一事务的一部分。    - 任何它想要的额外配置参数，放在消息中的参数请求列表选项中。- 2. 客户端发送DHCPREQUEST消息  客户端广播了 DHCPREQUEST 消息。然后，它过渡到 REBOOTING 状态，等待来自服务器的回复。- 3. 服务器接收和处理 DHCPREQUEST 消息并生成回复  网络上的每个 DHCP 服务器都接收并处理客户端的请求。服务器在其数据库中查找客户端，试图找到有关租约的信息。然后每个 DHCP 服务器决定如何回复客户端。    - 服务器拥有有效的客户租约信息。服务器拥有客户的租约信息。它发送一个 DHCPACK 消息来确认租约。它还将重申客户应该使用的任何参数。    - 服务器确定客户端租约无效。服务器确定客户的租约不再有效。发生这种情况的常见原因是客户在搬到一个不同的网络后试图确认租约，或者在事实上至少已经过期后。在这种情况下，服务器会发送一个 DHCPNAK 消息来否定租赁请求。    - 服务器没有关于客户租约的明确信息。没有租约信息的服务器不作回应。除非一个服务器的信息被保证是准确的，否则它也被要求不做回应。例如，如果一个服务器知道一个过期的租约，它不能假定该租约不再有效并发送 DHCPNAK，除非它也知道没有其他服务器为该客户提供更新的、有效的租约。- 4. 服务器发送回复  将要对客户的 DHCPREQUEST 做出响应的服务器会发送他们的DHCPACK或DHCPNAK消息。- 5. 客户端接收并处理 DHCPACK 或 DHCPNAK 消息  客户端等待一段时间以获得对其请求的回复。同样，有三种可能性，与上一步中的三种可能性相匹配。    - 正面确认。客户端收到一个 DHCPACK 消息；这确认了租赁的有效性。客户端将准备再次开始使用该租约，并继续进行下面的步骤。    - 否定的确认。该消息是一个 DHCPNAK ，它告诉客户端，它的租约不再有效。客户端过渡到 INIT 状态，以获得一个新的租约--分配过程中的第1步。    - 没有回复。如果客户端根本没有收到回复，它可以重新发送 DHCPREQUEST 消息。如果在一段时间后没有收到回复，它将得出结论，没有服务器拥有它的租约信息，并将返回 INIT 状态，尝试获得新的租约。- 6. 客户端检查地址是否正在使用  在恢复使用其租约之前，客户端设备应该执行最后的检查，以确保新地址没有被使用。尽管在租约已经存在的情况下不应该这样做，但作为一种安全措施，还是要这样做。该检查与分配过程的第13步所述相同：在本地网络上发出一个 ARP 请求，看看是否有其他设备认为它已经拥有该客户端刚刚租赁的 IP 地址。如果有其他设备响应，客户端就向服务器发送一个 DHCPDECLINE 消息，告诉它租约无效，因为有其他设备正在使用这个地址。然后，客户端回到INIT状态，获得一个新的租约。- 7. 客户端最终完成租约的分配  假设该地址还没有被使用，客户端最终完成租约并过渡到 BOUND 状态。现在它已经准备好进行正常操作了。</code></pre><h2 id="Renewal-amp-Rebinding-流程"><a href="#Renewal-amp-Rebinding-流程" class="headerlink" title="Renewal &amp; Rebinding 流程"></a>Renewal &amp; Rebinding 流程</h2><pre><code>- 1. 续约定时器（T1）过期  续约定时器，T1，默认设置为租赁长度的50%。当定时器关闭时，客户端从 BOUND 状态过渡到RENEWING状态。  客户端可以在 T1 定时器到期前启动租约更新。- 2. 客户端发送 DHCPREQUEST 更新消息  客户端创建一个 DHCPREQUEST 消息，标识自己和它的租约。然后，它将消息直接传送给最初授予租约的服务器，单播。这与分配/再分配过程中使用的 DHCPREQUEST 消息不同，后者的DHCPREQUEST是广播的。客户端可以请求一个特定的新租约长度，就像它在分配过程中请求租约长度一样，服务器对租约长度做最后的决定。- 3. 服务器接收和处理 DHCPREQUEST 消息并创建回复  假设服务器可以到达，它将接收并处理客户的更新请求。有两种可能的回应。    - 服务器同意更新客户租约。服务器决定客户的租约可以被续约。它准备向客户发送一个DHCPACK消息，以确认租约的更新，指出新的租约长度以及自租约创建或最后一次更新以来可能发生变化的任何参数。    - 服务器拒绝更新客户租约。服务器出于任何原因决定不更新客户的租约。它将创建一个DHCPNAK消息。- 4. 服务器发送回复  服务器将DHCPACK或DHCPNAK消息发回给客户。- 5. 客户端接收并处理服务器回复  客户端对服务器的回复采取适当的行动。    - 正面确认。客户端收到一个DHCPACK消息，更新租约。客户端注意到新的租约到期时间和服务器发送的任何变化的参数，重置T1和T2定时器，并过渡到BOUND状态。注意，客户端在更新时不需要做ARP IP地址检查。    - 否定确认。该消息是一个DHCPNAK，它告诉客户端它的续租请求被拒绝了。客户端将立即过渡到INIT状态，以获得一个新的租约--分配过程中的第1步。- 6. 重新绑定定时器（T2）过期  如果客户端没有收到服务器的回复，它将保持在 RENEWING 状态，并定期向服务器重传单播DHCPREQUEST。在这段时间内，从用户的角度来看，客户端仍在正常运行。如果没有收到来自服务器的响应，最终重新绑定计时器（T2）会过期。这将导致客户端过渡到REBINDING状态。回顾一下，默认情况下，T2定时器被设置为租赁长度的87.5%（8分之7）。- 7. 客户端发送DHCPREQUEST重新绑定消息  由于没有收到最初授予租约的服务器的回应，客户端 放弃该服务器，并试图联系任何可能能够延长其现有租约的服务器。它创建了一个DHCPREQUEST消息，并把它的IP地址放在CIAddr字段中，明确表示它目前拥有该地址。然后，它在本地网络上广播该请求。- 8. 服务器接收和处理DHCPREQUEST消息并发送回复  每台 DHCP 服务器都会收到请求，并根据它所掌握的客户信息作出回应。    - 服务器同意重新绑定客户租约。服务器拥有客户的租约信息并同意延长租约。它为客户准备了一个DHCPACK消息，以确认租约的更新，并指出自租约创建或最后一次更新以来可能发生的任何参数。    - 服务器决定客户不能延长其当前租约。服务器决定，无论出于什么原因，这个客户的租约不应该被延长。它准备向客户发送一个DHCPNAK消息。- 9. 服务器发送回复  每个响应客户的服务器都会发送其DHCPACK或DHCPNAK消息。- 10. 客户端收到服务器回复  客户端对上一步中的两种可能性采取适当的行动。    - 正面确认。客户端收到一个DHCPACK消息，重新绑定租约。客户端注意到现在负责这个租约的服务器，新的租约到期时间，以及服务器发送的任何改变的参数。它重置了T1和T2计时器，并过渡到BOUND状态。(它也可以像在常规租约分配期间那样探测新地址)。    - 否定确认。该消息是一个DHCPNAK，它告诉客户端，一些服务器已经确定租约不应该被延长。客户端立即过渡到INIT状态，以获得一个新的租约--分配过程中的第1步。- 11. 租约过期      如果客户端没有收到对其广播重新绑定请求的响应，它将像在RENEWING状态下一样，定期重发该请求。如果在租约到期时没有收到任何响应，它将过渡到INIT状态以获得新的租约。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;昨天配合一个同事排查虚拟机 IP 发生了变化的问题，正好整理一下 DHCP lease 生命周期以及变化流程。&lt;/p&gt;
&lt;h2 id=&quot;DH
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 执行 grub2-mkconfig 导致磁盘只读</title>
    <link href="https://zdyxry.github.io/2021/10/02/CentOS-%E6%89%A7%E8%A1%8C-grub2-mkconfig-%E5%AF%BC%E8%87%B4%E7%A3%81%E7%9B%98%E5%8F%AA%E8%AF%BB/"/>
    <id>https://zdyxry.github.io/2021/10/02/CentOS-执行-grub2-mkconfig-导致磁盘只读/</id>
    <published>2021-10-02T07:30:09.000Z</published>
    <updated>2022-01-10T10:49:33.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到了一个故障，在集群软件升级过程中，发现某一个磁盘分区变为只读，导致存储应用识别该磁盘不可用。调查发现集群升级过程中，会重新生成每个节点的 GRUB 配置文件，在执行 <code>grub2-mkconfig</code> 过程中导致的磁盘分区只读。记录下 <code>grub2-mkconfig</code> 命令执行到真正磁盘只读指令下发的流程。</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><h3 id="grub2-mkconfig"><a href="#grub2-mkconfig" class="headerlink" title="grub2-mkconfig"></a><code>grub2-mkconfig</code></h3><p>在执行 <code>grub2-mkconfig</code> 命令时，如果没有指定配置 <code>GRUB_DISABLE_OS_PROBER=true</code> 时，则 GRUB 会调用 os-prober （/etc/grub.d/30_os-prober）用于扫描其他操作系统进行后续配置。</p><h3 id="os-prober"><a href="#os-prober" class="headerlink" title="os-prober"></a>os-prober</h3><p>os-prober 是用来探测其他磁盘中存在操作系统的情况。通常由各个发行版本提供，源码地址：<a href="https://salsa.debian.org/installer-team/os-prober" target="_blank" rel="noopener">https://salsa.debian.org/installer-team/os-prober</a> 。</p><p>CentOS 默认包含的 os-prober 与源码版本并不相同，包含了一些额外的配置，通过 RPM changelog 可以查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Name        : os-prober</span><br><span class="line">Version     : 1.58</span><br><span class="line">Release     : 9.el7</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: Wed 18 Aug 2021 03:44:43 PM CST</span><br><span class="line">Group       : System Environment/Base</span><br><span class="line">Size        : 97946</span><br><span class="line">License     : GPLv2+ and GPL+</span><br><span class="line">Signature   : RSA/SHA256, Mon 21 Nov 2016 03:50:19 AM CST, Key ID 24c6a8a7f4a80eb5</span><br><span class="line">Source RPM  : os-prober-1.58-9.el7.src.rpm</span><br><span class="line">Build Date  : Sun 06 Nov 2016 11:30:02 AM CST</span><br><span class="line">Build Host  : worker1.bsys.centos.org</span><br><span class="line">Relocations : (not relocatable)</span><br><span class="line">Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;</span><br><span class="line">Vendor      : CentOS</span><br><span class="line">URL         : http://kitenet.net/~joey/code/os-prober/</span><br><span class="line">Summary     : Probes disks on the system for installed operating systems</span><br><span class="line">Description :</span><br><span class="line">This package detects other OSes available on a system and outputs the results</span><br><span class="line">in a generic machine-readable format. Support for new OSes and Linux</span><br><span class="line">distributions can be added easily.</span><br><span class="line">* Wed Sep 14 2016 rmarshall@redhat.com - 1.58-9</span><br><span class="line">- Fix regular expression that missed a corner case when detecting</span><br><span class="line">extended dos partitions.</span><br><span class="line">Resolves: rhbz#1322957</span><br><span class="line">        </span><br><span class="line">* Wed Jul 06 2016 rmarshall@redhat.com - 1.58-8</span><br><span class="line">- Resolve some coverity concerns with how the previous patch detected</span><br><span class="line">whether or not a partition was a device mapper device.</span><br><span class="line">Related: rhbz#1300262</span><br><span class="line">        </span><br><span class="line">* Tue Jul 05 2016 rmarshall@redhat.com - 1.58-7</span><br><span class="line">- Do not resolve device mapper links when generating stanzas</span><br><span class="line">for bootloader.</span><br><span class="line">Resolves: rhbz#1300262</span><br><span class="line">        </span><br><span class="line">* Wed May 04 2016 rmarshall@redhat.com - 1.58-6</span><br><span class="line">- Adding handling to skip probing extended dos partitions</span><br><span class="line">Resolves: rhbz#1322957</span><br><span class="line">- Improve Windows detection for dual boot and support Windows 10</span><br><span class="line">Resolves: rhbz#1322956</span><br><span class="line">- Suppress non-blocking dmraid sector size warning message</span><br><span class="line">Resolves: rhbz#1198918</span><br><span class="line">        </span><br><span class="line">* Fri Jan 24 2014 Daniel Mach &lt;dmach@redhat.com&gt; - 1.58-5</span><br><span class="line">- Mass rebuild 2014-01-24</span><br><span class="line">        </span><br><span class="line">* Mon Jan 20 2014 Peter Jones &lt;pjones@redhat.com&gt; - 1.58-4</span><br><span class="line">- Add man pages.</span><br><span class="line">Resolves: rhbz#948848</span><br></pre></td></tr></table></figure><p>通过下载 os-prober 的 source RPM 可以查看具体改动内容，查看 os-prober.spec 文件，查看额外的 Patch 列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Name:           os-prober</span><br><span class="line">Version:        1.58</span><br><span class="line">Release:        9%&#123;?dist&#125;</span><br><span class="line">Summary:        Probes disks on the system for installed operating systems</span><br><span class="line">            </span><br><span class="line">Group:          System Environment/Base</span><br><span class="line"># For more information about licensing, see copyright file.</span><br><span class="line">License:        GPLv2+ and GPL+</span><br><span class="line">URL:            http://kitenet.net/~joey/code/os-prober/</span><br><span class="line">Source0:        http://ftp.de.debian.org/debian/pool/main/o/os-prober/%&#123;name&#125;_%&#123;version&#125;.tar.gz</span><br><span class="line"># move newns binary outside of os-prober subdirectory, so that debuginfo</span><br><span class="line"># can be automatically generated for it</span><br><span class="line">Patch0001: 0001-Change-filepath-to-newns.patch</span><br><span class="line">Patch0002: 0002-Don-t-count-dummy-mach_kernel-as-MacOS-X-811412.patch</span><br><span class="line">Patch0003: 0003-Detect-OS-installed-to-mdraid-partition-752402.patch</span><br><span class="line">Patch0004: 0004-Yaboot-allows-spaces-in-append-825041.patch</span><br><span class="line">Patch0005: 0005-Detect-ld.so-after-usr-move-826754.patch</span><br><span class="line">Patch0006: 0006-Use-shell-processing-instead-of-basename-875356.patch</span><br><span class="line">Patch0007: 0007-Add-option-for-less-logging-893997.patch</span><br><span class="line">Patch0008: 0008-Improve-btrfs-detection-support-888341.patch</span><br><span class="line">Patch0009: 0009-Support-detection-on-btrfs-software-raid-906847.patch</span><br><span class="line">Patch0010: 0010-Name-lvm-boot-partitions-by-fstab-entry-893472.patch</span><br><span class="line">Patch0011: 0011-Set-correct-boot-partition-906886.patch</span><br><span class="line">Patch0012: 0012-Factor-out-unnecessary-logger-calls-875356.patch</span><br><span class="line">Patch0013: 0013-Issue-with-EFI-detection-in-logger-873207.patch</span><br><span class="line">Patch0014: 0014-Man-pages-missing-948848.patch</span><br><span class="line">Patch0015: 0015-Properly-handle-extended-dos-partitions-1322957.patch</span><br><span class="line">Patch0016: 0016-Windows-detection-requires-binary-grep-1322956.patch</span><br><span class="line">Patch0017: 0017-Add-Windows-10-detection-support-1322956.patch</span><br><span class="line">Patch0018: 0018-Suppress-non-blocking-dmraid-error-info-1198918.patch</span><br><span class="line">Patch0019: 0019-Do-not-resolve-device-mapper-symlinks-1300262.patch</span><br><span class="line">Patch0020: 0020-Use-POSIX-shell-syntax-1300262.patch</span><br><span class="line">Patch0021: 0021-Fix-extended-dos-partition-regex-1322957.patch</span><br></pre></td></tr></table></figure><p>单独查看每一个 Patch 很麻烦，直接看操作系统上已经安装的 os-prober 相关文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$rpm -ql os-prober</span><br><span class="line">/usr/bin/linux-boot-prober</span><br><span class="line">/usr/bin/os-prober</span><br><span class="line">/usr/libexec/linux-boot-probes</span><br><span class="line">/usr/libexec/linux-boot-probes/50mounted-tests</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/40grub</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/40grub2</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/50lilo</span><br><span class="line">/usr/libexec/linux-boot-probes/mounted/90fallback</span><br><span class="line">/usr/libexec/newns</span><br><span class="line">/usr/libexec/os-probes</span><br><span class="line">/usr/libexec/os-probes/50mounted-tests</span><br><span class="line">/usr/libexec/os-probes/init</span><br><span class="line">/usr/libexec/os-probes/init/10filesystems</span><br><span class="line">/usr/libexec/os-probes/mounted</span><br><span class="line">/usr/libexec/os-probes/mounted/05efi</span><br><span class="line">/usr/libexec/os-probes/mounted/10freedos</span><br><span class="line">/usr/libexec/os-probes/mounted/10qnx</span><br><span class="line">/usr/libexec/os-probes/mounted/20macosx</span><br><span class="line">/usr/libexec/os-probes/mounted/20microsoft</span><br><span class="line">/usr/libexec/os-probes/mounted/30utility</span><br><span class="line">/usr/libexec/os-probes/mounted/40lsb</span><br><span class="line">/usr/libexec/os-probes/mounted/70hurd</span><br><span class="line">/usr/libexec/os-probes/mounted/80minix</span><br><span class="line">/usr/libexec/os-probes/mounted/83haiku</span><br><span class="line">/usr/libexec/os-probes/mounted/90linux-distro</span><br><span class="line">/usr/libexec/os-probes/mounted/90solaris</span><br><span class="line">/usr/libexec/os-probes/mounted/efi</span><br><span class="line">/usr/libexec/os-probes/mounted/efi/10elilo</span><br><span class="line">/usr/libexec/os-probes/mounted/efi/20microsoft</span><br><span class="line">/usr/share/doc/os-prober-1.58</span><br><span class="line">/usr/share/doc/os-prober-1.58/README</span><br><span class="line">/usr/share/doc/os-prober-1.58/TODO</span><br><span class="line">/usr/share/doc/os-prober-1.58/changelog</span><br><span class="line">/usr/share/doc/os-prober-1.58/copyright</span><br><span class="line">/usr/share/man/man1/linux-boot-prober.1.gz</span><br><span class="line">/usr/share/man/man1/os-prober.1.gz</span><br><span class="line">/usr/share/os-prober</span><br><span class="line">/usr/share/os-prober/common.sh</span><br><span class="line">/var/lib/os-prober</span><br></pre></td></tr></table></figure><h3 id="grub2-mkconfig-调用-os-prober-流程"><a href="#grub2-mkconfig-调用-os-prober-流程" class="headerlink" title="grub2-mkconfig 调用 os-prober 流程"></a>grub2-mkconfig 调用 os-prober 流程</h3><p><code>grub2-mkconfig</code> 最终目的是生成 grub.cfg ，在执行过程中，会通过调用 <code>/etc/grub.d/</code> 路径下的配置脚本来依次执行，在 CentOS 存在 <code>/etc/grub.d/30_os-prober</code> 配置脚本。</p><p>执行 <code>os-prober</code> 的具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OSPROBED=&quot;`os-prober | tr &apos; &apos; &apos;^&apos; | paste -s -d &apos; &apos;`&quot;</span><br><span class="line">if [ -z &quot;$&#123;OSPROBED&#125;&quot; ] ; then</span><br><span class="line">  # empty os-prober output, nothing doing</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="CentOS-os-prober-执行流程"><a href="#CentOS-os-prober-执行流程" class="headerlink" title="CentOS os-prober 执行流程"></a>CentOS os-prober 执行流程</h3><ul><li>创建新的 namespace，在调试 os-prober 过程中建议注释掉该行为</li><li>确保所有的文件系统类型是支持的，执行 <code>/usr/libexec/os-prober/init/*</code></li><li>获取节点处于已挂载分区信息、swap 分区信息、RAID 设备分区信息</li><li><p>获取节点所有 partition 信息</p><ul><li>如果 partition 已经存在于swap 分区信息或 RAID 设备分区信息中，则跳过</li><li><p>通过 <code>blkid -o value -S type $path</code> 获取文件系统信息作为 type，比如：<br>  -</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$blkid -o value -s TYPE /dev/vdb1</span><br><span class="line">xfs_external_log</span><br></pre></td></tr></table></figure></code></pre><ul><li>如果 type == btrfs，则判断是否为 btrfs volume，如果是则过滤；如果不是，则使用 <code>/usr/libexec/os-probes/50mounted-tests</code> 针对该分区进行探测</li><li>如果分区不在已挂载分区信息中，则使用 <code>/usr/libexec/os-probes/50mounted-tests</code> 路径下的所有方式进行探测，遍历执行</li><li>如果分区处于已挂载分区信息中，则使用 <code>/usr/libexec/os-probes/50mounted-tests</code> 路径下的所有方式进行探测，遍历执行</li></ul></li></ul></li><li>探测结束</li></ul><h3 id="CentOS-usr-libexec-os-probes-50mounted-tests-探测流程"><a href="#CentOS-usr-libexec-os-probes-50mounted-tests-探测流程" class="headerlink" title="CentOS /usr/libexec/os-probes/50mounted-tests 探测流程"></a>CentOS <code>/usr/libexec/os-probes/50mounted-tests</code> 探测流程</h3><ul><li>参数校验，获取 partition 的 fs type 属性<ul><li>如果 type 处于未探测、空、LVM、swap、ctypto、ntfs则直接退出</li></ul></li><li>如果 type == btrfs ，则针对 subvolume 进行探测流程</li><li>如果节点存在 grub-mount ，存在 grub2-probe 则判断 partition 是否被GRUB 挂载</li><li>如果上述分支都没有进入，则将分区置为只读<ul><li>blockdev –setro $partition</li><li>并通过 trap 设置信号处理函数，当接收到 EXIT,HUP,INT,QUIT,TERM 信号时，则将partition 重新置为可读可写</li></ul></li><li>将分区根据当前 type 类型挂载到临时挂载点下，试用 <code>/usr/libexec/os-probes/mounted/</code> 路径下的探测方式进行探测，遍历执行</li><li>探测结束</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的节点上存在处于未被挂载，且文件系统类型不为空的情况，那么建议通过设置 GRUB 配置：<code>GRUB_DISABLE_OS_PROBER=true</code> 来禁用 os-prober 的执行，防止磁盘分区变为只读。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://tracker.ceph.com/issues/11298" target="_blank" rel="noopener">https://tracker.ceph.com/issues/11298</a></li><li><a href="https://www.thegeekdiary.com/how-to-disable-os-prober-in-centos-rhel-7/" target="_blank" rel="noopener">https://www.thegeekdiary.com/how-to-disable-os-prober-in-centos-rhel-7/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近遇到了一个故障，在集群软件升级过程中，发现某一个磁盘分区变为只读，导致存储应用识别该磁盘不可用。调查发现集群升级过程中，会重新生成每个节
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux audit buffer 配置</title>
    <link href="https://zdyxry.github.io/2021/08/15/Linux-audit-buffer-%E9%85%8D%E7%BD%AE/"/>
    <id>https://zdyxry.github.io/2021/08/15/Linux-audit-buffer-配置/</id>
    <published>2021-08-15T08:49:59.000Z</published>
    <updated>2022-01-10T10:49:33.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到了一个 case，一台主机处于挂起状态，当时主机的 IPMI console 显示日志 ： <code>audit: backlog limit exceeded</code> ，由于一些原因，导致没有及时的发送 NMI 信号触发 kernel core dump，所以只能根据已有信息进行排查，记录下 audit buffer 相关配置的学习。</p><h2 id="Audit"><a href="#Audit" class="headerlink" title="Audit"></a>Audit</h2><p>Linux kernel 在 2.6 引入 audit，为了能够更好的记录系统中的各种安全事件，比如文件修改事件和系统调用事件。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p><code>/etc/audit</code> 目录下</p><ul><li>控制规则：设置 audit 系统的一些行为以及修改其默认设置</li><li>文件系统规则：审计文件，记录特殊文件或目录的访问情况</li><li>系统调用规则：记录一些特殊应用程序的系统调用行为</li></ul><h3 id="buffer-配置"><a href="#buffer-配置" class="headerlink" title="buffer 配置"></a>buffer 配置</h3><ul><li><p>当事件无法被正确记录时，会打印一些异常日志：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">audit: audit_backlog=321 &gt; audit_backlog_limit=320</span><br><span class="line">audit: audit_lost=44395 audit_rate_limit=0 audit_backlog_limit=320</span><br><span class="line">audit: backlog limit exceeded</span><br></pre></td></tr></table></figure></code></pre></li><li><p>根据 audit 的flag 配置决定，当 flag ==1 时，打印提示日志；当 flag ==2 时，kernel panic。 默认flag = 1 。</p></li><li><p>在审计系统中，使用 socket buffer queue 来保存事件，每当接收到一条新的事件时，都会记录并准备添加到这个 queue 中，有以下几个参数来控制该行为：</p><ul><li>backlog_limit<ul><li>queue 最大长度，当记录了一个事件导致queue 长度超过限制，那么就会发生failure</li></ul></li><li>raid_limit<ul><li>速率，一秒钟内事件数量超过限定值时，则不会添加到 queue 中并会发生 failure</li></ul></li></ul></li></ul><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><ul><li><p>如果无法记录事件，那么会发生故障，根据 flag 设置来决定处理行为</p><ul><li>0，silent，静默处理</li><li><p>1， printk(默认行为)，打印到系统日志中，具体打印限制根据 kernel 参数决定：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sysctl -a | grep kernel.printk_rate</span><br><span class="line">kernel.printk_ratelimit = 5</span><br><span class="line">kernel.printk_ratelimit_burst = 10</span><br></pre></td></tr></table></figure></code></pre></li><li><p>2， panic，kernel panic</p></li></ul></li></ul><h3 id="buffer-资源计算"><a href="#buffer-资源计算" class="headerlink" title="buffer 资源计算"></a>buffer 资源计算</h3><ul><li>queue 在内存中，需要设置一个合理的 backlog_limit 数值来防止占用过多内存资源，每条事件在 9000 bytes 左右，如果设置为 320，那么占用内存资源为 320 * 9000 = 2.7 MiB 左右。</li></ul><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ul><li><p><code>audit: backlog limit exceeded</code></p><ul><li><p>IPMI console 打印以上日志，表示事件未被正确的记录，事件当前数量超过 backlog_limit 限制，可能会导致系统 hang 或者无响应</p><blockquote><p>An audit buffer queue at or exceeding capacity might also cause the instance to hang or remain in an unresponsive state.</p></blockquote></li><li><p>推荐根据实际情况调整 backlog_limit 大小，比如 8192.</p></li><li>可能产生的原因：<ul><li>审计系统设置参数设置不合理</li><li>冻结文件系统（通常由于系统快照）  </li></ul></li><li><p>audit 版本为 2.4.1-5 ，其中的配置为：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@dogfood-idc-elf-65 audit]# rpm -qa |grep audit</span><br><span class="line">audit-2.4.1-5.el7.x86_64</span><br><span class="line">audit-libs-2.4.1-5.el7.x86_64</span><br><span class="line">[root@dogfood-idc-elf-65 audit]# auditctl -s</span><br><span class="line">enabled 1</span><br><span class="line">flag 1</span><br><span class="line">pid 1093</span><br><span class="line">rate_limit 0</span><br><span class="line">backlog_limit 320</span><br><span class="line">lost 0</span><br><span class="line">backlog 0</span><br><span class="line">loginuid_immutable 0 unlocked</span><br></pre></td></tr></table></figure></code></pre></li><li><p>audit 版本为2.7.6-3，其中的配置为：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 14:16:09 ~]$rpm -q audit</span><br><span class="line">audit-2.7.6-3.el7.x86_64</span><br><span class="line">[root@node90 14:16:13 ~]$auditctl -s</span><br><span class="line">enabled 1</span><br><span class="line">failure 1</span><br><span class="line">pid 1133</span><br><span class="line">rate_limit 0</span><br><span class="line">backlog_limit 8192</span><br><span class="line">lost 0</span><br><span class="line">backlog 0</span><br><span class="line">loginuid_immutable 0 unlocked</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul><li>auditd 禁止 restart 操作（RefuseManualStop = yes），所以无法使用 [[systemctl]] 控制服务启停，可以使用 <code>service</code> 代替<ul><li><code>service auditd restart</code></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redhat 推荐在线上服务器上合理配置 audit 相关参数，避免因为参数不合理产生一些意外情况，CentOS7 系列的 audit 最新版本 backlog_limit 已经是 8192 。但是对于 audit 出现异常所产生的影响，不是很明确，在 AWS 的 KB 中是这么说的：</p><blockquote><p>An audit buffer queue at or exceeding capacity might also cause the instance to hang or remain in an unresponsive state.</p></blockquote><p>但是在 Redhat 的相关 KB 中关于具体可能产生怎样的影响并没有详细说明，还需要后续调查。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>buffer 的单位是什么？ <a href="https://serverfault.com/questions/701335/auditctl-buffer-setting-how-large-is-this" target="_blank" rel="noopener">https://serverfault.com/questions/701335/auditctl-buffer-setting-how-large-is-this</a></li><li>关于 buffer 参数的解释： <a href="https://blog.siphos.be/2015/05/audit-buffering-and-rate-limiting" target="_blank" rel="noopener">https://blog.siphos.be/2015/05/audit-buffering-and-rate-limiting</a></li><li>AWS 关于 <code>audit: backlog limit exceeded</code> 的KB： <a href="https://aws.amazon.com/cn/premiumsupport/knowledge-center/troubleshoot-audit-backlog-errors-ec2/?nc1=h_ls" target="_blank" rel="noopener">https://aws.amazon.com/cn/premiumsupport/knowledge-center/troubleshoot-audit-backlog-errors-ec2/?nc1=h_ls</a></li><li>RedHat 关于 <code>audit: backlog limit exceeded</code> 的 KB，其中提到了部分可能的原因和根本原因： <a href="https://access.redhat.com/solutions/19327" target="_blank" rel="noopener">https://access.redhat.com/solutions/19327</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近遇到了一个 case，一台主机处于挂起状态，当时主机的 IPMI console 显示日志 ： &lt;code&gt;audit: backlog
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Container Optimized OS(COS) 简单对比</title>
    <link href="https://zdyxry.github.io/2021/07/30/Container-Optimized-OS-COS-%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>https://zdyxry.github.io/2021/07/30/Container-Optimized-OS-COS-简单对比/</id>
    <published>2021-07-30T21:39:04.000Z</published>
    <updated>2022-01-10T10:49:33.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前简单调研过一些 Container Optimized OS，进行了一些简单的对比，最近又被同事问到了，整理一下发出来。</p><h2 id="COS"><a href="#COS" class="headerlink" title="COS"></a>COS</h2><img src="/2021/07/30/Container-Optimized-OS-COS-简单对比/cos.png" title="COS"><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果让我来选择一个 COS 作为 BaseOS 来进行定制，那我会根据以下几个条件来进行选择：</p><ul><li>是否支持 OSTree</li><li>是否有明星公司做背后支持，如 RedHat、VMware</li><li>社区活跃度</li></ul><p>根据以上几个条件，如果是我自己使用的话，我会选择 Fedora CoreOS，或者 VMware Photo（OSTree） 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前简单调研过一些 Container Optimized OS，进行了一些简单的对比，最近又被同事问到了，整理一下发出来。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>Gunicorn 信号处理</title>
    <link href="https://zdyxry.github.io/2021/06/27/Gunicorn-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    <id>https://zdyxry.github.io/2021/06/27/Gunicorn-信号处理/</id>
    <published>2021-06-27T18:55:41.000Z</published>
    <updated>2022-01-10T10:49:33.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在项目中使用到了 Gunicorn 的 Graceful Shutdown 功能，阅读代码学习一下 Gunicorn 的信号处理。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Gunicorn 启动入口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WSGIApplication(&quot;%(prog)s [OPTIONS] [APP_MODULE]&quot;).run()</span><br><span class="line">    BaseApplication().run()</span><br><span class="line">        Arbiter(self).run()</span><br></pre></td></tr></table></figure><p>Master 主要控制逻辑实现在 <code>Arbiter</code> 中，包括信号处理和主循环逻辑。在调用 <code>Arbiter().run()</code> 会最终调用到 <code>Arbiter.init_signals()</code> ，在该函数中会将 Master 中定义的需要处理的信号函数进行相应的注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arbiter().run():</span><br><span class="line">    Arbiter().start() </span><br><span class="line">        Arbiter().init_signals() # 初始化 Master 信号处理</span><br><span class="line">            # initialize all signals</span><br><span class="line">            for s in self.SIGNALS: # &quot;HUP QUIT INT TERM TTIN TTOU USR1 USR2 WINCH&quot;</span><br><span class="line">                signal.signal(s, self.signal)</span><br><span class="line">            signal.signal(signal.SIGCHLD, self.handle_chld)</span><br></pre></td></tr></table></figure><p>所有定义的信号处理函数都是 <code>Aribiter().signal()</code> ，该函数将接收到的信号存放在 <code>Arbiter.SIG_QUEUE</code> 中，最多保留 5 个信号，然后触发 <code>Arbiter().wakeup()</code> ，在 <code>Arbiter().wakeup()</code> 中，向 <code>Arbiter.PIPE</code> 管道写入数据，主要作用是唤醒 Master loop。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def signal(self, sig, frame):</span><br><span class="line">    if len(self.SIG_QUEUE) &lt; 5:</span><br><span class="line">        self.SIG_QUEUE.append(sig)</span><br><span class="line">        self.wakeup()</span><br><span class="line"></span><br><span class="line">def wakeup(self):</span><br><span class="line">    &quot;&quot;&quot;\</span><br><span class="line">    Wake up the arbiter by writing to the PIPE</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        os.write(self.PIPE[1], b&apos;.&apos;)</span><br><span class="line">    except IOError as e:</span><br><span class="line">        if e.errno not in [errno.EAGAIN, errno.EINTR]:</span><br><span class="line">            raise</span><br></pre></td></tr></table></figure><p>在 Arbiter 类中会实现相应的信号函数处理逻辑，针对 TERM 和 INT 信号处理的主要差异为是否会先执行 <code>Arbiter().stop(False)</code> ，最后都会 <code>raise StopIteration</code> 。对于 <code>HUP</code> 信号是执行自身的 <code>Arbiter().reload()</code> 逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def handle_hup(self):</span><br><span class="line">    &quot;&quot;&quot;\</span><br><span class="line">    HUP handling.</span><br><span class="line">    - Reload configuration</span><br><span class="line">    - Start the new worker processes with a new configuration</span><br><span class="line">    - Gracefully shutdown the old worker processes</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.log.info(&quot;Hang up: %s&quot;, self.master_name)</span><br><span class="line">    self.reload()</span><br><span class="line"></span><br><span class="line">def handle_term(self):</span><br><span class="line">    &quot;SIGTERM handling&quot;</span><br><span class="line">    raise StopIteration</span><br><span class="line"></span><br><span class="line">def handle_int(self):</span><br><span class="line">    &quot;SIGINT handling&quot;</span><br><span class="line">    self.stop(False)</span><br><span class="line">    raise StopIteration</span><br><span class="line"></span><br><span class="line">def handle_quit(self):</span><br><span class="line">    &quot;SIGQUIT handling&quot;</span><br><span class="line">    self.stop(False)</span><br><span class="line">    raise StopIteration</span><br><span class="line"></span><br><span class="line">def handle_ttin(self):</span><br><span class="line">    &quot;&quot;&quot;\</span><br><span class="line">    SIGTTIN handling.</span><br><span class="line">    Increases the number of workers by one.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.num_workers += 1</span><br><span class="line">    self.manage_workers()</span><br></pre></td></tr></table></figure><p>在 Master 进行信号处理初始化动作后，进入到 Master loop 阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    self.manage_workers()           # 启动 Worker，如果 Worker 数量不足则启动；如果数量超过预期则 kill。</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        self.maybe_promote_master()</span><br><span class="line"></span><br><span class="line">        sig = self.SIG_QUEUE.pop(0) if self.SIG_QUEUE else None</span><br><span class="line">        if sig is None:</span><br><span class="line">            self.sleep() # 如果 Master 没有接收到信号，则进入到 `Arbiter().sleep()` ，该函数从 `Arbiter.PIPE` 读取数据（阻塞），直到 `Arbiter.PIPE` 有数据后才返回</span><br><span class="line">            self.murder_workers() # 如果在当前循环中，接收到信号，则进行 worker 处理，清理无用 Worker</span><br><span class="line">            self.manage_workers() # 重新进入创建、清理 Worker 逻辑</span><br><span class="line">            continue # 进入下一循环，在下一次循环中，sig 为刚刚唤醒 Master 的信号</span><br><span class="line"></span><br><span class="line">        if sig not in self.SIG_NAMES:  # 如果接收到的信号不需要处理，则忽略</span><br><span class="line">            self.log.info(&quot;Ignoring unknown signal: %s&quot;, sig)</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        signame = self.SIG_NAMES.get(sig) # 获取信号名称</span><br><span class="line">        handler = getattr(self, &quot;handle_%s&quot; % signame, None) # 获取 Master 针对该信号的处理函数</span><br><span class="line">        if not handler:</span><br><span class="line">            self.log.error(&quot;Unhandled signal: %s&quot;, signame)</span><br><span class="line">            continue</span><br><span class="line">        self.log.info(&quot;Handling signal: %s&quot;, signame)</span><br><span class="line">        handler() # 执行信号处理</span><br><span class="line">        self.wakeup() </span><br><span class="line">except (StopIteration, KeyboardInterrupt): # 如果信号为 TERM 或 INT，则会触发 Exception，进入到 `Arbiter().halt()` 逻辑，清理配置并退出进程</span><br><span class="line">    self.halt()</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Master 创建 Worker 时，先执行 <code>worker.init_process()</code> 用来初始化进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.init_signals()</span><br><span class="line">...</span><br><span class="line"># Enter main run loop</span><br><span class="line">self.booted = True</span><br><span class="line">self.run()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def init_signals(self):</span><br><span class="line">    # reset signaling</span><br><span class="line">    for s in self.SIGNALS:</span><br><span class="line">        signal.signal(s, signal.SIG_DFL)</span><br><span class="line"></span><br><span class="line">    # init new signaling </span><br><span class="line">    signal.signal(signal.SIGQUIT, self.handle_quit)</span><br><span class="line">    signal.signal(signal.SIGTERM, self.handle_exit)</span><br><span class="line">    signal.signal(signal.SIGINT, self.handle_quit)</span><br><span class="line">    signal.signal(signal.SIGWINCH, self.handle_winch)</span><br><span class="line">    signal.signal(signal.SIGUSR1, self.handle_usr1)</span><br><span class="line">    signal.signal(signal.SIGABRT, self.handle_abort)</span><br><span class="line"></span><br><span class="line">    # Don&apos;t let SIGTERM and SIGUSR1 disturb active requests</span><br><span class="line">    # by interrupting system calls</span><br><span class="line">    signal.siginterrupt(signal.SIGTERM, False)</span><br><span class="line">    signal.siginterrupt(signal.SIGUSR1, False)</span><br><span class="line"></span><br><span class="line">    if hasattr(signal, &apos;set_wakeup_fd&apos;):</span><br><span class="line">        signal.set_wakeup_fd(self.PIPE[1])</span><br></pre></td></tr></table></figure><p>在 Worker 中，所有的信号处理函数都是直接触发，没有采用 Master 的 <code>SIG_QUEUE</code> 形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def handle_usr1(self, sig, frame):</span><br><span class="line">    self.log.reopen_files()</span><br><span class="line"></span><br><span class="line">def handle_exit(self, sig, frame):</span><br><span class="line">    self.alive = False</span><br><span class="line"></span><br><span class="line">def handle_quit(self, sig, frame):</span><br><span class="line">    self.alive = False</span><br><span class="line">    # worker_int callback</span><br><span class="line">    self.cfg.worker_int(self)</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    sys.exit(0)</span><br><span class="line"></span><br><span class="line">def handle_abort(self, sig, frame):</span><br><span class="line">    self.alive = False</span><br><span class="line">    self.cfg.worker_abort(self)</span><br><span class="line">    sys.exit(1)</span><br></pre></td></tr></table></figure><p>在 Worker 的 loop 逻辑中，优先检查 <code>self.alive</code> 是否为 True，如果为 True ，则进入请求处理逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def run_for_one(self, timeout):</span><br><span class="line">    listener = self.sockets[0]</span><br><span class="line">    while self.alive:</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line">        # Accept a connection. If we get an error telling us</span><br><span class="line">        # that no connection is waiting we fall down to the</span><br><span class="line">        # select which is where we&apos;ll wait for a bit for new</span><br><span class="line">        # workers to come give us some love.</span><br><span class="line">        try:</span><br><span class="line">            self.accept(listener)</span><br><span class="line">            # Keep processing clients until no one is waiting. This</span><br><span class="line">            # prevents the need to select() for every client that we</span><br><span class="line">            # process.</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        except EnvironmentError as e:</span><br><span class="line">            if e.errno not in (errno.EAGAIN, errno.ECONNABORTED,</span><br><span class="line">                               errno.EWOULDBLOCK):</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">        if not self.is_parent_alive():</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.wait(timeout)</span><br><span class="line">        except StopWaiting:</span><br><span class="line">            return</span><br></pre></td></tr></table></figure><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>以 HUP 信号为例，在 Gunicorn 文档中，HUP 可以优雅的重启 Worker 进程：</p><blockquote><p>HUP: Reload the configuration, start the new worker processes with a new configuration and gracefully shutdown older workers. If the application is not preloaded (using the preload_app option), Gunicorn will also load the new version of it.</p></blockquote><p>当 Master 进程收到 HUP 信号后：</p><ul><li>Master loop 唤醒，进入 <code>murder_workers</code> 和 <code>manage_workers</code> 处理</li><li>Master loop 进入下一循环，获取到 HUP 信号处理函数</li><li>执行 <code>Arbiter().handle_hup()</code> </li><li>执行 <code>Arbiter().reload()</code> 重新加载配置，重新加载 WSGI app，并按照 Worker 配置启动新 Worker ，启动完成后，执行 <code>manage_workers</code> 进行原有 Worker 处理，因为此时 Worker 数量为预期的一倍，因此会进入停掉原有 Worker 处理逻辑，执行 <code>Arbiter().kill_worker()</code> 逻辑，执行 <code>os.kill</code> ，传递信号为 TERM</li><li>此时 Master 信号处理完成，执行 <code>Arbiter().wakeup()</code> 使其重新进入 loop 阻塞逻辑。</li></ul><p>当 Worker 进程收到 TERM 信号后：</p><ul><li>执行 <code>Worker().handle_exit()</code> 逻辑，将 <code>self.alive</code> 置为 False</li><li>在 Worker 的 loop 逻辑中，优先检查 <code>self.alive</code> 是否为 True，如果不为True，则处理完成当前逻辑后，下一次循环退出，以此来实现 graceful shutdown</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://flaneur2020.github.io/2020/01/12/note-about-graceful-shutdown/" target="_blank" rel="noopener">http://flaneur2020.github.io/2020/01/12/note-about-graceful-shutdown/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在项目中使用到了 Gunicorn 的 Graceful Shutdown 功能，阅读代码学习一下 Gunicorn 的信号处理。&lt;/p
      
    
    </summary>
    
    
      <category term="Python" scheme="https://zdyxry.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OSTree 背景介绍</title>
    <link href="https://zdyxry.github.io/2021/05/22/OSTree-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zdyxry.github.io/2021/05/22/OSTree-背景介绍/</id>
    <published>2021-05-22T09:00:15.000Z</published>
    <updated>2022-01-10T10:49:33.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前段时间对 OSTree 做了一些简单的了解，进行了内部分享，好久没更新博客，把 PPT 整理出来水一篇。</p><p>仓库地址： <a href="https://github.com/zdyxry/ostree-share/" target="_blank" rel="noopener">https://github.com/zdyxry/ostree-share/</a><br>PPT： <a href="https://github.com/zdyxry/ostree-share/blob/master/ostree-intro.md" target="_blank" rel="noopener">https://github.com/zdyxry/ostree-share/blob/master/ostree-intro.md</a></p><p>（Marp 真的好用，用 Markdown 写草稿，然后短时间就可以转换成 PPT </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间对 OSTree 做了一些简单的了解，进行了内部分享，好久没更新博客，把 PPT 整理出来水一篇。&lt;/p&gt;
&lt;p&gt;仓库地址： &lt;a 
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《现代操作系统：原理与实现》读书笔记</title>
    <link href="https://zdyxry.github.io/2021/01/17/%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zdyxry.github.io/2021/01/17/《现代操作系统：原理与实现》读书笔记/</id>
    <published>2021-01-17T10:42:48.000Z</published>
    <updated>2022-01-10T10:49:33.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-操作系统概述"><a href="#第1章-操作系统概述" class="headerlink" title="第1章　操作系统概述"></a>第1章　操作系统概述</h2><p>操作系统有两个职责：对硬件进行管理和抽象，为应用提供服务并进行管理。<br>从硬件的角度来看，操作系统核心功能是将优先的，离散的资源高效的抽象为无限的、连续的资源。<br>从应用的角度来看，操作系统提供了不同层次，不同功能的接口，还提供了不同类型的访问控制。还负责对应用生命周期的管理，包括应用的加载、启动、切换、调度、销毁等。  </p><p>API vs ABI<br>API 是指应用编程接口，它定义了两层软件之间的源码层面的交互接口。<br>ABI 是指应用二进制接口，即在某个特定体系结构下两层软件之间二进制层面的交互接口，包括如何定义二进制文件格式、应用之间的调用约定、数据模式等。</p><h2 id="第2章-硬件结构"><a href="#第2章-硬件结构" class="headerlink" title="第2章　硬件结构"></a>第2章　硬件结构</h2><p>冯诺依曼结构包括三个主要部分：</p><ul><li>中央处理单元（CPU）：主要负责运算和逻辑控制，按照程序中的指令进行计算，并且根据条件执行程序中的不同部分</li><li>存储器（memory unit）：负责存储程序指令和数据，以及保存程序执行的中间结果和最终结构。在现代计算机中，存储器通常包括寄存器、cpu 缓存、内存等存储层次。</li><li>输入输出（I/O）：负责与外界进行交互，从外界获得输入，将结果向外界输出。</li></ul><p>指令集架构（ISA）是 CPU 和软件之间的桥梁。ISA 包含指令集、特权级、寄存器、执行模式、安全扩展、性能加速扩展等方面。</p><p>指令集是 ISA 的重要组成部分，通常包含一系列不同功能的指令，用于数据搬移、计算、内存访问、过程调用等。 </p><p>AArch64 属于精简指令集计算机（RISC）。AArch64 每跳指令的长度固定为 4 字节，指令类型包括：</p><ul><li>数据搬移指定（mov）；</li><li>寄存器计算指令（add，sub）；</li><li>内存读写指令（ldr，str）；</li><li>跳转指令（b）；</li><li>过程调用指令（bl，ret）；</li><li>特权指令（msr，mrs）。</li></ul><p>特权级也是 ISA 的重要组成部分。AArch64 中的特权级被称为异常级别（Exception Level，EL），共有四种特权级：</p><ul><li>EL0：最低的特权级，应用程序通常运行在该特权级，也成为用户态</li><li>EL1：操作系统通常运行在该特权级，也成为内核态</li><li>EL2：在虚拟化场景下需要，虚拟机监控器（VMM，也称为 Hypervisor）通常运行在该特权级</li><li>EL3：和安全特性 TrustZone 相关，负责普通世界（normal word）和安全世界（secure world）之间的切换</li></ul><p>一般来说，EL0 切换到 EL1 的可能场景有三种：</p><ol><li>应用程序需要调用操作系统提供的系统调用，此时应用程序会通过执行 svc（特权调用 supervisor call）指令将 CPU 特权级从 EL0 切换到 EL1</li><li>应用程序执行了一条指令，而该指令触发了异常（exception），该异常导致 CPU 特权级从 EL0 切换到了 EL1。例如，应用在执行一条访存指令时，触发了缺页异常（page fault），从而切换到操作系统内核进行处理</li><li>应用程序在执行的过程中，CPU 收到了一个来自外设的中断（interrupt），该中断也会导致 CPU 特权级从 EL0 切换到 EL1<br>前两种成为同步的 CPU 特权级切换，因为都是由于 CPU 正在执行的指令所导致的，第三种 CPU 发生的切换并不是由于指令导致的，属于异步的 CPU 特权级切换。</li></ol><p>在发生特权级切换时，CPU 负责保存当前执行状态，以便操作系统内核在处理异常是使用并在处理结束后能够恢复应用程序的执行，CPU 保存的主要状态包括：</p><ul><li>触发异常的指令地址（即当前的程序计数器（Program Counter,PC）），保存在 ELR_EL1（异常链接寄存器）中；</li><li>异常原因（即异常是由于执行 svc 指令还是由于访存缺页导致的），保存在 ESR_EL1（异常症状寄存器）中；</li><li>CPU 将栈指针（SP）从 SP_EL0 切换到 SP_EL1 ；</li><li>CPU 还会保存一些其他状态，例如将 CPU 的相关状态保存在 SPSR_EL1（以保存的程序状态寄存器）中，将引发缺页异常的地址保存在 FAR_EL1 （错误地址寄存器）中。</li></ul><p>寄存器是 ISA 的另一个重要组成部分，在 aarch64 中，有 31 个 64 位通用寄存器，被命名为 X0~X30，其中 X29 用作帧指针（FP）寄存器，按照惯例，一般用于保存函数调用过程中栈顶的地址；X30 用作链接指针（LP）寄存器，因为 CPU 在执行函数调用指令 b1 时会自动把返回地址保存在其中。</p><p>在 EL1 特权级下由两个“页表基地址寄存器（TTBR）“，即 TTBR0_EL1 和 TTBR1_EL1 ，它们负责翻译虚拟地址空间中不同的地址段，负责的地址范围由另一个控制寄存器 TCR_EL1（翻译控制寄存器）决定。操作系统中一种常见的配置是 TTBR0_EL1 负责[0，2^48）的地址映射（作为用户地址空间），TTBR1_EL1 负责[2^48 ,2^64）地址映射（作为操作系统内核地址空间）。</p><p>CPU 使用物理内存的方式：通过总线向物理内存发送一个读写请求，其中包括目标地址，物理内存在收到请求后进行读写操作。因此从 CPU 的角度，可以把物理内存看做由字节组成的大数组：其中每一个字节拥有一个地址（物理地址），CPU 可以在这个数组中存取数据。 </p><p>内存访问速度太慢，引入缓存（cache）。<br>CPU 缓存是由若干个缓存行（cache line）组成的。每个缓存行包括：<br>一个有效位，用户表示其是否有效；<br>一个标记地址，用于标识其对应的物理地址；<br>一些其他的状态信息。  </p><p>内存映射输入输出（MMIO）是一种常见的 CPU 控制和访问设备的方式。MMIO 的原理是：把输入输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配对应的地址。</p><p>CPU 通过访问 MMIO 配置的地址可以获取输入，但是 CPU 如何才能知道有输入事件发生了？   </p><p>一种方法是轮询。但是轮询会使 CPU 长时间处于等待输入的状态，造成 CPU 浪费，一种更高效的做法是：让设备在获得输入后主动告知 CPU，然后 CPU 再去获取输入。</p><p>中断，设备通过向 CPU 发出中断来打断 CPU 的执行，使得 CPU 去处理这个中断。操作系统可以为不同的设备中断配置不同的中断函数。</p><p>中断机制除了使得设备能够主动通知 CPU 之外，还包括让一个 CPU 核心去通知另一个 CPU 核心等用途。</p><p>MMIO 使得 CPU 可以主动访问设备，中断使得设备能够主动通知 CPU。<br>从应用程序的视角来看，异常和中断的区别是什么？ </p><p>在发生特权级切换时，如果不保存程序计数器和栈指针，会出现什么问题？</p><h2 id="第3章-操作系统结构"><a href="#第3章-操作系统结构" class="headerlink" title="第3章　操作系统结构"></a>第3章　操作系统结构</h2><p>策略表示要”做什么，机制表示该“如何做”。 </p><p>对于操作系统的调度系统而言，策略包括先到先得（FCFS），时间片轮转（RR）等，机制包括调度队列的设计，调度实体（线程）的表示与调度的中断处理等。</p><p>模块化划分要充分考虑“高内聚”和“低耦合”。</p><p>分层 vs 层级  </p><p>分层和层级这两个概念有点像，简而言之，分层是指不同类模块之间的层级，而层级则是指同类模块之间的分层。</p><h2 id="第4章-内存管理"><a href="#第4章-内存管理" class="headerlink" title="第4章　内存管理"></a>第4章　内存管理</h2><p>应用程序能够既高效又安全的功能使用物理内存资源的方案：虚拟内存。</p><p>虚拟内存的设计有如下三个方面的目标：</p><ul><li>高效性，一方面，虚拟内存抽象不能在应用程序运行过程中造成明显的性能开销；另一方面，虚拟内存抽象不能占用过多的物理内存资源</li><li>安全性，虚拟内存抽象需要使不同的应用程序的内存互相隔离，即一个应用程序只能访问属于自己的物理内存区域</li><li>透明性，虚拟内存抽象需要考虑对应用程序的透明性，使得应用程序开发者在编程时无需考虑虚拟内存抽象</li></ul><p>应用程序使用虚拟地址访问存储在内存中的数据和代码，在程序执行过程中，CPU 会把虚拟地址转换为物理地址，然后通过后者访问物理内存，虚拟地址转换成物理地址的过程，通常称为地址翻译。</p><p>内存管理单元（MMU），负责虚拟地址到物理地址的转换。程序在 CPU 核心上运行期间，它使用的虚拟地址都会由 MMU 进行翻译，当需要访问物理内存设备的时候，MMU 翻译出的物理地址将会通过总线传到相应的物理内存设备，从而完成相应的物理内存读写请求。为了加速地址翻译的过程，现代 CPU 引入了转址旁路缓存（TLB），TLB 是 MMU 内部的单元。</p><p>MMU 将虚拟地址翻译为物理地址的主要机制有两种：分段机制和分页机制。   </p><p>分段：应用程序的虚拟地址空间由若干个不同大小的段组成，比如代码段、数据段等。<br>分页：将应用程序的虚拟地址空间划分成连续的、等长的物理页（显著区分于分段机制下不同长度的段），同时物理内存也被划分成连续的、等长的物理页。虚拟也和物理页的页长固定且想等，从而使得操作系统能够很方便的为每个应用构造页表，即虚拟页到物理页的映射关系表。   </p><p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，可有效避免分段机制中外部碎片的问题。</p><p>为什么需要多级页表？<br>因为如果是单级页表，那么页表所占用的空间很大，为了压缩页表大小，引入了多级结构的页表。多级页表允许在整个页表结构中出现空洞，而单级页表需要每一项都实际存在。</p><p>为什么单级页表中每一项都需要存在？<br>单级页表可以看成以虚拟地址的虚拟页号作为索引的数组，整个数组的起始地址（物理地址）存储在页表基地址寄存器中。翻译某个虚拟地址即根据其虚拟页号找到对应的数组项，因此整个页表必须在物理内存中连续，其中没有被用到的数组项也需要预留（不能出现空洞）。</p><p>在 4 级页表结构中允许页表内存在“空洞”，假设整个应用程序的内存地址空间中只有两个虚拟页被使用，分别对应最低和最高的两个虚拟地址。在使用 4 级页表后，整个页表实际上只需要 1 个 0 级页表，2 个 1 级页表，2 个 2 级页表，2 个 3 级页表，合计 7 个页表页，仅仅占用 28KB 的物理内存空间，远小于单级页表。</p><p>多级页表会导致地址翻译实践增加，一次地址翻译可能会导致多次物理内存访问。为了减少地址翻译的访存次数，MMU 引入了转址旁路缓存（TLB）部件来加速地址翻译的过程。TLB 缓存了虚拟页号到物理页号的映射关系，若找到则可直接获得对应的物理页号而无须查询页表。</p><p>为什么硬件仅仅采用简单的 TLB 管理方式，就能在大多数情况下获得较高的 TLB 命中率？<br>因为局部性起了重要作用，应用程序在运行过程中访问内存的模式具有时间局部性和空间局部性，TLB 中的一条缓存项对应着一个内存页，由于内存访问的时空局部性，TLB 缓存项在将来很可能被多次查询。</p><p>如何保证 TLB 中的内容与当前页表内容的一致性？<br>由于TLB 是使用虚拟地址进行查询的，所以操作系统在进行页表切换（应用程序切换）的时候，需要主动刷新 TLB。若操作系统在切换应用的过程中刷新 TLB，那么应用程序开始执行（被切换到）的时候总会发生 TLB 未命中的情况，进而不可避免的造成性能损失。那么是否能够避免应用程序切换过程中 TLB 刷新的开销呢？<br>一种为 TLB 缓存打上“标签”的设计正是为了避免这样的开销。AArch64 体系结构为例，它提供了 ASID 功能（x86 64 上对应的功能为 PCID），具体来说，操作系统可以为不同的应用程序分配不同的 ASID 作为应用程序的标签，再将这个标签写入应用程序的页表基地址寄存器的空闲位，同时 TLB 中的缓存项也会包含 ASID 这个标签，从而使得 TLB 中属于不同应用程序的缓存项可以被区分开。因此，在切换页表的过程中，操作系统不再需要清空 TLB 缓存项。 </p><p>ASID 最多有 16 位，即同时最多可以有 65536 个标签，操作系统需要合理的为应用程序分配标签。</p><p>当一个虚拟页处于未分配状态或者已分配但未映射至物理内存状态的时候，应用程序访问虚拟页都会触发缺页异常，操作系统时如何区分的呢？操作系统时如何记录虚拟页分配状态的呢？<br>Linux 实现方法：由于应用程序通常使用虚拟地址空间的一些区域（比如数据和代码，栈，堆分别对应于三个互不连续的虚拟内存区域），所以在 linux 中，应用程序的虚拟地址空间被实现成由多个虚拟内存区域（VMA）组成的数据结构，每个 VMA 中包含该区域的起始虚拟地址，结束虚拟地址，访问权限等信息，当发生缺页异常时，操作系统判断该虚拟页是否属于该应用程序的某 VMA 来区分该页所处的分配状态。<br>页替换策略：</p><ul><li>MIN/OPT 策略</li><li>FIFO 策略</li><li>Second Chance 策略</li><li>LRU 策略</li><li>MRU 策略</li><li>时钟算法策略</li></ul><p>虚拟内存的功能</p><ul><li>共享内存，允许同一个物理页在不同的应用程序间共享，共享内存到的一个基本用途是可以让不同的应用程序之间互相通信、传递数据。基于共享内存的思想，操作系统又从中衍生出诸如写时拷贝、内存去重等功能</li><li>写时拷贝，页表中每个页表项除了记录物理页号，还记录了其他信息（属性位），用于标识虚拟页的权限（该页是否可写，可执行）的权限位，写时拷贝正式利用标识“是否可写”的权限位来实现的。写时拷贝允许应用 A 和应用 B 以只读的方式共享同一段物理内存，一单某个应用对该内存区域进行修改，就会触发缺页异常（这是由于违反权限导致的，不同于之前所说的换页机制下的未映射导致的）。在触发了缺页异常后，CPU 同样会将控制流传递给操作系统预先设置的缺页异常处理函数，在该函数中，操作系统会发现当前的缺页异常是由于应用程序写了只读内存，而且相应的内存区域又是被操作系统标记成写时拷贝的，于是操作系统会在物理内存中将缺页异常对应的物理页重新拷贝一份，并且将新拷贝的物理页以可读可写的方式重新映射给触发异常的应用程序，此后再恢复应用程序的执行。</li><li>内存去重，操作系统定期扫描具有相同内容的物理页，并找到映射到这些物理页的虚拟页，然后只保留其中一个物理页，将具有相同内容的其他虚拟页都用写时拷贝的方式映射到这个物理页，释放其他的物理页。Linux 中的 KSM 实现该功能。但是该功能会对性能产生影响。</li><li>内存压缩，当内存资源不足时，操作系统选择一些“最近不太会使用”的内存页，压缩其中的数据，从而释放更多空闲内存。如 Linux zswap。</li></ul><h2 id="第5章-进程与线程"><a href="#第5章-进程与线程" class="headerlink" title="第5章　进程与线程"></a>第5章　进程与线程</h2><p>进程的状态</p><ul><li>新生状态（new）：该状态表示一个进程刚刚被创建出来，还未完成初始化，不能被调度执行。在经过初始化过程之后，进程迁移至预备状态</li><li>预备状态（ready）：该状态表示进程可以被调度执行，但还未被调度器选择。由于 CPU 数量可能少于进程数量，在某一时刻只有部分进程能被调度到 CPU 上执行。此时，系统中其他的可被调度的进程都处于预备状态。在被调度器选择执行后，进程迁移至运行状态</li><li>运行状态（running）：该状态表示进程正在 CPU 上运行。当一个进程执行一段时间后，调度器可以选择中断它的执行并重新将其放回调度队列，它就迁移至预备状态。当进程运行结束，它会迁移至终止状态。如果一个进程需要等待某些外部事件，它可以放弃 CPU 并迁移至阻塞状态</li><li>阻塞状态（blocked）：该状态表示进程需要等待外部事件（如某个 I/O 请求的完成），暂时无法被调度。当进程等待的外部事件完成后，它会迁移至预备状态</li><li>终止状态（terminated）：该状态表示进程已经完成了执行，且不会再被调度</li></ul><p>进程的（虚拟内存）空间布局</p><ul><li>用户栈：栈保存了进程需要使用的各种临时数据（如临时变量的值）。栈是一种可以伸缩的数据结构，其扩展方向是自顶向下，栈底在高地址上，栈顶在低地址上。当临时数据被压入栈内时，栈顶会像低地址扩展。</li><li>代码库：进程的执行有时需要依赖共享的代码库（比如 libc），这些代码库会被映射到用户栈下方的虚拟地址处，并标记为只读。</li><li>用户堆：堆管理的是进程动态分配的内存。与栈相反，堆的扩展方向是自底向上，堆顶在高地址上，当进程需要更多内存时，堆顶会向高地址扩展。</li><li>数据与代码段：处于较低地址的是数据段与代码段，它们原本都保存在进程需要执行的二进制文件中，在进程执行前，操作系统会将它们载入虚拟地址空间。其中，数据段保存的是全局变量的值，代码段保存的是进程执行所需的代码。</li><li>内核部分：处于进程地址空间最顶端的是内核内存。每个进程的虚拟地址空间里都映射了相同的内核内存。当进程在用户态运行时，内核内存对其不可见；只有当进程进入内核态时，才能访问内核内存。与用户态相似，内核部分也有内核需要的代码和数据段，当进程由于中断或系统调用进入内核后，会使用内核的栈。</li></ul><p>每个进程都通过一个数据结构来保存它的相关状态，如进程标识符（PID）、进程状态、虚拟内存状态、打开的文件等。这个数据结构成为进程控制块（PCB）。在进行上下文切换时，会将前一个进程的寄存器状态保存到 PCB 中，然后将下一个进程先前保存的状态写入寄存器，从而切换到该进程执行。</p><p>进程的创建：fork，进程的执行：exec。 </p><p>进程间监控：wait，wait 可以用来等待子进程，来回收已经运行结束的子进程和释放资源。如果父进程没有调用 wait 操作，或者还没来得及调用 wait 操作，就算子进程已经终止了，它所占用的资源也不会完全释放，这种进程成为“僵尸进程”。内核会为僵尸进程保留其进程描述符 PID 和终止时的信息，以便父进程在调用 wait 时可以监控子进程的状态。由于管理 PID 也需要一定的内存开销，内核会设定最大可用 PID 的限制，如果一个进程创建了大量子进程却不调用 wait，那么僵尸进程会迅速占据可用 PID，使得后续的 fork 因为内核资源不足而失败。不过如果父进程退出了，那么子进程的信息就不再会被父进程使用，也就没有必要继续保留它们了。这时，所有父进程创建的僵尸进程都会被内核的第一个进程 init 通过 wait 的方式回收。</p><p>进程组是进程的集合，进程组的一大作用体现在对信号的处理，应用程序可以调用 killpg 向一个进程组发送信号，这个信号会被发送给这个进程组的每个进程。</p><p>会话是进程组的集合，可以由一个或多个进程组构成。会话将进程组根据执行状态分为前台进程组和后台进程组，控制终端进程是会话与外界进行交互的“窗口”，它负责接收从用户发来的输入。</p><p>fork 的优点：<br>简洁，fork 和 exec 的组合可以认为是将进程的创建过程进一步的解耦：fork 为进程搭建了“骨架”，而 exec 则为进程添加了“血肉”，两者的分工非常清晰，由于 fork 和 exec 的解耦，程序可以在 fork 调用后，exec 调用前，对子进程进行各种设定，比如对文件进行重定向。另外，fork 还强调了进程与进程之间的联系，由于 fork 具有创建原有进程的拷贝的语义，原进程与 fork 创建的进程之间存在较强的联系（父进程与子进程），这种联系为进程的管理提供了便利，比如在 Shell 中，虽然同一个 shell 创建的进程的功能不同，但是它们都来自同一个用户，因此可以共享很多状态。又如，web 服务场景中，服务器为每个请求单独创建一个进程，由于这些进程的逻辑相似，因此可以通过 fork 一次创建多个进程来应对用户的请求。</p><p>fork 的局限性：</p><ul><li>fork 过于复杂，由于 fork 到的默认语义是构造与父进程一样的拷贝，因此它会使得子进程与父进程共享大量状态，可能会使进程表现出看似违反直觉的行为。每当操作系统为进程的结构添加功能时，就必须考虑到对 fork 的实现和修改，fork 在实现过程中需要考虑的特殊情况越来越多，代码越来越复杂。另外由于 fork 的实现与进程、内存管理等模块的耦合程度越高，因此不利于内核的代码维护。</li><li>fork 的性能太差，由于 fork需要创建出原进程的一份拷贝，原进程的状态越多，fork 的性能就越差。尽管写时拷贝已经大大减少了内存拷贝，但对于这类应用来说，就连建立内存映射都需要耗费大量时间，fork 的效率已经满足不了它们的需要。</li><li>fork 存在潜在的安全漏洞，fork 建立的父进程与子进程之间的联系可能会成为攻击者的重要切入点。 </li></ul><p>除了以上三点，还有扩展性差、与异质硬件不兼容、线程不安全等。</p><p>Linux 针对 fork 提出了多种替代方案：</p><ul><li>posix_spawn：灵活度不如fork &amp; exec，但是性能要好于 fork&amp;exec</li><li>vfork：vfork 是 fork 的裁剪版，从父进程中创建出子进程，但是不会为子进程单独创建地址空间，只适合用在进程创建后立即使用 exec 的场景，vfork &amp; exec 相比 fork&amp;exec 省去了一次地址空间的拷贝。</li><li>rfork/clone：fork 的精密控制版本，允许应用程序通过参数对创建过程进行更多的控制</li></ul><p>进程抽象过于笨重：</p><ol><li>创建进程的开销较大，需要完成创建独立的地址空间、载入数据和代码段、初始化堆等步骤，即使使用 fork 接口创建进程，也需要对父进程的状态进行大量拷贝</li><li>由于进程拥有独立的虚拟地址空间，在进程间进行数据共享和同步比较麻烦，一般只能基于共享虚拟内存页（粒度较粗）或者基于进程间通信（开销较高）。</li></ol><p>因此提出在进程内部添加可独立执行的单元，它们共享进程的地址空间，但又各自保存运行时所需的状态（上下文），这就是线程。线程取代进程成为操作系统调度和管理程序的最小单位。</p><p>多线程的地址空间主要有两个重要特征：</p><ul><li>分离的内核栈和用户栈：由于每个线程的执行相对独立，进程为每个线程都准备了不同的栈，供它们存放临时数据。在内核中，每个线程也有对应的内核栈，当线程切换到内核中执行时，它的栈指针会切换到对应的内核栈</li><li>共享的其他区域：进程除栈以外的其他区域由该进程的所有线程共享，包括堆、数据段、代码段等。当一个进程的多个线程需要动态分配更多的内存时（在 C 语言中可通过调用 malloc 函数实现），它们的内存分配操作都是在同一个堆上完成的。因此 malloc 的实现需要使用“同步原语”，使每个线程能正确的获取可用的内存空间</li></ul><p>线程分为：用户态线程和内核态线程。有三种多线程模型：</p><ul><li>多对一模型</li><li>一对一模型（Linux &amp; Windows 默认）</li><li>多对多模型（macOS 和 iOS）  </li></ul><p>与进程类似，线程也有自己的线程控制块（TCB），用于保存与自身相关的信息。在目前主流的一对一线程模型中，内核态线程和用户态线程都会各自保存自己的 TCB。内核态 TCB 结构与 PCB 相似，会存储现成的运行状态、内存映射、标识符等信息。用户态 TCB 的结构则主要由线程库决定，对于 Linux 平台上使用 pthread 线程库的应用来说，pthread 结构体就是用户态的 TCB。用户态的 TCB 可以认为是内核态的扩展，可以用来存储更多与用户态相关的信息，其中一项重要的功能就是线程本地存储（TLS）。</p><p>sleep vs yield ：   </p><p>sleep 操作与 yield 有相似之处，他们都会让当前线程放弃 CPU 资源，交给其他线程执行。它们最重要的区别是调用后线程的状态。当线程调用 yield 后，它会处于预备状态，并可能很快就会被调度；在某些极端情况下，如果没有其他可调度线程，该线程甚至会继续执行。而当调用 sleep 之后，它会进入阻塞状态，只有满足条件后才会重新恢复到预备状态。可以把 yield 看做类似于 sleep（0），即挂起时间无限趋近于 0 的调用。</p><p>线程的上下文是上下文切换的基础，在实际硬件中，上下文主要指的是当前处理器中大部分寄存器的值，这其中包括：</p><ul><li>程序计数器（PC）存储 CPU 当前所执行指令的地址；</li><li>通用寄存器，存储 CPU 当前正在处理的一些数据；</li><li>特殊寄存器，存储 CPU 当前的一些硬件状态和配置，如页表地址等。</li></ul><h2 id="第6章-操作系统调度"><a href="#第6章-操作系统调度" class="headerlink" title="第6章　操作系统调度"></a>第6章　操作系统调度</h2><p>一般来说，一个系统会同时处理多个请求，但是其资源是优先的，调度就是用来协调每个请求对资源的使用的方法。调度中存在：优先级，时间片，截止时间等概念。</p><p>任务调度（task scheduling 也称 CPU 调度）负责调度可执行的任务对 CPU 的使用；I/O 调度负责对应该以何种顺序想存储设备发起 I/O 请求进行调度；内存管理也是一种调度，内存管理将虚拟内存映射到物理内存，物理内存是有限的资源，当需要使用的虚拟内存超过物理内存容量时，换页机制就是在对哪部分物理内页的内容可以留在内存中进行调度，并将剩余物理页上到的内容写回磁盘，进而复用那些剩余的物理页。</p><p>一般调度器会通过维护运行队列（run queue）的方式来管理任务，Linux 调度器会用红黑树来实现运行队列，任务在执行时若触发一定条件，则会停止执行，这些条件可以是：</p><ul><li>该任务执行了指定的时间片后，应让其他任务在当前 CPU 核心上执行</li><li>该任务发起了 I/O 请求，在 I/O 返回前，它不会继续执行</li><li>该任务主动停止执行或进入睡眠</li><li>该任务被系统中断打断，系统优先处理中断而暂缓该任务的执行</li></ul><p>调度器主要作用是做出调度决策，整个系统通过该决策进而决定如何调度，这些调度决策包括：</p><ul><li>从运行队列中选择下一个运行任务</li><li>决定执行该任务的 CPU 核心</li><li>决定该任务被允许执行的时间，即时间片</li></ul><p>调度器的设计问题主要可以归纳为两类：</p><ul><li>调度器应该做出什么样的调度决策（what）？</li><li>调度器应该如何做出符合预期的调度决策（how）？</li></ul><p>常用的调度指标包括：</p><ul><li>性能 <ul><li>吞吐量、周转时间、响应时间、调度开销 </li></ul></li><li>非性能 <ul><li>公平性、资源利用率 </li></ul></li><li>特殊 <ul><li>实时性、能耗 </li></ul></li></ul><p>调度器面临的挑战：</p><ul><li>调度指标多样性</li><li>调度可参考的信息有限</li><li>任务间的复杂交互</li><li>许多方便存在权衡</li></ul><p>调度器权衡包括但不限于一下几点：</p><ul><li>调度开销与调度效果</li><li>优先级与公平性</li><li>性能与能耗</li></ul><p>在任务调度中，长期、中期和短期调度相互协作，分别以不同的目标对进程进行调度。<br>长期任务的触发间隔较长，它粗粒度的决定是否应该将一个新的进程纳入调度管理，负责增加系统中可被调度的进程的数量；<br>中期调度的触发相对频繁，它辅助换页机制，负责限制系统中可被调度的进程的数量；<br>短期调度的触发最为频发，它负责细粒度的调度进程的执行，做出相应的调度决策。  </p><p>调度流程：</p><ol><li>在传统操作系统中，批处理任务被发起后，其信息会被存入磁盘中的批处理队列，等待被长期调度允许进入系统；</li><li>长期调度负责从批处理队列中选取下一个可被调度的批处理任务，为其创建对应的进程，将进程设为预备状态并放入运行队列；</li><li>由于交互任务和实时任务一般都有比较高的时延要求，需要在一定时间内返回结果。所以这两类任务一般不会被长期调度管理。系统会直接为他们创建对应的进程，将进程设为预备状态并放入运行队列；</li><li>通过短期调度的决策，运行队列中的进程会被调度到 CPU 上执行，此时进程为运行状态；</li><li>当进程运行完一个时间片后，短期调度会将其重新置为预备状态，并放回运行队列；</li><li>当运行中的进程发起 I/O 请求，等待用户输入或进入睡眠，因而需要被阻塞时，会被放入阻塞队列，短期调度会选择其他进程进行调度；</li><li>当进程等待的事件被触发后，操作系统直接将对应的进程移出阻塞队列，并将其置为预备状态，重新放入运行队列；</li><li>如果系统中的内存使用量偏大，就会触发换页机制，中期调度会挂起处于预备状态、阻塞状态的进程，将其置为挂起预备状态/挂起阻塞状态并放入挂起运行队列/挂起阻塞队列中；</li><li>处于挂起阻塞状态的进程，如果其等待的时间被处罚，会被置为挂起预备状态并被放入挂起运行队列中；</li><li>当系统的内存使用不再紧张时，中期调度会激活挂起运行队列/挂起阻塞队列中的进程，将其置为预备状态/阻塞状态并放回运行队列/阻塞队列中；</li><li>当进程结束后，会进入终止状态并最终被回收<h3 id="单核调度策略"><a href="#单核调度策略" class="headerlink" title="单核调度策略"></a>单核调度策略</h3><h4 id="经典调度"><a href="#经典调度" class="headerlink" title="经典调度"></a>经典调度</h4>先到先得（FCFS），<br>弊端：</li></ol><ul><li>在长短任务混合的场景下对短任务不友好</li><li>对 I/O 密集型任务不友好</li></ul><p>最短任务优先（SJF）</p><p>弊端：  </p><ul><li>必须预知任务的运行时间</li><li>其表现严重依赖与任务到达时间点</li><li>最短完成时间任务优先（STCF），SJF 的抢占式版本</li></ul><p>弊端：</p><ul><li>必须预知任务的运行时间</li><li>长任务饥饿</li></ul><p>时间片轮转（RR）</p><p>对于 RR 策略，一个关键点是它的时间片该如何选取。</p><p>弊端：</p><ul><li>在任务运行时间相似的场景下平均周转时间高，RR 一定程度上保证了每个任务之间的公平性，同时也可获得良好的响应时间，但是在特定场景下，任务的平均周转时间可能较差。</li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>多级队列（MLQ），每个任务会被分配预先设置好的优先级，每个优先级对应一个队列，任务会被存储在对应的优先级队列中。如果优先级不同的任务同时处于预备状态，那么调度器应该倾向于调度优先级较高的任务，因此一个任务必须等到所有优先级比它高的任务调度完成才可以被调度。处于相同优先级队列的任务，它们内部的调度方式没有统一标准，可以针对性的为不同队列采用不同的调度策略，如 FCFS 或 RR。</p><p>在设置 MLQ 策略的任务优先级时，需要注意将 I/O 密集型任务的优先级提高，保证 I/O 资源利用率。</p><p>弊端：</p><ul><li>低优先级任务饥饿，如果调度器需要保证一定的公平性，需要引入额外的机制监控任务等待时间，为等待时间过长（如超过一定的阈值）的任务提升优先级</li><li>优先级反转，在程序执行时，多个任务可能会对同一份数据产生竞争，因此任务会使用锁来保护共享数据。假设存在 3 个任务A，B，C，他们的优先级是 ABC，任务 C 在运行时持有一把锁，然后被高优先级的 A 抢占了，A 也想申请任务 C 持有的锁，但是申请失败，因此进入阻塞状态等待 C 释放锁，此时 BC 都处于可以运行状态，B 优先级高，因此 B 先运行，观察该情况，会发现 B 的优先级好像高于 A，这一问题称为优先级反转。一个可行的解决方案是优先级继承。</li></ul><p>多级反馈队列（MLFQ），在 MLQ 基础上，增加了动态设置任务优先级的策略，MLFQ 策略也会维护多个优先级队列，处于相同优先级的任务则采用 RR 策略执行，优先级的动态设置策略如下：</p><ul><li>短任务拥有更高的优先级，好处：1. 可以有更好的平均周转时间；2. I/O 密集型任务一般在 CPU 中执行的时间很短，给短任务提高优先级也相当于提高 I/O 密集型任务的优先级，提高系统的 I/O 资源利用率；3. 交互式任务一般是短任务，降低响应时间。根据每个任务（多次）执行时间来判断是短任务还是长任务。当任务进入系统中，假设任务是短任务，MLFQ 会为每个任务队列设置任务的最大运行时间，如果超过了最大时间，就会将该任务的优先级减一。</li><li>低优先级的任务采用更长的时间片，为了减少任务的调度次数，优先级月底的任务，其时间片越长，由于 MLFQ 策略支持抢占式调度，无须担心低优先级的任务阻塞新进入系统的任务。</li><li>定时将所有任务的优先级提升至最高，避免出现低优先级任务饥饿。</li></ul><p>公平共享调度</p><ul><li>“公平”是指任务对资源的使用符合用户预期</li></ul><p>公平共享调度会量化任务对系统资源的占有比例，从而实现对资源的公平调度。用份额（share）来量化每个任务对 CPU 时间的使用。份额支持曾计划的分配方式，可以将任务分组，以组为单位分配份额，任务组会在组内进一步分摊该组所拥有的份额。</p><p>优先级和份额都表示了任务在系统中的重要程度，但是目的是不同的。优先级调度是为了优化任务的周转时间、响应时间和资源利用率而设计的。不同任务的优先级只能用于相互比较，表明任务执行的先后。而基于份额的公平共享调度是为了让每个任务都能使用它应该获得的系统资源。分隔的值明确对应了任务应使用的系统资源比例。</p><p>彩票调度，彩票转让，彩票货币，彩票通胀。<br>弊端：</p><ul><li>随机数所带来的问题，彩票调度通过使用随机的方式实现了一个简单并且近似于公平共享的调度器，然而，随机数会导致某一任务占用 CPU 时间的比例，需要在该任务经历多次调度后，才能趋近于该任务的份额在所有任务总份额的比例。只有调度次数足够多，彩票调度效果才接近公平。<br>步幅调度，采用确定性的方式调度任务，核心概念是步幅。引入虚拟时间的概念。为了让虚拟时间短的任务能够“追赶”虚拟时间长的任务，使用虚拟时间的调度策略一般会选择调度所有任务中虚拟时间最少的任务。步幅调度通过设置虚拟时间的方式，让任务在每次调度时增加一定的虚拟时间，即步幅。经历虚拟时间相同的任务，它们使用的 CPU 时间之比就是步幅的倒数之比，换句话说，任务的份额之比正对应了任务的步幅的倒数之比。在真实的系统中，由于任务可能在任意时间进入系统，因此任务经历的虚拟时间不能为 0，而应该设置为当前所有任务的最小虚拟时间值，放置新进入的任务长时间占有 CPU。</li></ul><p>实时调度</p><p>根据任务超过截止时间所造成的后果分类：</p><ul><li>硬实时任务，该类任务必须在截止时间前完成</li><li>软实时任务，该类任务可以偶尔超过截止时间完成</li></ul><p>根据被触发的时间分类：</p><ul><li>周期任务，指到达系统时间遵循一定周期的任务</li><li>偶发任务，指不会周期性的到达系统的任务，且还要满足连续两个相同偶发任务到达系统的时间间隔有最小值，即系统不会在同一时刻处理两个相同的偶发任务。偶发任务通常是硬实时任务。</li><li>非周期性任务，指到达系统时间随机的任务，通常是软实时任务。</li></ul><h3 id="多核调度策略"><a href="#多核调度策略" class="headerlink" title="多核调度策略"></a>多核调度策略</h3><p>在多核上进行调度时，需要回答以下三个问题：</p><ul><li>当前应该调度哪个/哪些任务？</li><li>每个调度的任务应该在哪个 CPU 核心上执行？</li><li>每个调度的任务应该执行多久？</li></ul><p>负载分担</p><p>设想多核共享一个全局运行队列，当一个 CPU 核心需要调度任务时，根据给定的调度策略，决定全局运行队列中下一个由它执行的任务。给定的调度策略可以是任一一种单核调度策略，这种方法称为负载分担，因为系统的负载是被所有的 CPU 核心分担的。</p><p>优点：</p><ul><li>设计实现简单，通过使用负载分担，可以将多核调度问题规约为单核调度问题，使用已有的单核调度策略和单核调度器，就可以实现一个多核的全局调度器</li><li>每个 CPU 核心都会分担系统的负载，不会出现 CPU 资源浪费的情况，一个 CPU 核心执行完当前任务后，它会从全局任务队列中再选取一个任务执行，只要当前系统还有可以执行的任务，每个 CPU 核心都能获取到任务执行</li></ul><p>问题：</p><ul><li>多核共享一个全局运行队列的同步开销</li><li>任务在多个 CPU 核心间来回切换的开销，包括重新载入缓存，TLB 刷新等</li></ul><p>协同调度</p><p>为了满足对蚁族任务进行调度的需求，协同调度的概念应运而生。协同调度的目的是尽可能让一组任务并行执行，避免调度器同时调度有依赖关系的两组任务，同时避免关联任务执行效率降低的问题。</p><p>协同调度的经典策略是群组调度。</p><p>两级调度</p><p>为了减少任务在不同 CPU 核心上切换执行的开销，每个任务应尽可能只在一个 CPU 核心上进行调度。因此，新的调度策略改为每个 CPU 核心都引入一个本地调度器，并用它管理对应核心上执行的任务。这种调度策略使用全局调度器和本地调度器，构成了层级化结构，一般称为两级调度。</p><p>当一个任务进入系统时，全局调度器根据系统的当前信息，诸如每个 CPU 核心的负载情况，决定该任务应该被哪个 CPU 核心执行，当一个任务被分配给定的核心时，它将一直被该核心的本地调度器管理，不会迁移到其他 CPU 核心上执行。同时，每个本地调度器可以使用任意单核调度策略来调度任务。在避免线程在 CPU 核心间来回切换，提高了缓存局部性，较少了数据竞争的冲突的同时，这种曾计划的设计将设计单核调度策略与支持多核调度进行了解耦，使得调度器的设计实现更加灵活。以 Linux 为代表的一系列操作系统会为每个 CPU 核心分配一个本地运行队列，即可理解为每个 CPU 核心有一个本地调度器。</p><p>负载追踪与负载均衡</p><p>两级调度策略避免了任务在多核间切换，但是由于在任务开始时就指定了它在哪个 CPU 上运行，且没有任务在 CPU 核心间切换的机制，可能会导致多核间的负载不均衡，为了解决这个问题，引入了负载均衡的策略，负载均衡的思想是：通过追踪每个 CPU 核心当前的负载情况，将处于高负载的 CPU 核心管理的任务迁移至低负载的 CPU 核心上，尽可能的保证每个核心的负载大致相同。</p><p>负载均衡面临的挑战是：如何确定当前任务的负载情况，一个任务的执行负载是动态变化的，因此系统必须动态追踪当前的负载情况，这会造成一定的性能开销，如何保持低开销的同时对负载进行精确追踪是调度器设计实现的一大挑战，Linux 目前使用的是调度实体粒度负载追踪（PELT）。</p><p>运行队列粒度的负载追踪，在 Linux 3.8 以前，内核以每个 CPU 核心的运行队列为粒度计算负载，认为运行队列长的负载就高，导致负载追踪不够精确。</p><p>调度实体粒度的负载追踪，在 Linux 3.8 以后，Linux 使用了以调度实体（单个任务）为粒度的负载计算方式，做到了更细粒度的负载追踪。PELT通过记录每个任务的历史执行状况来表示任务的当前负载。具体的，调度器会以 1024 微妙作为一个周期，记录任务处于可运行状态（包括正在运行的以及等待被运行的）的时间，记为 x 微妙。该任务在第 i 个周期内对当前 CPU 的利用率为 x/1024，而对应的负载 Li 为 scale_cpu_capacity <em> x/1024 ，其中 scale_cpu_capacity 是 CPU 容量，可以理解为对应 CPU 核心的处理能力。在手机到任务每个周期内的负载后，PELT 需要计算一段时间内任务所有周期的累计负载，随着距离当前时间越远，数据参考意义越小，采用衰减系数 y 来计算：<br>L = L0 + L0 </em> y + L1 <em> y^2 + L2 </em> y ^3…. 通过计算每个任务的负载 L，PELT 就可以进而统计出每个运行队列的负载，便于调度器做出有效的迁移决策。</p><p>随着 CPU 核心数量越来越多，系统架构越来越复杂，负载均衡策略应该让任务尽量在迁移开销较小的 CPU核心间迁移，以 NUMA 架构为例，当任务从一个 NUMA 节点迁移到另一个 NUMA 节点，会严重影响任务的执行效率，又以超线程为例，一个物理核会被逻辑上分为两个逻辑核，任务在同属于一个五里河的两个逻辑核间切换的开销，会比在不同五里河的两个逻辑核间的开销小很多。</p><p>Linux 为了解决上述问题，采用层级化的方法，引入两个数据结构：调度与是有用相同特性的 CPU 核心的集合，这些核心间可以进行负载均衡。一个调度与保存一个或多个调度组，调度组是一个调度与内进行负载均衡的整体单位。通过自下而上的方式层级式的进行负载均衡，并且为了设计简单，只允许触发负载均衡的 CPU 核心拉取其他 CPU 核心的任务到本地。如果当前 CPU 核心触发负载均衡逻辑，首先在最底层调度域内的调度组间进行均衡，然后依次进入更高一级的调度域，并对其管理的调度组进行负载均衡。由于越高层级的调度域间进行负载均衡的开销越大，所以 Linux 为不同层级的调度域设置了不同的负载均衡触发频率与阈值。</p><p>对于非实时任务，Linux 使用 CFS 调度器进行调度，CFS 采用了累死公平共享调度的策略，因此其主要关心每个任务占用 CPU 时间的份额。sched_nice 为[-20,19] 的 Niceness ，越不友善的任务越倾向于使用更多的资源或抢占其他友善的任务。</p><p>Linux 调度器设计</p><p>O(n) 调度器</p><p>在 Linux 2.4 版本以前，Linux 调度器是一个机遇 RR 策略的运行队列，没有考虑很多因素（诸如任务的实时性要求）。从 Linux 2.4 版本开始，采用 O(n) 调度器，O(n) 调度器指定调度决策的时间复杂度是 O(n) ，n 代表的是调度器运行队列中的任务数量。</p><p>O(n) 调度器采用了负载分担的思想，所有任务被存储于一个全局运行队列中，被选择调度的任务会从运行队列中移除，当该任务执行完并且需要再次被调度时，会被重新放入运行队列的队尾。当调度器选择下一个被调度的任务时，需要遍历运行队列中的所有任务，并重新计算他们的动态优先级，然后选取动态优先级最高的任务。</p><p>存在问题：</p><ul><li>调度开销过大</li><li>多核扩展性差</li></ul><p>O(1) 调度器</p><p>由于O(n) 调度器存在上述问题，Linux 在 2.6.0 版本使用心得 O(1) 调度器替换 O(n) 调度器。 O(1) 调度器采用了两级调度的思想，每个 CPU 核心单独维护一个本地运行队列，让任务仅在同一个核心上调度。每个本地运行队列实际上是由两个多级队列：激活队列和过期队列组成的，分别用于管理仍有时间片剩余的任务和时间片耗尽的任务。当一个任务的时间片耗尽后，它会被加入到过期队列中。如果当前激活队列中没没有可调度的任务， O(1) 调度器会将两个队列的角色互换，开始新一轮调度。<br>每个多级队列都有 140 个优先级，其中高优先级 [0,100) 对应于实时任务，剩下的优先级 [100, 140) 对应于不同 Niceness 的非实时任务。每个多级队列都维护了一个位图，位图中的比特位用于判断对应的优先级队列是否有任务等待调度，在制定调度决策时， O(1) 调度器会根据位图找到激活队列中第一个不为空的队列，并调度该队列的第一个任务，其时间复杂度是 O(1) ，与运行队列中的任务数量无关。</p><p>用户可能不希望交互式任务在时间片用完后就需要等待所有其他任务的时间片用完才能再次执行，因此该类任务在时间片用完后，仍然会被加入激活队列中。同时，为了防止交互式任务过于激进而导致当前过期队列中的任务无法执行，当过期队列中的任务等待过长时间后， O(1) 调度器会把交互式任务加入过期多列中。</p><p>存在问题：</p><ul><li>交互式任务的判定算法过于复杂</li><li>静态时间片带来的问题， O(1) 调度器的非实时任务的运行时间片是根据其 Niceness 静态确定的，问题是，随着系统中任务数量的上升，任务的调度时延也会上升，对应的，响应时间也会受到影响。</li></ul><p>完全公平调度器</p><p>为了解决 O(1)调度器的问题，Linux 从 2.6.23 版本开始使用完全公平调度器。公平共享调度策略保证每个任务可以根据自己所占的份额共享 CPU 时间，这是 CFS 调度器的基本思想，O(1)调度器需要繁琐的通过启发式方法确定交互式任务，再给与交互式任务更多的执行机会。而 CFS 调度器只关心非实时任务对 CPU 时间的公平共享，避免了复杂的调度算法实现与调参。同时通过动态的设定任务时间片，确保了任务的调度时延不会过高。</p><p>CFS 调度器所使用的调度策略类似于步幅调度，vruntime 代表人物经过的虚拟时间，在调度是 CFS 会调度 vruntime 值最低的任务，Linux 静态的设置了 Niceness 与任务权重的对应关系，Niceness 越低则任务的权重越高，可被分配的 CPU 时间越多。</p><p>CFS 调度器的动态时间片，为了避免静态设置任务时间片所带来的问题，CFS 调度使用了调度周期的概念，并保证每经过一个调度周期，运行队列中所有任务都会被调度一次。因而在最坏的情况下，任务的调度时延即为一个调度周期。同时间片一样，调度周期会带来权衡问题。如果调度周期过长，则一系列任务必须在很长时间的运行后才能体现公平性，且任务的调度时延可能过长；如果调度周期过短，则调度开销会变大。</p><p>确定了 CFS 的调度周期后，调度器就可以开始计算在当前运行队列中，第 i 个任务的动态时间片 time_slice_i = sched_period * weight_i / weight_rq ，其中 weight_i 是第 i 个任务的权重，weight_rq 代表当前运行队列中的任务权重之和。</p><p>由于每个任务的动态时间片是不同的，都根据任务权重进行了缩放，所以任务每次执行后对 vruntime 的更新也要进行对应的缩放：<br>vruntime_i = vruntime_i + weight_nice0 / weight_i * real_runtime ，其中 weight_nice0 表示一个 Niceness 为 0 的任务的权重，该权重与 weight_i 的比值是一个系数，用于将任务的实际运行时间映射为虚拟时间。通过该系数，CFS 保证了不同动态时间片的任务执行完自己的时间片后，他们虚拟时间的增幅是一致的。</p><h2 id="第7章-进程间通信"><a href="#第7章-进程间通信" class="headerlink" title="第7章　进程间通信"></a>第7章　进程间通信</h2><p>共享内存 vs 基于共享内存的消息传递：基于共享内存的消息传递以共享内存为媒介进行消息的传输，其核心的通信抽象仍然是消息。共享内存的另一种使用方法是，直接在两个（多个）进程间建立共享区域，然后再共享区域上建立数据结构。进程可以直接使用该共享区域上的数据，而不存在”消息“的抽象。</p><p>宏内核下的典型的进程间通信机制：管道，消息队列，信号量，共享内存，信号，套接字。</p><h2 id="第8章-同步原语"><a href="#第8章-同步原语" class="headerlink" title="第8章　同步原语"></a>第8章　同步原语</h2><p>实际应用程序中有很多需要同步的场景，为了正确，搞笑的解决这些同步问题，抽象出了一系列同步原语。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当程序的正确性依赖于特定执行顺序的情况时，被称为竞争冒险。避免竞争冒险最直接的办法就是：确保同一时刻只有生产者中的一个能够对共享缓冲区进行操作。任意时刻只允许至多一个线程访问的方式被称为互斥访问，而保证互斥访问共享资源的代码区域被称为临界区。</p><p>需要满足以下条件：</p><ul><li>互斥访问：在同一时刻，最多只能有一个线程可以执行临界区</li><li>有限等待：当一个线程申请进入临界区后，必须在有限的时间内获得许可并进入临界区，不能无限等待</li><li>空闲让进：当没有线程在执行临界区代码时，必须在申请进入临界区的线程中选择一个线程，允许其执行临界区代码，保证程序执行的进展。</li></ul><p>硬件实现：关闭中断。   </p><p>关闭中断可以防止执行临界区的线程被抢占，避免多个线程同时执行临界区，保证了互斥访问。而有限等待依赖于内核的调度器，如果能保证有限时间内调度到该线程，则该线程可以再有限时间内进入临界区，达成有限等待的要求。最后，每个线程离开临界区时都开启了中断，允许调度器调度其他线程执行，达成了空闲让进的要求。但是多核环境中，即使关闭了所有核心的中断，也不能阻塞其他核心上正在运行的线程继续执行。</p><p>软件实现：皮特森算法<a href="https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95。" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95。</a></p><p>软硬件协同：使用原子操作实现互斥锁。原子操作指的是不可被打断的一个或一系列操作。即要么这一系列指令都执行完成，要么都没有执行，最常见的是比较与置换 （CAS）拿取并累加（FAA）。</p><p>互斥锁的实现种类多，不同的互斥锁被用于不同的场景，比如利用原子 CAS 实现的自旋锁，利用原子 FAA 实现的排号自旋锁。</p><p>自旋锁：利用一个变量 lock 表示锁的状态，lock 为 1 表示已经有人拿锁，为 0 表示空闲。在加锁时，线程会通过 CAS 判断 lock 是否为空闲，如果空闲则上锁，否则将一遍一遍重试。放锁时，直接将 lock 设置为 0 表示其空闲。自旋锁不能保证有限等待，即不具有公平性。自旋锁并非按照申请的顺序决定下一个获取锁的竞争者，而是让所有的竞争者均同时尝试完成原子操作。</p><p>排号自旋锁：排号自旋锁按照锁竞争者申请锁的顺序传递锁，锁的竞争者组成了一个 FIFO 的等待队列。排号锁的结构体有两个成员，owner 表示当前锁持有者序号，next 表示下一个需要分发的序号。获取排号所需要先通过原子的 FAA 操作拿到最新的序号并同时增加锁的分发序号，来避免其他竞争者拿到相同的序号。拿到序号后，竞争者通过判断 owner 的值，等待排到自己的序号，一旦两者想等，竞争者拥有该锁并被允许进入临界区。释放锁时，持有者更新 owner 的值将锁传递给下一个竞争者，保证了公平性。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>使用条件变量提供的借口，一个线程可以停止使用 CPU 并将自己挂起，当等待的条件满足时，其他的线程会唤醒该挂起的线程让其继续执行，使用条件变量能够有效的避免无谓的循环等待。</p><p>互斥锁 vs 条件变量：   </p><p>互斥锁与条件变量解决的不是同一个问题，互斥锁用于解决临界区的问题，保证互斥访问共享资源。而条件变量通过提供挂起/唤醒机制来避免循环等待，节省 CPU 资源。条件变量需要和互斥锁搭配使用。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量在不同的线程之间充当信号灯，根据剩余资源数量控制不同线程的执行或等待。信号量又被成为 PV 原语，P 为校验，V 为自增。</p><p>互斥锁 vs 信号量：<br>互斥锁与信号量有相似之处。当信号量的初始值为 1，且只允许其值在 0 和 1 之间变化时，wait 和 signal 操作分别于互斥锁的 lock 和 unlock 操作类似，称这种信号量为二院信号量。二元信号量与互斥锁的差别在于：互斥锁有拥有者概念，二元信号量没有。互斥锁往往由同一个线程加锁和放锁，信号量允许不同线程执行 wait 与 signal 操作。互斥锁与计数信号量（非二元信号量）区别较大，计数信号量允许多个线程通过，其数量等于剩余可用资源数量；而互斥锁同一时刻只允许一个线程获取。互斥锁用于保证多个线程对一个共享资源的互斥访问，而信号量用于协调多个线程对一系列共享资源的有序操作。</p><p>条件变量 vs 信号量：<br>信号量是由条件变量、互斥锁以及计数器实现的。而这个计数器就是信号量的核心，用于表示当前可用资源的数量。可以理解为：信号量利用条件变量实现了更高层级的抽象。</p><p>同步带来的问题</p><p>死锁</p><p>死锁产生的必要条件： </p><ul><li>互斥访问</li><li>持有并等待</li><li>资源非抢占</li><li>循环等待</li></ul><p>优先级反转：由于同步导致线程执行顺序违反预设优先级的问题。</p><p>解决方法：</p><ul><li>不可抢占临界区协议，核心时避免线程在临界区中被抢占，当线程获取锁，编不允许任何其他线程抢占。</li><li>优先级继承协议，在高优先级线程等待锁时，会使锁的持有者继承其优先级，从而避免该锁的临界区被低优先级的任务打断。</li><li>优先级置顶协议，将获取锁的线程的优先级置为可能竞争该锁的最高优先级。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第1章-操作系统概述&quot;&gt;&lt;a href=&quot;#第1章-操作系统概述&quot; class=&quot;headerlink&quot; title=&quot;第1章　操作系统概述&quot;&gt;&lt;/a&gt;第1章　操作系统概述&lt;/h2&gt;&lt;p&gt;操作系统有两个职责：对硬件进行管理和抽象，为应用提供服务并进行管理。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>Podman(Docker) Compose 学习记录</title>
    <link href="https://zdyxry.github.io/2021/01/09/Podman-Docker-Compose-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2021/01/09/Podman-Docker-Compose-学习记录/</id>
    <published>2021-01-09T18:56:30.000Z</published>
    <updated>2022-01-10T10:49:33.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>最近因为一些需求可能需要用到 Compose，看了看 Podman Compose 和 Docker Compose，记录一下。</p><p>Compose 主要功能：</p><ul><li>环境隔离(docker)</li><li>一组服务的起停控制</li><li>服务之间的依赖管理</li></ul><h2 id="Podman-compose"><a href="#Podman-compose" class="headerlink" title="Podman compose"></a>Podman compose</h2><p>项目地址：<a href="https://github.com/containers/podman-compose" target="_blank" rel="noopener">https://github.com/containers/podman-compose</a></p><p>用爱发电的项目，所有的实现都在 <code>podman_compose.py</code> 中，由于 Podman 没有一个好用的 client ，所以 compose 中所有的 Podman 相关的交互都是通过命令行来完成的，目前处于一个非常早期的状态，最基本的服务依赖都没有实现，不建议使用。</p><h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cli/            # 命令行解析</span><br><span class="line">config/         # 配置文件格式、校验方式、辅助函数</span><br><span class="line">const.py        # constants</span><br><span class="line">container.py    # 使用 docker client 对 container 命令及属性进行封装</span><br><span class="line">errors.py       # error code</span><br><span class="line">network.py      # 网络相关配置</span><br><span class="line">parallel.py     # 并发操作封装</span><br><span class="line">progress_stream.py # stream 相关</span><br><span class="line">project.py      # project，project 与 service 是一对多的关系</span><br><span class="line">service.py      # service，service 与 container 是一对一或一对多的关系</span><br><span class="line">timeparse.py    # 时间转换</span><br><span class="line">utils.py        # utils function</span><br><span class="line">volume.py       # volume 相关封装</span><br></pre></td></tr></table></figure><p>Docker 官方提供，所有的 container 都通过 docker python client 进行。service 之间的依赖管理通过拓扑排序实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def sort_service_dicts(services):</span><br><span class="line">    # Topological sort (Cormen/Tarjan algorithm).</span><br><span class="line">    unmarked = services[:]</span><br><span class="line">    temporary_marked = set()</span><br><span class="line">    sorted_services = []</span><br><span class="line"></span><br><span class="line">    def visit(n):</span><br><span class="line">        if n[&apos;name&apos;] in temporary_marked:</span><br><span class="line">            if n[&apos;name&apos;] in get_service_names(n.get(&apos;links&apos;, [])):</span><br><span class="line">                raise DependencyError(&apos;A service can not link to itself: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            if n[&apos;name&apos;] in n.get(&apos;volumes_from&apos;, []):</span><br><span class="line">                raise DependencyError(&apos;A service can not mount itself as volume: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            if n[&apos;name&apos;] in n.get(&apos;depends_on&apos;, []):</span><br><span class="line">                raise DependencyError(&apos;A service can not depend on itself: %s&apos; % n[&apos;name&apos;])</span><br><span class="line">            raise DependencyError(&apos;Circular dependency between %s&apos; % &apos; and &apos;.join(temporary_marked))</span><br><span class="line"></span><br><span class="line">        if n in unmarked:</span><br><span class="line">            temporary_marked.add(n[&apos;name&apos;])</span><br><span class="line">            for m in get_service_dependents(n, services):</span><br><span class="line">                visit(m)</span><br><span class="line">            temporary_marked.remove(n[&apos;name&apos;])</span><br><span class="line">            unmarked.remove(n)</span><br><span class="line">            sorted_services.insert(0, n)</span><br><span class="line"></span><br><span class="line">    while unmarked:</span><br><span class="line">        visit(unmarked[-1])</span><br><span class="line"></span><br><span class="line">    return sorted_services</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.project.up()</span><br><span class="line">    project:initialize()</span><br><span class="line">        self.networks.initialize()</span><br><span class="line">        self.volumes.initialize()</span><br><span class="line">    self.get_services_without_duplicate()</span><br><span class="line">    svc.ensure_image_exists()</span><br><span class="line">    self._get_convergence_plans()</span><br><span class="line">    parallel.parallel_execute()</span><br><span class="line">        service.execute_convergence_plan()</span><br><span class="line">        self._execute_convergence_create()</span><br><span class="line">            parallel_execute()</span><br><span class="line">                create_and_start()</span><br><span class="line">                    service.create_container()</span><br><span class="line">                    self.start_container()</span><br><span class="line">log_printer.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Compose&quot;&gt;&lt;a href=&quot;#Compose&quot; class=&quot;headerlink&quot; title=&quot;Compose&quot;&gt;&lt;/a&gt;Compose&lt;/h2&gt;&lt;p&gt;最近因为一些需求可能需要用到 Compose，看了看 Podman Compose 和 Docker
      
    
    </summary>
    
    
      <category term="Container" scheme="https://zdyxry.github.io/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>cgroups notification API demo</title>
    <link href="https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/"/>
    <id>https://zdyxry.github.io/2021/01/01/cgroups-notification-API-demo/</id>
    <published>2021-01-01T18:28:00.000Z</published>
    <updated>2022-01-10T10:49:33.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cgroups-notification-API-demo"><a href="#cgroups-notification-API-demo" class="headerlink" title="cgroups notification API demo"></a>cgroups notification API demo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"flag"</span></span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"io/ioutil"</span></span><br><span class="line">        <span class="string">"os"</span></span><br><span class="line">        <span class="string">"path/filepath"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"golang.org/x/sys/unix"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cgName := flag.String(<span class="string">"cgName"</span>, <span class="string">"yiran"</span>, <span class="string">"cgroup path"</span>)</span><br><span class="line">        flag.Parse()</span><br><span class="line">        level := <span class="string">"critical"</span></span><br><span class="line">        cgDir := filepath.Join(<span class="string">"/sys/fs/cgroup/memory/"</span>, *cgName)</span><br><span class="line">        evName := <span class="string">"memory.pressure_level"</span></span><br><span class="line">        fmt.Printf(<span class="string">"cgroup name is: %s\n"</span>, *cgName)</span><br><span class="line">        fmt.Printf(<span class="string">"cgroup path is: %s\n"</span>, cgDir)</span><br><span class="line">        fmt.Printf(<span class="string">"cgroup event name is: %s\n"</span>, evName)</span><br><span class="line"></span><br><span class="line">        evFile, err := os.Open(filepath.Join(cgDir, evName))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fd, err := unix.Eventfd(<span class="number">0</span>, unix.EFD_CLOEXEC)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                evFile.Close()</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eventfd := os.NewFile(<span class="keyword">uintptr</span>(fd), <span class="string">"eventfd"</span>)</span><br><span class="line"></span><br><span class="line">        eventControlPath := filepath.Join(cgDir, <span class="string">"cgroup.event_control"</span>)</span><br><span class="line">        data := fmt.Sprintf(<span class="string">"%d %d %s"</span>, eventfd.Fd(), evFile.Fd(), level)</span><br><span class="line">        <span class="keyword">if</span> err := ioutil.WriteFile(eventControlPath, []<span class="keyword">byte</span>(data), <span class="number">0700</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                eventfd.Close()</span><br><span class="line">                evFile.Close()</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                eventfd.Close()</span><br><span class="line">                evFile.Close()</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"start..."</span>)</span><br><span class="line">                <span class="keyword">if</span> _, err := eventfd.Read(buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="built_in">panic</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> _, err := os.Lstat(eventControlPath); os.IsNotExist(err) &#123;</span><br><span class="line">                        <span class="built_in">panic</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">                fmt.Println(<span class="string">"test success ..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备 memory cgroup 配置，并限制内存上限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go build /tmp/demo.go</span><br><span class="line">mkdir /sys/fs/cgroup/memory/yiran/</span><br><span class="line"><span class="built_in">echo</span> 10M &gt;  /sys/fs/cgroup/memory/yiran/memory.limit_in_bytes</span><br><span class="line"><span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/memory/yiran/tasks</span><br><span class="line">nohup /tmp/demo -cgName=yiran &amp; </span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero | <span class="built_in">read</span> x</span><br></pre></td></tr></table></figure><p><code>tailf /tmp/nohup.out</code> 查看输出结果。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cgroups-notification-API-demo&quot;&gt;&lt;a href=&quot;#cgroups-notification-API-demo&quot; class=&quot;headerlink&quot; title=&quot;cgroups notification API demo&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
      <category term="cgroups" scheme="https://zdyxry.github.io/tags/cgroups/"/>
    
  </entry>
  
  <entry>
    <title>2020 年终总结</title>
    <link href="https://zdyxry.github.io/2020/12/31/2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://zdyxry.github.io/2020/12/31/2020-年终总结/</id>
    <published>2020-12-31T08:42:51.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>减重 70 斤，身体达到近 10 年最健康的状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2020&quot;&gt;&lt;a href=&quot;#2020&quot; class=&quot;headerlink&quot; title=&quot;2020&quot;&gt;&lt;/a&gt;2020&lt;/h2&gt;&lt;p&gt;减重 70 斤，身体达到近 10 年最健康的状态。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020年读书记录</title>
    <link href="https://zdyxry.github.io/2020/12/28/2020%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/12/28/2020年读书记录/</id>
    <published>2020-12-28T09:03:03.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><ul><li><a href="https://zdyxry.github.io/2016/12/31/2016%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2016</a><ul><li>计划读 5 本，实际读 13 本。</li></ul></li><li><a href="https://zdyxry.github.io/2017/12/31/2017%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2017</a><ul><li>计划 32 本，实际读完 23 本。</li></ul></li><li><a href="https://zdyxry.github.io/2018/12/30/2018%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2018</a><ul><li>计划 30 本，实际25本。</li></ul></li><li><a href="https://zdyxry.github.io/2019/12/09/2019%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">2019</a><ul><li>计划 30 本，实际 43 本。</li></ul></li><li>2020<ul><li>计划 30 本，实际 40 本。</li></ul></li></ul><h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><ol><li>《时间的秩序》</li><li>《肠子的小心思》</li><li>《饮食的迷思》</li><li>《认知天性》</li><li>《Linux/UNIX系统编程手册》</li><li>《码农翻身》</li><li>《庆余年》</li><li>《凤凰项目》</li><li>《编程珠玑》</li><li>《了不起的我》</li><li>《见识》</li><li>《重来》</li><li>《重来2》</li><li>《Unix/Linux编程实践教程》</li><li>《漫画数据库》</li><li>《程序员修炼之道》</li><li>《Flask Web开发：基于Python的Web应用开发实战》</li><li>《HTTP权威指南》</li><li>《计算机网络（第7版）》</li><li>《程序员的数学》</li><li>《把时间当作朋友》</li><li>《KVM Virtualization Cookbook》</li><li>《Go语言学习笔记》</li><li>《UNIX网络编程》</li><li>《现代操作系统（原书第4版）》</li><li>《基本无害》</li><li>《宇宙尽头的餐馆》</li><li>《生命，宇宙以及一切》</li><li>《再会，谢谢所有的鱼》</li><li>《畅游日本（第3版）》</li><li>《基本穿搭》</li><li>《囚徒健身》</li><li>《蛤蟆先生去看心理医生》</li><li>《天生有罪》</li><li>《数据密集型应用系统设计》</li><li>《高效能人士的七个习惯》</li><li>《咖啡咖啡》</li><li>《TCP/IP网络编程》</li><li>《献给阿尔吉侬的花束》</li><li>《囚徒增肌》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;年终总结&quot;&gt;&lt;a href=&quot;#年终总结&quot; class=&quot;headerlink&quot; title=&quot;年终总结&quot;&gt;&lt;/a&gt;年终总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zdyxry.github.io/2016/12/31/2016%E5%B9%
      
    
    </summary>
    
    
      <category term="Book" scheme="https://zdyxry.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>2020 第39周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/26/2020-%E7%AC%AC39%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/26/2020-第39周-LeetCode-记录/</id>
    <published>2020-09-26T17:08:07.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1588-Sum-of-All-Odd-Length-Subarrays"><a href="#1588-Sum-of-All-Odd-Length-Subarrays" class="headerlink" title="1588. Sum of All Odd Length Subarrays"></a>1588. Sum of All Odd Length Subarrays</h3><p>处理当长度为 1 时特殊情况，其他都遍历长度为奇数情况然后求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                    res += sum(arr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> j + i &lt;= len(arr):</span><br><span class="line">                        res += sum(arr[j:j+i])</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1592-Rearrange-Spaces-Between-Words"><a href="#1592-Rearrange-Spaces-Between-Words" class="headerlink" title="1592. Rearrange Spaces Between Words"></a>1592. Rearrange Spaces Between Words</h3><p>统计空格出现的次数，然后求出平均空格数进行字符串拼接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderSpaces</span><span class="params">(self, text: str)</span> -&gt; str:</span></span><br><span class="line">        cnt=text.count(<span class="string">" "</span>)</span><br><span class="line">        n = text.split()</span><br><span class="line">        <span class="keyword">if</span> len(n)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> text.strip()+cnt*<span class="string">" "</span></span><br><span class="line">        space,last = divmod(cnt,len(n)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">" "</span>*space).join(n)+<span class="string">" "</span>*last</span><br></pre></td></tr></table></figure><h3 id="1593-Split-a-String-Into-the-Max-Number-of-Unique-Substrings"><a href="#1593-Split-a-String-Into-the-Max-Number-of-Unique-Substrings" class="headerlink" title="1593. Split a String Into the Max Number of Unique Substrings"></a>1593. Split a String Into the Max Number of Unique Substrings</h3><p>回溯法，使用集合记录出现过的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxUniqueSplit</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        d = set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(num, sub)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> sub:</span><br><span class="line">                self.ans = max(num, self.ans)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">in</span> d: <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sub) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> sub[:i] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d.add(sub[:i])</span><br><span class="line">                    helper(num + <span class="number">1</span>, sub[i:])</span><br><span class="line">                    d.remove(sub[:i]) </span><br><span class="line">                    </span><br><span class="line">        helper(<span class="number">0</span>, s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><h3 id="814-Binary-Tree-Pruning"><a href="#814-Binary-Tree-Pruning" class="headerlink" title="814. Binary Tree Pruning"></a>814. Binary Tree Pruning</h3><p>如果叶子节点的左子树和右子树为空且当前值为 0，则将其置为空，递归剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left = self.pruneTree(root.left)</span><br><span class="line">        root.right = self.pruneTree(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a>1008. Construct Binary Search Tree from Preorder Traversal</h3><p>提供先序遍历，构造二叉树，先序遍历的第一个元素是 root 节点，分别遍历之后元素，如果元素比 root 小，则记录到root 左子树中，反之记录到 root 右子树中，递归构造。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstFromPreorder</span><span class="params">(self, preorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        leftList = []</span><br><span class="line">        rightList = []</span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> preorder[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> num &lt; preorder[<span class="number">0</span>]:</span><br><span class="line">                leftList.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &gt; preorder[<span class="number">0</span>]:</span><br><span class="line">                rightList.append(num)</span><br><span class="line">        root.left = self.bstFromPreorder(leftList)</span><br><span class="line">        root.right = self.bstFromPreorder(rightList)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1588-Sum-of-All-Odd-Length-Subarrays&quot;&gt;&lt;a href=&quot;#1588-Sum-of-All-Odd-Length-Subarrays&quot; class=&quot;headerlink&quot; title=&quot;1588. Sum of All Odd
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第38周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/20/2020-%E7%AC%AC38%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/20/2020-第38周-LeetCode-记录/</id>
    <published>2020-09-20T07:45:55.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1582-Special-Positions-in-a-Binary-Matrix"><a href="#1582-Special-Positions-in-a-Binary-Matrix" class="headerlink" title="1582. Special Positions in a Binary Matrix"></a>1582. Special Positions in a Binary Matrix</h3><p>直接遍历二维数组之后，如果某个位置是 1，再去统计每行的和和每列的和是否为 1 时间复杂度太高，可以先统计每行每列的和，然后再遍历二维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecial</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n, ans = len(mat), len(mat[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">        row, col = [<span class="number">0</span>] * m, [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]:</span><br><span class="line">                    row[i] += <span class="number">1</span></span><br><span class="line">                    col[j] += <span class="number">1</span></span><br><span class="line">        pool = [j <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> col[j] == <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> row[i] != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> pool:</span><br><span class="line">                <span class="keyword">if</span> mat[i][j]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1025-Divisor-Game"><a href="#1025-Divisor-Game" class="headerlink" title="1025. Divisor Game"></a>1025. Divisor Game</h3><blockquote><p>如果N是奇数，因为奇数的所有因数都是奇数，因此 N 进行一次 N-x 的操作结果一定是偶数，所以如果 a 拿到了一个奇数，那么轮到 b 的时候，b拿到的肯定是偶数，这个时候 b 只要进行 -1， 还给 a 一个奇数，那么这样子b就会一直拿到偶数，到最后b一定会拿到最小偶数2，a就输了。</p><p>所以如果游戏开始时Alice拿到N为奇数，那么她必输，也就是false。如果拿到N为偶数，她只用 -1，让bob 拿到奇数，最后bob必输，结果就是true。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> N%<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="1583-Count-Unhappy-Friends"><a href="#1583-Count-Unhappy-Friends" class="headerlink" title="1583. Count Unhappy Friends"></a>1583. Count Unhappy Friends</h3><p>题目有些绕，python 可以直接用 <code>index</code> 方法来切片，golang 只能自己实现了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unhappyFriends</span><span class="params">(self, n: int, preferences: List[List[int]], pairs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        dd = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> pairs:</span><br><span class="line">            dd[i] = preferences[i][:preferences[i].index(x)]</span><br><span class="line">            dd[x] = preferences[x][:preferences[x].index(i)]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        print(dd)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dd:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> dd[i]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> dd[x]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1282-Group-the-People-Given-the-Group-Size-They-Belong-To"><a href="#1282-Group-the-People-Given-the-Group-Size-They-Belong-To" class="headerlink" title="1282. Group the People Given the Group Size They Belong To"></a>1282. Group the People Given the Group Size They Belong To</h3><p>对分组进行统计，组人数作为 key，在该人数的用户索引列表作为 value，然后遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupThePeople</span><span class="params">(self, groupSizes: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        groups = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, _id <span class="keyword">in</span> enumerate(groupSizes):</span><br><span class="line">            groups[_id].append(i)</span><br><span class="line">        </span><br><span class="line">        ans = list()</span><br><span class="line">        <span class="keyword">for</span> gsize, users <span class="keyword">in</span> groups.items():</span><br><span class="line">            <span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">0</span>, len(users), gsize):</span><br><span class="line">                ans.append(users[it : it + gsize])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1305-All-Elements-in-Two-Binary-Search-Trees"><a href="#1305-All-Elements-in-Two-Binary-Search-Trees" class="headerlink" title="1305. All Elements in Two Binary Search Trees"></a>1305. All Elements in Two Binary Search Trees</h3><p>如果只是单纯的用列表存储所有值，然后进行排序是最简单的实现方式，但是这道题考察的应该是归并排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAllElements</span><span class="params">(self, root1: TreeNode, root2: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, v)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.left, v)</span><br><span class="line">            v.append(node.val)</span><br><span class="line">            dfs(node.right, v)</span><br><span class="line">        </span><br><span class="line">        v1, v2 = list(), list()</span><br><span class="line">        dfs(root1, v1)</span><br><span class="line">        dfs(root2, v2)</span><br><span class="line">        ans, i, j = list(), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(v1) <span class="keyword">or</span> j &lt; len(v2):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(v1) <span class="keyword">and</span> (j == len(v2) <span class="keyword">or</span> v1[i] &lt;= v2[j]):</span><br><span class="line">                ans.append(v1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(v2[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1582-Special-Positions-in-a-Binary-Matrix&quot;&gt;&lt;a href=&quot;#1582-Special-Positions-in-a-Binary-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1582. Spec
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第37周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/13/2020-%E7%AC%AC37%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/13/2020-第37周-LeetCode-记录/</id>
    <published>2020-09-13T10:51:05.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1572-Matrix-Diagonal-Sum"><a href="#1572-Matrix-Diagonal-Sum" class="headerlink" title="1572. Matrix Diagonal Sum"></a>1572. Matrix Diagonal Sum</h3><p>对角线之和，需要注意当行为奇数和偶数时候的去重处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diagonalSum</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(mat)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != n<span class="number">-1</span>-i:</span><br><span class="line">                ans += mat[i][i]</span><br><span class="line">                ans += mat[i][n<span class="number">-1</span>-i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += mat[i][i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1576-Replace-All-’s-to-Avoid-Consecutive-Repeating-Characters"><a href="#1576-Replace-All-’s-to-Avoid-Consecutive-Repeating-Characters" class="headerlink" title="1576. Replace All ?’s to Avoid Consecutive Repeating Characters"></a>1576. Replace All ?’s to Avoid Consecutive Repeating Characters</h3><p>题目中说的是不能出现连续相同的字符，整个字符串中是可以出现重复字符的，只需要遍历字符串，然后判断前后是否相同替换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modifyString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        l = list(s)</span><br><span class="line">        alphabet = list(string.ascii_lowercase)</span><br><span class="line">        <span class="keyword">for</span> i, _ <span class="keyword">in</span> enumerate(l):</span><br><span class="line">            <span class="keyword">if</span> l[i] == <span class="string">"?"</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> alphabet:</span><br><span class="line">                    <span class="keyword">if</span> i == len(l) - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> l[i<span class="number">-1</span>] != j:</span><br><span class="line">                            l[i] = j</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> l[i<span class="number">-1</span>] != j <span class="keyword">and</span> l[i+<span class="number">1</span>] != j:</span><br><span class="line">                        l[i] = j</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(l)</span><br></pre></td></tr></table></figure><h3 id="1578-Minimum-Deletion-Cost-to-Avoid-Repeating-Letters"><a href="#1578-Minimum-Deletion-Cost-to-Avoid-Repeating-Letters" class="headerlink" title="1578. Minimum Deletion Cost to Avoid Repeating Letters"></a>1578. Minimum Deletion Cost to Avoid Repeating Letters</h3><p>给一个字符串 s 和一个整数数组 cost ，其中 cost[i] 是从 s 中删除字符 i 的代价。返回使字符串任意相邻两个字母不相同的最小删除成本。如果当前字符与前一个字符相同，那么比较当前字符的价格与前一个字符的价格对比，取小；当前一个字符的价格比当前价格大时，那么此时更新 pre 为当前字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, s: str, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[idx] == s[pre]:</span><br><span class="line">                res += min(cost[idx], cost[pre])</span><br><span class="line">            <span class="keyword">if</span> s[idx] != s[pre] <span class="keyword">or</span> cost[pre] &lt; cost[idx]:</span><br><span class="line">                pre = idx</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="763-Partition-Labels"><a href="#763-Partition-Labels" class="headerlink" title="763. Partition Labels"></a>763. Partition Labels</h3><p>字符串 S 由小写字母组成。要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。定义数组 last[char] 来表示字符 char 最后一次出现的下标。定义 anchor 和 j 来表示当前区间的首尾。如果遇到的字符最后一次出现的位置下标大于 j， 就让 j=last[c] 来拓展当前的区间。当遍历到了当前区间的末尾时(即 i==j )，把当前区间加入答案，同时将 start 设为 i+1 去找下一个区间。</p><blockquote><p><a href="https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span><span class="params">(self, S: str)</span> -&gt; List[int]:</span></span><br><span class="line">        last = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(S)&#125;</span><br><span class="line">        j = anchor = <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            j = max(j, last[c])</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                ans.append(i - anchor + <span class="number">1</span>)</span><br><span class="line">                anchor = i + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1252-Cells-with-Odd-Values-in-a-Matrix"><a href="#1252-Cells-with-Odd-Values-in-a-Matrix" class="headerlink" title="1252. Cells with Odd Values in a Matrix"></a>1252. Cells with Odd Values in a Matrix</h3><p>如果从正向方式求解会出现遍历二维数组 * 遍历 indices 的情况，可以先构造一个二维数组，然后遍历 indices 模拟数组，最终判断数组中的奇数个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddCells</span><span class="params">(self, n: int, m: int, indices: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        rows = [<span class="number">0</span>] * n</span><br><span class="line">        cols = [<span class="number">0</span>] * m</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> indices:</span><br><span class="line">            rows[x] += <span class="number">1</span></span><br><span class="line">            cols[y] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum((rows[x] + cols[y]) % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(n) <span class="keyword">for</span> y <span class="keyword">in</span> range(m))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1572-Matrix-Diagonal-Sum&quot;&gt;&lt;a href=&quot;#1572-Matrix-Diagonal-Sum&quot; class=&quot;headerlink&quot; title=&quot;1572. Matrix Diagonal Sum&quot;&gt;&lt;/a&gt;1572. Matrix 
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第36周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/09/06/2020-%E7%AC%AC36%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/09/06/2020-第36周-LeetCode-记录/</id>
    <published>2020-09-06T15:04:19.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times"><a href="#1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times" class="headerlink" title="1566. Detect Pattern of Length M Repeated K or More Times"></a>1566. Detect Pattern of Length M Repeated K or More Times</h3><p>判断数组中是否存在连续长度为 m 且重复次数为 k 的字符串，直接对 arr 进行切片判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsPattern</span><span class="params">(self, arr: List[int], m: int, k: int)</span> -&gt; bool:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(arr):</span><br><span class="line">            p = arr[i:i+m]</span><br><span class="line">            <span class="keyword">if</span> p * k == arr[i:i+m*k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1567-Maximum-Length-of-Subarray-With-Positive-Product"><a href="#1567-Maximum-Length-of-Subarray-With-Positive-Product" class="headerlink" title="1567. Maximum Length of Subarray With Positive Product"></a>1567. Maximum Length of Subarray With Positive Product</h3><p>给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。使用数组记录数值为负数的索引值，当数字为 0 时则重置数组，当负数数量为偶数时，则更新最大值，最大值为当前索引减去第一个非 0 数字索引，如果负数数量为奇数时，则最大值为当前索引减去第一个负数索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxLen</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        pre=<span class="number">-1</span></span><br><span class="line">        l=[]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num&lt;<span class="number">0</span>:</span><br><span class="line">                l.append(i)</span><br><span class="line">            <span class="keyword">elif</span> num==<span class="number">0</span>:</span><br><span class="line">                l,pre = [],i</span><br><span class="line">            <span class="keyword">if</span> len(l)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                res=max(res,i-pre)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = max(res,i-l[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="1161-Maximum-Level-Sum-of-a-Binary-Tree"><a href="#1161-Maximum-Level-Sum-of-a-Binary-Tree" class="headerlink" title="1161. Maximum Level Sum of a Binary Tree"></a>1161. Maximum Level Sum of a Binary Tree</h3><p>给一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推，找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。BFS 直接找，只是在找的过程中要记录层号以及该层的和，我直接用一个数组记录每层的和，然后数组的索引就是层级号，求最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxLevelSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result, current = [], [root]</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            next_level, vals = [], []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> current:</span><br><span class="line">                vals.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    next_level.append(node.right)</span><br><span class="line">            current = next_level</span><br><span class="line">            result.append(vals)</span><br><span class="line"></span><br><span class="line">        result = [sum(i) <span class="keyword">for</span> i <span class="keyword">in</span> result]</span><br><span class="line">        print(result)</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> enumerate(result):</span><br><span class="line">            <span class="keyword">if</span> v == max(result):</span><br><span class="line">                <span class="keyword">return</span> idx+<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="1219-Path-with-Maximum-Gold"><a href="#1219-Path-with-Maximum-Gold" class="headerlink" title="1219. Path with Maximum Gold"></a>1219. Path with Maximum Gold</h3><p>回溯法，每次递归计算下一个数值时，将当前数值置为 0，递归结束后重置该值，找到最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, grid, pos, m, n, count)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt; m <span class="keyword">and</span> y &gt;= <span class="number">0</span> <span class="keyword">and</span> y &lt; n <span class="keyword">and</span> grid[x][y] != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(pos)</span></span><br><span class="line">            count += grid[x][y]</span><br><span class="line">            temp = grid[x][y]</span><br><span class="line">            grid[x][y] = <span class="number">0</span></span><br><span class="line">            self.helper(grid, (x<span class="number">-1</span>, y), m, n, count)</span><br><span class="line">            self.helper(grid, (x+<span class="number">1</span>, y), m, n, count)</span><br><span class="line">            self.helper(grid, (x, y<span class="number">-1</span>), m, n, count)</span><br><span class="line">            self.helper(grid, (x, y+<span class="number">1</span>), m, n, count)</span><br><span class="line">            grid[x][y] = temp</span><br><span class="line">        self.res.append(count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaximumGold</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                self.helper(grid, (i, j), m, n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(self.res)</span><br></pre></td></tr></table></figure><h3 id="728-Self-Dividing-Numbers"><a href="#728-Self-Dividing-Numbers" class="headerlink" title="728. Self Dividing Numbers"></a>728. Self Dividing Numbers</h3><p>python 可以直接将数字转换为字符串，继而转换为数组直接判断，不然的话就通过每次对 10 取余数，判断完后除 10。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isDividingNumbers</span><span class="params">(i <span class="keyword">int</span>)</span><span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> i&lt;<span class="number">10</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">v:=i</span><br><span class="line"><span class="keyword">for</span> i!=<span class="number">0</span>&#123;</span><br><span class="line">r :=i%<span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> r==<span class="number">0</span>||v%r!=<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">i =i/<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selfDividingNumbers</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">     <span class="keyword">for</span> i:=left;i&lt;=right;i++&#123;</span><br><span class="line"> <span class="keyword">if</span> isDividingNumbers(i)&#123;</span><br><span class="line"> res = <span class="built_in">append</span>(res,i)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times&quot;&gt;&lt;a href=&quot;#1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times&quot; class=
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第35周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/29/2020-%E7%AC%AC35%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/29/2020-第35周-LeetCode-记录/</id>
    <published>2020-08-29T18:42:34.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1560-Most-Visited-Sector-in-a-Circular-Track"><a href="#1560-Most-Visited-Sector-in-a-Circular-Track" class="headerlink" title="1560. Most Visited Sector in a Circular Track"></a>1560. Most Visited Sector in a Circular Track</h3><p>在中间走过多少圈，对于各个扇区来说是相同的，只需要考虑起点和终点的位置关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostVisited</span><span class="params">(self, n: int, rounds: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        s, d = rounds[<span class="number">0</span>], rounds[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> s &lt;= d:</span><br><span class="line">            <span class="keyword">return</span> list(range(s, d+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> list(range(<span class="number">1</span>, d+<span class="number">1</span>)) + list(range(s, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes"><a href="#1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes" class="headerlink" title="1557. Minimum Number of Vertices to Reach All Nodes"></a>1557. Minimum Number of Vertices to Reach All Nodes</h3><p>如果某个节点出现在到达节点，那么这个节点一定不在结果中，相反则一定在结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSmallestSetOfVertices</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> list(set(range(n)) - set(e[<span class="number">1</span>] <span class="keyword">for</span> e <span class="keyword">in</span> edges))</span><br></pre></td></tr></table></figure><h3 id="1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array"><a href="#1558-Minimum-Numbers-of-Function-Calls-to-Make-Target-Array" class="headerlink" title="1558. Minimum Numbers of Function Calls to Make Target Array"></a>1558. Minimum Numbers of Function Calls to Make Target Array</h3><p>一共有两种操作：1. 将某个索引位置的数值 +1； 2. 将所有数值 * 2 。<br>从结果上来说肯定是操作 2 效率更高，因为我们要求最小次数，所以我们想调用最多的操作 2。首先将判断数组中数字是否为奇数，如果是奇数的话就-1 并将结果 +1。执行完成后数组中所有数字都是偶数后，整体将数组中所有数字 /2 ，并将结果 +1。直到数组中所有数字都为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> any(nums):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] % <span class="number">2</span>:</span><br><span class="line">                    nums[i] -= <span class="number">1</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> any(nums):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    nums[i] //= <span class="number">2</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1561-Maximum-Number-of-Coins-You-Can-Get"><a href="#1561-Maximum-Number-of-Coins-You-Can-Get" class="headerlink" title="1561. Maximum Number of Coins You Can Get"></a>1561. Maximum Number of Coins You Can Get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。</span><br><span class="line">Alice 将会取走硬币数量最多的那一堆。</span><br><span class="line">你将会取走硬币数量第二多的那一堆。</span><br><span class="line">Bob 将会取走最后一堆。</span><br><span class="line">重复这个过程，直到没有更多硬币。</span><br></pre></td></tr></table></figure><p>虽然不可以选择最多的硬币，但是可以选择第二多的，所以可以先将数组排序，然后每次选择第二大的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, piles: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1,2,2,4,7,8 =&gt; 7,2</span></span><br><span class="line">        <span class="comment"># 1,2,3,4,5,6,7,8,9 =&gt; 8,6,4</span></span><br><span class="line">        piles.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(piles):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i += <span class="number">1</span>    </span><br><span class="line">            res.append(piles[i])</span><br><span class="line">            <span class="keyword">if</span> len(res) == len(piles) /<span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> sum(res)</span><br><span class="line">        <span class="keyword">return</span> sum(res)</span><br></pre></td></tr></table></figure><h3 id="1079-Letter-Tile-Possibilities"><a href="#1079-Letter-Tile-Possibilities" class="headerlink" title="1079. Letter Tile Possibilities"></a>1079. Letter Tile Possibilities</h3><p>使用 DFS + 回溯，先统计字母出现的次数，分别遍历 26 个字母，如果字母出现的次数不为 0 ，那么将字母出现的次数 -1 ，并进行 dfs，在深度搜索后再将字母次数 +1，避免影响最终结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTilePossibilities</span><span class="params">(self, tiles: str)</span> -&gt; int:</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> tile <span class="keyword">in</span> tiles: record[ord(tile)-ord(<span class="string">'A'</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(record)</span>:</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> record[i]: <span class="keyword">continue</span></span><br><span class="line">                record[i] -= <span class="number">1</span></span><br><span class="line">                s += dfs(record) + <span class="number">1</span> </span><br><span class="line">                record[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> dfs(record)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1560-Most-Visited-Sector-in-a-Circular-Track&quot;&gt;&lt;a href=&quot;#1560-Most-Visited-Sector-in-a-Circular-Track&quot; class=&quot;headerlink&quot; title=&quot;1560
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2020 第34周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/23/2020-%E7%AC%AC34%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/23/2020-第34周-LeetCode-记录/</id>
    <published>2020-08-23T16:37:12.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1550-Three-Consecutive-Odds"><a href="#1550-Three-Consecutive-Odds" class="headerlink" title="1550. Three Consecutive Odds"></a>1550. Three Consecutive Odds</h3><p>判断数组是否存在连续 3 个奇数的情况存在，直接遍历判断，使用变量记录当前奇数个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeConsecutiveOdds</span><span class="params">(self, arr: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="1551-Minimum-Operations-to-Make-Array-Equal"><a href="#1551-Minimum-Operations-to-Make-Array-Equal" class="headerlink" title="1551. Minimum Operations to Make Array Equal"></a>1551. Minimum Operations to Make Array Equal</h3><p>一道数学题，等差数列求和公式变形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=3 最小操作数是 2</span><br><span class="line">n=4 最小操作数是 1 + 3</span><br><span class="line">n=5 最小操作数是 2 + 4</span><br><span class="line">n=6 最小操作数是 1 + 3 + 5</span><br><span class="line">n=7 最小操作数是 2 + 4 + 6</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperations</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> n*n // <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a>410. Split Array Largest Sum</h3><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p>求最大值最小一般采用二分法来做，数值最终在 max(nums) &lt; result &lt; sum(nums) 区间中，假设当前数值符合条件，然后检查是否符合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums: List[int], m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(x: int)</span> -&gt; bool:</span></span><br><span class="line">            total, cnt = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> total + num &gt; x:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    total = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    total += num</span><br><span class="line">            <span class="keyword">return</span> cnt &lt;= m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        left = max(nums)</span><br><span class="line">        right = sum(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="1552-Magnetic-Force-Between-Two-Balls"><a href="#1552-Magnetic-Force-Between-Two-Balls" class="headerlink" title="1552. Magnetic Force Between Two Balls"></a>1552. Magnetic Force Between Two Balls</h3><p>与 410 类似，也是求最大化最小值，相同的解法，二分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDistance(self, position: List[int], m: int) -&gt; int:</span><br><span class="line">        position.sort()</span><br><span class="line">        </span><br><span class="line">        def check(x):</span><br><span class="line">            cnt = 1</span><br><span class="line">            t = position[0]</span><br><span class="line">            for i in range(1, len(position)):</span><br><span class="line">                if position[i]-t &gt; x:</span><br><span class="line">                    cnt += 1</span><br><span class="line">                    t = position[i]</span><br><span class="line">            return cnt &gt;= m</span><br><span class="line">        </span><br><span class="line">        l, r = 0, position[-1]</span><br><span class="line">        while l &lt; r:</span><br><span class="line">            mid = l + (r-l)//2</span><br><span class="line">            if check(mid):</span><br><span class="line">                l = mid+1</span><br><span class="line">            else:</span><br><span class="line">                r = mid</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure><h3 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a>406. Queue Reconstruction by Height</h3><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p><blockquote><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序：</span><br><span class="line">按高度降序排列。</span><br><span class="line">在同一高度的人中，按 k 值的升序排列。</span><br><span class="line">逐个地把它们放在输出队列中，索引等于它们的 k 值。</span><br><span class="line">返回输出队列</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            output.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="1249-Minimum-Remove-to-Make-Valid-Parentheses"><a href="#1249-Minimum-Remove-to-Make-Valid-Parentheses" class="headerlink" title="1249. Minimum Remove to Make Valid Parentheses"></a>1249. Minimum Remove to Make Valid Parentheses</h3><p>给你一个字符串，其中字符串包含一些括号，但是括号不是成对出现的，需要你删除其中不平衡的括号使其达到平衡。<br>自己做的时候使用了两个栈来分别记录括号和括号所在的索引，如果出现平衡的括号，那么两个栈同时出栈，最终将保存索引的栈中对应的字母删除，返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> idx, i <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> [<span class="string">'('</span>, <span class="string">')'</span>]:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                    res.append(idx)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">'('</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        res.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack.append(i)</span><br><span class="line">                        res.append(idx)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> idx, i <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(tmp)</span><br></pre></td></tr></table></figure><p>虽然也能通过但是复杂度很高，可以直接遍历字符串，使用一个栈记录 <code>(</code> ，如果字符串为 <code>(</code> 那么入栈，如果字符串为 <code>)</code> 并且栈长度不为 0，那么出栈，否则将字符串对应索引字母置为空，此时结果中所有多余的 <code>)</code> 都已经处理完了，接下来处理栈中存在的多余的 <code>(</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        indices, ans = [], list(s)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> indices:</span><br><span class="line">                    indices.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans[i] = <span class="string">''</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'('</span>:</span><br><span class="line">                indices.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> indices:</span><br><span class="line">            ans[i] = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1550-Three-Consecutive-Odds&quot;&gt;&lt;a href=&quot;#1550-Three-Consecutive-Odds&quot; class=&quot;headerlink&quot; title=&quot;1550. Three Consecutive Odds&quot;&gt;&lt;/a&gt;1550
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>ARM 服务器？能用。</title>
    <link href="https://zdyxry.github.io/2020/08/22/ARM-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E8%83%BD%E7%94%A8%E3%80%82/"/>
    <id>https://zdyxry.github.io/2020/08/22/ARM-服务器？能用。/</id>
    <published>2020-08-22T15:09:04.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上一次写 <a href="https://zdyxry.github.io/2019/11/01/ARM-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E8%83%BD%E7%94%A8%EF%BC%9F/">ARM 服务器</a>相关的是在大半年以前了，当时适配工作做得神烦，最近在折腾 ARM 上 KVM 虚拟化相关的事情，目标是虚拟化功能最小代码改动同时兼容 x86 和 ARM，记录一下目前的一点经验总结。</p><p>硬件配置：  </p><ul><li>华为泰山服务器</li><li>Kunpeng 920</li></ul><p>软件配置：  </p><ul><li>CentOS 7.6</li><li>kernel-4.18.0-193.1.2.el7.aarch64</li><li>libvirt-4.5.0</li><li>qemu-2.12.0</li></ul><h2 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h2><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>如果产品之前都是 x86 架构下的，在适配 ARM 时往往需要进行架构判断，此时可以通过 <code>arch</code> 来获取，在 ARM 架构显示 <code>aarch64</code> ，在 x86 架构下显示 <code>x86_64</code> 。</p><p><code>aarch64</code> 等价于 <code>arm64</code>。</p><blockquote><p>AArch64 or ARM64 is the 64-bit extension of the ARM architecture.</p></blockquote><h3 id="KVM-module"><a href="#KVM-module" class="headerlink" title="KVM module"></a>KVM module</h3><p>在 x86 上我们可以直接通过 <code>lsmod |grep kvm</code> 查看到 KVM module 情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:24:30 ~]$lsmod |grep kvm</span><br><span class="line">kvm_intel             188644  82 </span><br><span class="line">kvm                   621480  1 kvm_intel</span><br></pre></td></tr></table></figure><p>但是在 arm 上是没有加载 KVM module 的，此时想要知道 KVM 配置是否正确，可以通过 <code>dmesg</code> 中查看 KVM 相关日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: IPA Size Limit: 48bits</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: GICv4 support disabled</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: vgic-v2@9b020000</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: GIC system register CPU interface enabled</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: vgic interrupt IRQ1</span><br><span class="line">[Wed Jul  8 13:43:11 2020] kvm [1]: VHE mode initialized successfully</span><br></pre></td></tr></table></figure><p>如果看到 <code>VHE mode initialized successfully</code> ，那么 KVM 正常。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>在 CentOS 中通常使用 cpuinfo 来获取 CPU 相关信息，但是发现集群中某个节点无法获取主频相关信息，通过 lscpu 也无法正确显示，开始以为是 <code>util-linux</code> 相关软件的版本不兼容导致，后续排查发现不是这个问题，于是考虑通过其他方式获取主频。</p><p>正常 cpuinfo 输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hz Advertised: 2.6000 GHz</span><br><span class="line">Hz Actual: 2.6000 GHz</span><br><span class="line">Hz Advertised Raw: (2600000000, 0)</span><br><span class="line">Hz Actual Raw: (2600000000, 0)</span><br><span class="line">Arch: ARM_8</span><br></pre></td></tr></table></figure><p>如果作为他信息统计的话我们往往使用的是 <code>Hz Advertised Raw</code> 字段，我们可以通过 <code>dmidecode</code> 获取，<code>dmidecode</code> 输出结果示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node90 19:33:47 ~]$dmidecode -t 4 </span><br><span class="line">        ...</span><br><span class="line">        Max Speed: 4000 MHz</span><br><span class="line">        Current Speed: 2600 MHz</span><br><span class="line">        Status: Populated, Enabled</span><br><span class="line">        Upgrade: Socket LGA2011</span><br><span class="line">        L1 Cache Handle: 0x0009</span><br><span class="line">        L2 Cache Handle: 0x000A</span><br><span class="line">        L3 Cache Handle: 0x000B</span><br></pre></td></tr></table></figure><p>这里需要进行区分， <code>dmidecode</code> 获取到的是主板信息，比如 <code>Max Speed</code> 指的是主板支持最大主频，如果我们想获取当前 CPU 标称主频，需要使用 <code>Current Speed</code> 字段数值。</p><h2 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h2><h3 id="Machine-Type"><a href="#Machine-Type" class="headerlink" title="Machine Type"></a>Machine Type</h3><p>在 x86 架构下，支持两种 Machine Type，分别为 q35 和 i440fx(pc)，我们使用的是 i440fx，这两种类型我理解最主要的区别在于 PCI 和 PCIE 的支持，通俗描述就是 <code>兼容性</code> 更好。目前 x86 架构下的 Machine Type 我们使用的是 i440fx(pc)。但是在 ARM 架构下只支持一种 Machine Type，就是 mach-virt(virt) ，而这种架构下的大部分行为与 q35 相同，所以我们在创建虚拟机时所指定的基本参数就需要进行相应的调整。</p><h3 id="Boot-Options"><a href="#Boot-Options" class="headerlink" title="Boot Options"></a>Boot Options</h3><p>ARM 架构下虚拟机不支持 BIOS 引导，只支持 UEFI，在设置 UEFI  bootloader 时，需要使用 aarch64 版本的 edk2(EFI Development Kit II)，虽然 edk2 的 x86 下使用的是 noarch 版本，但是这里的 noarch 是假象，还是需要指定 aarch64 版本才可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node26 19:58:59 ~]$rpm -ql edk2.git-aarch64-0-20200515.1405.g9af1064995.noarch</span><br><span class="line">/usr/share/edk2.git</span><br><span class="line">/usr/share/edk2.git/aarch64</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_EFI.fd</span><br><span class="line">/usr/share/edk2.git/aarch64/QEMU_VARS.fd</span><br><span class="line">/usr/share/edk2.git/aarch64/vars-template-pflash.raw</span><br><span class="line">/usr/share/qemu/firmware/80-uefi-a64-git.json</span><br></pre></td></tr></table></figure><p>在 libvirt qemu 配置文件中指定 nvram 文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node26 19:59:23 ~]$cat /etc/libvirt/qemu.conf </span><br><span class="line">nvram = [&quot;/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw:/usr/share/edk2.git/aarch64/vars-template-pflash.raw&quot;]</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>虚拟机配置中，一个比较重要的地方是 Controller 配置，在 q35 Machine Type 中：不支持 PCI Controller，仅支持 PCI-E Controller，因此需要特殊注意；同时 USB Controller 支持 XHCI Controller，XHCI 可以同时支持 USB 1.1，2.0，3.0 设备。</p><h4 id="PCI-E-Controller"><a href="#PCI-E-Controller" class="headerlink" title="PCI-E Controller"></a>PCI-E Controller</h4><p>默认的 PCI 拓扑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;controller type=&apos;pci&apos; index=&apos;0&apos; model=&apos;pcie-root&apos;/&gt;</span><br><span class="line">&lt;controller type=&apos;pci&apos; index=&apos;1&apos; model=&apos;pcie-root-port&apos;&gt;</span><br><span class="line">  &lt;model name=&apos;pcie-root-port&apos;/&gt;</span><br><span class="line">  &lt;target chassis=&apos;1&apos; port=&apos;0x10&apos;/&gt;</span><br><span class="line">  &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x01&apos; function=&apos;0x0&apos;/&gt;</span><br><span class="line">&lt;/controller&gt;</span><br></pre></td></tr></table></figure><p><code>pcie-root</code> 不支持设备的热插拔，因此需要将设备添加到 <code>pcie-root-port</code> 上，但是 <code>pcie-root-port</code> 自身也不支持热插拔，所以需要在虚拟机创建时预先分配好一定数量的 <code>pcie-root-port</code> Controller 用于后续其他设备的热插拔。</p><p>文档中提到 q35 支持 <code>pcie-to-pci-bridge</code> 控制器用于连接一些传统的 PCI 设备，但是实际测试中发现没有作用，不知道是不是我的姿势有问题。</p><p>上面提到要在虚拟机创建时预先分配 <code>pcie-root-port</code> Controller，我们需要知道 <code>pcie-root</code> 所支持的 <code>pcie-root-port</code> 数量上限是多少，没有找到相关文档，于是我去看了看 virt-manager 中是否有特殊处理，代码中没找到 <code>pcie-root-port</code> 关键字，在测试的 XML 文件中，发现最多添加了 8 个 <code>pcie-root-port</code> Controller。virt-manager 没找到，那么就去 OpenStack Nova 中找。</p><p>在 nova/virt/libvirt/driver.py 中，看到了添加 <code>pcie-root-port</code> Controller 的相关逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_guest_add_pcie_root_ports</span><span class="params">(self, guest)</span>:</span></span><br><span class="line">    <span class="string">"""Add PCI Express root ports.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    PCI Express machine can have as many PCIe devices as it has</span></span><br><span class="line"><span class="string">    pcie-root-port controllers (slots in virtual motherboard).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we want to have more PCIe slots for hotplug then we need to create</span></span><br><span class="line"><span class="string">    whole PCIe structure (libvirt limitation).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    pcieroot = vconfig.LibvirtConfigGuestPCIeRootController()</span><br><span class="line">    guest.add_device(pcieroot)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, CONF.libvirt.num_pcie_ports):</span><br><span class="line">        pcierootport = vconfig.LibvirtConfigGuestPCIeRootPortController()</span><br><span class="line">        guest.add_device(pcierootport)</span><br></pre></td></tr></table></figure><p>nova 在创建虚拟机时，直接预先分配了所有的 <code>pcie-root-port</code> ，达到了 libvirt 的上限，在 nova 中时一个常量 28，并且给出了 qemu 关于 PCI-E 相关的文档说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    cfg.IntOpt(&apos;num_pcie_ports&apos;,</span><br><span class="line">               default=0,</span><br><span class="line">               min=0,</span><br><span class="line">               max=28,</span><br><span class="line">               help= &quot;&quot;&quot;</span><br><span class="line">The number of PCIe ports an instance will get.</span><br><span class="line"></span><br><span class="line">Libvirt allows a custom number of PCIe ports (pcie-root-port controllers) a</span><br><span class="line">target instance will get. Some will be used by default, rest will be available</span><br><span class="line">for hotplug use.</span><br><span class="line"></span><br><span class="line">By default we have just 1-2 free ports which limits hotplug.</span><br><span class="line"></span><br><span class="line">More info: https://github.com/qemu/qemu/blob/master/docs/pcie.txt</span><br><span class="line"></span><br><span class="line">Due to QEMU limitations for aarch64/virt maximum value is set to &apos;28&apos;.</span><br><span class="line"></span><br><span class="line">Default value &apos;0&apos; moves calculating amount of ports to libvirt.</span><br><span class="line">&quot;&quot;&quot;),</span><br></pre></td></tr></table></figure><p>于是我在创建虚拟机的时候指定了 28个 <code>pcie-root-port</code> Controller，但是发现虚拟机无法成功引导，简单的二分最终确认在当前环境配置下，虚拟机最多支持 15 个 <code>pcie-root-port</code> ，猜测可能根当前使用的版本有关。</p><h4 id="USB-Controller"><a href="#USB-Controller" class="headerlink" title="USB Controller"></a>USB Controller</h4><p>USB Controller model 选择 <code>qemu-xhci</code> ，添加一个即可，涉及到的设备有 mouse, keyboard, tablet ，都需要将 bus 设置未 usb 。</p><p>在 Controller 确认完成后，我们可以得出当前虚拟机支持设备上限：最多可以连接 15 个 Device/Controller，其中 USB Controller 和 Virtio Video 占用 2个 port，剩余 13 个 port，可以最多插入 13 个 Virtio Device ，也可插入 13 个 Controller，1 个 SCSI Controller 可以插入 7 个 SCSI Disk。</p><h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><p>q35 仅支持 <code>virtio</code> 类型的 Video 设备，cirrus, vga, qxl 都不支持。</p><h3 id="CDROM"><a href="#CDROM" class="headerlink" title="CDROM"></a>CDROM</h3><p>不支持 IDE 磁盘，因此需要将 CDROM 的 bus 总线设置为 SCSI。</p><h3 id="CPU-Model"><a href="#CPU-Model" class="headerlink" title="CPU Model"></a>CPU Model</h3><p>通常我们为了虚拟机兼容性考虑，都会将虚拟机的 CPU Model 设置的略微低一些，避免当一个集群中存在节点 CPU 代数不一致时导致虚拟机无法热迁移，通常我们在 x86 下可以通过 <code>virsh domcapabilities</code> 获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;mode name=&apos;custom&apos; supported=&apos;yes&apos;&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;qemu64&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;qemu32&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;phenom&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;yes&apos;&gt;IvyBridge&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;IvyBridge-IBRS&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-noTSX&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-noTSX-IBRS&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;no&apos;&gt;Haswell-IBRS&lt;/model&gt;</span><br><span class="line">&lt;/mode&gt;</span><br></pre></td></tr></table></figure><p>可以通过 <code>usable</code> 属性来判断是否可以配置，但是在 ARM 下所有的 <code>usable</code> 属性都是 unknown，强行设置后，虚拟机无法启动，在当前版本下时无法进行 CPU Model 设置的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mode name=&apos;host-passthrough&apos; supported=&apos;yes&apos;/&gt;</span><br><span class="line">&lt;mode name=&apos;host-model&apos; supported=&apos;no&apos;/&gt;</span><br><span class="line">&lt;mode name=&apos;custom&apos; supported=&apos;yes&apos;&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a53&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a57&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;max&lt;/model&gt;</span><br><span class="line">  &lt;model usable=&apos;unknown&apos;&gt;cortex-a15&lt;/model&gt;</span><br><span class="line">&lt;/mode&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一番折腾，终于可以在 ARM 服务器上进行虚拟化功能的使用了，实际使用感受还不错，没啥问题。</p><p>例行吐槽：</p><ul><li>尽量使用华为官方文档中提到的建议版本，否则就有坑</li><li>华为鲲鹏论坛的活跃度不高，而且遇到了问题基本上没啥回复，全得靠自己</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.huaweicloud.com/kunpeng/" target="_blank" rel="noopener">https://www.huaweicloud.com/kunpeng/</a></li><li><a href="https://stackoverflow.com/questions/31851611/differences-between-arm64-and-aarch64" target="_blank" rel="noopener">https://stackoverflow.com/questions/31851611/differences-between-arm64-and-aarch64</a></li><li><a href="https://libvirt.org/pci-hotplug.html#aarch64-virt" target="_blank" rel="noopener">https://libvirt.org/pci-hotplug.html#aarch64-virt</a></li><li><a href="https://sourcegraph.com/github.com/openstack/nova/-/blob/nova/conf/libvirt.py" target="_blank" rel="noopener">https://sourcegraph.com/github.com/openstack/nova/-/blob/nova/conf/libvirt.py</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上一次写 &lt;a href=&quot;https://zdyxry.github.io/2019/11/01/ARM-%E6%9C%8D%E5%8A%
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://zdyxry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020 第33周 LeetCode 记录</title>
    <link href="https://zdyxry.github.io/2020/08/16/2020-%E7%AC%AC33%E5%91%A8-LeetCode-%E8%AE%B0%E5%BD%95/"/>
    <id>https://zdyxry.github.io/2020/08/16/2020-第33周-LeetCode-记录/</id>
    <published>2020-08-16T10:27:06.000Z</published>
    <updated>2022-01-10T10:49:33.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1544-Make-The-String-Great"><a href="#1544-Make-The-String-Great" class="headerlink" title="1544. Make The String Great"></a>1544. Make The String Great</h3><p>使用栈来记录最终结果，如果栈顶和当前字符相同，那么出栈，否则入栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeGood</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> ((ord(stack[<span class="number">-1</span>])<span class="number">-32</span>) == ord(i) <span class="keyword">or</span> (ord(stack[<span class="number">-1</span>])+<span class="number">32</span>) == ord(i)):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure><h3 id="1545-Find-Kth-Bit-in-Nth-Binary-String"><a href="#1545-Find-Kth-Bit-in-Nth-Binary-String" class="headerlink" title="1545. Find Kth Bit in Nth Binary String"></a>1545. Find Kth Bit in Nth Binary String</h3><p>找出第 N 个二进制字符串中的第 K 位，其中二进制字符串的生成是按照特定规律的，可以直接暴力模拟生成二进制字符串，找出第 N 个，这种方法不会超时，但是不好。考虑使用递归求解，每个二进制字符串的左半部分，都是上一个二进制字符串，那么需要判断 K 在第 N 个字符串中的左边还是右边，如果是中间就直接返回 1 ；如果是左边，那么就找 N-1 个二进制字符串中 K 个；如果是右边，那么就找 N-1 个二进制字符串中的 K 对称位置，并将结果取反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        l = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">        mid = (l &gt;&gt; <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == mid:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">elif</span> k &lt; mid:</span><br><span class="line">            <span class="keyword">return</span> self.findKthBit(n - <span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = l + <span class="number">1</span> -k</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span> <span class="keyword">if</span> self.findKthBit(n - <span class="number">1</span>, k) == <span class="string">'0'</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthBit</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        s = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + <span class="string">'1'</span> + self.reverse(s[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> s[n][k<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">                res.append(<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target"><a href="#1546-Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target" class="headerlink" title="1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target"></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</h3><p>这是一道告诉你方法就会立刻做出来的题目，前缀和，因为要求不重叠，因此在遍历过的结果中找到 target，那么就需要将 set 重置，cur_sum 清零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNonOverlapping</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += num</span><br><span class="line">            <span class="keyword">if</span> cur_sum - target <span class="keyword">in</span> s:</span><br><span class="line">                s = &#123;<span class="number">0</span>&#125;</span><br><span class="line">                cur_sum = <span class="number">0</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(cur_sum)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="1541-Minimum-Insertions-to-Balance-a-Parentheses-String"><a href="#1541-Minimum-Insertions-to-Balance-a-Parentheses-String" class="headerlink" title="1541. Minimum Insertions to Balance a Parentheses String"></a>1541. Minimum Insertions to Balance a Parentheses String</h3><p>看完题目第一想法是用栈来做，但是写了半天发现题目理解错了，这题跟 #1544 不同的是，它不会因为栈中某个时刻符合平衡括号的条件就全部出栈，比如 <code>&quot;(()))(()))()())))&quot;</code> 这个用例，如果自己计算理解了这个用例这道题也就做出来了。</p><p>使用栈记录当前遍历字符为 <code>(</code> 的情况，如果为 <code>(</code> 那么直接入栈，如果为 <code>)</code> ，那么此时有两种情况：</p><ul><li>如果栈不存在，意味着左边缺少 <code>(</code> ，那么就至少需要补充一个 <code>(</code> ，此时判断当前字符的右侧是否为 <code>)</code> ，如果是，那么只需要添加一个 <code>(</code> ，如果不是 <code>)</code> ，那么就需要添加一个 <code>(</code> 和一个 <code>)</code>；</li><li>如果栈存在，意味着左侧存在 <code>(</code> ，此时判断当前字符右侧是否为 <code>)</code> ，如果是，那么将左侧字符出栈，此时已经满足了平衡括号情况，无须添加，如果不是 <code>)</code> ，那么需要添加一个 <code>)</code> 满足平衡。</li></ul><p>最终判断 stack 是否还存在，如果存在，则每个 <code>(</code> 需要添加两个 <code>)</code> 满足条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># use stack</span></span><br><span class="line">        stack = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># when facing empty stack</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">if</span> i+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        count += <span class="number">1</span>  <span class="comment"># add one "("</span></span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">2</span>   <span class="comment"># add one "("  and one ")"</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># check two positions</span></span><br><span class="line">                    <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">")"</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count += <span class="number">1</span>   <span class="comment"># add one ")"</span></span><br><span class="line">                        stack.pop()</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        rest = len(stack)*<span class="number">2</span>  <span class="comment"># still have "(" on the stack. one "(" pairs with two ")"</span></span><br><span class="line">        <span class="keyword">return</span> count + rest</span><br></pre></td></tr></table></figure><h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h3><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/solution/da-lao-de-dai-ma-kan-ming-bai-hou-ji-ge-bi-ji-yong/" target="_blank" rel="noopener">leetcode-cn</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:                            </span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy=ListNode(float(-inf))             <span class="comment">#首项负无穷保证插的数据不在最前头</span></span><br><span class="line">        dummy.next=head                         <span class="comment">#用于返回答案</span></span><br><span class="line">        pre=head                                    </span><br><span class="line">        nxt=head.next</span><br><span class="line">        <span class="keyword">while</span> nxt:                              <span class="comment">#最后一项为None结束循环</span></span><br><span class="line">            <span class="keyword">if</span> nxt.val&gt;pre.val:                 <span class="comment">#从头开始，如果后一项大于前一项不改变节点</span></span><br><span class="line">               pre=nxt                          <span class="comment">#这两行移动指针（往后挪一格）</span></span><br><span class="line">               nxt=nxt.next</span><br><span class="line">            <span class="keyword">else</span>:                               <span class="comment">#如果后项小需要把后项nxt的节点插到正确位置</span></span><br><span class="line">                pre.next=nxt.next               <span class="comment">#把nxt指向的节点拿出来</span></span><br><span class="line">                cp1=dummy                       <span class="comment">#这两个指针负责从头开始比较nxt的位置</span></span><br><span class="line">                cp2=dummy.next                  <span class="comment">#使用dummy的原因见11行注释</span></span><br><span class="line">                <span class="keyword">while</span> nxt.val&gt;cp2.val:          <span class="comment">#因为前面是排好序的循环结束nxt正好在cp1和cp2中间</span></span><br><span class="line">                    cp1=cp2                     <span class="comment">#</span></span><br><span class="line">                    cp2=cp2.next                <span class="comment">#</span></span><br><span class="line">                nxt.next=cp2                    <span class="comment">#这两行负责插</span></span><br><span class="line">                cp1.next=nxt                    <span class="comment">#把nxt指向的节点查到cp1和cp2中间</span></span><br><span class="line">                nxt=pre.next                    <span class="comment">#指针从哪来回哪去 准备下一个循环</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1544-Make-The-String-Great&quot;&gt;&lt;a href=&quot;#1544-Make-The-String-Great&quot; class=&quot;headerlink&quot; title=&quot;1544. Make The String Great&quot;&gt;&lt;/a&gt;1544. M
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://zdyxry.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
